/*
    ejsLib.c -- Embedthis Ejscript Library Source

    This file is a catenation of all the source code. Amalgamating into a
    single file makes embedding simpler and the resulting application faster.

    Prepared by: orion
 */

#define EJS_DEFINE_OPTABLE 1

#include "ejs.h"

#if ME_COM_EJS

/************************************************************************/
/*
    Start of file "src/cmd/romFiles.c"
 */
/************************************************************************/

/*
 *  romFiles -- Compiled Files
 */
#include "mpr.h"

#if ME_ROM
static uchar _file_1[] = {
    112,114,105,110,116, 40, 39, 72,101,108,108,111, 32, 87,111,114,
    108,100, 39, 41, 10,
    0 };

MprRomInode romFiles[] = {
    { "hello.es", _file_1, 21, 1 },
    { 0, 0, 0, 0 },
};
#endif /* ME_ROM */

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/compiler/ecAst.c"
 */
/************************************************************************/

/**
    ecAst.c - Process AST nodes and define all variables.

    Note on error handling. If a non-recoverable error occurs, then EcCompiler.hasFatalError will be set and
    processing will be aborted. If a recoverable error occurs, then hasError will be set and processing will continue.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************** Defines ***********************************/
/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(cp) if (ecEnterState(cp) < 0) { return; } else

#undef LEAVE
#define LEAVE(cp) ecLeaveState(cp)

/***************************** Forward Declarations ***************************/

static void     addGlobalProperty(EcCompiler *cp, EcNode *np, EjsName *qname);
static void     addScope(EcCompiler *cp, EjsBlock *block);
static void     astBinaryOp(EcCompiler *cp, EcNode *np);
static void     astBindName(EcCompiler *cp, EcNode *np);
static void     astBlock(EcCompiler *cp, EcNode *np);
static void     astBreak(EcCompiler *cp, EcNode *np);
static void     astCall(EcCompiler *cp, EcNode *np);
static void     astCaseElements(EcCompiler *cp, EcNode *np);
static void     astCaseLabel(EcCompiler *cp, EcNode *np);
static void     astCatch(EcCompiler *cp, EcNode *np);
static void     astClass(EcCompiler *cp, EcNode *np);
static void     astDirectives(EcCompiler *cp, EcNode *np);
static void     astDot(EcCompiler *cp, EcNode *np);
static void     astDo(EcCompiler *cp, EcNode *np);
static void     astError(EcCompiler *cp, EcNode *np, cchar *fmt, ...);
static void     astExpressions(EcCompiler *cp, EcNode *np);
static void     astField(EcCompiler *cp, EcNode *np);
static void     astFor(EcCompiler *cp, EcNode *np);
static void     astForIn(EcCompiler *cp, EcNode *np);
static void     astFunction(EcCompiler *cp, EcNode *np);
static void     astHash(EcCompiler *cp, EcNode *np);
static void     astIf(EcCompiler *cp, EcNode *np);
static void     astName(EcCompiler *cp, EcNode *np);
static void     astNew(EcCompiler *cp, EcNode *np);
static void     astObjectLiteral(EcCompiler *cp, EcNode *np);
static void     astPostfixOp(EcCompiler *cp, EcNode *np);
static void     astPragmas(EcCompiler *cp, EcNode *np);
static void     astPragma(EcCompiler *cp, EcNode *np);
static void     astProgram(EcCompiler *cp, EcNode *np);
static void     astReturn(EcCompiler *cp, EcNode *np);
static void     astSuper(EcCompiler *cp, EcNode *np);
static void     astSwitch(EcCompiler *cp, EcNode *np);
static void     astThis(EcCompiler *cp, EcNode *np);
static void     astThrow(EcCompiler *cp, EcNode *np);
static void     astTry(EcCompiler *cp, EcNode *np);
static void     astUnaryOp(EcCompiler *cp, EcNode *np);
static void     astModule(EcCompiler *cp, EcNode *np);
static void     astUseNamespace(EcCompiler *cp, EcNode *np);
static void     astVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value);
static void     astVarDefinition(EcCompiler *cp, EcNode *np, int *codeRequired, int *instanceCode);
static void     astVoid(EcCompiler *cp, EcNode *np);
static void     astWarn(EcCompiler *cp, EcNode *np, cchar *fmt, ...);
static void     astWith(EcCompiler *cp, EcNode *np);
static void     badAst(EcCompiler *cp, EcNode *np);
static void     bindVariableDefinition(EcCompiler *cp, EcNode *np);
static void     closeBlock(EcCompiler *cp);
#if KEEP
static EjsNamespace *createHoistNamespace(EcCompiler *cp, EjsObj *obj);
#endif
static EjsModule    *createModule(EcCompiler *cp, EcNode *np);
static EjsFunction *createModuleInitializer(EcCompiler *cp, EcNode *np, EjsModule *mp);
static int      defineParameters(EcCompiler *cp, EcNode *np);
static void     defineVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value);
static void     fixupClass(EcCompiler *cp, EjsType *type);
static EjsBlock *getBlockForDefinition(EcCompiler *cp, EcNode *np, EjsBlock *block, int attributes);
static EcNode   *getNextAstNode(EcCompiler *cp, EcNode *np, int *next);
static EjsObj   *getTypeProperty(EcCompiler *cp, EjsObj *vp, EjsName name);
#if KEEP
static bool     hoistBlockVar(EcCompiler *cp, EcNode *np);
#endif
static void     openBlock(EcCompiler *cp, EcNode *np, EjsBlock *block);
static void     processAstNode(EcCompiler *cp, EcNode *np);
static void     removeProperty(EcCompiler *cp, EjsObj *block, EcNode *np);
static EjsNamespace *resolveNamespace(EcCompiler *cp, EcNode *np, EjsAny *block, bool *modified);
static void     removeScope(EcCompiler *cp);
static int      resolveName(EcCompiler *cp, EcNode *node, EjsAny *vp,  EjsName name);
static int      resolveProperty(EcCompiler *cp, EcNode *node, EjsType *type, EjsName name);
static void     setAstDocString(Ejs *ejs, EcNode *np, cchar *tag, void *vp, int slotNum);
static EjsNamespace *lookupNamespace(Ejs *ejs, EjsString *namespace);

/*********************************************** Code ***********************************************/
/*
    Top level AST node processing.
 */
static int astProcess(EcCompiler *cp, EcNode *np)
{
    EcState     *fileState, *blockState;
    int         phase;

    fileState = cp->fileState;
    blockState = cp->blockState;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }
    cp->blockState = cp->state;

    /*
        We do 5 phases over all the nodes: define, conditional, fixup, bind and erase
     */
    for (phase = 0; phase < EC_AST_PHASES && cp->errorCount == 0; phase++) {
        /*
            Looping through the input source files. A single top level node describes the source file.
         */
        cp->phase = phase;
        cp->fileState = cp->state;
        cp->fileState->strict = cp->strict;
        processAstNode(cp, np);
    }
    ecLeaveState(cp);
    cp->fileState = fileState;
    cp->blockState = blockState;
    cp->error = 0;
    return (cp->errorCount > 0) ? EJS_ERR : 0;
}


PUBLIC int ecAstProcess(EcCompiler *cp)
{
    EcNode      *np;
    int         phase, i, count;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }
    cp->blockState = cp->state;

    /*
        We do 5 phases over all the nodes: define, load, fixup, block vars and bind
     */
    for (phase = 0; phase < EC_AST_PHASES && cp->errorCount == 0; phase++) {
        cp->phase = phase;

        /*
            Loop over each source file
         */
        count = mprGetListLength(cp->nodes);
        for (i = 0; i < count && !cp->fatalError; i++) {
            /*
                Looping through the input source files. A single top level node describes the source file.
             */
            np = mprGetItem(cp->nodes, i);
            if (np == 0) {
                continue;
            }
            cp->fileState = cp->state;
            cp->fileState->strict = cp->strict;
            processAstNode(cp, np);
        }
    }
    ecLeaveState(cp);
    cp->fileState = 0;
    cp->blockState = 0;
    cp->error = 0;
    return (cp->errorCount > 0) ? EJS_ERR : 0;
}


static void astArgs(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    assert(np->kind == N_ARGS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astSpread(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    assert(np->kind == N_SPREAD);
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


/*
    Generate an assignment expression
 */
static void astAssignOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    assert(np->kind == N_ASSIGN_OP);
    assert(np->left);
    assert(np->right);

    if (state->inSettings && cp->phase >= EC_PHASE_BIND) {
        /*
            Assignment in a class initializer. The lhs must be scoped outside the block. The rhs must be scoped inside.
         */
        openBlock(cp, state->currentFunctionNode->function.body, (EjsBlock*) state->currentFunction->activation);
        processAstNode(cp, np->right);
        closeBlock(cp);
    } else {
        processAstNode(cp, np->right);
    }
    state->onLeft = 1;
    processAstNode(cp, np->left);
    LEAVE(cp);
}


/*
    Handle a binary operator. We recursively process left and right nodes.
 */
static void astBinaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_BINARY_OP);

    if (np->left) {
        processAstNode(cp, np->left);
    }
    if (np->right) {
        processAstNode(cp, np->right);
    }
    LEAVE(cp);
}


static void defineBlock(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsBlock    *block, *letBlock;
    int         slotNum;

    ejs = cp->ejs;
    state = cp->state;
    letBlock = state->letBlock;

    assert(cp->phase == EC_PHASE_CONDITIONAL);
    assert(np->kind == N_BLOCK || np->kind == N_MODULE);

    block = np->blockRef;

    if (np->createBlockObject) {
        slotNum = ejsDefineProperty(ejs, letBlock, -1, np->qname, TYPE(block), 0, block);
        if (slotNum < 0) {
            astError(cp, np, "Cannot define block");
        } else {
            np->blockCreated = 1;
            if (letBlock == ejs->global) {
                addGlobalProperty(cp, np, &np->qname);
            }
        }
    }
}


static void bindBlock(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    
    assert(cp->phase == EC_PHASE_BIND);
    assert(np->kind == N_BLOCK || np->kind == N_MODULE);

    ejs = cp->ejs;

    resolveName(cp, np, NULL, np->qname);
    if (np->blockCreated) {
        if (! np->createBlockObject) {
            assert(cp->lookup.obj);
            assert(np->lookup.slotNum >= 0);
            ejsDeleteProperty(ejs, np->lookup.obj, np->lookup.slotNum);
            np->blockCreated = 0;
        } else {
            /*
                Mark the parent block as needing to be created to hold this block.
             */
            if (cp->state->next->letBlockNode) {
                cp->state->next->letBlockNode->createBlockObject = 1;
            }
        }
    }
}


static void astBlock(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next, needBlock;

    ENTER(cp);
    
    needBlock = 0;
    if (cp->phase < EC_PHASE_BIND) {
        needBlock = 1;
    } else if (cp->phase == EC_PHASE_BIND) {
        /*
            Bind the block here before processing the child nodes so we can mark the block as hidden if it will be expunged.
         */
        bindBlock(cp, np);
        needBlock = np->blockCreated;
    }

    /*
        Open block will change state->letBlock which we need preserved in defineBlock. Use ENTER/LEAVE to save and restore.
     */
    ENTER(cp);
    if (needBlock) {
        openBlock(cp, np, NULL);
    }
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    if (needBlock) {
        closeBlock(cp);
    }
    LEAVE(cp);

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Do define block after the variables have been processed. This allows us to determine if the block is 
            really needed.
         */
        defineBlock(cp, np);

        /* Try to hoist the block object itself */
        if (np->blockCreated /* KEEP && !hoistBlockVar(cp, np) */) {
            cp->state->letBlockNode->createBlockObject = 1;
        }
    }
    LEAVE(cp);
}


static void astBreak(EcCompiler *cp, EcNode *np)
{
    assert(np->kind == N_BREAK);
}


static void astCall(EcCompiler *cp, EcNode *np)
{
    EcState         *state;

    assert(np->kind == N_CALL);

    ENTER(cp);
    
    state = cp->state;

    if (state->onLeft) {
        astError(cp, np, "Invalid call expression on the left hand side of assignment");
        LEAVE(cp);
        return;
    }
    if (np->right) {
        assert(np->right->kind == N_ARGS);
        astArgs(cp, np->right);
    }
    processAstNode(cp, np->left);

    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        if (np->left) {
            np->lookup = np->left->lookup;
            np->qname = np->left->qname;
        }
    }
    LEAVE(cp);
}


static void astCaseElements(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    assert(np->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astCaseLabel(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    assert(np->kind == N_CASE_LABEL);

    if (np->caseLabel.kind == EC_SWITCH_KIND_CASE) {
        assert(np->caseLabel.expression);
        processAstNode(cp, np->caseLabel.expression);

    } else {
        assert(np->caseLabel.kind == EC_SWITCH_KIND_DEFAULT);
    }

    /*
        Process the directives for this case label
     */
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astCatch(EcCompiler *cp, EcNode *np)
{
    EjsBlock    *block;

    ENTER(cp);

    block = ejsCreateBlock(cp->ejs, 0);
    mprSetName(block, MPR_NAME("catch"));
    addScope(cp, block);
    processAstNode(cp, np->left);
    removeScope(cp);
    LEAVE(cp);
}


static EjsType *defineClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EcState         *state;
    EcNode          *constructorNode;
    EjsName         qname;
    int             fatt, attributes, slotNum, sid;
    
    assert(np->kind == N_CLASS);

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;
    sid = -1;

    if ((slotNum = ecLookupVar(cp, ejs->global, np->qname)) >= 0 && cp->fileState->strict) {
        astError(cp, np, "%N Class is already defined.", np->qname);
        return 0;
    }
    type = ejsGetPropertyByName(ejs, ejs->service->immutable, np->qname);

    if (np->attributes & EJS_PROP_NATIVE) {
        astWarn(cp, np, "Native attribute on class %@ is not required, ignoring.", np->qname.name);
    }
    attributes = np->attributes | EJS_TYPE_FIXUP;
    if (np->klass.isInterface) {
        attributes |= EJS_TYPE_INTERFACE;
    }
    if (type == 0) {
        attributes |= EJS_TYPE_POT;
        type = ejsCreateType(ejs, np->qname, state->currentModule, NULL, NULL, sid, 0, 0, 0, 0, attributes);
        if (type == 0) {
            astError(cp, np, "Cannot create type %N", type->qname);
            return 0;
        }
        
    } else {
        ejsSetTypeAttributes(type, type->instanceSize, type->manager, attributes);
        type->module = state->currentModule;
    }
    type->typeData = np;
    np->klass.ref = type;

    ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PROTECTED_NAMESPACE);
    ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PRIVATE_NAMESPACE);

    /*
        Define a property for the type in global
     */
    slotNum = ejsDefineProperty(ejs, ejs->global, slotNum, np->qname, EST(Type), attributes, type);
    if (slotNum < 0) {
        astError(cp, np, "Cannot install type %n",  np->qname);
        return 0;
    }
    if (!type->isInterface) {
        /*
            Reserve one slot for the static initializer to ensure it is the first non-inherited slot.
            This slot may be reclaimed during fixup if not required. Instance initializers are prepended to the constructor.
         */
        qname.name = ejsCreateStringFromAsc(ejs, sfmt("-%@-", type->qname.name));
        qname.space = ejsCreateStringFromAsc(ejs, EJS_INIT_NAMESPACE);
        fatt = EJS_TRAIT_HIDDEN | EJS_PROP_STATIC;
        ejsDefineProperty(ejs, type, 0, qname, EST(Function), fatt, ESV(null));
        constructorNode = np->klass.constructor;
        if (constructorNode && !constructorNode->function.isDefault) {
            type->hasConstructor = 1;
        }
    }
    return type;
}


static void validateFunction(EcCompiler *cp, EcNode *np, EjsFunction *spec, EjsFunction *fun)
{
}

static void validateClass(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsType     *type, *iface, *baseType;
    EjsName     qname;
    EjsFunction *fun;
    EjsObj      *vp;
    int         next, i, count;

    ejs = cp->ejs;
    type = np->klass.ref;

    baseType = type->baseType;
    if (baseType && baseType->final) {
        astError(cp, np, "Class \"%@\" is attempting to subclass a final class \"%@\"", type->qname.name, 
            baseType->qname.name);
    }

    /*
        Ensure the class implements all required implemented methods
     */
    for (next = 0; ((iface = (EjsType*) mprGetNextItem(type->implements, &next)) != 0); ) {
        count = ejsGetLength(ejs, iface);
        for (i = 0; i < count; i++) {
            fun = ejsGetProperty(ejs, iface, i);
            if (!ejsIsFunction(ejs, fun) || fun->isInitializer) {
                continue;
            }
            qname = ejsGetPropertyName(ejs, iface, i);
            vp = ejsGetPropertyByName(ejs, type, qname);
            if (vp == 0 || !ejsIsFunction(ejs, vp)) {
                astError(cp, np, "Missing method \"%@\" required by interface \"%@\"", qname.name, iface->qname.name);
            } else {
                validateFunction(cp, np, fun, (EjsFunction*) vp);
            }
        }
    }
    if (type->implements) {
        if (mprGetListLength(type->implements) > 1 || 
                (type->baseType && ejsCompareAsc(ejs, type->baseType->qname.name, "Object") != 0)) {
            astError(cp, np, "Only one implements or one extends supported");
        }
    }        
}


/*
    Lookup the set of open namespaces for the required namespace for this class
 */
static void bindClass(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsType     *type;
    EjsFunction *fun;
    EjsModule   *mp;
    EcState     *state;
    bool        modified;

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;

    assert(cp->phase == EC_PHASE_BIND);

    if (type->hasInitializer) {
        /*
            Create the static initializer function. Code gen will fill out the code
         */
        mp = state->currentModule;
        fun = ejsCreateFunction(ejs, np->qname.name, NULL, -1, 0, 0, 0, EST(Void), EJS_FUN_INITIALIZER, mp, NULL, 
            cp->fileState->strict);
        np->klass.initializer = fun;
        ejsSetProperty(ejs, type, 0, fun);
    }

    modified = 0;
    if (!np->literalNamespace && resolveNamespace(cp, np, ejs->global, &modified) == 0) {
        return;
    }
    if (modified) {
        ejsSetTypeName(ejs, type, np->qname);
    }
    addGlobalProperty(cp, np, &type->qname);

    if (type->hasBaseConstructors) {
        //  TODO cleanup should already be set.
        assert(type->hasConstructor);
        type->hasConstructor = 1;
    }
    if (resolveName(cp, np, ejs->global, type->qname) < 0) {
        return;
    }
    setAstDocString(ejs, np, "class", ejs->global, np->lookup.slotNum);
}


/*
    Process a class node
 */
static void astClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EcState         *state;
    EcNode          *constructor;
    bool            hasInitializer;

    assert(np->kind == N_CLASS);
    
    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    state->classState = state;
    type = np->klass.ref;
    
    if (np->klass.implements) {
        processAstNode(cp, np->klass.implements);
    }        
    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            removeProperty(cp, ejs->global, np);
        }
        LEAVE(cp);
        return;
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        type = defineClass(cp, np);

    } else if (cp->phase == EC_PHASE_FIXUP) {
         fixupClass(cp, type);

    } else if (cp->phase >= EC_PHASE_BIND) {
        validateClass(cp, np);
        bindClass(cp, np);
    }
    if (cp->error) {
        LEAVE(cp);
        return;
    }
    state->currentClass = type;
    state->currentClassNode = np;
    state->inClass = 1;
    
    state->inFunction = 0;
    state->inMethod = 0;
    state->blockIsMethod = 0;
    state->currentFunction = 0;
    state->currentFunctionNode = 0;

    /*
        Add the type to the scope chain and the static initializer if present. Use push frame to make it eaiser to
        pop the type off the scope chain later.
     */
    hasInitializer = 0;
    addScope(cp, (EjsBlock*) type);
    if (np->klass.initializer) {
        openBlock(cp, np, (EjsBlock*) np->klass.initializer);
        hasInitializer++;
    }
    if (cp->phase == EC_PHASE_FIXUP && type->baseType) {
        ejsInheritBaseClassNamespaces(ejs, type, type->baseType);
    }
    state->optimizedLetBlock = (EjsBlock*) type;
    state->letBlock = (EjsBlock*) type;
    state->varBlock = (EjsBlock*) type;

    /*
        Process the class body
     */
    assert(np->left->kind == N_DIRECTIVES);
    processAstNode(cp, np->left);
    
    if (hasInitializer) {
        closeBlock(cp);
    }

    /*
        Only need to do this if this is a default constructor, ie. does not exist in the class body.
     */
    constructor = np->klass.constructor;
    if (constructor && constructor->function.isDefault) {
        astFunction(cp, constructor);
    }
    removeScope(cp);
    LEAVE(cp);
}


static void astDassign(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    assert(np->kind == N_DASSIGN);

    if (np->objectLiteral.typeNode) {
        processAstNode(cp, np->objectLiteral.typeNode);
    }
    for (next = 0; (child = getNextAstNode(cp, np, &next)) != 0; ) {
        processAstNode(cp, child);
    }
}


static void astDirectives(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    assert(np->kind == N_DIRECTIVES);
    ENTER(cp);

    cp->state->blockNestCount++;
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    cp->state->blockNestCount--;
    LEAVE(cp);
}


/*
    Handle a do statement
 */
static void astDo(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_DO);

    if (np->forLoop.cond) {
        processAstNode(cp, np->forLoop.cond);
    }
    if (np->forLoop.body) {
        processAstNode(cp, np->forLoop.body);
    }
    LEAVE(cp);
}


/*
    Handle property dereferencing via "." and "[". This routine will bind a
    name path reference into slot bindings if possible. The dot node is a
    binary node.

            local.a.b.c
            arg.a.b.c
            obj.a.b.c
            static.a.b.c
            any[expression]
            unqualifiedName         - dynamic bound
            expression              - dynamic bound
 */
static void astDot(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcNode      *left;

    assert(np->kind == N_DOT);
    assert(np->left);
    assert(np->right);

    ENTER(cp);

    state = cp->state;
    state->onLeft = 0;
    left = np->left;

    /*
        Optimize to assist with binding. Remove an expressions node which has a sole QNAME.
     */
    if (left && left->kind == N_EXPRESSIONS && left->left && left->left->kind == N_QNAME && left->right == 0) {
        np->left = np->left->left;
    }

    /*
        Process the left of the "."
     */
    processAstNode(cp, np->left);

    state->currentObjectNode = np->left;
    
    /*
        If the right is a terminal node, then assume the parent state's onLeft status
     */
    switch (np->right->kind) {
    case N_QNAME:
/*
    Need to allow obj[fun()] = 7
    case N_EXPRESSIONS: 
 */
    case N_LITERAL:
    case N_OBJECT_LITERAL:
        cp->state->onLeft = cp->state->next->onLeft;
        break;

    default:
        break;
    }
    processAstNode(cp, np->right);

    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        np->lookup = np->right->lookup;
        np->qname = np->right->qname;
    }
    LEAVE(cp);
}


/*
    Process an expressions node
 */
static void astExpressions(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    assert(np->kind == N_EXPRESSIONS);

    ENTER(cp);

    /*
        No current object when computing an expression. E.g. obj[a + b]
        We don't want obj set as the context object for a or b.
     */
    cp->state->currentObjectNode = 0;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next)) != 0) {
        processAstNode(cp, child);
    }
    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        child = mprGetLastItem(np->children);
        if (child) {
            np->lookup = child->lookup;
            np->qname = child->qname;
        }
    }
    LEAVE(cp);
}


static EjsFunction *defineFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcState         *state;
    EcNode          *parameters;
    EjsFunction     *fun;
    EjsBlock        *block;
    int             numArgs;
    int             slotNum;

    assert(np->kind == N_FUNCTION);
    assert(cp->phase == EC_PHASE_DEFINE);

    ejs = cp->ejs;
    state = cp->state;

    if (np->function.isMethod) {
        np->attributes |= EJS_TRAIT_FIXED | EJS_TRAIT_READONLY;
        if (!(np->attributes & EJS_PROP_ENUMERABLE)) {
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
        block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);

    } else {
        if (np->function.isExpression) {
            block = state->letBlock;
        } else {
            block = state->optimizedLetBlock;
        }
        if (block != state->varBlock && block != ejs->global) {
            state->letBlockNode->createBlockObject = 1;
        }
    }
    parameters = np->function.parameters;
    numArgs = (parameters) ? mprGetListLength(parameters->children) : 0;
    
    if (np->function.resultType) {
        np->attributes |= np->function.resultType->attributes;
    }
    if (np->function.isConstructor) {
        assert(ejsIsType(ejs, block));
        np->attributes |= EJS_FUN_CONSTRUCTOR;
        fun = (EjsFunction*) block;
        ejsInitFunction(ejs, fun, np->qname.name, NULL, 0, numArgs, 0, 0, NULL, np->attributes, state->currentModule, 
            NULL, cp->fileState->strict);
        
    } else {
        /*
            Create a function object. Don't have code yet so we create without it. Cannot resolve the return type yet, so we 
            leave it unset. The numDefault and numExceptions will be fixed when the function is bound.
         */
        fun = ejsCreateFunction(ejs, np->qname.name, NULL, 0, numArgs, 0, 0, NULL, np->attributes, state->currentModule, 
            NULL, cp->fileState->strict);
        if (fun == 0) {
            astError(cp, np, "Cannot create function \"%@\"", np->qname.name);
            return 0;
        }  

        /*
            Check if this function has already been defined in this block. Cannot check base classes yes. Must wait till 
            bindFunction()
         */
        assert(block);
        slotNum = ejsLookupProperty(ejs, block, np->qname);

        if (slotNum >= 0 && cp->fileState->strict) {
            if ((np->function.setter && ejsPropertyHasTrait(ejs, block, slotNum, EJS_TRAIT_SETTER)) ||
                (np->function.getter && ejsPropertyHasTrait(ejs, block, slotNum, EJS_TRAIT_GETTER))) {
                astError(cp, np, "Property \"%@\" is already defined.", np->qname);
                return 0;
            }
        }
        slotNum = ejsDefineProperty(ejs, block, slotNum, np->qname, TYPE(fun), np->attributes, fun);
        if (slotNum < 0) {
            astError(cp, np, "Cannot define function in type \"%@\"", state->currentClass->qname.name);
            return 0;
        }
    }
    np->function.functionVar = fun;
    fun->activation = (EjsPot*) ejsCreateCompilerFrame(ejs, fun);
    return fun;
}


/*
    Define function parameters during the DEFINE phase.
 */
static int defineParameters(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcNode          *nameNode, *child, *parameters;
    int             next, attributes, slotNum, numDefault;

    ejs = cp->ejs;
    parameters = np->function.parameters;
    if (parameters == 0) {
        return 0;
    }
    fun = np->function.functionVar;
    slotNum = 0;
    next = 0;
    numDefault = 0;

    while ((child = getNextAstNode(cp, parameters, &next))) {
        assert(child->kind == N_VAR_DEFINITION);
        attributes = 0;
        nameNode = 0;
        if (child->left->kind == N_QNAME) {
            nameNode = child->left;
        } else if (child->left->kind == N_ASSIGN_OP) {
            numDefault++;
            nameNode = child->left->left;
        }
        attributes |= nameNode->attributes;
        slotNum = ejsDefineProperty(ejs, fun->activation, slotNum, nameNode->qname, NULL, attributes, NULL);
        assert(slotNum >= 0);
        /*
            Can assign the lookup information here as these never need fixups.
         */
        nameNode->lookup.slotNum = slotNum;
        nameNode->lookup.obj = fun;
        nameNode->lookup.trait = ejsGetPropertyTraits(ejs, fun->activation, slotNum);
        assert(nameNode->lookup.trait);
        slotNum++;
    }
    fun->numDefault = numDefault;
    if (np->function.getter && fun->numArgs != 0) {
        astError(cp, np, "Getter function \"%@\" must not define parameters.", np->qname.name);
    } else if (np->function.setter && fun->numArgs != 1) {
        astError(cp, np, "Setter function \"%@\" must define exactly one parameter.", np->qname.name);
    }
    return 0;
}


/*
    Bind the function parameter types. Local variables get bound as the block gets traversed.
 */
static void bindParameters(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *child, *varNode, *assignNode, *parameters, *localType;
    EjsTrait        *trait;
    EjsFunction     *fun;
    EjsType         *arrayType;
    int             next, slotNum, arraySlot, attributes;

    ejs = cp->ejs;
    fun = np->function.functionVar;
    next = 0;
    parameters = np->function.parameters;

    if (parameters) {
        while ((child = getNextAstNode(cp, parameters, &next))) {
            assert(child->kind == N_VAR_DEFINITION);
            slotNum = next - 1;
            trait = ejsGetPropertyTraits(ejs, fun->activation, slotNum);
            attributes = trait->attributes;
            
            varNode = 0;
            if (child->left->kind == N_QNAME) {
                varNode = child->left;

            } else if (child->left->kind == N_ASSIGN_OP) {
                /*
                    Bind defaulting parameters. Only need to do if there is a body. Native functions ignore this code as they
                    have no body. The lhs must be scoped inside the function. The rhs must be scoped outside.
                 */
                if (np->function.body) {
                    assignNode = child->left;
                    openBlock(cp, np->function.body, (EjsBlock*) fun->activation);
                    processAstNode(cp, assignNode->left);
                    closeBlock(cp);
                    processAstNode(cp, assignNode->right);
                }
                varNode = child->left->left;
            }
            assert(varNode);
            assert(varNode->kind == N_QNAME);

            if (varNode->typeNode == 0) {
                if (varNode->name.isRest) {
                    arraySlot = ejsLookupProperty(ejs, ejs->global, N(EJS_EJS_NAMESPACE, "Array"));
                    assert(arraySlot >= 0);
                    arrayType = ejsGetProperty(ejs, ejs->global, arraySlot);
                    ejsSetPropertyTraits(ejs, fun->activation, slotNum, arrayType, -1);
                    fun->rest = 1;
                }

            } else {
                localType = varNode->typeNode;
                processAstNode(cp, localType);
                if (localType->lookup.ref) {
                    attributes |= (localType->attributes & (EJS_TRAIT_CAST_NULLS | EJS_TRAIT_THROW_NULLS));
                    ejsSetPropertyTraits(cp->ejs, fun->activation, slotNum, (EjsType*) localType->lookup.ref, attributes);
                }
            }
        }
    }
}


/*
    Utility routine to bind function return type and locals/args
 */
static EjsFunction *bindFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *resultTypeNode;
    EcState         *state;
    EjsType         *iface, *currentClass;
    EjsFunction     *fun;
    EjsBlock        *block;
    EjsName         qname;
    bool            modified;
    int             next, slotNum;

    assert(cp->phase >= EC_PHASE_BIND);
    assert(np->kind == N_FUNCTION);
    assert(np->qname.name);

    state = cp->state;
    ejs = cp->ejs;
    fun = np->function.functionVar;
    currentClass = state->currentClass;
    assert(fun);

    if (np->function.isMethod) {
        block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);
    } else if (np->function.isExpression) {
        block = state->letBlock;
    } else {
        block = state->optimizedLetBlock;
    }
    resultTypeNode = np->function.resultType;

    if (cp->phase == EC_PHASE_BIND) {
        /*
            Exclude a literalNamespace as the empty phase as the namespace name is changed for the URI.
            Exclude constructors which are hidden in the virtual constructor namespace.
         */
        if (!np->literalNamespace && !np->function.isConstructor) {
            if (resolveNamespace(cp, np, block, &modified) == 0) {
                return 0;
            }
            if (modified && np->left) {
                np->left->qname = np->qname;
            }
        }
        if (block == ejs->global) {
            addGlobalProperty(cp, np, &np->qname);
        }
    }
    
    /*
        Test for clashes with non-overridden methods in base classes.
     */
    if (currentClass && currentClass->baseType) {
        slotNum = ecLookupVar(cp, currentClass->baseType, np->qname);
        if (slotNum >= 0 && ejsIsA(ejs, np->lookup.ref, (EjsType*) cp->lookup.obj)) {
            if (!(np->attributes & EJS_FUN_OVERRIDE) && !currentClass->baseType->isInterface) {
                //  OPT
                if (currentClass->qname.space != ejsCreateStringFromAsc(ejs, EJS_EJS_NAMESPACE) && 
                    currentClass->qname.name != ejsCreateStringFromAsc(ejs, "Type")) {
                    astError(cp, np, 
                        "Function \"%@\" is already defined in a base class. Using \"override\" keyword.", np->qname.name);
                    return 0;
                }
            }

            assert(!ejsLookupProperty(ejs, currentClass, np->qname));
            slotNum = -1;
            /*
                Install the new function into the v-table by overwriting the method from the closest base class.
                Must now define the name of the property and attributes.
             */
            ejsDefineProperty(ejs, block, slotNum, np->qname, 0, np->attributes, fun);
        }
    }

    /*
        Test for clashes with non-overridden methods in implemented classes.
     */
    if (state->currentClass && state->currentClass->implements) {
        next = 0;
        while ((iface = (EjsType*) mprGetNextItem(state->currentClass->implements, &next))) {
            slotNum = ecLookupVar(cp, iface, np->qname);
            if (slotNum >= 0 && cp->lookup.obj == iface) {
                if (!iface->isInterface) {
                    if (!(np->attributes & EJS_FUN_OVERRIDE)) {
                        astError(cp, np, 
                            "Function \"%@\" is already defined in an implemented class. Use the \"override\" keyword.", 
                            np->qname.name);
                        return 0;
                    }

                    /*
                        Install the new function into the v-table by overwriting the inherited implemented method.
                     */
                    ejsDefineProperty(ejs, block, slotNum, np->qname, 0, np->attributes, fun);
                }
            }
        }
    }

    if (resultTypeNode) {
        //  TODO -- assumes all types are in global. Should do a scope search?
        if (resolveName(cp, resultTypeNode, ejs->global, resultTypeNode->qname) < 0) {
            if (STRICT_MODE(cp)) {
                astError(cp, np, "Cannot find type \"%@\". All variables must be declared and typed in strict mode.", 
                    resultTypeNode->qname.name);
            }
        } else {
            resultTypeNode->qname.space = resultTypeNode->lookup.name.space;
        }
    }

    if (!np->function.isConstructor) {
        if (resolveName(cp, np, block, np->qname) < 0) {
            astError(cp, np, "Internal error. Cannot resolve function %@", np->qname.name);
        }
        if (np->lookup.slotNum >= 0) {
            setAstDocString(ejs, np, "fun", np->lookup.obj, np->lookup.slotNum);
        }
    } else {
        qname.space = NULL;
        qname.name = np->qname.name;
        if (resolveName(cp, np, ejs->global, qname) < 0) {
            if (resolveName(cp, np, ejs->global, np->qname) < 0) {
                astError(cp, np, "Internal error. Cannot resolve constructor %@", np->qname.name);
            }
        }
        if (np->lookup.slotNum >= 0) {
            setAstDocString(ejs, np, "fun", np->lookup.obj, np->lookup.slotNum);
        }
    }

    /*
        Bind the result type. Set the result type in np->trait->type
     */
    if (resultTypeNode) {
        assert(resultTypeNode->lookup.ref == 0 || ejsIsType(ejs, resultTypeNode->lookup.ref));
        fun->resultType = (EjsType*) resultTypeNode->lookup.ref;
    }

    /*
        Optimize away closures
        Global functions need scope for the "internal" namespace. If defined as public, dont need it.
        TODO OPT. Dont set fullScope if public
     */
    if (/* fun->owner == ejs->global || */ np->function.isMethod || np->attributes & EJS_PROP_NATIVE) {
        fun->fullScope = 0;
    } else {
        fun->fullScope = 1;
    }
    if (!np->function.isConstructor) {
        if (np->function.isMethod) {
            fun->block.scope = (EjsBlock*) state->varBlock;
        } else {
            fun->block.scope = (EjsBlock*) state->optimizedLetBlock;
        }
    }
    return fun;
}


/*
    Process the N_FUNCTION node and bind the return type and parameter types
 */
static void astFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EjsBlock        *block;
    EcState         *state;

    assert(np->kind == N_FUNCTION);
    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    fun = np->function.functionVar;

    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            if (np->function.isMethod) {
                block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);
            } else {
                block = state->optimizedLetBlock;
            }
            removeProperty(cp, (EjsObj*) block, np);
        }
        LEAVE(cp);
        return;
    }

    /*
        Process the function definition (no parameters yet)
     */
    if (cp->phase == EC_PHASE_DEFINE) {
        fun = defineFunction(cp, np);
    } else if (cp->phase >= EC_PHASE_BIND) {
        fun = bindFunction(cp, np);
    }
    if (fun == 0) {
        LEAVE(cp);
        return;
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        defineParameters(cp, np);
    } else if (cp->phase >= EC_PHASE_BIND) {
        bindParameters(cp, np);
    }
    state->currentFunction = fun;
    state->currentFunctionNode = np;
    state->inFunction = 1;
    state->inMethod = state->inMethod || np->function.isMethod;
    state->blockIsMethod = np->function.isMethod;

    state->optimizedLetBlock = (EjsBlock*) fun->activation;
    state->letBlock = (EjsBlock*) fun->activation;
    state->varBlock = (EjsBlock*) fun->activation;

    if (np->function.body) {
        assert(fun->activation);
        assert(ejsIsFrame(ejs, fun->activation));
        openBlock(cp, np->function.body, (EjsBlock*) fun->activation);
        assert(np->function.body->kind == N_DIRECTIVES);
        processAstNode(cp, np->function.body);
        closeBlock(cp);
    }
    /*
        Fixup scope if the class has a static initializer. The static initializer is opened for static initialization
        statements. TODO - refactor this some how.
     */
    if (state->inMethod && state->currentClassNode->klass.initializer) {
        if (fun->block.scope == (EjsBlock*) state->currentClassNode->klass.initializer) {
            fun->block.scope = fun->block.scope->scope;
        }
    }
    if (np->function.constructorSettings) {
        /*
            TODO The constructor settings need special namespace treatment. Consider:
            class Shape {
                var x
                function Shape(arg1) : this.x = arg1 {}
            }
        
            Note the left hand side can use "this" whereas the right hand side must not.
            The right hand side can see the parameters wheres the left hand side must not.
         */
        state->inSettings = 1;
        processAstNode(cp, np->function.constructorSettings);
        state->inSettings = 0;
    }

    /*
        TODO -- No need to add this namespace to be emitted as all function variables are bound (always)
        Process the parameters. Scope for default initialization code for the parameters is as follows:
            left hand side:  inside the function block
            right hand side: outside the function block.
    
        Namespaces are done on each phase because pragmas must apply only from the point of declaration onward 
        (use namespace)
     */
    if (cp->phase >= EC_PHASE_BIND) {
        if (!np->function.hasReturn && (np->function.resultType != 0)) {
            if (fun->resultType == 0 || fun->resultType != EST(Void)) {
                /*
                    Native classes have no body defined in script, so we can't verify whether or not it has 
                    an appropriate return.
                 */
                if (!(state->currentClass && state->currentClass->isInterface) && !(np->attributes & EJS_PROP_NATIVE)) {
                    if (ejs->initialized || fun->resultType == 0 || fun->resultType != EST(Void)) {
                        astError(cp, np, "Function \"%@\" must return a value",  np->qname.name);
                    }
                }
            }
        }
        if (fun->activation->numProp == 0) {
            /* Activation object not required */
            fun->activation = 0;
        }
    }
    LEAVE(cp);
}


/*
    Handle a for statement
 */
static void astFor(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_FOR);

    if (np->forLoop.initializer) {
        processAstNode(cp, np->forLoop.initializer);
    }
    if (np->forLoop.cond) {
        processAstNode(cp, np->forLoop.cond);
    }
    if (np->forLoop.perLoop) {
        processAstNode(cp, np->forLoop.perLoop);
    }
    if (np->forLoop.body) {
        processAstNode(cp, np->forLoop.body);
    }
    LEAVE(cp);
}


/*
    Handle a for/in statement
 */
static void astForIn(EcCompiler *cp, EcNode *np)
{
    Ejs     *ejs;

    ENTER(cp);

    assert(np->kind == N_FOR_IN);
    
    ejs = cp->ejs;

    if (np->forInLoop.iterVar) {
        processAstNode(cp, np->forInLoop.iterVar);
    }
    if (np->forInLoop.iterGet) {
        processAstNode(cp, np->forInLoop.iterGet);
    }

    /*
        Link to the iterGet node so we can bind the "next" call.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        np->forInLoop.iterNext->qname = N("public", "next");
        resolveName(cp, np->forInLoop.iterNext, EST(Iterator)->prototype, np->forInLoop.iterNext->qname);
        np->forInLoop.iterNext->lookup.bind = 0;
    }
    if (np->forInLoop.body) {
        processAstNode(cp, np->forInLoop.body);
    }
    LEAVE(cp);
}


static EjsObj *evalNode(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsModule   *mp;
    EjsType     *config;
    EjsObj      *result;
    int         saveDebug;

    ejs = cp->ejs;
    assert(ejs->exception == 0);
    
    if ((mp = ejsCreateModule(cp->ejs, ejsCreateStringFromAsc(ejs, "__conditional__"), 0, NULL)) == NULL) {
        return 0;
    }
    mp->initializer = createModuleInitializer(cp, np, mp);
    mp->initializer->isInitializer = 1;
    mp->hasInitializer = 1;
    saveDebug = cp->debug;
    cp->debug = 0;

    if (astProcess(cp, np) < 0) {
        cp->debug = saveDebug;
        return 0;
    }
    ecResetParser(cp);
    ecGenConditionalCode(cp, np, mp);
    if (cp->errorCount > 0) {
        cp->debug = saveDebug;
        return 0;
    }
    /*  Install the Config object as a local variable in the initializer function */
    config = ejsGetPropertyByName(ejs, ejs->global, N("ejs", "Config"));
    ejsDefineProperty(ejs, mp->initializer->activation, 0, EN("Config"), EST(Type), 0, config);
    ejsDefineConfigProperties(ejs);

    result = ejsRunInitializer(ejs, mp);
    cp->debug = saveDebug;

    if (result == 0) {
        ejsClearException(ejs);
        return 0;
    }
    return result;
}


/*
    Handle an hash statement (conditional compilation)
 */
static void astHash(EcCompiler *cp, EcNode *np)
{
    EjsObj      *result;
    int         savePhase;

    ENTER(cp);

    assert(np->kind == N_HASH);
    assert(np->hash.expr);
    assert(np->hash.body);

    cp->state->inHashExpression = 1;

    if (cp->phase < EC_PHASE_CONDITIONAL) {
        processAstNode(cp, np->hash.expr);

    } else if (cp->phase == EC_PHASE_CONDITIONAL) {
        ENTER(cp);
        savePhase = cp->phase;
        result = evalNode(cp, np->hash.expr);
        cp->phase = savePhase;
        LEAVE(cp);

        if (result) {
            result = (EjsObj*) ejsToBoolean(cp->ejs, result);
            if (result && !ejsGetBoolean(cp->ejs, result)) {
                result = 0;
            }
        }
        if (result == 0) {
            np->hash.disabled = 1;
        }
    }
    if (np->hash.disabled) {
        cp->state->disabled = 1;
    }
    cp->state->inHashExpression = 0;
    processAstNode(cp, np->hash.body);
    LEAVE(cp);
}


/*
    Handle an if statement (tenary node)
 */
static void astIf(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_IF);

    assert(np->tenary.cond);
    assert(np->tenary.thenBlock);

    processAstNode(cp, np->tenary.cond);
    processAstNode(cp, np->tenary.thenBlock);

    if (np->tenary.elseBlock) {
        processAstNode(cp, np->tenary.elseBlock);
    }
    LEAVE(cp);
}


static void astImplements(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;
    
    ENTER(cp);
    assert(np->kind == N_TYPE_IDENTIFIERS);
    
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


/*
    Generate a name reference. This routine will bind a name path reference into slot bindings if possible.
    The node and its children represent a  name path.
 */
static void astName(EcCompiler *cp, EcNode *np)
{
    if (np->name.qualifierExpr) {
        processAstNode(cp, np->name.qualifierExpr);
    }
    if (np->name.nameExpr) {
        processAstNode(cp, np->name.nameExpr);
    }
    if (cp->phase >= EC_PHASE_BIND) {
        astBindName(cp, np);
        return;
    }
}


static void astBindName(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EjsLookup       *lookup;
    EjsFunction     *fun;
    EcNode          *left;
    EcState         *state;
    int             rc;

    assert(cp->phase >= EC_PHASE_BIND);
    assert(np->kind == N_QNAME);
    
    if (np->qname.name == 0 || np->name.qualifierExpr || np->name.nameExpr) {
        return;
    }
    ENTER(cp);
    state = cp->state;

    /*
        If resolving a name to the right of a "." or "[", then only search relative to the object to the left of the dot.
     */
    left = state->currentObjectNode;
    ejs = cp->ejs;
    rc = -1;

    if (np->name.isType) {
        rc = resolveName(cp, np, ejs->global, np->qname);
        if (rc < 0) {
            //  NOTE: np->qname.space may be null
            astError(cp, np, "Cannot find class \"%@\". Ensure the class is visible.", np->qname.name);
        }

    } else if (left) {
        if (left->kind == N_THIS) {
            /*
                Explicit "this.property"
                TODO - does not yet handle "this function, this callee, this function, this type"
             */
            if (state->currentClass) {
                rc = resolveProperty(cp, np, state->currentClass, np->qname);
                if (rc < 0 && STRICT_MODE(cp)) {
                    astError(cp, np, "Cannot find property \"%@\" in this class %@.", np->qname.name, 
                         state->currentClass->qname.name);
                }
            }

        /*
            Do we know the type of the left side?
         */
        } else if (left->lookup.trait && left->lookup.trait->type) {
            /*
                We must handle 2 cases differently:
                    1. obj.property
                    2. Type.property
            
                This is because in the first case, we must extract the type of an object, whereas in the 2nd case,
                we already have the type via an explicit type reference.
             */
            if (left->lookup.ref && (ejsIsType(ejs, left->lookup.ref))) {
                /*
                    Case 2. Type.property. We have resolved the type reference.
                 */
                np->lookup.ownerIsType = 1;
                rc = resolveProperty(cp, np, (EjsType*) left->lookup.ref, np->qname);
                if (rc < 0 && STRICT_MODE(cp) && !((EjsType*) left->lookup.ref)->dynamicInstances) {
                    astError(cp, np, "Cannot find property \"%@\" in class \"%@\".", np->qname.name,
                        ((EjsType*) left->lookup.ref)->qname.name);

                } else if (np->lookup.trait && !(np->lookup.trait->attributes & EJS_PROP_STATIC) &&
                        np->lookup.obj != ejs->global) {
                    if (np->lookup.slotNum >= ES_Object_NUM_CLASS_PROP) {
                        /* Exclude the case of calling a function (constructor) to create a new instance */
                        if (!(left->kind == N_CALL || left->kind == N_EXPRESSIONS)) {
                            astError(cp, np, "Accessing instance level propery \"%@\" without an instance", np->qname.name);
                        }
                    }
                    
                } else if (left->kind == N_CALL) {
                    /*
                        Calling a constructor as a function. This will return an instance
                     */
                    np->lookup.nthBase++;
                }

            } else {
                fun = (EjsFunction*) left->lookup.ref;
                if (fun && ejsIsFunction(ejs, fun)) {
                    /* 
                        Cannot use a getter to bind to as the value is determined at run time.
                     */
                    rc = -1;

                } else {

                    /*
                        Case 1: Left side is a normal object. We use the type of the lhs to search for name.
                     */
                    rc = resolveProperty(cp, np, left->lookup.trait->type, np->qname);
                    if (rc == 0) {
                        /*
                            Since we searched above on the type of the object and the lhs is an object, increment nthBase.
                            BUG: but what if lhs is a type? then nthBase is one too many
                         */
                        if (!np->lookup.instanceProperty) {
                            np->lookup.nthBase++;
                        }
                    }
                }
            }

        } else if (left->kind == N_EXPRESSIONS) {
            /* 
                Suppress error message below. We can't know the left because it is an expression. 
                So we can't bind the variable 
             */
            rc = 0;
        }

    } else {
        /*
            No left side, so search the scope chain
         */
        rc = resolveName(cp, np, NULL, np->qname);

        /*
            Check for static function code accessing instance properties or instance methods
         */
        lookup = &np->lookup;
        if (rc == 0 && state->inClass && !state->instanceCode) {
            if (ejsIsPrototype(ejs, lookup->obj) || 
                    (ejsIsType(ejs, lookup->obj) && (lookup->trait && !(lookup->trait->attributes & EJS_PROP_STATIC)))) {
                if (!state->inFunction || (state->currentFunctionNode->attributes & EJS_PROP_STATIC)) {
                    astError(cp, np, "Accessing instance level property \"%@\" without an instance", np->qname.name);
                    rc = -1;
                }
            }
        }
    }

    if (rc < 0) {
#if FUTURE
        //  TODO - need propert expression calculation and propagation
        if (left && left->lookup.trait && left->lookup.trait->type) {
            type = left->lookup.trait->type;
            if (!type->dynamicInstances) {
                astError(cp, np, "Cannot find a declaration for \"%@\".", np->qname.name);
            }
        }
#endif
        if (STRICT_MODE(cp) && !cp->error) {
            astError(cp, np, "Cannot find a declaration for \"%@\". All variables must be declared and typed in strict mode.",
                np->qname.name);
        }

    } else {
        if (np->lookup.trait) {
            /* Copy traits of property into the reference. Not sure if all are needed */
            np->attributes |= np->lookup.trait->attributes;
        }
    }

    /*
        Disable binding of names in certain cases.
     */
    lookup = &np->lookup;
    
    if (ejsIsFrame(ejs, lookup->obj) && lookup->nthBlock == 0) {
        ;
    } else {
        lookup->bind = 0;
        lookup->useThis = 0;
    }
    if (lookup->slotNum >= 0) {
        /*
            Unbind if slot number won't fit in one byte or the object is not a standard Object. The bound op codes 
            require one byte slot numbers.
         */
        if (lookup->slotNum >= 256) {
            lookup->bind = 0;
        }

        if (lookup->obj == ejs->global && !cp->bind) {
            /*
                Unbind non-core globals
             */
            if ((lookup->slotNum >= ES_global_NUM_CLASS_PROP)) {
                lookup->bind = 0;
            }
        }
        if (ejsIsType(ejs, np->lookup.obj)) {
            type = (EjsType*) np->lookup.obj;
            if (type->constructor.block.nobind || type->isInterface) {
                /*
                    Type requires non-bound access. Types that implement interfaces will have different slots.
                 */
                lookup->bind = 0;

            } else if (type->dynamicInstances /* && !BUILTIN(type) */) {
                /*
                    Don't bind non-core dynamic properties
                 */
                lookup->bind = 0;

            } else {
                /*
                    Ugly (but effective) hack just for XML to discriminate between length and length()
                    TODO - refactor away
                 */
                if (type == EST(XML) || type == EST(XMLList)) {
                    if (np->parent == 0 || np->parent->parent == 0 || np->parent->parent->kind != N_CALL) {
                        lookup->bind = 0;
                    }
                }
            }
        }
        if (lookup->trait && lookup->trait->attributes & EJS_TRAIT_GETTER) {
            lookup->bind = 0;
        }
    }

    /*
        If accessing unbound variables, then the function will require full scope if a closure is ever required.
     */
    if (lookup->slotNum < 0) {
        if (cp->phase == EC_PHASE_BIND && cp->warnLevel > 5) {
            astWarn(cp, np, "Using unbound variable reference for \"%@\"", np->qname.name);
        }
    }
    LEAVE(cp);
}


static void astNew(EcCompiler *cp, EcNode *np)
{
    EjsType     *type;
    EcNode      *left;

    assert(np->kind == N_NEW);
    assert(np->left);
    assert(np->left->kind == N_QNAME || np->left->kind == N_DOT);
    assert(np->right == 0);

    ENTER(cp);

    left = np->left;
    processAstNode(cp, left);

    if (cp->phase != EC_PHASE_BIND) {
        LEAVE(cp);
        return;
    }
    assert(cp->phase >= EC_PHASE_BIND);

    np->newExpr.callConstructors = 1;

    if (left->lookup.ref) {
        type = (EjsType*) left->lookup.ref;
        if (type && ejsIsType(cp->ejs, type)) {
            /* Type is bound, has no constructor or base class constructors */
            if (!type->hasConstructor && !type->hasBaseConstructors) {
                np->newExpr.callConstructors = 0;
            }
            /*
                Propagate up the left side. Increment nthBase because it is an instance.
             */
            np->qname = left->qname;
            np->lookup = left->lookup;
            np->lookup.trait = mprAllocObj(EjsTrait, NULL);
            np->lookup.trait->type = (EjsType*) np->lookup.ref;
            np->lookup.ref = 0;
            np->lookup.instanceProperty = 1;
        }
    }
    LEAVE(cp);
}


static void astObjectLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    assert(np->kind == N_OBJECT_LITERAL);

    processAstNode(cp, np->objectLiteral.typeNode);
    for (next = 0; (child = getNextAstNode(cp, np, &next)) != 0; ) {
        processAstNode(cp, child);
    }
}


static void astField(EcCompiler *cp, EcNode *np)
{
    if (np->field.fieldKind == FIELD_KIND_VALUE && np->field.expr) {
        processAstNode(cp, np->field.expr);
    }
}


static void astPragmas(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    assert(np->kind == N_PRAGMAS);

    ENTER(cp);
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astPragma(EcCompiler *cp, EcNode *np)
{
    assert(np->kind == N_PRAGMA);

    ENTER(cp);
    if (np->pragma.strict) {
        cp->fileState->strict = np->pragma.strict;
    }
    LEAVE(cp);
}



static void astPostfixOp(EcCompiler *cp, EcNode *np)
{
    EcNode      *left;
    
    assert(np->kind == N_POSTFIX_OP);

    ENTER(cp);
    left = np->left;
    if (left->kind == N_LITERAL) {
        astError(cp, np, "Invalid postfix operand");
    } else {
        processAstNode(cp, np->left);
    }
    LEAVE(cp);
}


static void astProgram(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcNode      *child;
    int         next;

    ENTER(cp);
    state = cp->state;
    state->nspace = np->qname.name;
    next = 0;
    while ((child = getNextAstNode(cp, np, &next)) != 0) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astReturn(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcNode          *functionNode;
    EcState         *state;

    ENTER(cp);
    ejs = cp->ejs;
    state = cp->state;

    assert(state->currentFunctionNode->kind == N_FUNCTION);
    state->currentFunctionNode->function.hasReturn = 1;

    if (np->left) {
        processAstNode(cp, np->left);
    }

    if (cp->phase >= EC_PHASE_BIND) {
        assert(state->currentFunction);
        assert(state->currentFunction);
        functionNode = state->currentFunctionNode;
        state->currentFunction->hasReturn = functionNode->function.hasReturn;

        fun = state->currentFunction;
        if (fun->hasReturn) {
            if (np->left) {
                if (fun->resultType && fun->resultType == EST(Void)) {
                    /*
                        Allow block-less function expressions where a return node was generated by the parser.
                     */
                    if (!np->ret.blockless) {
                        astError(cp, np, "Void function \"%@\" can't return a value", functionNode->qname.name);
                    }
                }

            } else {
                if (fun->resultType && fun->resultType != EST(Void)) {
                    if (! (!ejs->initialized && fun->resultType->qname.name == EST(Void)->qname.name)) {
                        astError(cp, np, "Return in function \"%@\" must return a value", functionNode->qname.name);
                    }
                }
            }
        }
    }
    LEAVE(cp);
}


static void astSuper(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;
    if (state->currentObjectNode == 0) {
        if (state->currentFunction == 0) {
            if (cp->phase == EC_PHASE_DEFINE) {
                astError(cp, np, "Cannot use unqualified \"super\" outside a method");
            }
            LEAVE(cp);
            return;
        }
        if (!state->currentFunctionNode->function.isConstructor) {
            if (cp->phase == EC_PHASE_DEFINE) {
                astError(cp, np, "Cannot use unqualified \"super\" outside a constructor");
            }
            LEAVE(cp);
            return;
        }
        if (cp->phase >= EC_PHASE_BIND) {
            if (state->currentClass->hasBaseConstructors == 0) {
                astError(cp, np, "No base class constructors exist to call via super");
                LEAVE(cp);
                return;
            }
        }
        state->currentClass->callsSuper = 1;
        if (np->left && np->left->kind != N_NOP) {
            processAstNode(cp, np->left);
        }

    } else {
        astError(cp, np, "Cannot use unqualified \"super\" outside a method");
    }
    LEAVE(cp);
}


static void astSwitch(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    assert(np->kind == N_SWITCH);
    assert(np->right->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astThis(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;

    switch (np->thisNode.thisKind) {
    case EC_THIS_GENERATOR:
        //  TODO - binding not implemented
        break;

    case EC_THIS_CALLEE:
        //  TODO - binding not implemented
        break;

    case EC_THIS_TYPE:
        //  TODO - binding not implemented
        if (!state->inClass) {
            astError(cp, np, "\"this type\" is only valid inside a class");
        } else {
            np->lookup.obj = (EjsObj*) state->currentClass;
            np->lookup.slotNum = 0;
        }
        break;

    case EC_THIS_FUNCTION:
        //  TODO - binding not implemented
        if (!state->inFunction) {
            astError(cp, np, "\"this function\" is not valid outside a function");
        } else {
            np->lookup.obj = (EjsObj*) state->currentFunction;
            np->lookup.slotNum = 0;
        }
        break;

    default:
        np->lookup.obj = (EjsObj*) state->currentClass;
        np->lookup.slotNum = 0;
    }
    LEAVE(cp);
}


static void astThrow(EcCompiler *cp, EcNode *np)
{
    assert(np->left);
    processAstNode(cp, np->left);
}


/*
    Try, catch, finally
 */
static void astTry(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsBlock    *block;
    EcNode      *child;
    int         next, count;

    ENTER(cp);

    assert(np->kind == N_TRY);
    assert(np->exception.tryBlock);

    ejs = cp->ejs;
    processAstNode(cp, np->exception.tryBlock);

    if (cp->phase == EC_PHASE_BIND) {
        /*
            Calculate the number of lexical blocks in the try block. These must be discarded by the VM when executing
            catch and finally blocks.
         */
        for (count = 0, block = ejs->state->bp->scope; block && !ejsIsFrame(ejs, block); block = block->scope) {
            count++;
        }
        np->exception.numBlocks = count;
    }
    if (np->exception.catchClauses) {
        next = 0;
        while ((child = getNextAstNode(cp, np->exception.catchClauses, &next))) {
            processAstNode(cp, child);
        }
    }
    if (np->exception.finallyBlock) {
        block = ejsCreateBlock(cp->ejs, 0);
        addScope(cp, block);
        processAstNode(cp, np->exception.finallyBlock);
        removeScope(cp);
    }
    LEAVE(cp);
}


/*
    Handle a unary operator.
 */
static void astUnaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_UNARY_OP);
    assert(np->left);

    if (np->left->kind == N_LITERAL && (np->tokenId == T_PLUS_PLUS || np->tokenId == T_MINUS_MINUS)) {
        astError(cp, np, "Invalid prefix operand");
    } else {
        processAstNode(cp, np->left);
    }
    LEAVE(cp);
}


/*
    Create a module defined via a module directive.
 */
static void astModule(EcCompiler *cp, EcNode *np)
{
    EjsModule       *mp, *core;
    Ejs             *ejs;
    EcState         *state;
    EcNode          *child;
    EjsBlock        *saveChain;
    int             next;

    assert(np->kind == N_MODULE);

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    
    if (state->disabled) {
        LEAVE(cp);
        return;
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        mp = createModule(cp, np);
    } else {
        mp = np->module.ref;
        assert(mp);
    }
    if (mp == 0) {
        return;
    }
    assert(mp->initializer);
    assert(mp->initializer->activation);

    /*
        Start a new scope chain for this module. ie. Don't nest modules in the scope chain.
     */
    saveChain = ejs->state->bp->scope;
    ejs->state->bp->scope = mp->scope;

    /*
        Create a block for the module initializer. There is also a child block but that is to hide namespace declarations 
        from other compilation units. Open the block explicitly rather than using astBlock. We do this because we need 
        varBlock to be set to ejs->global and let block to be mp->initializer. The block is really only used to scope 
        namespaces.
     */
    openBlock(cp, np, (EjsBlock*) mp->initializer->activation);
    
    if (cp->phase == EC_PHASE_BIND) {
        /*
            Bind the block here before processing the child nodes so we can mark the block as hidden if it will be expunged.
         */
        bindBlock(cp, np->left);
    }
    
    /*
        Open the child block here so we can set the letBlock and varBlock values inside the block.
     */
    assert(np->left->kind == N_BLOCK);
    openBlock(cp, np->left, NULL);
    
    state->optimizedLetBlock = (EjsBlock*) ejs->global;
    state->varBlock = (EjsBlock*) ejs->global;
    state->letBlock = (EjsBlock*) mp->initializer->activation;
    state->currentModule = mp;

    if (mp->dependencies == 0) {
        mp->dependencies = mprCreateList(-1, 0);
        core = ejsLookupModule(ejs, ejsCreateStringFromAsc(ejs, "ejs"), 0, 0);
        if (core && core != mp && mprLookupItem(mp->dependencies, core) < 0) {
            mprAddItem(mp->dependencies, core);
        }
    }

    /*
        Skip the first (block) child that was processed manually above.
     */
    for (next = 0; (child = getNextAstNode(cp, np->left, &next)); ) {
        processAstNode(cp, child);
    }
    closeBlock(cp);
    closeBlock(cp);
    
    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Define block after the variables have been processed. This allows us to determine if the block is really needed.
         */
        defineBlock(cp, np->left);
    }
    ejs->state->bp->scope = saveChain;
    LEAVE(cp);
}


/*
    Use Namespace
 */
static void astUseNamespace(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsNamespace    *namespace;
    EcState         *state, *s;

    assert(np->kind == N_USE_NAMESPACE);
    
    ENTER(cp);

    state = cp->state;
    ejs = cp->ejs;
    namespace = 0;

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            At the define phase, we create a dummy namespace assuming that it will exist somewhere in this block or an 
            outer block. At the fixup phase, we actually resolve the reference to the namespace unless it is a string 
            literal namespace.
         */
        namespace = ejsCreateNamespace(ejs, np->qname.name);
        np->namespaceRef = namespace;

    } else if (cp->phase >= EC_PHASE_BIND) {
        if (np->name.isLiteral) {
            namespace = np->namespaceRef;

        } else {
            /*
                Resolve the real namespace. Must be visible in the current scope (even in standard mode). 
                Then update the URI. URI not used.
             */
            if (resolveName(cp, np, NULL, np->qname) < 0) {
                astError(cp, np, "Cannot find namespace \"%@\"", np->qname.name);

            } else {
                np->lookup.bind = 0;
                namespace = (EjsNamespace*) np->lookup.ref;
                if (namespace) {
                    np->namespaceRef->value = namespace->value;
                    if (!ejsIs(ejs, namespace, Namespace)) {
                        astError(cp, np, "The variable \"%@\" is not a namespace", np->qname.name);
                    } else {
                        np->namespaceRef = namespace;
                    }
                }
            }
            if (namespace && np->name.isDefault) {
                /*
                    Apply the namespace URI to all upper blocks
                 */
                for (s = cp->state; s; s = s->next) {
                    s->nspace = namespace->value;
                    if (s == cp->blockState) {
                        break;
                    }
                }
            }
        }
    } else {
        namespace = np->namespaceRef;
    }
    if (namespace) {
        if (state->letBlockNode) {
            state->letBlockNode->createBlockObject = 1;
        }
        if (state->inClass && !state->inFunction) {
            /*
                Must attach to the class itself and not to the outermost block
             */
            ejsAddNamespaceToBlock(ejs, (EjsBlock*) state->currentClass, namespace);
        } else {
            ejsAddNamespaceToBlock(ejs, state->letBlock, namespace);
        }
    }
    LEAVE(cp);
}


/*
    Module depenency
 */
static void astRequire(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsModule   *currentModule, *mp;
    int         flags;

    assert(np->kind == N_USE_MODULE);
    assert(np->qname.name);

    ENTER(cp);

    ejs = cp->ejs;
    currentModule = cp->state->currentModule;
    assert(currentModule);

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Is this a module we are currently compiling?
         */
        mp = ecLookupModule(cp, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
        if (mp == 0) {
            /*
                Is this module already loaded by the vm?
             */
            mp = ejsLookupModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
            if (mp == 0) {
                flags = cp->fileState->strict ? EJS_LOADER_STRICT : 0;
                if (ejsLoadModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion, flags) < 0) {
                    astError(cp, np, "%s", ejsGetErrorMsg(ejs, 1));
                    cp->fatalError = 1;
                    LEAVE(cp);
                    return;
                }
                mp = ejsLookupModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
            }
        }

        if (mp == 0) {
            astError(cp, np, "Cannot find required module \"%@\"", np->qname.name);

        } else if (mp != currentModule) {
            if (currentModule->dependencies == 0) {
                currentModule->dependencies = mprCreateList(-1, 0);
            }
            if (mprLookupItem(currentModule->dependencies, mp) < 0 && 
                    mprAddItem(currentModule->dependencies, mp) < 0) {
                assert(0);
            }
        }
        assert(np->left->kind == N_USE_NAMESPACE);
        np->left->qname.name = mp->vname;
    }
    assert(np->left->kind == N_USE_NAMESPACE);
    processAstNode(cp, np->left);
    LEAVE(cp);
}


static void astWith(EcCompiler *cp, EcNode *np)
{
    EjsLookup   *lookup;
    bool        pushed;

    ENTER(cp);
    pushed = 0;
    processAstNode(cp, np->with.object);

    if (cp->phase >= EC_PHASE_BIND) {
        processAstNode(cp, np->with.object);
        /*
            To permit early binding, if the object is typed, then add that type to the scope chain.
         */
        lookup = &np->with.object->lookup;
        if (lookup->trait && lookup->trait->type) {
            addScope(cp, (EjsBlock*) lookup->trait->type);
            pushed++;
        }
    }
    processAstNode(cp, np->with.statement);

    if (pushed) {
        removeScope(cp);
    }
    LEAVE(cp);

}


static bool typeIsCompatible(EcCompiler *cp, EjsType *first, EjsType *second)
{
    if (first == 0 || second == 0) {
        return 1;
    }
    if (first->qname.name == second->qname.name && first->qname.space == second->qname.space) {
        return 1;
    }
    return 0;
}


/*
    Define a variable
 */
static void defineVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value)
{
    Ejs             *ejs;
    EjsObj          *obj;
    EjsType         *type;
    EcState         *state;
    int             slotNum, attributes;

    ejs = cp->ejs;
    assert(cp->phase == EC_PHASE_DEFINE);
    state = cp->state;

    if (state->inClass) {
        np->attributes |= EJS_TRAIT_FIXED;
        if (!(np->attributes & EJS_PROP_ENUMERABLE) && !(state->currentClassNode->attributes & EJS_PROP_ENUMERABLE)) {
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
        if (ejsContainsAsc(ejs, np->qname.space, ",private") >= 0) {
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
    }
    attributes = np->attributes;

    /*
        Only create block scope vars if the var block is different to the let block. This converts global let vars to vars.
     */
    np->name.letScope = 0;
    if (varKind & KIND_LET && (state->varBlock != state->optimizedLetBlock)) {
        np->name.letScope = 1;
    }
    if (np->name.letScope) {
        assert(varKind & KIND_LET);
        obj = (EjsObj*) getBlockForDefinition(cp, np, state->optimizedLetBlock, attributes);
        if (ecLookupScope(cp, np->qname) >= 0 && cp->lookup.obj == obj) {
            obj = cp->lookup.obj;
            slotNum = cp->lookup.slotNum;
            if (cp->fileState->strict) {
                astError(cp, np, "Variable \"%@\" is already defined", np->qname.name);
                return;
            }
        } else {
            slotNum = ejsDefineProperty(ejs, obj, -1, np->qname, 0, attributes, value);
        }

    } else {
        if (ecLookupVar(cp, (EjsObj*) state->varBlock, np->qname) >= 0) {
            obj = cp->lookup.obj;
            slotNum = cp->lookup.slotNum;
            if (cp->fileState->strict) {
                astError(cp, np, "Variable \"%@\" is already defined.", np->qname.name);
                return;
            }
        }
        /*
            Var declarations are hoisted to the nearest function, class or global block (never nested block scope)
         */
        obj = (EjsObj*) getBlockForDefinition(cp, np, state->varBlock, attributes);
        slotNum = ejsDefineProperty(ejs, obj, -1, np->qname, 0, attributes, value);
    }
    if (slotNum < 0) {
        astError(cp, np, "Cannot define variable \"%@\"", np->qname.name);
        return;
    }
    if (ejsIsType(ejs, obj) && !(np->attributes & EJS_TRAIT_READONLY)) {
        type = (EjsType*) obj;
        if (state->instanceCode) {
            type->mutableInstances = 1;
        } else {
            type->mutable = 1;
        }
    }
}


#if KEEP
/*
    Hoist a block scoped variable and define in the nearest function, class or global block. This runs during the
    Hoist conditional phase. We hoist the variable by defining with a "-hoisted-%d" namespace which is added to the set of
    Hoist open namespaces. This namespace is only used when compiling and not at runtime. All access to the variable is bound
 */
static bool hoistBlockVar(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsBlock    *block;
    EjsObj      *obj, *vp;
    int         slotNum, attributes;

    assert(cp->phase == EC_PHASE_CONDITIONAL);

    //  TODO -- all hoisting is currently disabled.
    if (1 /* TODO || cp->optimizeLevel == 0 */) {
        return 0;
    }
    ejs = cp->ejs;
    state = cp->state;
    block = (np->kind == N_BLOCK) ? state->letBlock : state->optimizedLetBlock;
    attributes = np->attributes;

    if (state->inClass && state->inFunction) {
        obj = (EjsObj*) state->varBlock;
    } else {
        /*
            Global or class level block
         */
        assert(!state->instanceCode);
        obj = (EjsObj*) state->varBlock;
        attributes |= EJS_PROP_STATIC;
    }
    if (!cp->bind && obj == ejs->global) {
        /* Cannot hoist variables to global scope if not binding */
        return 0;
    }

    /*
        Delete the property from the original block. Don't reclaim slot, delete will set to 0.
        This lookup may fail it there were more than one declaration in a block. ie. already hoisted.
     */
    slotNum = ejsLookupProperty(ejs, block, np->qname);
    if (slotNum < 0) {
        assert(state->letBlockNode->namespaceRef);
        np->namespaceRef = state->letBlockNode->namespaceRef;
        np->qname.space = np->namespaceRef->value;
    } else {
        vp = ejsGetProperty(ejs, block, slotNum);
        ejsDeleteProperty(ejs, block, slotNum);

        /*
            Redefine hoisted in the outer var block. Use a unique hoisted namespace to avoid clashes with other
            hoisted variables of the same name. Save the generated namespace for this block and reuse for any
            other hoisted vars from this block.
         */
        if (state->letBlockNode->namespaceRef) {
            np->namespaceRef = state->letBlockNode->namespaceRef;
        } else {
            np->namespaceRef = createHoistNamespace(cp, obj);
            state->letBlockNode->namespaceRef = np->namespaceRef;
        }
        np->qname.space = np->namespaceRef->value;

        slotNum = ejsDefineProperty(ejs, obj, -1, np->qname, 0, attributes, vp);
        if (slotNum < 0) {
            astError(cp, np, "Cannot define local variable \"%N\"", np->qname.space, np->qname.name);
            return 0;
        }
        if (obj == ejs->global) {
            addGlobalProperty(cp, np, &np->qname);
        }
    }
    np->name.letScope = 0;
    return 1;
}
#endif


/*
    Fully bind a variable definition. We already know the owning type and the slot number.
    We now need to  bind the variable type and set the trait reference.
 */
static void bindVariableDefinition(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsBlock        *block;
    EjsTrait        *trait;
    EcState         *state;
    EcNode          *typeNode;
    bool            modified;

    ENTER(cp);

    assert(cp->phase >= EC_PHASE_BIND);

    ejs = cp->ejs;
    state = cp->state;

    if (np->name.letScope) {
        block = state->optimizedLetBlock;
    } else {
        block = getBlockForDefinition(cp, np, state->varBlock, np->attributes);
    }
    modified = 0;
    if (!np->literalNamespace && resolveNamespace(cp, np, block, &modified) == 0) {
        LEAVE(cp);
        return;
    }
    if (modified && np->left && np->left->left && np->left->left->kind == N_QNAME) {
        /* Fix the namespace of the lhs */
        np->left->left->qname = np->qname;
    }
    if (cp->phase == EC_PHASE_BIND && (EjsObj*) block == ejs->global) {
        addGlobalProperty(cp, np, &np->qname);
    }
    /*
        Check if there is a name clash with any subclasses. Must do after fixup so that the base type has been defined.
        Look in the current type for any public property of the same name.
     */
    if (state->inClass && !state->inFunction && state->currentClass->baseType) {
        if (ecLookupVar(cp, (EjsObj*) state->currentClass->baseType, np->qname) >= 0) {
            astError(cp, np, "Public property %@ is already defined in a base class", np->qname.name);
            LEAVE(cp);
            return;
        }
    }
    if (resolveName(cp, np, block, np->qname) < 0) {
        astError(cp, np, "Cannot find variable \"%N\"", np->qname.space, np->qname.name);
    }
    typeNode = np->typeNode;
    if (typeNode && np->lookup.trait) {
        if (typeNode->lookup.ref) {
            if (!ejsIsType(ejs, typeNode->lookup.ref)) {
                astError(cp, np, "Type is not a type object");
                LEAVE(cp);
                return;
            }
            if (!cp->fileState->strict) {
                /*
                    Allow variable redefinitions providing they are compatible
                 */
                trait = ejsGetPropertyTraits(ejs, np->lookup.obj, np->lookup.slotNum);
                if (!typeIsCompatible(cp, trait->type, (EjsType*) typeNode->lookup.ref)) {
                    astError(cp, np, "Redefinition of \"%@\" is not compatible with prior definition", np->qname.name);
                    LEAVE(cp);
                    return;
                }
            }
            ejsSetPropertyTraits(cp->ejs, np->lookup.obj, np->lookup.slotNum, (EjsType*) typeNode->lookup.ref, -1);
        }
    }
    setAstDocString(ejs, np, "var", np->lookup.obj, np->lookup.slotNum);
    np->lookup.bind = 0;
    LEAVE(cp);
}


/*
    Initialize constants here so they can be used for conditional compilation and "use namespace"
 */
static void astInitVar(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *right;
    int         slotNum;

    ejs = cp->ejs;
    state = cp->state;

    assert(np->left);
    assert(np->left->kind == N_ASSIGN_OP);

    right = np->left->right;
    assert(right);

    if (right->kind == N_LITERAL && !(np->name.varKind & KIND_LET) && !(np->attributes & EJS_PROP_NATIVE)) {
        assert(np->kind == N_VAR);
        assert(right->literal.var);

        /* Exclude class instance variables */
        if (! (state->inClass && !(np->attributes & EJS_PROP_STATIC))) {
            slotNum = ejsLookupProperty(ejs, state->varBlock, np->qname);
            if (cp->phase == EC_PHASE_DEFINE) {
                ejsSetProperty(ejs, state->varBlock, slotNum, right->literal.var);

            } else if (cp->phase >= EC_PHASE_BIND && !np->name.isNamespace && slotNum >= 0) {
                /*
                    Erase the value incase being run in the ejs shell. Must not prematurely define values.
                 */
                ejsSetProperty(ejs, state->varBlock, slotNum, ESV(undefined));
            }
        }
    }
}


static void astVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value)
{
    EcState     *state;
    Ejs         *ejs;
    EjsObj      *obj;

    ejs = cp->ejs;
    state = cp->state;

    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            obj = (EjsObj*) getBlockForDefinition(cp, np, state->varBlock, np->attributes);
            removeProperty(cp, obj, np);
        }
        return;
    }
    state->instanceCode = 0;
    if (state->inClass && !(np->attributes & EJS_PROP_STATIC)) {
        if (state->inMethod) {
            state->instanceCode = 1;
        } else if (state->classState->blockNestCount == (state->blockNestCount - 1)) {
            /*
                Top level var declaration without a static attribute
             */
            state->instanceCode = 1;
        }
    }

    if (np->typeNode) {
        if (np->typeNode->kind != N_QNAME) {
            astError(cp, np, "Bad type name");
            return;
        }
        if (ejsCompareAsc(ejs, np->typeNode->qname.name, "*") != 0) {
            processAstNode(cp, np->typeNode);
        }
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        defineVar(cp, np, varKind, value);

    } else if (cp->phase == EC_PHASE_CONDITIONAL && np->name.letScope) {
#if KEEP
        if (!hoistBlockVar(cp, np)) {
            /*
                Unhoisted let scoped variable.
             */
#endif
            state->letBlockNode->createBlockObject = 1;
#if KEEP
        }
#endif

    } else if (cp->phase >= EC_PHASE_BIND) {
        if (np->namespaceRef) {
            /*
                Add any hoist namespaces that were defined in hoistBlockVar in the conditional phase
             */
            ejsAddNamespaceToBlock(ejs, (EjsBlock*) cp->state->optimizedLetBlock, np->namespaceRef);
        }
        bindVariableDefinition(cp, np);
    }
    if (!state->disabled && np->left) {
        astAssignOp(cp, np->left);
        astInitVar(cp, np);
    }
}


static void astVarDefinition(EcCompiler *cp, EcNode *np, int *codeRequired, int *instanceCode)
{
    EcNode      *var;
    EcState     *state;
    int         next;

    assert(np->kind == N_VAR_DEFINITION);
    ENTER(cp);
    state = cp->state;

    for (next = 0; (var = getNextAstNode(cp, np, &next)); ) {
        if (var->kind == N_VAR) {
            astVar(cp, var, var->name.varKind, var->name.nsvalue);
            if (var->left && !state->disabled) {
                *codeRequired = 1;
                *instanceCode = state->instanceCode;
            }
        } else {
            processAstNode(cp, var);
        }
    }
    LEAVE(cp);
}


/*
    Void type node
 */
static void astVoid(EcCompiler *cp, EcNode *np)
{
    EjsName     qname;
    Ejs         *ejs;

    assert(np->kind == N_VOID);
    ejs = cp->ejs;

    ENTER(cp);

    if (cp->phase >= EC_PHASE_BIND) {
        qname = N(EJS_EJS_NAMESPACE, "Void");
        if (resolveName(cp, np, 0, qname) < 0) {
            astError(cp, np, "Cannot find variable \"%N\"", qname.space, qname.name);
        }
    }
    LEAVE(cp);
}


/********************************* Support Code *******************************/
/*
    Create a function to hold the module initialization code. Set a basic scope chain here incase running in ejs.
 */

static EjsFunction *createModuleInitializer(EcCompiler *cp, EcNode *np, EjsModule *mp)
{
    Ejs             *ejs;
    EjsFunction     *fun;

    ejs = cp->ejs;
    
    fun = ejsCreateFunction(ejs, mp->name, 0, -1, 0, 0, 0, EST(Void), EJS_FUN_MODULE_INITIALIZER, mp, mp->scope, 
        cp->state->strict);
    if (fun == 0) {
        astError(cp, np, "Cannot create initializer function");
        return 0;
    }
    fun->activation = (EjsPot*) ejsCreateCompilerFrame(ejs, fun);
    return fun;
}


/*
    Create the required module
 */
static EjsModule *createModule(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsModule       *mp;

    ejs = cp->ejs;

    assert(np->kind == N_MODULE);

    if (np->module.version == 0 && cp->modver && ejsCompareAsc(ejs, np->qname.name, EJS_DEFAULT_MODULE) != 0) {
        np->module.version = cp->modver;
    }
    mp = ecLookupModule(cp, np->qname.name, np->module.version, np->module.version);
    if (mp == 0) {
        mp = ejsCreateModule(cp->ejs, np->qname.name, np->module.version, NULL);
        if (mp == 0) {
            astError(cp, np, "Cannot create module %@", np->qname.name);
            return 0;
        }
        if (ecAddModule(cp, mp) < 0) {
            astError(cp, 0, "Cannot insert module");
            return 0;
        }
        /*
            This will prevent the loading of any module that uses this module.
         */
        if (ejsCompareAsc(ejs, mp->name, EJS_DEFAULT_MODULE) != 0) {
            mp->compiling = 1;
        }
    }
    if (mp->initializer == 0) {
        mp->initializer = createModuleInitializer(cp, np, mp);
    }
    np->module.ref = mp;

    if (cp->outputFile) {
        np->module.filename = cp->outputFile;
    } else {
        np->module.filename = mprJoinPath(cp->outputDir, sfmt("%@%s", np->qname.name, EJS_MODULE_EXT));
    }
    return mp;
}


static EcNode *getNextAstNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->fatalError) {
        return 0;
    }
    if (np == 0 || np->children == 0) {
        return 0;
    }
    return (EcNode*) mprGetNextItem(np->children, next);
}


static void processAstNode(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    int         codeRequired, instanceCode;

    ENTER(cp);
    assert(np->parent || np->kind == N_PROGRAM);

    state = cp->state;
    codeRequired = 0;
    instanceCode = state->instanceCode;
    
    switch (np->kind) {
    case N_ARGS:
        astArgs(cp, np);
        codeRequired++;
        break;

    case N_ASSIGN_OP:
        astAssignOp(cp, np);
        codeRequired++;
        break;

    case N_BINARY_OP:
        astBinaryOp(cp, np);
        codeRequired++;
        break;

    case N_BLOCK:
        astBlock(cp, np);
        break;

    case N_BREAK:
        astBreak(cp, np);
        break;

    case N_CALL:
        astCall(cp, np);
        codeRequired++;
        break;

    case N_CASE_ELEMENTS:
        astCaseElements(cp, np);
        codeRequired++;
        break;

    case N_CASE_LABEL:
        astCaseLabel(cp, np);
        codeRequired++;
        break;

    case N_CATCH:
        astCatch(cp, np);
        codeRequired++;
        break;

    case N_CATCH_ARG:
        codeRequired++;
        break;

    case N_CLASS:
        astClass(cp, np);
        codeRequired++;
        break;

    case N_CONTINUE:
        break;

    case N_DASSIGN:
        astDassign(cp, np);
        break;

    case N_DIRECTIVES:
        astDirectives(cp, np);
        break;

    case N_DO:
        astDo(cp, np);
        codeRequired++;
        break;

    case N_DOT:
        astDot(cp, np);
        codeRequired++;
        break;

    case N_END_FUNCTION:
        break;

    case N_EXPRESSIONS:
        astExpressions(cp, np);
        break;

    case N_FOR:
        astFor(cp, np);
        codeRequired++;
        break;

    case N_FOR_IN:
        astForIn(cp, np);
        codeRequired++;
        break;

    case N_FUNCTION:
        astFunction(cp, np);
        break;

    case N_LITERAL:
        codeRequired++;
        break;

    case N_OBJECT_LITERAL:
        astObjectLiteral(cp, np);
        codeRequired++;
        break;

    case N_FIELD:
        astField(cp, np);
        codeRequired++;
        break;

    case N_QNAME:
        astName(cp, np);
        codeRequired++;
        break;

    case N_NEW:
        astNew(cp, np);
        codeRequired++;
        break;

    case N_NOP:
        break;

    case N_POSTFIX_OP:
        astPostfixOp(cp, np);
        codeRequired++;
        break;

    case N_PRAGMAS:
        astPragmas(cp, np);
        break;

    case N_PRAGMA:
        astPragma(cp, np);
        break;

    case N_PROGRAM:
        astProgram(cp, np);
        break;

    case N_REF:
        codeRequired++;
        break;

    case N_RETURN:
        astReturn(cp, np);
        codeRequired++;
        break;

    case N_SPREAD:
        astSpread(cp, np);
        codeRequired++;
        break;

    case N_SUPER:
        astSuper(cp, np);
        codeRequired++;
        break;

    case N_SWITCH:
        astSwitch(cp, np);
        codeRequired++;
        break;

    case N_HASH:
        astHash(cp, np);
        break;

    case N_IF:
        astIf(cp, np);
        codeRequired++;
        break;

    case N_THIS:
        astThis(cp, np);
        codeRequired++;
        break;

    case N_THROW:
        astThrow(cp, np);
        codeRequired++;
        break;

    case N_TRY:
        astTry(cp, np);
        break;

    case N_UNARY_OP:
        astUnaryOp(cp, np);
        codeRequired++;
        break;

    case N_MODULE:
        astModule(cp, np);
        break;
            
    case N_TYPE_IDENTIFIERS:
        astImplements(cp, np);
        break;

    case N_USE_NAMESPACE:
        astUseNamespace(cp, np);
        break;

    case N_USE_MODULE:
        astRequire(cp, np);
        break;

    case N_VAR_DEFINITION:
        astVarDefinition(cp, np, &codeRequired, &instanceCode);
        break;

    case N_VOID:
        astVoid(cp, np);
        break;

    case N_WITH:
        astWith(cp, np);
        break;

    default:
        assert(0);
        badAst(cp, np);
    }
    
    /*
        Determine if classes need initializers. If class code is generated outside of a method, then some form of
        initialization will be required. Either a class constructor, initializer or a global initializer.
     */
    if (cp->phase == EC_PHASE_DEFINE && codeRequired && !state->inMethod && !state->inHashExpression) {
        if (state->inClass && !state->currentClass->isInterface) {
            if (instanceCode) {
                state->currentClass->hasConstructor = 1;
            } else {
                state->currentClass->hasInitializer = 1;
            }
        } else {
            state->currentModule->hasInitializer = 1;
        }
    }
    assert(state == cp->state);
    LEAVE(cp);
}


static void removeProperty(EcCompiler *cp, EjsObj *obj, EcNode *np)
{
    Ejs             *ejs;
    EjsName         *prop;
    MprList         *globals;
    int             next, slotNum;

    assert(obj);
    ejs = cp->ejs;

    if (np->globalProp) {
        globals = cp->state->currentModule->globalProperties;
        assert(globals);

        for (next = 0; ((prop = (EjsName*) mprGetNextItem(globals, &next)) != 0); ) {
            if (np->qname.space == prop->space && np->qname.name == prop->name) {
                mprRemoveItem(globals, prop);
                break;
            }
        }
    }
    slotNum = ejsLookupProperty(ejs, obj, np->qname);
    if (slotNum >= 0) {
        ejsRemovePotProperty(ejs, obj, slotNum);
    }
}


/*
    Fixup all slot definitions in types. When types are first created, they do not reserve space for inherited slots.
    Now that all types should have been resolved, we can reserve room for inherited slots. Override functions also 
    must be removed.
 */
static void fixupClass(EcCompiler *cp, EjsType *type)
{
    Ejs             *ejs;
    EjsType         *baseType, *iface, *typeType;
    EjsFunction     *fun;
    EjsPot          *prototype;
    EjsObj          *obj;
    EjsName         qname;
    EjsTrait        *trait;
    EcNode          *np, *child;
    int             next, slotNum, attributes, hasInstanceVars;

    if (VISITED(type) || !type->needFixup) {
        return;
    }
    type->needFixup = 0;

    assert(cp);
    assert(type);
    assert(ejsIsType(ejs, type));

    ENTER(cp);

    ejs = cp->ejs;
    SET_VISITED(type, 1);
    np = (EcNode*) type->typeData;
    type->typeData = 0;
    baseType = type->baseType;

    if (baseType == 0) {
        if (np && np->kind == N_CLASS && !np->klass.isInterface) {
            if (np->klass.extends) {
                qname.space = NULL;
                qname.name = np->klass.extends;
                baseType = (EjsType*) getTypeProperty(cp, ejs->global, qname);
            } else {
                if (! (!ejs->initialized && type->qname.name == EST(Object)->qname.name)) {
                    baseType = (EjsType*) getTypeProperty(cp, ejs->global, N(EJS_EJS_NAMESPACE, "Object"));
                }
            }
        }
    }
    if (np->klass.implements) {
        type->implements = mprCreateList(-1, 0);
        next = 0;
        while ((child = getNextAstNode(cp, np->klass.implements, &next))) {
            iface = (EjsType*) getTypeProperty(cp, ejs->global, child->qname);
            if (iface) {
                mprAddItem(type->implements, iface);
            } else {
                astError(cp, np, "Cannot find interface \"%@\"", child->qname.name);
                SET_VISITED(type, 0);
                LEAVE(cp);
                return;
            }
        }
    }
    if (baseType == 0) {
        if (! (!ejs->initialized && type->qname.name == EST(Object)->qname.name) && !np->klass.isInterface) {
            astError(cp, np, "Cannot find base type for %@", type->qname.name);
            SET_VISITED(type, 0);
            LEAVE(cp);
            return;
        }
    }
    if (baseType) {
        if (baseType->needFixup) {
            fixupClass(cp, baseType);
        }
        if (baseType->hasConstructor) {
            type->hasBaseConstructors = 1;
        }
        if (baseType->hasInitializer) {
            type->hasBaseInitializers = 1;
        }
    }
    if (type->implements) {
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            if (iface->needFixup) {
                fixupClass(cp, iface);
            }
            if (iface->hasConstructor) {
                type->hasBaseConstructors = 1;
            }
            if (iface->hasInitializer) {
                type->hasBaseInitializers = 1;
            }
        }
    }
    if (!type->constructor.block.pot.isPrototype && (EjsObj*) type != ejs->global && !type->isInterface) {
        /*
            Remove the static initializer slot if this class does not require a static initializer
            By convention, it is installed in slot number 1.
         */
        if (type->hasBaseInitializers) {
            type->hasInitializer = 1;
        }
        if (!type->hasInitializer) {
            ejsRemovePotProperty(ejs, (EjsObj*) type, 0);
        }
        /*
            Disable the constructor if this class does not require it
         */
        if (type->hasBaseConstructors) {
            type->hasConstructor = 1;
        }
        if (!type->hasConstructor) {
            np->klass.constructor = 0;
            ejsRemoveConstructor(ejs, type);
            assert(!(np->attributes & EJS_TYPE_HAS_CONSTRUCTOR));
        }
    }

    /*
        Determine if instances need to copy the prototype properties
     */
    hasInstanceVars = 0;
    prototype = type->prototype;
    for (slotNum = 0; slotNum < prototype->numProp; slotNum++) {
        obj = ejsGetProperty(ejs, prototype, slotNum);
        if (!ejsIsFunction(ejs, obj) && !ejsIsBlock(ejs, obj)) {
            hasInstanceVars = 1;
            break;
        }
    }
    type->hasInstanceVars |= hasInstanceVars;
    if (baseType) {
        type->hasInstanceVars |= baseType->hasInstanceVars;
    }
    ejsFixupType(ejs, type, baseType, 1);
    
    if (ejs->empty) {
        typeType = (EjsType*) getTypeProperty(cp, ejs->global, N(EJS_EJS_NAMESPACE, "Type"));
    } else {
        typeType = EST(Type);
    }
    if (typeType == 0) {
        astError(cp, 0, "Cannot find Type class");
    }
    if (typeType->needFixup) {
        fixupClass(cp, typeType);
    }

    /*
        Remove the original overridden method. Set the inherited slot to the overridden method. This implements a v-table.
     */
    prototype = type->prototype;
    for (slotNum = type->numInherited; slotNum < prototype->numProp; slotNum++) {
        trait = ejsGetPropertyTraits(ejs, prototype, slotNum);
        if (trait == 0) {
            continue;
        }
        attributes = trait->attributes;
        if (attributes & EJS_FUN_OVERRIDE && type->numInherited > 0) {
            /*
                If the type is not an orphan, it must preserve the slot order dictated by the base class
             */
            fun = ejsGetProperty(ejs, prototype, slotNum);
            assert(fun && ejsIsFunction(ejs, fun));
            qname = ejsGetPropertyName(ejs, prototype, slotNum);
            ejsRemovePotProperty(ejs, prototype, slotNum);
            slotNum--;
            if (resolveName(cp, NULL, (EjsObj*) type, qname) < 0 || cp->lookup.slotNum < 0) {
                astError(cp, 0, "Cannot find method \"%N\" in base type of \"%@\" to override", qname.space, qname.name, 
                    type->qname.name);
            } else {
                ejsSetProperty(ejs, prototype, cp->lookup.slotNum, (EjsObj*) fun);
                ejsSetPropertyTraits(cp->ejs, prototype, cp->lookup.slotNum, NULL, attributes);
            }
        }
    }
    SET_VISITED(type, 0);
    LEAVE(cp);
}


/*
    Lookup the namespace for a definition (np->qname.space).  We look for the namespace variable declaration if it is a user
    defined namespace. Otherwise, we trust that if the set of open namespaces has the namespace -- it must exist.
 */
static EjsNamespace *resolveNamespace(EcCompiler *cp, EcNode *np, EjsAny *block, bool *modified)
{
    Ejs             *ejs;
    EjsName         qname;
    EjsNamespace    *nspace;
    int             slotNum;

    ejs = cp->ejs;

    if (modified) {
        *modified = 0;
    }
    qname.name = np->qname.space;
    qname.space = 0;
    nspace = (EjsNamespace*) getTypeProperty(cp, 0, qname);
    if (nspace == 0 || !ejsIs(ejs, nspace, Namespace)) {
        nspace = lookupNamespace(cp->ejs, np->qname.space);
    }
    if (nspace == 0 && cp->state->nspace == np->qname.space) {
        nspace = ejsCreateNamespace(ejs, np->qname.space);
    }
    if (nspace == 0) {
        if (!np->literalNamespace) {
            astError(cp, np, "Cannot find namespace \"%@\"", qname.name);
        }
    } else {
        if (nspace->value != np->qname.space) {
            slotNum = ejsLookupProperty(ejs, block, np->qname);
            assert(slotNum >= 0);
            if (slotNum >= 0) {
                /*
                    Change the name to use the namespace URI. This will change the property name and set
                    "modified" so that the caller can modify the derrived names (type->qname)
                 */
                np->qname.space = nspace->value;
                ejsSetPropertyName(ejs, block, slotNum, np->qname);
                if (modified) {
                    *modified = 1;
                }
            }
        }
    }
    //  TODO - nobody uses this except as a return code
    return nspace;
}


/*
    Locate a property in context. NOTE this only works for type properties not instance properties.
 */
static EjsObj *getTypeProperty(EcCompiler *cp, EjsObj *vp, EjsName name)
{
    EcNode      node;

    assert(cp);

    if (resolveName(cp, &node, vp, name) < 0) {
        return 0;
    }
    return node.lookup.ref;
}


static int resolveProperty(EcCompiler *cp, EcNode *np, EjsType *type, EjsName name)
{
    EcNode      node;

    assert(cp);

    if (resolveName(cp, &node, (EjsObj*) type->prototype, name) < 0) {
        if (resolveName(cp, &node, (EjsObj*) type, name) < 0) {
            return -1;
        }
    }
    return 0;
}


/*
    Locate a property via lookup and determine the best way to address the property.
 */
static int resolveName(EcCompiler *cp, EcNode *np, EjsAny *vp, EjsName qname)
{
    Ejs         *ejs;
    EjsLookup   *lookup;
    EjsType     *type, *currentClass, *tp;
    EcState     *state;
    EjsBlock    *block;

    ejs = cp->ejs;
    state = cp->state;
    lookup = &cp->lookup;

    cp->lookup.bind = 0;

    if (vp) {
        if (ecLookupVar(cp, vp, qname) < 0) {
            return EJS_ERR;
        }
    } else if (ecLookupScope(cp, qname) < 0) {
        return EJS_ERR;
    }
    cp->lookup.bind = 1;

    /*
        Revise the nth block to account for blocks that will be erased
     */
    lookup->nthBlock = 0;
    for (block = ejs->state->bp->scope; block; block = block->scope) {
        if ((EjsObj*) block == lookup->obj) {
            break;
        }
        if (ejsIsType(ejs, block)) {
            type = (EjsType*) block;
            if ((EjsObj*) type->prototype == lookup->obj) {
                break;
            }
        }
        lookup->nthBlock++;
    }
    if (block == 0) {
        lookup->nthBlock = 0;
    }
    assert(lookup->ref);    
    if (lookup->ref == ESV(null)) {
        lookup->ref = 0;
    }

    if ((ejsIsType(ejs, lookup->obj) || ejsIsPrototype(ejs, lookup->obj)) && state->currentObjectNode == 0) {
        assert(lookup->obj != ejs->global);
        //  NOTE: could potentially do this for static properties as well
        if (lookup->trait && lookup->slotNum >= 0) {
            /*
                class instance or method properties
             */
            type = (EjsType*) lookup->obj;
            currentClass = state->currentClass;
            if (currentClass) {
                assert(state->inClass);
                for (tp = currentClass; tp; tp = tp->baseType) {
                    if ((EjsObj*) tp == lookup->obj || (EjsObj*) tp->prototype == lookup->obj) {
                        /*
                            Method code or class level instance initialization code. This is code that is a subtype of the 
                            type owning the property, so we can use the thisObj to access it.
                         */
                        if (state->inClass) {
                            lookup->useThis = 1;
                        }
                    }
                }
            }
        }
    }

    if (np) {
        np->lookup = cp->lookup;
    }
    return 0;
}


/*
    Wrap the define property routine. Need to keep a module to property mapping
 */
static void addGlobalProperty(EcCompiler *cp, EcNode *np, EjsName *qname)
{
    EjsModule   *up;
    EjsName     *p;
    int         next;

    up = cp->state->currentModule;
    assert(up);

    if (up->globalProperties == 0) {
        up->globalProperties = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    }
    //  TODO OPT - should this be a hash?
    for (next = 0; (p = (EjsName*) mprGetNextItem(up->globalProperties, &next)) != 0; ) {
        if (p->name == qname->name && p->space == qname->space) {
            return;
        }
    }
    next = mprAddItem(up->globalProperties, qname);
    if (np) {
        np->globalProp = qname;
    }
}


static void setAstDocString(Ejs *ejs, EcNode *np, cchar *tag, void *vp, int slotNum)
{
    assert(vp);
    assert(slotNum >= 0);

    if (np->doc && vp && slotNum >= 0) {
        ejsCreateDoc(ejs, tag, vp, slotNum, np->doc);
    }
}


static void addScope(EcCompiler *cp, EjsBlock *block)
{
    assert(block != cp->ejs->state->bp);

    //  TODO -- why is there a "Compiler" object on the top at all times?
    block->scope = cp->ejs->state->bp->scope;
    cp->ejs->state->bp->scope = block;
    assert(block != block->scope);
}


static void removeScope(EcCompiler *cp)
{
    EjsBlock    *block;

    block = cp->ejs->state->bp;
    assert(block != block->scope);
    block->scope = block->scope->scope;
}


/*
    Create a new lexical block scope and open it
 */
static void openBlock(EcCompiler *cp, EcNode *np, EjsBlock *block)
{
    Ejs             *ejs;
    EcState         *state;
    EjsNamespace    *namespace;
    char            *debugName;
    int             next;

    ejs = cp->ejs;
    state = cp->state;

    if (cp->phase == EC_PHASE_DEFINE) {
        if (block == 0) {
            static int index = 0;
            if (np->loc.filename == 0) {
                debugName = sfmt("block_%04d", index++);
            } else {
                debugName = sfmt("block_%04d_%d", np->loc.lineNumber, index++);
            }
            block = ejsCreateBlock(cp->ejs, 0);
            np->qname = N(EJS_BLOCK_NAMESPACE, debugName);
        }
        np->blockRef = block;

    } else {
        /*
            Must reset the namespaces each phase. This is because pragmas must apply from the point of use in a block onward
            only. Except for hoisted variable namespaces which must apply from the start of the block. They are applied below
         */
        if (block == 0) {
            block = np->blockRef;
        }
        if (!ejsIsType(ejs, block) && block != ejs->global) {
            ejsResetBlockNamespaces(ejs, block);
        }
    }
    state->namespaceCount = ejsGetNamespaceCount(block);

    /*
        Special case for the outermost module block. The module (file) block is created to provide a compilation unit
        level scope. However, we do not use the block for the let or var scope, rather we use the global scope.
        Namespaces always use this new block.
     */
    if (! (state->letBlock == ejs->global && np->parent->kind == N_MODULE)) {
        state->optimizedLetBlock = block;
    }
    state->letBlock = block;
    state->letBlockNode = np;

    /*
        Add namespaces that must apply from the start of the block. Current users: hoisted let vars.
     */
    //  TODO -- this seems to always be null
    assert(np->namespaces == NULL);
    if (np->namespaces) {
        for (next = 0; (namespace = (EjsNamespace*) mprGetNextItem(np->namespaces, &next)) != 0; ) {
            ejsAddNamespaceToBlock(ejs, block, namespace);
        }
    }
    /*
        Mark the state corresponding to the last opened block
     */
    state->prevBlockState = cp->blockState;
    cp->blockState = state;
    addScope(cp, block);
}


static void closeBlock(EcCompiler *cp)
{
    EjsBlock    *block;
    EcState     *state;
    
    state = cp->state;
    
    block = cp->ejs->state->bp->scope;
    ejsPopBlockNamespaces(block, state->namespaceCount);
    cp->blockState = state->prevBlockState;
    removeScope(cp);
}


/*
    Determine the block in which to define a variable.
 */
static EjsBlock *getBlockForDefinition(EcCompiler *cp, EcNode *np, EjsBlock *block, int attributes)
{
    EcState     *state;
    EjsType     *type;

    state = cp->state;

    if (ejsIsType(cp->ejs, block) && state->inClass) {
        if (!(attributes & EJS_PROP_STATIC) && !state->inFunction &&
                state->blockNestCount <= (state->classState->blockNestCount + 1)) {
            /*
                Use the prototype object if not static, outside a function and in the top level block.
             */
            type = (EjsType*) block;
            if (!(np->kind == N_FUNCTION && np->function.isConstructor)) {
                block = (EjsBlock*) type->prototype;
            }
            if (np->kind == N_QNAME || np->kind == N_VAR) {
                np->name.instanceVar = 1;
            }
        }
    }
    return block;
}


static EjsNamespace *lookupNamespace(Ejs *ejs, EjsString *nspace)
{
    MprList         *namespaces;
    EjsNamespace    *nsp;
    EjsBlock        *block;
    int             nextNamespace;

    /*
        Lookup the scope chain considering each block and the open namespaces at that block scope.
     */
    for (block = ejs->state->bp; block; block = block->scope) {
        if (!ejsIsBlock(ejs, block)) {
            continue;
        }
        namespaces = &block->namespaces;
        for (nextNamespace = -1; (nsp = (EjsNamespace*) mprGetPrevItem(namespaces, &nextNamespace)) != 0; ) {
            if (nsp->value == nspace) {
                return nsp;
            }
        }
    }
    block = ejs->global;
    namespaces = &block->namespaces;
    for (nextNamespace = -1; (nsp = (EjsNamespace*) mprGetPrevItem(namespaces, &nextNamespace)) != 0; ) {
        if (nsp->value == nspace) {
            return nsp;
        }
    }
    return 0;
}


//  TODO - common this with the slow-path version in the VM

/*
    Look for a variable by name in the scope chain and return the location in "cp->lookup" and a positive slot 
    number if found.  If the name.space is non-null/non-empty, then only the given namespace will be used. 
    otherwise the set of open namespaces will be used. The lookup structure will contain details about the location 
    of the variable.
 */
PUBLIC int ecLookupScope(EcCompiler *cp, EjsName name)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EjsBlock        *bp;
    EjsState        *state;
    EjsType         *type;
    EjsPot          *prototype;
    EjsLookup       *lookup;
    int             slotNum, nthBase;

    assert(cp);
    assert(name.name);

    ejs = cp->ejs;
    if (name.space == NULL) {
        name.space = ESV(empty);
    }
    lookup = &cp->lookup;
    state = ejs->state;
    slotNum = -1;
    
    memset(lookup, 0, sizeof(*lookup));

    //  TODO -- remove nthBlock. Not needed if not binding
    //  TODO -- should start one in to step over Compiler block
    for (lookup->nthBlock = 0, bp = state->bp; bp; bp = bp->scope, lookup->nthBlock++) {
        /* Seach simple object */
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, bp, name, lookup)) >= 0) {
            return slotNum;
        }
        if (ejsIsFrame(ejs, bp)) {
            fun = (EjsFunction*) bp;
            if (cp->state->inMethod && !fun->staticMethod && !fun->isInitializer) {
                /* Instance method only */
                /* Search prototype chain */
                for (nthBase = 1, type = cp->state->currentClass; type; type = type->baseType, nthBase++) {
                    if ((prototype = type->prototype) == 0 || prototype->shortScope) {
                        break;
                    }
                    if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
                        lookup->nthBase = nthBase;
                        return slotNum;
                    }
                }
            }
        } else if (ejsIsType(ejs, bp)) {
            if (cp->state->inClass && !cp->state->inFunction) {
                /* TODO Instance level initialization code. Should really be inside a constructor */
                for (nthBase = 1, type = cp->state->currentClass; type; type = type->baseType, nthBase++) {
                    if ((prototype = type->prototype) == 0 || prototype->shortScope) {
                        break;
                    }
                    if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
                        lookup->nthBase = nthBase;
                        return slotNum;
                    }
                }
            }
            //  TODO -- remove nthBase. Not needed if not binding.
            /* Search base class chain */
            for (nthBase = 1, type = (EjsType*) bp; type; type = type->baseType, nthBase++) {
                if (type->constructor.block.pot.shortScope) {
                    break;
                }
                if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
                    lookup->nthBase = nthBase;
                    return slotNum;
                }
            }
        }
    }
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, ejs->global, name, lookup)) >= 0) {
        return slotNum;
    }
    return -1;
}


PUBLIC int ecLookupVar(EcCompiler *cp, EjsAny *obj, EjsName name)
{
    Ejs         *ejs;
    EjsLookup   *lookup;
    EjsType     *type;
    EjsPot      *prototype;
    int         slotNum, nthBase;

    assert(obj);
    
    ejs = cp->ejs;
    lookup = &cp->lookup;
    if (name.space == NULL) {
        name.space = ESV(empty);
    }
    memset(lookup, 0, sizeof(*lookup));

    /* Lookup simple object */
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, name, lookup)) >= 0) {
        return slotNum;
    }
    /* Lookup prototype chain */
    type = ejsIsType(ejs, obj) ? ((EjsType*) obj) : TYPE(obj);
    for (nthBase = 1; type; type = type->baseType, nthBase++) {
        if ((prototype = type->prototype) == 0 || prototype->shortScope) {
            break;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    /* Lookup base-class chain */
    type = ejsIsType(ejs, obj) ? ((EjsType*) obj)->baseType : TYPE(obj);
    for (nthBase = 1; type; type = type->baseType, nthBase++) {
        if (type->constructor.block.pot.shortScope) {
            continue;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    return -1;
}


static void astError(EcCompiler *cp, EcNode *np, cchar *fmt, ...)
{
    EcLocation  *loc;
    va_list     args;

    va_start(args, fmt);
    cp->errorCount++;
    cp->error = 1;
    cp->noout = 1;
    
    if (np) {
        loc = &np->loc;
        ecErrorv(cp, "Error", loc, fmt, args);
    } else {
        ecError(cp, "Error", NULL, fmt, args);
    }
    va_end(args);
}


static void astWarn(EcCompiler *cp, EcNode *np, cchar *fmt, ...)
{
    va_list     args;
    EcLocation  *loc;

    va_start(args, fmt);

    cp->warningCount++;
    loc = &np->loc;
    ecError(cp, "Warning", loc, fmt, args);
    va_end(args);
}


static void badAst(EcCompiler *cp, EcNode *np)
{
    cp->fatalError = 1;
    cp->errorCount++;
    mprError("Unsupported language feature\nUnknown AST node kind %d",  np->kind);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/compiler/ecCodeGen.c"
 */
/************************************************************************/

/**
    ecCodeGen.c - Ejscript code generator
  
    This module generates code for a program that is represented by an in-memory AST set of nodes.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************** Defines ***********************************/
/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(a)    if (ecEnterState(a) < 0) { return; } else

#undef LEAVE
#define LEAVE(cp)   ecLeaveState(cp)

#define SAVE_ONLEFT(cp)                                     \
    if (1) {                                                \
            cp->state->saveOnLeft = cp->state->onLeft;      \
            cp->state->onLeft = 0;                          \
    } else

#define RESTORE_ONLEFT(cp)                                  \
    cp->state->onLeft = cp->state->saveOnLeft

/***************************** Forward Declarations ***************************/

static void     addDebug(EcCompiler *cp, EcNode *np);
static void     addDebugLine(EcCompiler *cp, EcCodeGen *code, int offset, wchar *source);
static void     addException(EcCompiler *cp, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart, 
                    uint handlerEnd, int numBlocks, int numStack, int flags);
static void     addJump(EcCompiler *cp, EcNode *np, int kind);
static void     addModule(EcCompiler *cp, EjsModule *mp);
static EcCodeGen *allocCodeBuffer(EcCompiler *cp);
static void     badNode(EcCompiler *cp, EcNode *np);
static void     copyCodeBuffer(EcCompiler *cp, EcCodeGen *dest, EcCodeGen *code);
static void     createInitializer(EcCompiler *cp, EjsModule *mp);
static void     discardBlockItems(EcCompiler *cp, int preserve);
static void     discardStackItems(EcCompiler *cp, int preserve);
static void     emitNamespace(EcCompiler *cp, EjsNamespace *nsp);
static int      flushModule(MprFile *file, EcCodeGen *code);
static void     genBinaryOp(EcCompiler *cp, EcNode *np);
static void     genBlock(EcCompiler *cp, EcNode *np);
static void     genBreak(EcCompiler *cp, EcNode *np);
static void     genBoundName(EcCompiler *cp, EcNode *np);
static void     genCall(EcCompiler *cp, EcNode *np);
static void     genCatchArg(EcCompiler *cp, EcNode *np);
static void     genClass(EcCompiler *cp, EcNode *child);
static void     genClassName(EcCompiler *cp, EjsType *type);
static void     genContinue(EcCompiler *cp, EcNode *np);
static void     genDassign(EcCompiler *cp, EcNode *np);
static void     genDirectives(EcCompiler *cp, EcNode *np, bool saveResult);
static void     genDo(EcCompiler *cp, EcNode *np);
static void     genDot(EcCompiler *cp, EcNode *np, EcNode **rightMost);
static void     genError(EcCompiler *cp, EcNode *np, char *fmt, ...);
static void     genEndFunction(EcCompiler *cp, EcNode *np);
static void     genExpressions(EcCompiler *cp, EcNode *np);
static void     genField(EcCompiler *cp, EcNode *np);
static void     genFor(EcCompiler *cp, EcNode *np);
static void     genForIn(EcCompiler *cp, EcNode *np);
static void     genFunction(EcCompiler *cp, EcNode *np);
static void     genHash(EcCompiler *cp, EcNode *np);
static void     genIf(EcCompiler *cp, EcNode *np);
static void     genLeftHandSide(EcCompiler *cp, EcNode *np);
static void     genLiteral(EcCompiler *cp, EcNode *np);
static void     genLogicalOp(EcCompiler *cp, EcNode *np);
static void     genModule(EcCompiler *cp, EcNode *np);
static void     genName(EcCompiler *cp, EcNode *np);
static void     genNameExpr(EcCompiler *cp, EcNode *np);
static void     genNew(EcCompiler *cp, EcNode *np);
static void     genArrayLiteral(EcCompiler *cp, EcNode *np);
static void     genObjectLiteral(EcCompiler *cp, EcNode *np);
static void     genProgram(EcCompiler *cp, EcNode *np);
static void     genPragmas(EcCompiler *cp, EcNode *np);
static void     genPostfixOp(EcCompiler *cp, EcNode *np);
static void     genReturn(EcCompiler *cp, EcNode *np);
static void     genSuper(EcCompiler *cp, EcNode *np);
static void     genSwitch(EcCompiler *cp, EcNode *np);
static void     genThis(EcCompiler *cp, EcNode *np);
static void     genThrow(EcCompiler *cp, EcNode *np);
static void     genTry(EcCompiler *cp, EcNode *np);
static void     genUnaryOp(EcCompiler *cp, EcNode *np);
static void     genUnboundName(EcCompiler *cp, EcNode *np);
static void     genUseNamespace(EcCompiler *cp, EcNode *np);
static void     genVar(EcCompiler *cp, EcNode *np);
static void     genVarDefinition(EcCompiler *cp, EcNode *np);
static void     genWith(EcCompiler *cp, EcNode *np);
static int      getCodeLength(EcCompiler *cp, EcCodeGen *code);
static EcNode   *getNextNode(EcCompiler *cp, EcNode *np, int *next);
static EcNode   *getPrevNode(EcCompiler *cp, EcNode *np, int *next);
static int      getStackCount(EcCompiler *cp);
static int      mapToken(EcCompiler *cp, int tokenId);
static MprFile  *openModuleFile(EcCompiler *cp, cchar *filename);
static void     orderModule(EcCompiler *cp, MprList *list, EjsModule *mp);
static void     patchJumps(EcCompiler *cp, int kind, int target);
static void     popStack(EcCompiler *cp, int count);
static void     processNode(EcCompiler *cp, EcNode *np);
static void     processModule(EcCompiler *cp, EjsModule *mp);
static void     pushStack(EcCompiler *cp, int count);
static void     setCodeBuffer(EcCompiler *cp, EcCodeGen *saveCode);
static void     setFunctionCode(EcCompiler *cp, EjsFunction *fun, EcCodeGen *code);
static void     setStack(EcCompiler *cp, int count);

/************************************ Code ************************************/
/*
    Generate code for evaluating conditional compilation directives
 */
PUBLIC void ecGenConditionalCode(EcCompiler *cp, EcNode *np, EjsModule *mp)
{
    ENTER(cp);

    addModule(cp, mp);
    genDirectives(cp, np, 1);

    if (cp->errorCount > 0) {
        ecRemoveModule(cp, mp);
        LEAVE(cp);
        return;
    }
    createInitializer(cp, mp);
    ecRemoveModule(cp, mp);
    LEAVE(cp);
}


/*
    Top level for code generation. Loop through the AST nodes recursively.
 */
PUBLIC int ecCodeGen(EcCompiler *cp)
{
    EjsModule   *mp;
    EcNode      *np;
    MprList     *modules;
    int         next, i, count;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }
    count = mprGetListLength(cp->nodes);
    for (i = 0; i < count && !cp->error; i++) {
        np = mprGetItem(cp->nodes, i);
        cp->fileState = cp->state;
        cp->fileState->strict = cp->strict;
        if (np) {
            processNode(cp, np);
        }
    }
    if (cp->error) {
        return EJS_ERR;
    }

    /*
        Open once if merging into a single output file
     */
    if (cp->outputFile) {
        for (next = 0; (mp = mprGetNextItem(cp->modules, &next)) != 0; ) {
            if (next <= 1 || mp->globalProperties || mp->hasInitializer || 
                    ejsCompareAsc(cp->ejs, mp->name, EJS_DEFAULT_MODULE) != 0) {
                break;
            }
        }
        if (openModuleFile(cp, cp->outputFile) == 0) {
            return EJS_ERR;
        }
    }

    /*
        Now generate code for all the modules
     */
    modules = mprCreateList(-1, 0);
    for (next = 0; (mp = mprGetNextItem(cp->modules, &next)) != 0; ) {
        orderModule(cp, modules, mp);
    }
    for (next = 0; (mp = mprGetNextItem(modules, &next)) != 0 && !cp->fatalError; ) {
        //  TODO -- remove this test. Should be able to add to a loaded module??
        assert(!mp->loaded);
        if (mp->loaded) {
            continue;
        }
        /*
            Don't generate the default module unless it contains some real code or definitions and 
            we have more than one module.
         */
        if (mprGetListLength(cp->modules) == 1 || mp->globalProperties || mp->hasInitializer || 
                ejsCompareAsc(cp->ejs, mp->name, EJS_DEFAULT_MODULE) != 0) {
            mp->initialized = 0;
            processModule(cp, mp);
        }
    }
    cp->modules = modules;

    if (cp->outputFile) {
        if (flushModule(cp->file, cp->state->code) < 0) {
            genError(cp, 0, "Cannot write to module file %s", cp->outputFile);
        }
        mprCloseFile(cp->file);
    }
    cp->file = 0;
    ecLeaveState(cp);
    return (cp->fatalError) ? EJS_ERR : 0;
}


static void orderModule(EcCompiler *cp, MprList *list, EjsModule *mp)
{
    EjsModule   *dp;
    int         next;
    
    mp->visited = 1;
    for (next = 0; (dp = mprGetNextItem(mp->dependencies, &next)) != 0; ) {
        if (mprLookupItem(list, dp) < 0 && mprLookupItem(cp->modules, dp) >= 0) {
            if (!dp->visited) {
                orderModule(cp, list, dp);
            }
        }
    }
    if (mprLookupItem(list, mp) < 0) {
        mprAddItem(list, mp);
    }
    mp->visited = 0;
}


static void genArgs(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);
    assert(np->kind == N_ARGS);

    cp->state->needsValue = 1;

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        if (child->kind == N_ASSIGN_OP) {
            child->needDup = 1;
        }
        processNode(cp, child);
        child->needDup = 0;
    }
    LEAVE(cp);
}


static void genSpread(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    assert(np->kind == N_SPREAD);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        if (child->kind == N_ASSIGN_OP) {
            child->needDup = 1;
        }
        processNode(cp, child);
        child->needDup = 0;
    }
    ecEncodeOpcode(cp, EJS_OP_SPREAD);
    LEAVE(cp);
}


/*
    Generate an assignment expression
 */
static void genAssignOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    assert(np->kind == N_ASSIGN_OP);
    assert(np->left);
    assert(np->right);

    state = cp->state;
    state->onLeft = 0;

    /*
        Dup the object on the stack so it is available for subsequent operations
     */
    if (np->needDupObj) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }

    /*
        Process the expression on the right. Leave the result on the stack.
     */
    if (np->right->kind == N_ASSIGN_OP) {
        np->right->needDup = 1;
    }

    state->needsValue = 1;
    processNode(cp, np->right);
    state->needsValue = 0;

    if (np->needDupObj) {
        /*
            Get the object on the top above the value
         */
        ecEncodeOpcode(cp, EJS_OP_SWAP);
    }

    /*
        If this expression is part of a function argument, the result must be preserved.
     */
    if (np->needDup || state->next->needsValue) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }

    /*
        Store to the left hand side
     */
    genLeftHandSide(cp, np->left);
    LEAVE(cp);
}


static void genBinaryOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    state->needsValue = 1;

    assert(np->kind == N_BINARY_OP);

    switch (np->tokenId) {
    case T_LOGICAL_AND:
    case T_LOGICAL_OR:
        genLogicalOp(cp, np);
        break;

    default:
        if (np->left) {
            processNode(cp, np->left);
        }
        if (np->right) {
            processNode(cp, np->right);
        }
        ecEncodeOpcode(cp, mapToken(cp, np->tokenId));
        popStack(cp, 2);
        pushStack(cp, 1);
        break;
    }
    assert(state == cp->state);
    LEAVE(cp);
}


static void genBreak(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    discardBlockItems(cp, state->code->blockMark);
    if (state->captureFinally) {
        ecEncodeOpcode(cp, EJS_OP_CALL_FINALLY);
    } else if (cp->state->captureBreak) {
        ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
    }
    if (state->code->jumps == 0 || !(state->code->jumpKinds & EC_JUMP_BREAK)) {
        genError(cp, np, "Illegal break statement");
    } else {
        discardStackItems(cp, state->code->breakMark);
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        addJump(cp, np, EC_JUMP_BREAK);
        ecEncodeInt32(cp, 0);
    }
    LEAVE(cp);
}


static void genBlock(EcCompiler *cp, EcNode *np)
{
    EjsNamespace    *namespace;
    EcState         *state;
    EjsBlock        *block;
    EjsLookup       *lookup;
    EcNode          *child;
    int             next;

    ENTER(cp);

    state = cp->state;
    block = (EjsBlock*) np->blockRef;

    if (block && np->createBlockObject) {
        state->prevBlockState = cp->blockState;
        cp->blockState = state;

        lookup = &np->lookup;
        if (lookup->slotNum >= 0) {
            assert(lookup->bind);
            ecEncodeOpcode(cp, EJS_OP_OPEN_BLOCK);
            ecEncodeNum(cp, lookup->slotNum);
            ecEncodeNum(cp, lookup->nthBlock);
            state->code->blockCount++;
        }
        /*
            Emit block namespaces
         */
        if (block->namespaces.length > 0) {
            for (next = 0; ((namespace = (EjsNamespace*) mprGetNextItem(&block->namespaces, &next)) != 0); ) {
                if (namespace->value->value[0] == '-') {
                    emitNamespace(cp, namespace);
                }
            }
        }
        state->letBlock = block;
        state->letBlockNode = np;

        next = 0;
        while ((child = getNextNode(cp, np, &next))) {
            processNode(cp, child);
        }
        if (lookup->slotNum >= 0) {
            assert(lookup->bind);
            ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
            state->code->blockCount--;
        }
        cp->blockState = state->prevBlockState;
        ecAddNameConstant(cp, np->qname);

    } else {
        next = 0;
        while ((child = getNextNode(cp, np, &next))) {
            processNode(cp, child);
        }
    }
    LEAVE(cp);
}


/*
    Block scope variable reference
 */
static void genBlockName(EcCompiler *cp, int slotNum, int nthBlock)
{
    int         code;

    assert(slotNum >= 0);

    code = (!cp->state->onLeft) ?  EJS_OP_GET_BLOCK_SLOT :  EJS_OP_PUT_BLOCK_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);
    ecEncodeNum(cp, nthBlock);
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


static void genContinue(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    discardBlockItems(cp, cp->state->code->blockMark);
    if (cp->state->captureFinally) {
        ecEncodeOpcode(cp, EJS_OP_CALL_FINALLY);
    } else if (cp->state->captureBreak) {
        ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
    }
    if (cp->state->code->jumps == 0 || !(cp->state->code->jumpKinds & EC_JUMP_CONTINUE)) {
        genError(cp, np, "Illegal continue statement");
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        addJump(cp, np, EC_JUMP_CONTINUE);
        ecEncodeInt32(cp, 0);
    }
    LEAVE(cp);
}


static void genDelete(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *left, *lright;

    ENTER(cp);
    assert(np);

    ejs = cp->ejs;
    left = np->left;
    assert(left);

    switch (left->kind) {
    case N_DOT:
        processNode(cp, left->left);
        lright = left->right;
        if (lright->kind == N_QNAME) {
            /* delete obj.name */
            genNameExpr(cp, lright);
            ecEncodeOpcode(cp, EJS_OP_DELETE_NAME_EXPR);
            popStack(cp, 3);
            pushStack(cp, 1);
        } else {
            /* delete obj[expr] */
            ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
            ecEncodeConst(cp, ESV(empty));
            processNode(cp, lright);
            ecEncodeOpcode(cp, EJS_OP_DELETE_NAME_EXPR);
            popStack(cp, 2);
            pushStack(cp, 1);
        }
        break;

    case N_QNAME:
        /* delete space::name */
        genNameExpr(cp, left);
        ecEncodeOpcode(cp, EJS_OP_DELETE_SCOPED_NAME_EXPR);
        popStack(cp, 2);
        pushStack(cp, 1);
        break;

    default:
        assert(0);
    }
    LEAVE(cp);
}


/*
    Global variable
 */
static void genGlobalName(EcCompiler *cp, int slotNum)
{
    int     code;

    assert(slotNum >= 0);

    code = (!cp->state->onLeft) ?  EJS_OP_GET_GLOBAL_SLOT :  EJS_OP_PUT_GLOBAL_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);

    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Function local variable or argument reference
 */
static void genLocalName(EcCompiler *cp, int slotNum)
{
    int     code;

    assert(slotNum >= 0);

    if (slotNum < 10) {
        code = (!cp->state->onLeft) ?  EJS_OP_GET_LOCAL_SLOT_0 :  EJS_OP_PUT_LOCAL_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!cp->state->onLeft) ?  EJS_OP_GET_LOCAL_SLOT :  EJS_OP_PUT_LOCAL_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNum(cp, slotNum);
    }
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Generate code for a logical operator. Called by genBinaryOp
  
    (expression OP expression)
 */
static void genLogicalOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcCodeGen   *saveCode, *rightCode;
    int         doneIfTrue, rightLen;

    ENTER(cp);

    state = cp->state;
    saveCode = state->code;
    rightCode = 0;

    assert(np->kind == N_BINARY_OP);

    switch (np->tokenId) {
    case T_LOGICAL_AND:
        doneIfTrue = 0;
        break;

    case T_LOGICAL_OR:
        doneIfTrue = 1;
        break;

    default:
        doneIfTrue = 1;
        assert(0);
        ecEncodeOpcode(cp, mapToken(cp, np->tokenId));
        break;
    }

    /*
        Process the conditional test. Put the pop for the branch here prior to the right hand side.
     */
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_DUP);
    pushStack(cp, 1);
    popStack(cp, 1);

    assert(np->right);
    if (np->right) {
        state->code = allocCodeBuffer(cp);
        rightCode = state->code;
        /*
            Evaluating right hand side, so we must pop the left side duped value.
         */
        ecEncodeOpcode(cp, EJS_OP_POP);
        popStack(cp, 1);
        processNode(cp, np->right);
    }
    rightLen = (int) mprGetBufLength(rightCode->buf);

    /*
        Now copy the code to the output code buffer
     */
    setCodeBuffer(cp, saveCode);

    /*
        Jump to done if we know the result due to lazy evalation.
     */
    if (rightLen > 0 && rightLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, (doneIfTrue) ? EJS_OP_BRANCH_TRUE_8: EJS_OP_BRANCH_FALSE_8);
        ecEncodeByte(cp, rightLen);
    } else {
        ecEncodeOpcode(cp, (doneIfTrue) ? EJS_OP_BRANCH_TRUE: EJS_OP_BRANCH_FALSE);
        ecEncodeInt32(cp, rightLen);
    }
    copyCodeBuffer(cp, state->code, rightCode);
    assert(state == cp->state);
    LEAVE(cp);
}


/*
    Generate a property name reference based on the object already pushed.
    The owning object (pushed on the VM stack) may be an object or a type.
 */
static void genPropertyName(EcCompiler *cp, int slotNum)
{
    EcState     *state;
    int         code;

    assert(slotNum >= 0);

    state = cp->state;

    assert(0);
    if (slotNum < 10) {
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_SLOT_0 :  EJS_OP_PUT_OBJ_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_SLOT :  EJS_OP_PUT_OBJ_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNum(cp, slotNum);
    }

    popStack(cp, 1);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class property name reference
    The owning object (pushed on the VM stack) may be an object or a type. We must access its base class.
 */
static void genBaseClassPropertyName(EcCompiler *cp, int slotNum, int nthBase)
{
    EcState     *state;
    int         code;

    assert(slotNum >= 0);

    state = cp->state;

    assert(0);
    code = (!cp->state->onLeft) ?  EJS_OP_GET_TYPE_SLOT : EJS_OP_PUT_TYPE_SLOT;

    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);
    ecEncodeNum(cp, nthBase);

    popStack(cp, 1);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class property name reference
    The owning object (pushed on the VM stack) may be an object or a type. We must access its base class.
 */
static void genThisBaseClassPropertyName(EcCompiler *cp, EjsType *type, int slotNum)
{
    EcState     *state;
    int         code, nthBase;

    assert(0);
    assert(slotNum >= 0);
    assert(type && ejsIsType(ejs, type));
    state = cp->state;

    /*
        Count based up from object 
     */
    for (nthBase = 0; type->baseType; type = type->baseType) {
        nthBase++;
    }
    code = (!state->onLeft) ?  EJS_OP_GET_THIS_TYPE_SLOT :  EJS_OP_PUT_THIS_TYPE_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNum(cp, slotNum);
    ecEncodeNum(cp, nthBase);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class name reference or a global reference.
 */
static void genClassName(EcCompiler *cp, EjsType *type)
{
    Ejs         *ejs;
    EcState     *state;
    int         slotNum;

    assert(type);

    ejs = cp->ejs;
    state = cp->state;

    if (type == ejs->global) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);
        return;
    }
    slotNum = ejsLookupProperty(ejs, ejs->global, type->qname);
    if (cp->bind && slotNum < ES_global_NUM_CLASS_PROP) {
        //  TODO - WARNING: this won't work if classes are implemented like Record.
        assert(slotNum >= 0);
        genGlobalName(cp, slotNum);

    } else if (type == state->currentClass &&
            (!state->inFunction || (state->currentFunction && state->currentFunction->staticMethod))) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);

    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);
        ecEncodeOpcode(cp, EJS_OP_GET_OBJ_NAME);
        ecEncodeName(cp, type->qname);
        popStack(cp, 1);
        pushStack(cp, 1);
    }
}


/*
    Generate a property reference in the current object
 */
static void genPropertyViaThis(EcCompiler *cp, int slotNum)
{
    EcState         *state;
    int             code;

    assert(slotNum >= 0);
    assert(0);
    state = cp->state;

    /*
        Property in the current "this" object
     */
    if (slotNum < 10) {
        code = (!state->onLeft) ?  EJS_OP_GET_THIS_SLOT_0 :  EJS_OP_PUT_THIS_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!state->onLeft) ?  EJS_OP_GET_THIS_SLOT :  EJS_OP_PUT_THIS_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNum(cp, slotNum);
    }
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Generate code for a bound name reference. We already know the slot for the property and its owning type.
 */
static void genBoundName(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsLookup   *lookup;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    lookup = &np->lookup;

    assert(lookup->slotNum >= 0);
    assert(lookup->bind);

    if (lookup->obj == ejs->global) {
        /*
            Global variable
         */
        if (lookup->slotNum < 0 || lookup->slotNum > ES_global_NUM_CLASS_PROP) {
            lookup->bind = 0;
            genUnboundName(cp, np);

        } else {
            genGlobalName(cp, lookup->slotNum);
        }
#if OLD
    } else if (ejsIsFunction(ejs, lookup->obj) && lookup->nthBlock == 0) {
        genLocalName(cp, lookup->slotNum);
#else
    } else if (lookup->obj == (EjsObj*) state->currentFunction->activation) {
        genLocalName(cp, lookup->slotNum);
#endif

    } else if ((ejsIsBlock(ejs, lookup->obj) || ejsIsFunction(ejs, lookup->obj)) && 
            (!ejsIsType(ejs, lookup->obj) && !ejsIsPrototype(ejs, lookup->obj))) {
        genBlockName(cp, lookup->slotNum, lookup->nthBlock);

    } else if (lookup->useThis) {
        if (lookup->instanceProperty) {
            /*
                Property being accessed via the current object "this" or an explicit object?
             */
            genPropertyViaThis(cp, lookup->slotNum);
        } else {
            genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
        }

    } else if (!state->currentObjectNode) {
        if (lookup->instanceProperty) {
            genBlockName(cp, lookup->slotNum, lookup->nthBlock);

        } else {
            /*
                Static property with no explicit object. ie. Not "obj.property". The property was found via a scope search.
                We ignore nthBase as we use the actual type (lookup->obj) where the property was found.
             */
            if (state->inClass && state->inFunction && state->currentFunction->staticMethod) {
                genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
                
            } else {
                if (state->inFunction && ejsIsA(ejs, (EjsObj*) state->currentClass, (EjsType*) lookup->obj)) {
                    genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
                    
                } else {
                    SAVE_ONLEFT(cp);
                    genClassName(cp, (EjsType*) lookup->obj);
                    RESTORE_ONLEFT(cp);
                    genPropertyName(cp, lookup->slotNum);
                }
            }
        }

    } else {
        /*
            Explicity object. ie. "obj.property". The object in a dot expression is already pushed on the stack.
            Determine if we can access the object itself or if we need to use the type of the object to access
            static properties.
         */
        if (lookup->instanceProperty) {
            genPropertyName(cp, lookup->slotNum);

        } else {
            /*
                Property is in the nth base class from the object already pushed on the stack (left hand side).
             */
            genBaseClassPropertyName(cp, lookup->slotNum, lookup->nthBase);
        }
    }
    LEAVE(cp);
}


static void processNodeGetValue(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    cp->state->needsValue = 1;
    processNode(cp, np);
    LEAVE(cp);
}


static int genCallArgs(EcCompiler *cp, EcNode *np) 
{
    if (np == 0) {
        return 0;
    }
    processNode(cp, np);
    return mprGetListLength(np->children);
}


static void genCallSequence(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *left, *right;
    EcState         *state;
    EjsFunction     *fun;
    EjsLookup       *lookup;
    int             fast, argc, staticMethod;    
        
    ejs = cp->ejs;
    state = cp->state;
    left = np->left;
    right = np->right;
    lookup = &np->left->lookup;
    argc = 0;
    
    if (!lookup->bind || lookup->slotNum < 0) {
        /*
            Unbound or Function expression or instance variable containing a function. Cannot use fast path op codes below.
         */
        if (left->kind == N_QNAME && !(left->name.nameExpr || left->name.qualifierExpr)) {
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_SCOPED_NAME);
            ecEncodeName(cp, np->qname);
            
        } else if (left->kind == N_DOT && left->right->kind == N_QNAME && 
                   !(left->right->name.nameExpr || left->right->name.qualifierExpr)) {
            processNodeGetValue(cp, left->left);
            if (state->dupLeft) {
                ecEncodeOpcode(cp, EJS_OP_DUP);
                pushStack(cp, 1);
                state->dupLeft = 0;
            }
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_NAME);
            ecEncodeName(cp, np->qname);
            popStack(cp, 1);
            
        } else {
            /*
                Could be an arbitrary expression on the left. Need a consistent way to save the right most
                object before the property. 
             */
            processNodeGetValue(cp, left);
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS_LOOKUP);
            pushStack(cp, 1);
            ecEncodeOpcode(cp, EJS_OP_SWAP);
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL);
            popStack(cp, 2);
        }
        ecEncodeNum(cp, argc); 
        popStack(cp, argc);
        return;
    }
        
    fun = (EjsFunction*) lookup->ref;
    staticMethod = (ejsIsFunction(ejs, fun) && fun->staticMethod);
        
    /*
        Use fast opcodes when the call sequence is bindable and either:
            expression.name()
            name
     */
    fast = (left->kind == N_DOT && left->right->kind == N_QNAME) || left->kind == N_QNAME;      
        
    if (!fast) {
        /*
            Resolve a reference to a function expression
            TODO REFACTOR needThis. Example: (function (s) { print(s);})("hello");
         */
        if (left->kind == N_EXPRESSIONS) {
            if (left->right == 0) {
                left->left->needThis = 1;
            } else {
                left->right->needThis = 1;
            }
        } else {
            left->needThis = 1;
        }
        processNodeGetValue(cp, left);
        argc = genCallArgs(cp, right);
        ecEncodeOpcode(cp, EJS_OP_CALL);
        popStack(cp, 2);
        ecEncodeNum(cp, argc); 
        popStack(cp, argc);
        return;
    }
    if (staticMethod) {
        assert(ejsIsType(ejs, lookup->obj));
        if (state->currentClass && state->inFunction && 
                lookup->obj != EST(Object)) {
            /*
                Calling a static method from within a class or subclass. So we can use "this".
             */
            argc = genCallArgs(cp, right);
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_THIS_STATIC_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            if (!state->currentFunction->staticMethod) {
                /*
                    If calling from within an instance function, need to step over the instance also
                 */
                lookup->nthBase++;
            }
            ecEncodeNum(cp, lookup->nthBase);
            
        } else if (left->kind == N_DOT && left->right->kind == N_QNAME) {
            /*
                Calling a static method with an explicit object or expression. Call via the object.
             */
            processNode(cp, left->left);
            argc = genCallArgs(cp, right);
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_STATIC_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            if (lookup->ownerIsType) {
                lookup->nthBase--;
            }
            ecEncodeNum(cp, lookup->nthBase);
            popStack(cp, 1);
            
        } else {
            /*
                Foreign static method. Call directly on the correct class type object.
             */
            genClassName(cp, (EjsType*) lookup->obj);
            argc = genCallArgs(cp, right);
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_STATIC_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            ecEncodeNum(cp, 0);
            popStack(cp, 1);
        }
        
    } else {
        // pushStack(cp, 1);
        if (left->kind == N_DOT && left->right->kind == N_QNAME) {
            if (left->left->kind == N_THIS) {
                lookup->useThis = 1;
            }
        }
        
        if (lookup->useThis && !lookup->instanceProperty) {
            argc = genCallArgs(cp, right);
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_THIS_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            
        } else if (lookup->obj == ejs->global) {
            /*
                Instance function or type being invoked as a constructor (e.g. Date(obj))
             */
            argc = genCallArgs(cp, right);
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_GLOBAL_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            
        } else if (lookup->instanceProperty && left->left) {
            processNodeGetValue(cp, left->left);
            argc = genCallArgs(cp, right);
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_INSTANCE_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            popStack(cp, 1);
            
        } else if (ejsIsType(ejs, lookup->obj) || ejsIsPrototype(ejs, lookup->obj)) {
            if (left->kind == N_DOT && left->right->kind == N_QNAME) {
                processNodeGetValue(cp, left->left);
                argc = genCallArgs(cp, right);
                assert(0);
                ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_SLOT);
                assert(lookup->slotNum >= 0);
                ecEncodeNum(cp, lookup->slotNum);
                popStack(cp, 1);
                
            } else {
                left->needThis = 1;
                processNodeGetValue(cp, left);
                argc = genCallArgs(cp, right);
                ecEncodeOpcode(cp, EJS_OP_CALL);
                popStack(cp, 2);
            }
            
        } else if (ejsIsBlock(ejs, lookup->obj)) {
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_BLOCK_SLOT);
            ecEncodeNum(cp, lookup->slotNum);
            ecEncodeNum(cp, lookup->nthBlock);
        }
    }
    ecEncodeNum(cp, argc); 
    popStack(cp, argc);
}


/*
    Code generation for function calls
 */
static void genCall(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *left, *right;
    EcState         *state;
    EjsFunction     *fun;
    int             argc, hasResult;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    left = np->left;
    right = np->right;
    fun = (EjsFunction*) np->lookup.ref;    
    
    if (left->kind == N_NEW && !left->newExpr.callConstructors) {
        processNode(cp, left);
        LEAVE(cp);
        return;
    }
    if (left->kind == N_NEW) {
        processNode(cp, left);
        argc = genCallArgs(cp, right);
        ecEncodeOpcode(cp, EJS_OP_CALL_CONSTRUCTOR);
        ecEncodeNum(cp, argc);
        popStack(cp, argc);
        LEAVE(cp);
        return;
    }
    genCallSequence(cp, np);

    /*
        Process the function return value. Call by ref has a this pointer plus method reference plus args
     */
    hasResult = 0;
    if (fun && ejsIsFunction(ejs, fun)) {
        if (fun->resultType && fun->resultType != EST(Void)) {
            hasResult = 1;

        } else if (fun->hasReturn || ejsIsType(ejs, fun)) {
            /*
                Untyped function, but it has a return stmt.
                We don't do data flow to make sure all return cases have returns (sorry).
             */
            hasResult = 1;
        }
        if (state->needsValue && !hasResult) {
            genError(cp, np, "Function call does not return a value.");
        }
    }
    /*
        If calling a type as a constructor (Date()), must push result
     */
    if (state->needsValue || ejsIsType(ejs, np->lookup.ref)) {
        ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


static void genCatchArg(EcCompiler *cp, EcNode *np)
{
    ecEncodeOpcode(cp, EJS_OP_PUSH_CATCH_ARG);
    pushStack(cp, 1);
}


/*
    Code is injected before existing code
 */
static int injectCode(Ejs *ejs, EjsFunction *fun, EcCodeGen *extra)
{
    EjsCode     *old;
    EjsEx       *ex;
    EjsDebug    *debug;
    uchar       *byteCode;
    int         next, i, len, codeLen, extraCodeLen;

    if (extra == NULL || extra->buf == NULL) {
        return 0;
    }
    old = fun->body.code;
    codeLen = (fun->body.code) ? old->codeLen : 0;
    extraCodeLen = (int) mprGetBufLength(extra->buf);
    len = codeLen + extraCodeLen;

    if (extraCodeLen == 0 || len == 0) {
        return 0;
    }
    if ((byteCode = mprAllocZeroed(len)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprMemcpy(byteCode, extraCodeLen, mprGetBufStart(extra->buf), extraCodeLen);
    if (codeLen) {
        mprMemcpy(&byteCode[extraCodeLen], codeLen, old->byteCode, codeLen);
    }
    ejsSetFunctionCode(ejs, fun, old->module, byteCode, len, extra->debug);

    debug = old->debug;
    if (debug && debug->numLines > 0) {
        for (i = 0; i < debug->numLines; i++) {
            if (ejsAddDebugLine(ejs, &fun->body.code->debug, debug->lines[i].offset + extraCodeLen, 
                    debug->lines[i].source) < 0) {
                return MPR_ERR_MEMORY;
            }
        }
    }

    /*
        Recreate all exception handlers
     */
    for (i = 0; i < old->numHandlers; i++) {
        ex = old->handlers[i];
        ex->tryStart += extraCodeLen;
        ex->tryEnd += extraCodeLen;
        ex->handlerStart += extraCodeLen;
        ex->handlerEnd += extraCodeLen;
        ejsAddException(ejs, fun, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, ex->handlerEnd, 
            ex->numBlocks, ex->numStack, ex->flags, -1);
    }
    for (next = 0; (ex = mprGetNextItem(extra->exceptions, &next)) != 0; ) {
        ejsAddException(ejs, fun, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, ex->handlerEnd, 
            ex->numBlocks, ex->numStack, ex->flags, -1);
    }
    return 0;
}


/*
    Process a class node.
 */
static void genClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type, *baseType;
    EjsFunction     *constructor;
    EcCodeGen       *code;
    EcState         *state;
    EcNode          *constructorNode;
    EjsName         qname;

    ENTER(cp);
    assert(np->kind == N_CLASS);

    ejs = cp->ejs;
    state = cp->state;
    type = (EjsType*) np->klass.ref;
    assert(type);

    state->inClass = 1;
    state->inFunction = 0;

    /*
        Op code to define the class. This goes into the module code buffer. DefineClass will capture the current scope
        including the internal namespace for this file.
        OPT See above todo
     */
    ecEncodeOpcode(cp, EJS_OP_DEFINE_CLASS);
    ecEncodeGlobal(cp, (EjsObj*) type, type->qname);

    state->letBlock = (EjsBlock*) type;
    state->varBlock = (EjsBlock*) type;
    state->currentClass = type;
    state->currentClassNode = np;

    constructorNode = np->klass.constructor;

    /*
        Create code buffers to hold the static and instance level initialization code. The AST module will always
        create a constructor node for us if there is instance level initialization code. We currently put the class
        initialization code in the constructor. Static variable initialization code will go into the current
        module buffer (cp->currentModule) and will be run when the module is loaded. 
        BUG - CLASS INITIALIZATION ORDERING.
     */
    state->code = state->currentModule->code;

    /*
        Create a code buffer for static initialization code and set it as the default buffer
     */
    state->code = state->staticCodeBuf = allocCodeBuffer(cp);

    if (type->constructor.block.pot.isFunction) {
        state->instanceCodeBuf = allocCodeBuffer(cp);
    }

    /*
        The current code buffer is the static initializer buffer. genVar will redirect to the instanceCodeBuf as required.
     */
    processNode(cp, np->left);

    if (type->hasInitializer) {
        /*
            Create the static initializer
         */
        ecEncodeOpcode(cp, EJS_OP_RETURN);
        setFunctionCode(cp, np->klass.initializer, state->staticCodeBuf);
    }

    if (type->constructor.block.pot.isFunction) {
        assert(constructorNode);
        assert(state->instanceCodeBuf);
        code = state->code = state->instanceCodeBuf;

        constructor = state->currentFunction = (EjsFunction*) type;
        assert(constructor);
        if (constructorNode->function.isDefault) {
            /*
                No constructor exists, so generate the default constructor. Append the default constructor 
                instructions after any initialization code. Will only get here if there is no required instance 
                initialization.
             */
            baseType = type->baseType;
            if (baseType && baseType->constructor.block.pot.isFunction) {
                ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
                ecEncodeName(cp, baseType->qname);
                ecEncodeNum(cp, 0);
            }
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            setFunctionCode(cp, (EjsFunction*) type, code);
            ecAddCStringConstant(cp, EJS_PUBLIC_NAMESPACE);
            ecAddCStringConstant(cp, EJS_CONSTRUCTOR_NAMESPACE);

        } else if (type->constructor.block.pot.isFunction) {
            injectCode(ejs, constructor, code);
        }
    }
    ecAddNameConstant(cp, np->qname);

    if (type->hasInitializer) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) type, 0);
        ecAddNameConstant(cp, qname);
    }
    if (type->baseType) {
        ecAddNameConstant(cp, type->baseType->qname);
    }

    /*
        Emit any properties implemented via another class (there is no Node for these)
     */
    ecAddConstants(cp, (EjsObj*) type);
    if (type->prototype) {
        ecAddConstants(cp, (EjsObj*) type->prototype);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "class", np->lookup.obj, np->lookup.slotNum);
    }
    LEAVE(cp);
}


static void genDassign(EcCompiler *cp, EcNode *np)
{
    EcNode      *field;
    int         next, count;

    assert(np->kind == N_DASSIGN);

    ENTER(cp);

    count = mprGetListLength(np->children);
    for (next = 0; (field = getNextNode(cp, np, &next)) != 0; ) {
        assert(field->kind == N_FIELD);
        if (next < count) {
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
        }
        if (np->objectLiteral.isArray) {
            ecEncodeOpcode(cp, EJS_OP_GET_OBJ_SLOT);
            ecEncodeNum(cp, field->field.index);
        } else {
            ecEncodeOpcode(cp, EJS_OP_GET_OBJ_NAME);
            ecEncodeName(cp, field->field.fieldName->qname);
        }
        assert(field->field.expr);
        processNode(cp, field->field.expr);
    }
    LEAVE(cp);
}


static void genDirectives(EcCompiler *cp, EcNode *np, bool saveResult)
{
    EcState     *lastDirectiveState;
    EcNode      *child;
    int         next, mark;

    ENTER(cp);

    lastDirectiveState = cp->directiveState;
    next = 0;
    mark = getStackCount(cp);
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        cp->directiveState = cp->state;
        processNode(cp, child);
        if (!saveResult) {
            discardStackItems(cp, mark);
        }
    }
    if (saveResult) {
        ecEncodeOpcode(cp, EJS_OP_SAVE_RESULT);
    }
    cp->directiveState = lastDirectiveState;
    LEAVE(cp);
}


/*
    Handle property dereferencing via "." and "[". This routine generates code for bound properties where we know
    the slot offsets and also for unbound references. Return the right most node in right.
 */
static void genDot(EcCompiler *cp, EcNode *np, EcNode **rightMost)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *left, *right;
    int         put;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    state->onLeft = 0;
    left = np->left;
    right = np->right;

    /*
        Process the left of the dot and leave an object reference on the stack
     */
    switch (left->kind) {
    case N_DOT:
    case N_EXPRESSIONS:
    case N_LITERAL:
    case N_THIS:
    case N_REF:
    case N_QNAME:
    case N_CALL:
    case N_SUPER:
    case N_OBJECT_LITERAL:
        state->needsValue = 1;
        processNode(cp, left);
        state->needsValue = state->next->needsValue;
        break;

    default:
        assert(0);
    }
    state->currentObjectNode = np->left;

    if (np->needThis || state->dupLeft) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        np->needThis = 0;
        state->dupLeft = 0;
    }
    put = state->next->onLeft;

    /*
        Process the right
     */
    switch (right->kind) {
    case N_CALL:
        state->needsValue = state->next->needsValue;
        genCall(cp, right);
        state->needsValue = 0;
        break;

    case N_QNAME:
        state->onLeft = state->next->onLeft;
        genName(cp, right);
        break;

    case N_SUPER:
        ecEncodeOpcode(cp, EJS_OP_SUPER);
        break;

    case N_LITERAL:
    case N_OBJECT_LITERAL:
    default:
        state->currentObjectNode = 0;
        state->needsValue = 1;
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, ESV(empty));
        pushStack(cp, 1);
        if (right->kind == N_LITERAL) {
            genLiteral(cp, right);
        } else if (right->kind == N_OBJECT_LITERAL) {
            genObjectLiteral(cp, right);
        } else {
            processNode(cp, right);
        }
        state->onLeft = state->next->onLeft;
        ecEncodeOpcode(cp, put ? EJS_OP_PUT_OBJ_NAME_EXPR :  EJS_OP_GET_OBJ_NAME_EXPR);
        popStack(cp, (put) ? 4 : 2);
        break;
    }
    if (rightMost) {
        *rightMost = right;
    }
    LEAVE(cp);
}


static void genEndFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;

    ENTER(cp);

    assert(np);

    ejs = cp->ejs;
    fun = cp->state->currentFunction;
    
    if (cp->lastOpcode != EJS_OP_RETURN_VALUE && cp->lastOpcode != EJS_OP_RETURN) {
        /*
            Ensure code cannot run off the end of a method.
            TODO OPT - must do a better job of basic block analysis and check if all paths out of a function have a return.
         */
        if (fun->isConstructor) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);

        } else if (fun->resultType == 0) {
            if (fun->hasReturn) {
                //  TODO - OPT. Should be able to avoid this somehow. We put it here now to ensure that all
                //  paths out of the function terminate with a return.
                ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
                ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            } else {
                ecEncodeOpcode(cp, EJS_OP_RETURN);
            }

        } else if (fun->resultType == EST(Void)) {
            ecEncodeOpcode(cp, EJS_OP_RETURN);

        } else {
            //  TODO - OPT. Should be able to avoid this somehow.
            ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
        }
    }
    cp->lastOpcode = 0;
    LEAVE(cp);
}


static void genExpressions(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    assert(np->kind == N_EXPRESSIONS);

    ENTER(cp);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        processNode(cp, child);
    }
    LEAVE(cp);
}


/*
    This handles "do { ... } while" constructs.
  
    do {
         body
    } while (conditional)
  
    Labels:
        topOfLoop:
            body
        continueLabel:
            conditional
            bxx topOfLoop
        endLoop:
 */
static void genDo(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         condLen, bodyLen, len, condShortJump, continueLabel, breakLabel, mark;

    ENTER(cp);
    assert(np->kind == N_DO);

    state = cp->state;
    state->captureFinally = 0;
    state->captureBreak = 0;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);

    if (np->forLoop.body) {
        np->forLoop.bodyCode = state->code = allocCodeBuffer(cp);
        mark = getStackCount(cp);
        processNode(cp, np->forLoop.body);
        discardStackItems(cp, mark);
    }
    if (np->forLoop.cond) {
        np->forLoop.condCode = state->code = allocCodeBuffer(cp);
        state->needsValue = 1;
        processNode(cp, np->forLoop.cond);
        state->needsValue = 0;
    }
    /*
        Get the lengths of code blocks
     */
    condLen = bodyLen = 0;
    if (np->forLoop.condCode) {
        condLen = (int) mprGetBufLength(np->forLoop.condCode->buf);
    }
    if (np->forLoop.bodyCode) {
        bodyLen = (int) mprGetBufLength(np->forLoop.bodyCode->buf);
    }

    /*
        Now that we know the body length, we can calculate the jump back to the top.
     */
    condShortJump = 0;
    len = bodyLen + condLen;
    if (len > 0) {
        if (len < 0x7f && cp->optimizeLevel > 0) {
            condShortJump = 1;
            condLen += 2;
        } else {
            condLen += 5;
        }
    }

    setCodeBuffer(cp, code);
    if (np->forLoop.cond) {
        pushStack(cp, 1);
    }
    continueLabel = (int) mprGetBufLength(cp->state->code->buf);

    /*
        Add the body
     */
    if (np->forLoop.bodyCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.bodyCode);
    }

    /*
        Copy the conditional code and add condition jump to the end of the for loop, then copy the body code.
     */
    if (np->forLoop.condCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.condCode);
        len = bodyLen + condLen;
        if (condShortJump) {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_TRUE_8);
            ecEncodeByte(cp, -len);
        } else {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_TRUE);
            ecEncodeInt32(cp, -len);
        }
        popStack(cp, 1);
    }

    breakLabel = (int) mprGetBufLength(cp->state->code->buf);
    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, continueLabel);

    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    This handles "for" and while" constructs but not "for .. in"
  
    for (initializer; conditional; perLoop) { body }
  
    Labels:
            initializer
        topOfLoop:
            conditional
            bxx endLoop
        topOfBody:
            body
        continueLabel:
            perLoop
        endIteration:
            goto topOfLoop
        endLoop:
 */
static void genFor(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         condLen, bodyLen, perLoopLen, len, condShortJump, perLoopShortJump, continueLabel, breakLabel, mark;
    int         startMark;

    ENTER(cp);

    assert(np->kind == N_FOR);

    state = cp->state;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);
    startMark = getStackCount(cp);
    state->captureFinally = 0;
    state->captureBreak = 0;

    /*
        initializer is outside the loop
     */
    if (np->forLoop.initializer) {
        mark = getStackCount(cp);
        processNode(cp, np->forLoop.initializer);
        discardStackItems(cp, mark);
    }

    /*
        For conditional
     */
    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);

    if (np->forLoop.cond) {
        np->forLoop.condCode = state->code = allocCodeBuffer(cp);
        state->needsValue = 1;
        processNode(cp, np->forLoop.cond);
        state->needsValue = 0;
        /* Leaves one item on the stack, but this will be cleared when compared */
        assert(state->code->stackCount >= 1);
        popStack(cp, 1);
    }

    if (np->forLoop.body) {
        mark = getStackCount(cp);
        np->forLoop.bodyCode = state->code = allocCodeBuffer(cp);
        processNode(cp, np->forLoop.body);
        discardStackItems(cp, mark);
    }

    /*
        Per loop iteration
     */
    if (np->forLoop.perLoop) {
        np->forLoop.perLoopCode = state->code = allocCodeBuffer(cp);
        mark = getStackCount(cp);
        processNode(cp, np->forLoop.perLoop);
        discardStackItems(cp, mark);
    }

    /*
        Get the lengths of code blocks
     */
    perLoopLen = condLen = bodyLen = 0;

    if (np->forLoop.condCode) {
        condLen = (int) mprGetBufLength(np->forLoop.condCode->buf);
    }
    if (np->forLoop.bodyCode) {
        bodyLen = (int) mprGetBufLength(np->forLoop.bodyCode->buf);
    }
    if (np->forLoop.perLoopCode) {
        perLoopLen = (int) mprGetBufLength(np->forLoop.perLoopCode->buf);
    }

    /*
        Now that we know the body length, we can calculate the jump at the top. This is the shorter of
        the two jumps as it does not span the conditional code, so we optimize it first incase the saving
        of 3 bytes allows us to also optimize the branch back to the top. Subtract 5 to the test with 0x7f to
        account for the worst-case jump at the bottom back to the top
     */
    condShortJump = 0;
    if (condLen > 0) {
        len = bodyLen + perLoopLen;
        if (len < (0x7f - 5) && cp->optimizeLevel > 0) {
            condShortJump = 1;
            condLen += 2;
        } else {
            condLen += 5;
        }
    }

    /*
        Calculate the jump back to the top of the loop (per-iteration jump). Subtract 5 to account for the worst case
        where the per loop jump is a long jump.
     */
    len = condLen + bodyLen + perLoopLen;
    if (len < (0x7f - 5) && cp->optimizeLevel > 0) {
        perLoopShortJump = 1;
        perLoopLen += 2;
    } else {
        perLoopShortJump = 0;
        perLoopLen += 5;
    }

    /*
        Copy the conditional code and add condition jump to the end of the for loop, then copy the body code.
     */
    setCodeBuffer(cp, code);
    if (np->forLoop.condCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.condCode);
        len = bodyLen + perLoopLen;
        if (condShortJump) {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
            ecEncodeByte(cp, len);
        } else {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
            ecEncodeInt32(cp, len);
        }
    }

    /*
        Add the body and per loop code
     */
    if (np->forLoop.bodyCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.bodyCode);
    }
    continueLabel = (int) mprGetBufLength(state->code->buf);
    if (np->forLoop.perLoopCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.perLoopCode);
    }

    /*
        Add the per-loop jump back to the top of the loop
     */
    len = condLen + bodyLen + perLoopLen;
    if (perLoopShortJump) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, -len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeInt32(cp, -len);
    }
    breakLabel = (int) mprGetBufLength(state->code->buf);
    discardStackItems(cp, startMark);

    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, continueLabel);

    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    This routine is a little atypical in that it hand-crafts an exception block.
 */
static void genForIn(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *iterVar, *iterGet;
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         len, breakLabel, tryStart, tryEnd, handlerStart, mark, startMark, varCount;

    ENTER(cp);

    assert(cp->state->code->stackCount >= 0);
    assert(np->kind == N_FOR_IN);

    ejs = cp->ejs;
    state = cp->state;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);
    startMark = getStackCount(cp);
    state->captureFinally = 0;
    state->captureBreak = 0;
    iterVar = np->forInLoop.iterVar;
    iterGet = np->forInLoop.iterGet;
    varCount = mprGetListLength(iterVar->children);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);
    processNode(cp, iterVar);

    /*
        Consider:
            for (i in obj.get())
                body
      
        Now process the obj.get()
     */
    np->forInLoop.initCode = state->code = allocCodeBuffer(cp);

    if (varCount == 2) {
        state->dupLeft = 1;
        processNode(cp, iterGet);
        state->dupLeft = 0;
    } else {
        processNode(cp, iterGet);
    }
    ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
    pushStack(cp, 1);
    assert(state->code->stackCount >= 1);

    /*
        Process the iter.next()
     */
    np->forInLoop.bodyCode = state->code = allocCodeBuffer(cp);

    /*
        Dup the iterator reference each time round the loop as iter.next() will consume the object.
        TODO - OPT. Consider having a CALL op code that does not consume the object.
     */
    ecEncodeOpcode(cp, EJS_OP_DUP);
    pushStack(cp, 1);

    /*
        Emit code to invoke the iterator
     */
    tryStart = getCodeLength(cp, np->forInLoop.bodyCode);

    if (np->forInLoop.iterNext->lookup.bind && np->forInLoop.iterNext->lookup.slotNum >= 0) {
        assert(0);
        ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_SLOT);
        ecEncodeNum(cp, np->forInLoop.iterNext->lookup.slotNum);
    } else {
        ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_NAME);
        ecEncodeName(cp, np->forInLoop.iterNext->qname);
    }
    ecEncodeNum(cp, 0);
    popStack(cp, 1);
    
    tryEnd = getCodeLength(cp, np->forInLoop.bodyCode);

    if (varCount == 2) {
        /* Dup original object being iterated */
        ecEncodeOpcode(cp, EJS_OP_DUP_STACK);
        ecEncodeByte(cp, 1);
        pushStack(cp, 1);
        //  TODO space is not used with numericIndicies
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, ESV(empty));
        pushStack(cp, 1);
    }

    /*
        Save the result of the iter.next() call
     */
    ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
    pushStack(cp, 1);

    if (varCount == 2) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }
    state->onLeft = 1;
    genName(cp, iterVar->left);
    state->onLeft = 0;

    if (iterVar->kind == N_VAR_DEFINITION && iterVar->def.varKind == KIND_LET) {
        ecAddNameConstant(cp, iterVar->left->qname);
    }
    mark = getStackCount(cp);
    if (np->forInLoop.body) {
        if (varCount == 2) {
            ecEncodeOpcode(cp, EJS_OP_GET_OBJ_NAME_EXPR);
            popStack(cp, 2);
            state->onLeft = 1;
            genName(cp, iterVar->right);
            state->onLeft = 0;
        }
        processNode(cp, np->forInLoop.body);
        discardStackItems(cp, mark);
    }
    len = getCodeLength(cp, np->forInLoop.bodyCode);
    if (len < (0x7f - 5)) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        len += 2;
        ecEncodeByte(cp, -len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        len += 5;
        ecEncodeInt32(cp, -len);
    }

    /*
        Create exception catch block around iter.next() to catch the StopIteration exception.
        Note: we have a zero length handler (noop)
     */
    handlerStart = ecGetCodeOffset(cp);
    addException(cp, tryStart, tryEnd, EST(StopIteration), handlerStart, handlerStart, 0, startMark,
        EJS_EX_CATCH | EJS_EX_ITERATION);

    /*
        Patch break/continue statements
     */
    discardStackItems(cp, startMark);
    breakLabel = (int) mprGetBufLength(state->code->buf);

    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, 0);

    setCodeBuffer(cp, code);
    copyCodeBuffer(cp, state->code, np->forInLoop.initCode);
    copyCodeBuffer(cp, state->code, np->forInLoop.bodyCode);
    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    Generate code for default parameters. Native classes must handle this themselves. We
    generate the code for all default parameters in sequence with a computed goto at the front.
 */
static void genDefaultParameterCode(EcCompiler *cp, EcNode *np, EjsFunction *fun)
{
    Ejs             *ejs;
    EcNode          *parameters, *child;
    EcState         *state;
    EcCodeGen       **buffers, *saveCode;
    int             len, next, needLongJump, count, firstDefault;

    ejs = cp->ejs;
    state = cp->state;
    saveCode = state->code;

    parameters = np->function.parameters;
    assert(parameters);

    count = mprGetListLength(parameters->children);
    buffers = (EcCodeGen**) mprAllocZeroed(count * sizeof(EcCodeGen*));

    for (next = 0; (child = getNextNode(cp, parameters, &next)) && !cp->error; ) {
        assert(child->kind == N_VAR_DEFINITION);
        if (child->left->kind == N_ASSIGN_OP) {
            buffers[next - 1] = state->code = allocCodeBuffer(cp);
            genAssignOp(cp, child->left);
        }
    }
    if (fun->rest) {
        buffers[count - 1] = state->code = allocCodeBuffer(cp);
        ecEncodeOpcode(cp, EJS_OP_NEW_ARRAY);
        ecEncodeGlobal(cp, (EjsObj*) EST(Array), EST(Array)->qname);
        ecEncodeNum(cp, 0);
        pushStack(cp, 1);
        if (fun->numArgs < 10) {
            ecEncodeOpcode(cp, EJS_OP_PUT_LOCAL_SLOT_0 + fun->numArgs - 1);
        } else {
            ecEncodeOpcode(cp, EJS_OP_PUT_LOCAL_SLOT);
            ecEncodeNum(cp, fun->numArgs - 1);
        }
    }
    firstDefault = fun->numArgs - fun->numDefault - fun->rest;
    assert(firstDefault >= 0);
    needLongJump = cp->optimizeLevel > 0 ? 0 : 1;

    /*
        Compute the worst case jump size. Start with 4 because the table is always one larger than the
        number of default args.
     */
    len = 4;
    for (next = firstDefault; next < count; next++) {
        if (buffers[next]) {
            len = (int) mprGetBufLength(buffers[next]->buf) + 4;
            if (len >= 0x7f) {
                needLongJump = 1;
                break;
            }
        }
    }
    setCodeBuffer(cp, saveCode);

    /*
        This is a jump table where each parameter initialization segments falls through to the next one.
        We have one more entry in the table to jump over the entire computed jump section.
     */
    ecEncodeOpcode(cp, (needLongJump) ? EJS_OP_INIT_DEFAULT_ARGS: EJS_OP_INIT_DEFAULT_ARGS_8);
    ecEncodeByte(cp, fun->numDefault + fun->rest + 1);

    len = (fun->numDefault + fun->rest + 1) * ((needLongJump) ? 4 : 1);
    for (next = firstDefault; next < count; next++) {
        if (buffers[next] == 0) {
            continue;
        }
        if (needLongJump) {
            ecEncodeInt32(cp, len);
        } else {
            ecEncodeByte(cp, len);
        }
        len += (int) mprGetBufLength(buffers[next]->buf);
    }
    /*
        Add one more jump to jump over the entire jump table
     */
    if (needLongJump) {
        ecEncodeInt32(cp, len);
    } else {
        ecEncodeByte(cp, len);
    }

    /*
        Now copy all the initialization code
     */
    for (next = firstDefault; next < count; next++) {
        if (buffers[next]) {
            copyCodeBuffer(cp, state->code, buffers[next]);
        }
    }
}


static void genFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsEx           *ex;
    EcState         *state;
    EcCodeGen       *code;
    EjsFunction     *fun;
    EjsType         *baseType;
    EjsName         qname;
    EjsTrait        *trait;
    EjsPot          *activation;
    int             i, numProp;

    ENTER(cp);

    assert(np->kind == N_FUNCTION);
    
    ejs = cp->ejs;
    state = cp->state;
    cp->lastOpcode = 0;
    assert(state);

    assert(np->function.functionVar);
    fun = np->function.functionVar;
    activation = fun->activation;
    numProp = activation ? activation->numProp: 0;

    state->inFunction = 1;
    state->inMethod = state->inMethod || np->function.isMethod;
    state->blockIsMethod = np->function.isMethod;
    state->currentFunction = fun;
    state->currentFunctionNode = np;

    /*
        Capture the scope chain by the defineFunction op code. Emit this into the existing code buffer. 
        Don't do if a method as they get scope via other means. Native methods also don't use this as an optimization.
        Native methods must handle scope explicitly.
      
        We only need to define the function if it needs full scope (unbound property access) or it is a nested function.
     */
    if (fun->fullScope) {
        ecEncodeOpcode(cp, EJS_OP_DEFINE_FUNCTION);
        ecEncodeName(cp, np->qname);
    }
    code = state->code = allocCodeBuffer(cp);

    if (!fun->isNativeProc) {
        addDebug(cp, np);
    }

    /*
        Generate code for any parameter default initialization.
        Native classes must do default parameter initialization themselves.
     */
    if (fun->numDefault > 0 && !(np->attributes & EJS_PROP_NATIVE)) {
        genDefaultParameterCode(cp, np, fun);
    }
    if (np->function.constructorSettings) {
        genDirectives(cp, np->function.constructorSettings, 0);
    }
    state->letBlock = (EjsBlock*) fun;
    state->varBlock = (EjsBlock*) fun;

    if (np->function.isConstructor) {
        /*
            Function is a constructor. Call any default constructors if required.
            Should this be before or after default variable initialization?
         */
        assert(state->currentClass);
        baseType = state->currentClass->baseType;
        if (!state->currentClass->callsSuper && baseType && baseType->constructor.block.pot.isFunction && 
                !(np->attributes & EJS_PROP_NATIVE)) {
            ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
            ecEncodeName(cp, baseType->qname);
            ecEncodeNum(cp, 0);
        }
    }

    /*
        May be no body for native functions
     */
    if (np->function.body) {
        assert(np->function.body->kind == N_DIRECTIVES);
        processNode(cp, np->function.body);
    }
    if (cp->errorCount > 0) {
        LEAVE(cp);
        return;
    }
    setFunctionCode(cp, fun, code);
    ecAddNameConstant(cp, np->qname);

    for (i = 0; i < numProp; i++) {
        qname = ejsGetPropertyName(ejs, activation, i);
        ecAddNameConstant(cp, qname);
        trait = ejsGetPropertyTraits(ejs, activation, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, trait->type->qname);
        }
    }
    for (i = 0; i < fun->block.pot.numProp; i++) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) fun, i);
        ecAddNameConstant(cp, qname);
        trait = ejsGetPropertyTraits(ejs, fun, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, trait->type->qname);
        }
    }
    if (fun->resultType) {
        ecAddNameConstant(cp, fun->resultType->qname);
    }
    if (fun->body.code) {
        for (i = 0; i < fun->body.code->numHandlers; i++) {
            ex = fun->body.code->handlers[i];
            if (ex && ex->catchType) {
                ecAddNameConstant(cp, ex->catchType->qname);
            }
        }
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "fun", np->lookup.obj, np->lookup.slotNum);
    }
    LEAVE(cp);
}


static void genHash(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (!np->hash.disabled) {
        processNode(cp, np->hash.body);
    }
    LEAVE(cp);
}


static void genIf(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *saveCode;
    EcState     *state;
    int         thenLen, elseLen, mark;

    ENTER(cp);

    assert(np->kind == N_IF);

    state = cp->state;
    saveCode = state->code;

    /*
        Process the conditional. Put the popStack for the branch here so the stack is correct for the "then" and 
        "else" blocks.
     */
    state->needsValue = 1;
    processNode(cp, np->tenary.cond);
    state->needsValue = 0;
    popStack(cp, 1);

    /*
        Process the "then" block.
     */
    np->tenary.thenCode = state->code = allocCodeBuffer(cp);
    mark = getStackCount(cp);
    
    //  CHANGE: Added for return (cond) ? call(): other;
    state->needsValue = state->next->needsValue;
    processNode(cp, np->tenary.thenBlock);
    if (state->next->needsValue) {
        /* Part of a tenary expression */
        if (state->code->stackCount < (mark + 1)) {
            genError(cp, np, "Then expression does not evaluate to a value. Check if operands are void");
        }
        discardStackItems(cp, mark + 1);
        if (np->tenary.elseBlock) {
            setStack(cp, mark);
        }
    } else {
        discardStackItems(cp, mark);
    }

    /*
        Else block (optional)
     */
    if (np->tenary.elseBlock) {
        np->tenary.elseCode = state->code = allocCodeBuffer(cp);
        state->needsValue = state->next->needsValue;
        processNode(cp, np->tenary.elseBlock);
        state->needsValue = 0;
        if (state->next->needsValue) {
            if (state->code->stackCount < (mark + 1)) {
                genError(cp, np, "Else expression does not evaluate to a value. Check if operands are void");
            }
            discardStackItems(cp, mark + 1);
        } else {
            discardStackItems(cp, mark);
        }
    }

    /*
        Calculate jump lengths. Then length will vary depending on if the jump at the end of the "then" block
        can jump over the "else" block with a short jump.
     */
    elseLen = (np->tenary.elseCode) ? (int) mprGetBufLength(np->tenary.elseCode->buf) : 0;
    thenLen = (int) mprGetBufLength(np->tenary.thenCode->buf);
    thenLen += (elseLen < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;

    /*
        Now copy the basic blocks into the output code buffer, starting with the jump around the "then" code.
     */
    setCodeBuffer(cp, saveCode);

    if (thenLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
        ecEncodeByte(cp, thenLen);
    } else {
        ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
        ecEncodeInt32(cp, thenLen);
    }

    /*
        Copy the then code
     */
    copyCodeBuffer(cp, state->code, np->tenary.thenCode);

    /*
        Create the jump to the end of the if statement
     */
    if (elseLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, elseLen);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeInt32(cp, elseLen);
    }
    if (np->tenary.elseCode) {
        copyCodeBuffer(cp, state->code, np->tenary.elseCode);
    }
    if (state->next->needsValue) {
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
    Expect data on the stack already to assign
 */
static void genLeftHandSide(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(cp);
    assert(np);

    cp->state->onLeft = 1;

    switch (np->kind) {
    case N_DASSIGN:
    case N_DOT:
    case N_QNAME:
    case N_SUPER:
    case N_EXPRESSIONS:
    case N_OBJECT_LITERAL:
    case N_VAR:
        processNode(cp, np);
        break;

    case N_CALL:
    default:
        genError(cp, np, "Illegal left hand side");
    }
    LEAVE(cp);
}


static void genLiteral(EcCompiler *cp, EcNode *np)
{
    EjsNamespace    *nsp;
    EjsBoolean      *bp;
    EjsNumber       *ip;
    EjsString       *pattern, *data;
    Ejs             *ejs;
    int64           n;
    int             sid;

    ENTER(cp);
    ejs = cp->ejs;

    if (TYPE(np->literal.var) == EST(XML)) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_XML);
        //  UNICODE
        data = ejsCreateString(ejs, (wchar*) mprGetBufStart(np->literal.data), 
                mprGetBufLength(np->literal.data) / sizeof(wchar));
        ecEncodeConst(cp, data);
        pushStack(cp, 1);
        LEAVE(cp);
        return;
    }

    /*
        Map Numbers to the configured real type
     */
    sid = TYPE(np->literal.var)->sid;
    switch (sid) {
    case ES_Boolean:
        bp = (EjsBoolean*) np->literal.var;
        if (bp->value) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_TRUE);
        } else {
            ecEncodeOpcode(cp, EJS_OP_LOAD_FALSE);
        }
        break;

    case ES_Number:
        /*
            These are signed values
         */
        ip = (EjsNumber*) np->literal.var;
        if (ip->value != floor(ip->value) || ip->value <= -MAXINT || ip->value >= MAXINT) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_DOUBLE);
            ecEncodeDouble(cp, ip->value);
        } else {
            n = (int64) ip->value;
            if (0 <= n && n <= 9) {
                ecEncodeOpcode(cp, EJS_OP_LOAD_0 + (int) n);
            } else {
                ecEncodeOpcode(cp, EJS_OP_LOAD_INT);
                ecEncodeNum(cp, n);
            }
        }
        break;

    case ES_Namespace:
        ecEncodeOpcode(cp, EJS_OP_LOAD_NAMESPACE);
        nsp = (EjsNamespace*) np->literal.var;
        ecEncodeConst(cp, nsp->value);
        break;

    case ES_Null:
        ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
        break;

    case ES_String:
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, ((EjsString*) np->literal.var));
        break;

    case ES_RegExp:
        ecEncodeOpcode(cp, EJS_OP_LOAD_REGEXP);
        pattern = (EjsString*) ejsRegExpToString(cp->ejs, (EjsRegExp*) np->literal.var);
        ecEncodeConst(cp, pattern);
        break;

    case ES_Void:
        ecEncodeOpcode(cp, EJS_OP_LOAD_UNDEFINED);
        break;

    default:
        assert(0);
        break;
    }
    pushStack(cp, 1);
    LEAVE(cp);
}


/*
    Generate code for name reference. This routine handles both loads and stores.
 */
static void genName(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_QNAME || np->kind == N_USE_NAMESPACE || np->kind == N_VAR);

    if (np->needThis) {
        if (np->lookup.useThis) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);

        } else if (np->lookup.obj == cp->ejs->global){
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);

        } else if (cp->state->currentObjectNode) {
            ecEncodeOpcode(cp, EJS_OP_DUP);

        } else {
            /*
                Unbound function
             */
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        }
        pushStack(cp, 1);
        np->needThis = 0;
    }
    if (np->lookup.bind && np->lookup.slotNum >= 0) {
        genBoundName(cp, np);
    } else {
        genUnboundName(cp, np);
    }
    LEAVE(cp);
}


static void genNew(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    assert(np->kind == N_NEW);
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_NEW);
    popStack(cp, 1);
    pushStack(cp, 1);
    LEAVE(cp);
}


static void genArrayLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child, *typeNode;
    EjsType     *type;
    Ejs         *ejs;
    int         next, argc;

    ENTER(cp);
    ejs = cp->ejs;

    for (next = 0; (child = getNextNode(cp, np, &next)) != 0; ) {
        processNode(cp, child);
    }
    argc = next;
    ecEncodeOpcode(cp, EJS_OP_NEW_ARRAY);
    typeNode = np->objectLiteral.typeNode;
    type = (EjsType*) typeNode->lookup.ref;
    ecEncodeGlobal(cp, (EjsObj*) type, (type) ? type->qname: N(NULL, NULL));
    ecEncodeNum(cp, argc);
    pushStack(cp, 1);
    popStack(cp, argc * 2);
    LEAVE(cp);
}


static void genObjectLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child, *typeNode;
    EjsType     *type;
    Ejs         *ejs;
    int         next, argc;

    if (np->objectLiteral.isArray) {
        genArrayLiteral(cp, np);
        return;
    }
    ENTER(cp);
    ejs = cp->ejs;

    /*
        Push all the literal args
     */
    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        processNode(cp, child);
    }
    argc = next;
    ecEncodeOpcode(cp, EJS_OP_NEW_OBJECT);
    typeNode = np->objectLiteral.typeNode;
    type = (EjsType*) typeNode->lookup.ref;
    ecEncodeGlobal(cp, (EjsObj*) type, (type) ? type->qname: N(NULL, NULL));
    ecEncodeNum(cp, argc);
    for (next = 0; (child = getNextNode(cp, np, &next)) != 0; ) {
        ecEncodeNum(cp, child->attributes);
    }
    pushStack(cp, 1);
    popStack(cp, argc * 3);
    LEAVE(cp);
}


static void genField(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *fieldName;

    ejs = cp->ejs;
    fieldName = np->field.fieldName;

    if (np->field.index >= 0) {
        //  TODO OPT use LOAD_INT_NN instructions
        ecEncodeOpcode(cp, EJS_OP_LOAD_INT);
        ecEncodeNum(cp, np->field.index);
        pushStack(cp, 1);

    } else if (fieldName->kind == N_QNAME) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->field.fieldName->qname.space);
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->field.fieldName->qname.name);
        pushStack(cp, 2);

    } else if (fieldName->kind == N_LITERAL) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, ESV(empty));
        pushStack(cp, 1);
        genLiteral(cp, fieldName);

    } else {
        //  TODO
        assert(0);
        processNode(cp, fieldName);
    }
    if (np->field.fieldKind == FIELD_KIND_VALUE || np->field.fieldKind == FIELD_KIND_FUNCTION) {
        if (np->field.expr) {
            processNode(cp, np->field.expr);
        } else {
            ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
            pushStack(cp, 1);            
        }
    }
}


static void genPostfixOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    /*
        Dup before inc
     */
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_DUP);
    ecEncodeOpcode(cp, EJS_OP_INC);
    ecEncodeByte(cp, (np->tokenId == T_PLUS_PLUS) ? 1 : -1);
    genLeftHandSide(cp, np->left);
    pushStack(cp, 1);
    LEAVE(cp);
}


static void genProgram(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {

        switch (child->kind) {
        case N_MODULE:
            genModule(cp, child);
            break;

        case N_DIRECTIVES:
            genDirectives(cp, child, 0);
            break;

        default:
            badNode(cp, np);
        }
    }
    LEAVE(cp);
}


static void genPragmas(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    next = 0;
    while ((child = getNextNode(cp, np, &next))) {
        processNode(cp, child);
    }
}


/*
    Generate code for function returns
 */
static void genReturn(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;

    ENTER(cp);

    ejs = cp->ejs;
    if (cp->state->captureFinally) {
        ecEncodeOpcode(cp, EJS_OP_CALL_FINALLY);
    }
    if (np->left) {
        fun = cp->state->currentFunction;
        if (fun->resultType == NULL || fun->resultType != EST(Void)) {
            cp->state->needsValue = 1;
            processNode(cp, np->left);
            cp->state->needsValue = 0;
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            popStack(cp, 1);

        } else if (np->ret.blockless) {
            /*
                The return was inserted by the parser. So we must still process the statement
             */
            processNode(cp, np->left);
        }

    } else {
        /*
            return;
         */
        fun = cp->state->currentFunction;
        if (fun->isConstructor) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
        } else {
            ecEncodeOpcode(cp, EJS_OP_RETURN);
        }
    }
    LEAVE(cp);
}


/*
    Load the super pointer. Super function calls (super()) are handled via N_CALL.
 */
static void genSuper(EcCompiler *cp, EcNode *np)
{
    int         argc;

    ENTER(cp);
    assert(np->kind == N_SUPER);

    if (np->left) {
        argc = mprGetListLength(np->left->children);
        if (argc > 0) {
            processNode(cp, np->left);
        }
        ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
        ecEncodeName(cp, cp->state->currentClass->baseType->qname);
        ecEncodeNum(cp, argc);        
        popStack(cp, argc);
    } else {
        ecEncodeOpcode(cp, EJS_OP_SUPER); 
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


static void genSwitch(EcCompiler *cp, EcNode *np)
{
    EcNode      *caseItem, *elements;
    EcCodeGen   *code, *outerBlock;
    EcState     *state;
    int         next, len, nextCaseLen, nextCodeLen, totalLen, mark;

    ENTER(cp);

    state = cp->state;
    state->captureFinally = 0;
    state->captureBreak = 0;

    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);

    /*
        Generate code for the switch (expression)
     */
    processNode(cp, np->left);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK);

    /*
        Generate the code for each case label expression and case statements.
        next set to one to skip the switch expression.
     */
    elements = np->right;
    assert(elements->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((caseItem = getNextNode(cp, elements, &next)) && !cp->error) {
        /*
            Allocate a buffer for the case expression and generate that code
         */
        mark = getStackCount(cp);
        assert(caseItem->kind == N_CASE_LABEL);
        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            caseItem->caseLabel.expressionCode = state->code = allocCodeBuffer(cp);
            /*
                Dup the switch expression value to preserve it for later cases.
                OPT - don't need to preserve for default cases or if this is the last case
             */
            ecEncodeOpcode(cp, EJS_OP_DUP);
            assert(caseItem->caseLabel.expression);
            processNode(cp, caseItem->caseLabel.expression);
            popStack(cp, 1);
        }

        /*
            Generate code for the case directives themselves.
         */
        caseItem->code = state->code = allocCodeBuffer(cp);
        assert(caseItem->left->kind == N_DIRECTIVES);
        processNode(cp, caseItem->left);
        setStack(cp, mark);
    }

    /*
        Calculate jump lengths. Start from the last case and work backwards.
     */
    nextCaseLen = 0;
    nextCodeLen = 0;
    totalLen = 0;

    next = -1;
    while ((caseItem = getPrevNode(cp, elements, &next)) && !cp->error) {
        if (caseItem->kind != N_CASE_LABEL) {
            break;
        }
        /*
            CODE jump
            Jump to the code block of the next case. In the last block, we just fall out the bottom.
         */
        caseItem->caseLabel.nextCaseCode = nextCodeLen;
        if (nextCodeLen > 0) {
            len = (caseItem->caseLabel.nextCaseCode < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;
            nextCodeLen += len;
            nextCaseLen += len;
            totalLen += len;
        }

        /*
            CASE jump
            Jump to the next case expression evaluation.
         */
        len = getCodeLength(cp, caseItem->code);
        nextCodeLen += len;
        nextCaseLen += len;
        totalLen += len;

        caseItem->jumpLength = nextCaseLen;
        nextCodeLen = 0;

        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            /*
                Jump to the next case expression test. Increment the length depending on whether we are using a
                goto_8 (2 bytes) or goto (4 bytes). Add one for the CMPEQ instruction (3 vs 6)
             */
            len = (caseItem->jumpLength < 0x7f && cp->optimizeLevel > 0) ? 3 : 6;
            nextCodeLen += len;
            totalLen += len;

            if (caseItem->caseLabel.expressionCode) {
                len = getCodeLength(cp, caseItem->caseLabel.expressionCode);
                nextCodeLen += len;
                totalLen += len;
            }
        }
        nextCaseLen = 0;
    }

    /*
        Now copy the basic blocks into the output code buffer.
     */
    setCodeBuffer(cp, code);

    next = 0;
    while ((caseItem = getNextNode(cp, elements, &next)) && !cp->error) {

        if (caseItem->caseLabel.expressionCode) {
            copyCodeBuffer(cp, state->code, caseItem->caseLabel.expressionCode);
        }

        /*
            Encode the jump to the next case
         */
        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            ecEncodeOpcode(cp, EJS_OP_COMPARE_STRICTLY_EQ);
            if (caseItem->jumpLength < 0x7f && cp->optimizeLevel > 0) {
                ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
                ecEncodeByte(cp, caseItem->jumpLength);
            } else {
                ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
                ecEncodeInt32(cp, caseItem->jumpLength);
            }
        }
        assert(caseItem->code);
        copyCodeBuffer(cp, state->code, caseItem->code);

        /*
            Encode the jump to the next case's code. Last case/default block may have zero length jump.
         */
        if (caseItem->caseLabel.nextCaseCode > 0) {
            if (caseItem->caseLabel.nextCaseCode < 0x7f && cp->optimizeLevel > 0) {
                ecEncodeOpcode(cp, EJS_OP_GOTO_8);
                ecEncodeByte(cp, caseItem->caseLabel.nextCaseCode);
            } else {
                ecEncodeOpcode(cp, EJS_OP_GOTO);
                ecEncodeInt32(cp, caseItem->caseLabel.nextCaseCode);
            }
        }
    }
    popStack(cp, 1);

    totalLen = (int) mprGetBufLength(state->code->buf);
    patchJumps(cp, EC_JUMP_BREAK, totalLen);

    /*
        Pop the switch value
     */
    ecEncodeOpcode(cp, EJS_OP_POP);
    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    Load the this pointer.
 */
static void genThis(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;

    switch (np->thisNode.thisKind) {
    case EC_THIS_GENERATOR:
        //  TODO
        break;

    case EC_THIS_CALLEE:
        //  TODO
        break;

    case EC_THIS_TYPE:
        genClassName(cp, state->currentClass);
        break;

    case EC_THIS_FUNCTION:
        genName(cp, state->currentFunctionNode);
        break;

    default:
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
  
 */
static void genThrow(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    cp->state->needsValue = 1;
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_THROW);
    popStack(cp, 1);
    LEAVE(cp);
}


/*
    Try, catch, finally.
 */
static void genTry(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *child, *arg;
    EcCodeGen       *saveCode;
    EcState         *state;
    EjsType         *catchType;
    uint            tryStart, tryEnd, handlerStart, handlerEnd;
    int             next, len, numStack;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;

    /*
        Switch to a new code buffer for the try block
     */
    numStack = getStackCount(cp);
    saveCode = state->code;
    assert(saveCode);
    np->exception.tryBlock->code = state->code = allocCodeBuffer(cp);

    /*
        Process the try block. Will add a goto into either the finally block or if no finally block,
        to after the last catch.
     */
    state->captureFinally = np->exception.finallyBlock ? 1 : 0;
    processNode(cp, np->exception.tryBlock);
    state->captureFinally = 0;

    if (np->exception.catchClauses) {
        /*
            If there is a finally block it must be invoked before acting on any break/continue and return statements 
         */
        next = 0;
        state->captureFinally = np->exception.finallyBlock ? 1 : 0;
        state->captureBreak = 1;
        while ((child = getNextNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            child->code = state->code = allocCodeBuffer(cp);
            assert(child->left);
            processNode(cp, child->left);
            if (np->exception.finallyBlock == 0) {
                ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
            }
            /* Add jumps below */
        }
        state->captureFinally = 0;
        state->captureBreak = 0;
    }
    if (np->exception.finallyBlock) {
        state->captureBreak = 1;
        np->exception.finallyBlock->code = state->code = allocCodeBuffer(cp);
        /* Finally pushes the original PC */
        pushStack(cp, 1);
        processNode(cp, np->exception.finallyBlock);
        ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
        popStack(cp, 1);
        state->captureBreak = 0;
    }

    /*
        Calculate jump lengths for the catch block into a finally block. Start from the last catch block and work backwards.
     */
    len = 0;
    if (np->exception.catchClauses) {
        next = -1;
        while ((child = getPrevNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            child->jumpLength = len;
            if (child->jumpLength > 0 && np->exception.finallyBlock) {
                /*
                    Add jumps if there is a finally block. Otherwise, we use and end_ecception instruction
                    Increment the length depending on whether we are using a goto_8 (2 bytes) or goto (4 bytes)
                 */
                len += (child->jumpLength < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;
            }
            len += getCodeLength(cp, child->code);
        }
    }

    /*
        Now copy the code. First the try block. Restore the primary code buffer and copy try/catch/finally
        code blocks into the code buffer.
     */
    setCodeBuffer(cp, saveCode);

    tryStart = ecGetCodeOffset(cp);

    /*
        Copy the try code and add a jump
     */
    copyCodeBuffer(cp, state->code, np->exception.tryBlock->code);

    if (np->exception.finallyBlock) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_FINALLY);
    } else if (len < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeInt32(cp, len);
    }
    tryEnd = ecGetCodeOffset(cp);

    /*
        Now the copy the catch blocks and add jumps
     */
    if (np->exception.catchClauses) {
        next = 0;
        while ((child = getNextNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            handlerStart = ecGetCodeOffset(cp);
            copyCodeBuffer(cp, state->code, child->code);
            if (child->jumpLength > 0 && np->exception.finallyBlock) {
                if (child->jumpLength < 0x7f && cp->optimizeLevel > 0) {
                    ecEncodeOpcode(cp, EJS_OP_GOTO_8);
                    ecEncodeByte(cp, child->jumpLength);
                } else {
                    ecEncodeOpcode(cp, EJS_OP_GOTO);
                    ecEncodeInt32(cp, child->jumpLength);
                }
            }
            handlerEnd = ecGetCodeOffset(cp);

            /*
                Create exception handler record
             */
            catchType = 0;
            arg = 0;
            if (child->catchBlock.arg && child->catchBlock.arg->left) {
                arg = child->catchBlock.arg->left;
            }
            if (arg && arg->typeNode && ejsIsType(cp->ejs, arg->typeNode->lookup.ref)) {
                catchType = (EjsType*) arg->typeNode->lookup.ref;
            }
            if (catchType == 0) {
                catchType = EST(Void);
            }
            ecAddNameConstant(cp, catchType->qname);
            addException(cp, tryStart, tryEnd, catchType, handlerStart, handlerEnd, np->exception.numBlocks, numStack, 
                EJS_EX_CATCH);
        }
    }

    /*
        Finally, the finally block
     */
    if (np->exception.finallyBlock) {
        handlerStart = ecGetCodeOffset(cp);
        copyCodeBuffer(cp, state->code, np->exception.finallyBlock->code);
        handlerEnd = ecGetCodeOffset(cp);
        addException(cp, tryStart, tryEnd, EST(Void), handlerStart, handlerEnd, np->exception.numBlocks, numStack, 
            EJS_EX_FINALLY);
    }
    LEAVE(cp);
}


static void genUnaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_UNARY_OP);
    assert(np->left);

    switch (np->tokenId) {
    case T_DELETE:
        genDelete(cp, np);
        break;

    case T_LOGICAL_NOT:
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_LOGICAL_NOT);
        break;

    case T_PLUS:
        /* Just ignore the plus */
        processNode(cp, np->left);
        break;

    case T_PLUS_PLUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_INC);
        ecEncodeByte(cp, 1);
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        genLeftHandSide(cp, np->left);
        break;

    case T_MINUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_NEG);
        break;

    case T_MINUS_MINUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_INC);
        ecEncodeByte(cp, -1);
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        genLeftHandSide(cp, np->left);
        break;

    case T_TILDE:
        /* Bitwise not */
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_NOT);
        break;

    case T_TYPEOF:
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_TYPE_OF);
        break;

    case T_VOID:
        /* Ignore the node and just push a void */
        ecEncodeOpcode(cp, EJS_OP_LOAD_UNDEFINED);
        pushStack(cp, 1);
        break;
    }
    LEAVE(cp);
}


static void genNameExpr(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    
    ENTER(cp);
    
    state = cp->state;
    state->currentObjectNode = 0;
    state->onLeft = 0;
    
    if (np->name.qualifierExpr) {
        processNode(cp, np->name.qualifierExpr);
    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->qname.space);
        pushStack(cp, 1);
    }
    if (np->name.nameExpr) {
        processNode(cp, np->name.nameExpr);
    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeConst(cp, np->qname.name);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
    Generate code for an unbound name reference. We don't know the slot.
 */
static void genUnboundName(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EjsObj      *owner;
    EjsLookup   *lookup;
    int         code;

    ENTER(cp);

    state = cp->state;
    assert(!np->lookup.bind || !cp->bind);

    lookup = &np->lookup;
    owner = lookup->obj;
    
    if (state->currentObjectNode && np->needThis) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        np->needThis = 0;
    }
    if (np->name.qualifierExpr || np->name.nameExpr) {
        genNameExpr(cp, np);
        if (state->currentObjectNode) {
            code = (!cp->state->onLeft) ? EJS_OP_GET_OBJ_NAME_EXPR :  EJS_OP_PUT_OBJ_NAME_EXPR;
            popStack(cp, (cp->state->onLeft) ? 4 : 2);
        } else {
            code = (!cp->state->onLeft) ? EJS_OP_GET_SCOPED_NAME_EXPR :  EJS_OP_PUT_SCOPED_NAME_EXPR;
            popStack(cp, (cp->state->onLeft) ? 3 : 1);
        }
        ecEncodeOpcode(cp, code);
        LEAVE(cp);
        return;
    }
    if (state->currentObjectNode) {
        /*
            Property name (requires obj on stack)
            Store: -2, load: 0
         */
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else if (lookup->useThis) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);
        if (np->needThis) {
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else if (owner && ejsIsType(ejs, owner)) {
        SAVE_ONLEFT(cp);
        genClassName(cp, (EjsType*) owner);
        RESTORE_ONLEFT(cp);

        if (np->needThis) {
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else {
        /*
            Unqualified name
         */
        if (np->needThis) {
            assert(0);
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_SCOPED_NAME :  EJS_OP_PUT_SCOPED_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, np->qname);

        /*
            Store: -1, load: 1
         */
        pushStack(cp, (state->onLeft) ? -1 : 1);
    }
    LEAVE(cp);
}


static void genModule(EcCompiler *cp, EcNode *np)
{    
    ENTER(cp);

    assert(np->kind == N_MODULE);

    addModule(cp, np->module.ref);
    genBlock(cp, np->left);
    LEAVE(cp);
}


static void genUseModule(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    assert(np->kind == N_USE_MODULE);

    next = 0;
    while ((child = getNextNode(cp, np, &next))) {
        processNode(cp, child);
    }
    LEAVE(cp);
}


static void genUseNamespace(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np->kind == N_USE_NAMESPACE);

    /*
        Load the namespace reference. NOTE: use default space; will not add a namespace to the set of open spaces.
     */
    if (np->name.isLiteral) {
        ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE);
        ecEncodeConst(cp, np->qname.name);
    } else {
        genName(cp, np);
        ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE_REF);
        popStack(cp, 1);
    }
    LEAVE(cp);
}


static void genVar(EcCompiler *cp, EcNode *np)
{
    assert(np->kind == N_VAR);

    ENTER(cp);
    ecAddNameConstant(cp, np->qname);
    if (np->lookup.trait && np->lookup.trait->type) {
        ecAddStringConstant(cp, np->lookup.trait->type->qname.name);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "var", np->lookup.obj, np->lookup.slotNum);
    }
    if (np->left) {
        processNode(cp, np->left);
    }
    LEAVE(cp);
}


static void genVarDefinition(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcNode      *var;
    int         next;

    assert(np->kind == N_VAR_DEFINITION);

    ENTER(cp);
    state = cp->state;

    for (next = 0; (var = getNextNode(cp, np, &next)) != 0; ) {
        if (var->kind == N_VAR) {
            if (var->left) {
                /*
                    Class level variable initializations must go into the instance code buffer.
                 */
                if (var->name.instanceVar) {
                    state->instanceCode = 1;
                    assert(state->instanceCodeBuf);
                    state->code = state->instanceCodeBuf;
                }
            }
            genVar(cp, var);
        } else {
            processNode(cp, var);
        }
    }
    LEAVE(cp);
}


static void genWith(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    processNode(cp, np->with.object);
    ecEncodeOpcode(cp, EJS_OP_OPEN_WITH);
    popStack(cp, 1);
    processNode(cp, np->with.statement);
    ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
    LEAVE(cp);
}


/********************************* Support Code *******************************/
/*
    Create the module file.
 */

static MprFile *openModuleFile(EcCompiler *cp, cchar *filename)
{
    EcState     *state;

    assert(cp);
    assert(filename && *filename);

    state = cp->state;

    if (cp->noout) {
        return 0;
    }
    filename = mprJoinPath(cp->outputDir, filename);
    if ((cp->file = mprOpenFile(filename,  O_CREAT | O_WRONLY | O_TRUNC | O_BINARY, 0664)) == 0) {
        genError(cp, 0, "Cannot create module file \"%s\"", filename);
        return 0;
    }

    /*
        Create a module header once per file instead of per-module in the file
     */
    state->code = allocCodeBuffer(cp);
    if (ecCreateModuleHeader(cp) < 0) {
        genError(cp, 0, "Cannot write module file header");
        return 0;
    }
    return cp->file;
}


static void manageCodeGen(EcCodeGen *code, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(code->buf);
        mprMark(code->jumps);
        mprMark(code->exceptions);
        if (code->debug) {
            assert(code->debug->magic == EJS_DEBUG_MAGIC);
        }
        mprMark(code->debug);
    }
}


/*
    Create a new code buffer
 */
static EcCodeGen *allocCodeBuffer(EcCompiler *cp)
{
    EcState     *state;
    EcCodeGen   *code;

    assert(cp);

    state = cp->state;
    assert(state);

    if ((code = mprAllocObj(EcCodeGen, manageCodeGen)) == 0) {
        cp->fatalError = 1;
        return 0;
    }
    if ((code->buf = mprCreateBuf(EC_CODE_BUFSIZE, 0)) == 0) {
        assert(0);
        cp->fatalError = 1;
        return 0;
    }
    if ((code->exceptions = mprCreateList(-1, 0)) == 0) {
        assert(0);
        return 0;
    }
    /*
        Jumps are fully processed before the state is freed
     */
    code->jumps = mprCreateList(-1, 0);
    if (code->jumps == 0) {
        assert(0);
        return 0;
    }

    /*
        Inherit the allowable jump kinds and stack level
     */
    if (state->code) {
        code->jumpKinds = state->code->jumpKinds;
        code->blockCount = state->code->blockCount;
        code->stackCount = state->code->stackCount;
        code->breakMark = state->code->breakMark;
        code->blockMark = state->code->blockMark;
    }
    return code;
}


static int getCodeLength(EcCompiler *cp, EcCodeGen *code)
{
    return (int) mprGetBufLength(code->buf);
}


static void copyCodeBuffer(EcCompiler *cp, EcCodeGen *dest, EcCodeGen *src)
{
    EjsEx           *exception;
    EjsDebug        *debug;
    EcJump          *jump;
    uint            baseOffset;
    int             next, len, i;

    assert(dest != src);

    len = getCodeLength(cp, src);
    if (len <= 0) {
        return;
    }
    /*
        Copy the code
     */
    baseOffset = (int) mprGetBufLength(dest->buf);
    if (mprPutBlockToBuf(dest->buf, mprGetBufStart(src->buf), len) != len) {
        assert(0);
        return;
    }
    /*
        Copy and fix the jump offset of jump patch records. jump->offset starts out being relative to the current code src.
        We add the original length of dest to make it absolute to the new dest buffer.
     */
    if (src->jumps) {
        if (src->jumps != dest->jumps) {
            next = 0;
            while ((jump = (EcJump*) mprGetNextItem(src->jumps, &next)) != 0) {
                jump->offset += baseOffset;
                mprAddItem(dest->jumps, jump);
            }
        }
    }

    /*
        Copy and fix exception target addresses
     */
    if (src->exceptions) {
        next = 0;
        while ((exception = (EjsEx*) mprGetNextItem(src->exceptions, &next)) != 0) {
            exception->tryStart += baseOffset;
            exception->tryEnd += baseOffset;
            exception->handlerStart += baseOffset;
            exception->handlerEnd += baseOffset;
            mprAddItem(dest->exceptions, exception);
        }
    }

    /*
        Copy and fix debug offsets
     */
    if (src->debug) {
        debug = src->debug;
        for (i = 0; i < debug->numLines; i++) {
            addDebugLine(cp, dest, baseOffset + debug->lines[i].offset, debug->lines[i].source);
        }
    }
}


/*
    Patch jump addresses a code buffer. Kind is the kind of jump (break | continue)
 */
static void patchJumps(EcCompiler *cp, int kind, int target)
{
    EcJump      *jump;
    EcCodeGen   *code;
    int         next, offset;

    code = cp->state->code;
    assert(code);

rescan:
    next = 0;
    while ((jump = (EcJump*) mprGetNextItem(code->jumps, &next)) != 0) {
        if (jump->kind == kind) {
            offset = target - jump->offset - 4;
            assert(-10000 < offset && offset < 10000);
            assert(jump->offset < mprGetBufLength(code->buf));
            ecEncodeInt32AtPos(cp, jump->offset, offset);
            mprRemoveItem(code->jumps, jump);
            goto rescan;
        }
    }
}


/*
    Write the module contents
 */
static int flushModule(MprFile *file, EcCodeGen *code)
{
    int         len;

    len = (int) mprGetBufLength(code->buf);
    if (len > 0) {
        if (mprWriteFile(file, mprGetBufStart(code->buf), len) != len) {
            return EJS_ERR;
        }
        mprFlushBuf(code->buf);
    }
    return 0;
}


/*
    Create the module initializer
 */
static void createInitializer(EcCompiler *cp, EjsModule *mp)
{
    EjsFunction     *fun;
    EcState         *state;
    EcCodeGen       *code;

    ENTER(cp);

    state = cp->state;
    assert(state);

    /*
        Note: if hasInitializer is false, we may still have some code in the buffer if --debug is used.
        We can safely just ignore this debug code.
     */
    if (!mp->hasInitializer || !mp->code) {
        LEAVE(cp);
        return;
    }
    assert((int) mprGetBufLength(mp->code->buf) > 0);

    if (cp->errorCount > 0) {
        LEAVE(cp);
        return;
    }
    state->code = mp->code;
    cp->directiveState = state;
    code = cp->state->code;
    ecEncodeOpcode(cp, EJS_OP_END_CODE);

    /*
        Extract the initialization code
     */
    fun = state->currentFunction = mp->initializer;
    if (fun) {
        setFunctionCode(cp, fun, code);
    }
    LEAVE(cp);
}


static EcNode *getNextNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->error) {
        return 0;
    }
    return (EcNode*) mprGetNextItem(np->children, next);
}


static EcNode *getPrevNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->fatalError || cp->error) {
        return 0;
    }
    return (EcNode*) mprGetPrevItem(np->children, next);
}


/*
    Map a lexical token to an op code
 */
static int mapToken(EcCompiler *cp, int tokenId)
{
    int     cond;

    cond = cp->state->conditional;

    switch (tokenId) {
    case T_BIT_AND:
        return EJS_OP_AND;

    case T_BIT_OR:
        return EJS_OP_OR;

    case T_BIT_XOR:
        return EJS_OP_XOR;

    case T_DIV:
        return EJS_OP_DIV;

    case T_EQ:
        return (cond) ? EJS_OP_BRANCH_EQ : EJS_OP_COMPARE_EQ;

    case T_NE:
        return (cond) ? EJS_OP_BRANCH_NE : EJS_OP_COMPARE_NE;

    case T_GT:
        return (cond) ? EJS_OP_BRANCH_GT : EJS_OP_COMPARE_GT;

    case T_GE:
        return (cond) ? EJS_OP_BRANCH_GE : EJS_OP_COMPARE_GE;

    case T_LT:
        return (cond) ? EJS_OP_BRANCH_LT : EJS_OP_COMPARE_LT;

    case T_LE:
        return (cond) ? EJS_OP_BRANCH_LE : EJS_OP_COMPARE_LE;

    case T_STRICT_EQ:
        return (cond) ? EJS_OP_BRANCH_STRICTLY_EQ : EJS_OP_COMPARE_STRICTLY_EQ;

    case T_STRICT_NE:
        return (cond) ? EJS_OP_BRANCH_STRICTLY_NE : EJS_OP_COMPARE_STRICTLY_NE;

    case T_LSH:
        return EJS_OP_SHL;

    case T_LOGICAL_NOT:
        return EJS_OP_NOT;

    case T_MINUS:
        return EJS_OP_SUB;

    case T_MOD:
        return EJS_OP_REM;

    case T_MUL:
        return EJS_OP_MUL;

    case T_PLUS:
        return EJS_OP_ADD;

    case T_RSH:
        return EJS_OP_SHR;

    case T_RSH_ZERO:
        return EJS_OP_USHR;

    case T_IS:
        return EJS_OP_IS_A;

    case T_INSTANCEOF:
        return EJS_OP_INST_OF;

    case T_CAST:
        return EJS_OP_CAST;

    case T_IN:
        return EJS_OP_IN;

    default:
        assert(0);
        return -1;
    }
}


static void addDebugLine(EcCompiler *cp, EcCodeGen *code, int offset, wchar *source)
{
    assert(code->debug == 0 || code->debug->magic == EJS_DEBUG_MAGIC);
    if (ejsAddDebugLine(cp->ejs, &code->debug, offset, source) < 0) {
        genError(cp, 0, "Cannot allocate memory for debug section");
        return;
    }
}


static void addDebug(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *code;
    wchar       *source;
    int         offset;

    code = cp->state->code;
    if (!cp->debug || code == 0 || np->loc.lineNumber <= code->lastLineNumber) {
        return;
    }
    source = np->loc.source;
    if (source[0] == '}' && source[1] == 0) {
        return;
    }
    offset = (int) mprGetBufLength(code->buf);
    source = (wchar*) mfmt("%s|%d|%w", np->loc.filename, np->loc.lineNumber, np->loc.source);
    addDebugLine(cp, code, offset, source);
    code->lastLineNumber = np->loc.lineNumber;
}


static void processNode(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;

    assert(np->parent || np->kind == N_PROGRAM || np->kind == N_MODULE);

    if (np->kind != N_FUNCTION) {
        addDebug(cp, np);
    }
    switch (np->kind) {
    case N_ARGS:
        state->needsValue = 1;
        genArgs(cp, np);
        break;

    case N_ASSIGN_OP:
        genAssignOp(cp, np);
        break;

    case N_BINARY_OP:
        genBinaryOp(cp, np);
        break;

    case N_BLOCK:
        genBlock(cp, np);
        break;

    case N_BREAK:
        genBreak(cp, np);
        break;

    case N_CALL:
        genCall(cp, np);
        break;

    case N_CLASS:
        genClass(cp, np);
        break;

    case N_CATCH_ARG:
        genCatchArg(cp, np);
        break;

    case N_CONTINUE:
        genContinue(cp, np);
        break;

    case N_DASSIGN:
        genDassign(cp, np);
        break;

    case N_DIRECTIVES:
        genDirectives(cp, np, 0);
        break;

    case N_DO:
        genDo(cp, np);
        break;

    case N_DOT:
        genDot(cp, np, 0);
        break;

    case N_END_FUNCTION:
        genEndFunction(cp, np);
        break;

    case N_EXPRESSIONS:
        genExpressions(cp, np);
        break;

    case N_FOR:
        genFor(cp, np);
        break;

    case N_FOR_IN:
        genForIn(cp, np);
        break;

    case N_FUNCTION:
        genFunction(cp, np);
        break;

    case N_HASH:
        genHash(cp, np);
        break;

    case N_IF:
        genIf(cp, np);
        break;

    case N_LITERAL:
        genLiteral(cp, np);
        break;

    case N_OBJECT_LITERAL:
        genObjectLiteral(cp, np);
        break;

    case N_FIELD:
        genField(cp, np);
        break;

    case N_QNAME:
        genName(cp, np);
        break;

    case N_NEW:
        genNew(cp, np);
        break;

    case N_NOP:
        break;

    case N_POSTFIX_OP:
        genPostfixOp(cp, np);
        break;

    case N_PRAGMA:
        break;

    case N_PRAGMAS:
        genPragmas(cp, np);
        break;

    case N_PROGRAM:
        genProgram(cp, np);
        break;

    case N_REF:
        break;

    case N_RETURN:
        genReturn(cp, np);
        break;

    case N_SPREAD:
        genSpread(cp, np);
        break;

    case N_SUPER:
        genSuper(cp, np);
        break;

    case N_SWITCH:
        genSwitch(cp, np);
        break;

    case N_THIS:
        genThis(cp, np);
        break;

    case N_THROW:
        genThrow(cp, np);
        break;

    case N_TRY:
        genTry(cp, np);
        break;

    case N_UNARY_OP:
        genUnaryOp(cp, np);
        break;

    case N_USE_NAMESPACE:
        genUseNamespace(cp, np);
        break;

    case N_VAR:
        genVar(cp, np);
        break;

    case N_VAR_DEFINITION:
        genVarDefinition(cp, np);
        break;

    case N_MODULE:
        genModule(cp, np);
        break;

    case N_USE_MODULE:
        genUseModule(cp, np);
        break;

    case N_WITH:
        genWith(cp, np);
        break;

    default:
        assert(0);
        badNode(cp, np);
    }
    assert(state == cp->state);
    LEAVE(cp);
}


/*
    Oputput one module.
 */
static void processModule(EcCompiler *cp, EjsModule *mp)
{
    EcState     *state;
    EcCodeGen   *code;
    char        *path;

    ENTER(cp);

    state = cp->state;
    state->currentModule = mp;

    createInitializer(cp, mp);

    if (cp->noout || !mp->code) {
        return;
    }
    if (! cp->outputFile) {
        if (mp->version) {
            path = sfmt("%s-%d.%d.%d%s", mp->name, EJS_MAJOR(mp->version), EJS_MINOR(mp->version), 
                EJS_PATCH(mp->version), EJS_MODULE_EXT);
        } else {
            path = sfmt("%@%s", mp->name, EJS_MODULE_EXT);
        }
        if ((mp->file = openModuleFile(cp, path)) == 0) {
            LEAVE(cp);
            return;
        }

    } else {
        mp->file = cp->file;
    }
    assert(mp->code);
    assert(mp->file);
    code = state->code;

    if (mp->hasInitializer) {
        //  TODO -- make these standard strings in native core
        ecAddCStringConstant(cp, EJS_INITIALIZER_NAME);
        ecAddCStringConstant(cp, EJS_EJS_NAMESPACE);
        if (mp->initializer->resultType) {
            ecAddNameConstant(cp, mp->initializer->resultType->qname);
        }
    }
    if (ecCreateModuleSection(cp) < 0) {
        genError(cp, 0, "Cannot write module sections");
        LEAVE(cp);
        return;
    }
    if (flushModule(mp->file, code) < 0) {
        genError(cp, 0, "Cannot write to module file %s", mp->name);
        LEAVE(cp);
        return;
    }
    if (!cp->outputFile) {
        mprCloseFile(mp->file);
    }
    mp->file = 0;
}


/*
    Keep a list of modules potentially containing generated code and declarations.
 */
static void addModule(EcCompiler *cp, EjsModule *mp)
{
    EjsModule       *module;
    Ejs             *ejs;
    EcState         *state;
    int             next;

    assert(cp);

    state = cp->state;
    ejs = cp->ejs;

    if (mp->code == 0 || cp->interactive) {
        mp->code = state->code = allocCodeBuffer(cp);
    }
    mp->loaded = 0;
    state->code = mp->code;
    assert(mp->code);
    assert(mp->code->buf);

    state->currentModule = mp;
    state->varBlock = ejs->global;
    state->letBlock = ejs->global;

    assert(mp->initializer);
    state->currentFunction = mp->initializer;

    /*
        Merge means aggregate dependent input modules with the output
     */
    if (mp->dependencies && !cp->merge) {
        for (next = 0; (module = mprGetNextItem(mp->dependencies, &next)) != 0; ) {
            ecAddStringConstant(cp, module->name);
        }
    }
}


//  TODO -- cleanup
#if ME_MPR_TRACING
static int level = 8;
#endif

static void pushStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;

    assert(code);

    assert(code->stackCount >= 0);
    code->stackCount += count;
    assert(code->stackCount >= 0);

    mprTrace(level, "Stack %d, after push %d", code->stackCount, count);
}


static void popStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;

    assert(code);
    assert(code->stackCount >= 0);

    code->stackCount -= count;
    assert(code->stackCount >= 0);

    mprTrace(level, "Stack %d, after pop %d", code->stackCount, count);
}


static void setStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;
    assert(code);
    code->stackCount = count;
}


static int getStackCount(EcCompiler *cp)
{
    return cp->state->code->stackCount;
}


static void discardStackItems(EcCompiler *cp, int preserve)
{
    EcCodeGen       *code;
    int             count;

    code = cp->state->code;

    assert(code);
    count = code->stackCount - preserve;

    if (count <= 0) {
        return;
    }
    if (count == 1) {
        ecEncodeOpcode(cp, EJS_OP_POP);
    } else {
        ecEncodeOpcode(cp, EJS_OP_POP_ITEMS);
        ecEncodeByte(cp, count);
    }
    code->stackCount -= count;
    assert(code->stackCount >= 0);
    mprTrace(level, "Stack %d, after discard\n", code->stackCount);
}


static void discardBlockItems(EcCompiler *cp, int preserve)
{
    EcCodeGen       *code;
    int             count, i;

    code = cp->state->code;
    assert(code);
    count = code->blockCount - preserve;

    for (i = 0; i < count; i++) {
        ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
    }
    code->blockCount -= count;
    assert(code->blockCount >= 0);
    mprTrace(level, "Block level %d, after discard\n", code->blockCount);
}


/*
    Set the default code buffer
 */
static void setCodeBuffer(EcCompiler *cp, EcCodeGen *saveCode)
{
    cp->state->code = saveCode;
    mprTrace(level, "Stack %d, after restore code buffer\n", cp->state->code->stackCount);
}


static void addException(EcCompiler *cp, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart, uint handlerEnd, 
    int numBlocks, int numStack, int flags)
{
    EcCodeGen       *code;
    EcState         *state;
    EjsEx           *exception;

    state = cp->state;
    assert(state);

    code = state->code;
    assert(code);

    if ((exception = mprAllocZeroed(sizeof(EjsEx))) == 0) {
        assert(0);
        return;
    }
    exception->tryStart = tryStart;
    exception->tryEnd = tryEnd;
    exception->catchType = catchType;
    exception->handlerStart = handlerStart;
    exception->handlerEnd = handlerEnd;
    exception->numBlocks = numBlocks;
    exception->numStack = numStack;
    exception->flags = flags;
    mprAddItem(code->exceptions, exception);
}


static void addJump(EcCompiler *cp, EcNode *np, int kind)
{
    EcJump      *jump;

    ENTER(cp);

    jump = mprAllocZeroed(sizeof(EcJump));
    assert(jump);

    jump->kind = kind;
    jump->node = np;
    jump->offset = ecGetCodeOffset(cp);

    mprAddItem(cp->state->code->jumps, jump);
    LEAVE(cp);
}


static void setFunctionCode(EcCompiler *cp, EjsFunction *fun, EcCodeGen *code)
{
    EjsEx       *ex;
    int         next, len;

    len = (int) mprGetBufLength(code->buf);
    assert(len >= 0);
    if (len > 0) {
        ejsSetFunctionCode(cp->ejs, fun, cp->state->currentModule, (uchar*) mprGetBufStart(code->buf), len, code->debug);
    }
    /*
        Define any try/catch blocks encountered
     */
    next = 0;
    while ((ex = (EjsEx*) mprGetNextItem(code->exceptions, &next)) != 0) {
        ejsAddException(cp->ejs, fun, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, 
            ex->handlerEnd, ex->numBlocks, ex->numStack, ex->flags, -1);
    }
}


static void emitNamespace(EcCompiler *cp, EjsNamespace *nsp)
{
    ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE);
    ecEncodeConst(cp, nsp->value);
}


/*
    Aggregate the allowable kinds of jumps
 */
PUBLIC void ecStartBreakableStatement(EcCompiler *cp, int kinds)
{
    EcState     *state;

    assert(cp);

    state = cp->state;
    state->code->jumpKinds |= kinds;
    state->breakState = state;
    state->code->breakMark = state->code->stackCount;
    state->code->blockMark = state->code->blockCount;
}

static void genError(EcCompiler *cp, EcNode *np, char *fmt, ...)
{
    va_list     args;
    EcLocation  *loc;

    va_start(args, fmt);

    cp->errorCount++;
    cp->error = 1;
    cp->noout = 1;
    if (np) {
        loc = &np->loc;
        ecErrorv(cp, "Error", loc, fmt, args);
    } else {
        ecErrorv(cp, "Error", NULL, fmt, args);
    }
    va_end(args);
}


static void badNode(EcCompiler *cp, EcNode *np)
{
    cp->fatalError = 1;
    cp->errorCount++;
    mprError("Unsupported language feature\nUnknown AST node kind %d", np->kind);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/compiler/ecCompiler.c"
 */
/************************************************************************/

/**
    ecCompile.c - Interface to the compiler

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/***************************** Forward Declarations ***************************/

static void compileError(EcCompiler *cp, cchar *fmt, ...);
static int compileInner(EcCompiler *cp, int argc, char **argv);
static EjsObj *loadScriptLiteral(Ejs *ejs, EjsString *script, cchar *cache);
static EjsObj *loadScriptFile(Ejs *ejs, cchar *path, cchar *cache);
static void manageCompiler(EcCompiler *cp, int flags);

/************************************ Code ************************************/

PUBLIC EcCompiler *ecCreateCompiler(Ejs *ejs, int flags)
{
    EcCompiler      *cp;

    if ((cp = mprAllocObj(EcCompiler, manageCompiler)) == 0) {
        return 0;
    }
    cp->ejs = ejs;
    cp->strict = 0;
    cp->tabWidth = EC_TAB_WIDTH;
    cp->warnLevel = 1;
    cp->shbang = 1;
    cp->optimizeLevel = 9;
    cp->warnLevel = 1;
    cp->outputDir = sclone(".");

    if (flags & EC_FLAGS_DOC) {
        cp->doc = 1;
    }
    if (flags & EC_FLAGS_BIND) {
        cp->bind = 1;
    }
    if (flags & EC_FLAGS_DEBUG) {
        cp->debug = 1;
    }
    if (flags & EC_FLAGS_MERGE) {
        cp->merge = 1;
    }
    if (flags & EC_FLAGS_NO_OUT) {
        cp->noout = 1;
    }
    if (flags & EC_FLAGS_VISIBLE) {
        cp->visibleGlobals = 1;
    }
    if (ecResetModuleList(cp) < 0) {
        return 0;
    }
    ecInitLexer(cp);
    ecResetParser(cp);
    return cp;
}

        
static void manageCompiler(EcCompiler *cp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(cp->nodes);
        mprMark(cp->certFile);
        mprMark(cp->docToken);
        mprMark(cp->extraFiles);
        mprMark(cp->file);
        mprMark(cp->keywords);
        mprMark(cp->peekToken);
        mprMark(cp->putback);
        mprMark(cp->state);
        mprMark(cp->stream);
        mprMark(cp->token);
        mprMark(cp->outputDir);
        mprMark(cp->outputFile);
        mprMark(cp->fixups);
        mprMark(cp->require);
        mprMark(cp->modules);
        mprMark(cp->errorMsg);
    }
}


PUBLIC int ecCompile(EcCompiler *cp, int argc, char **argv)
{
    Ejs     *ejs;
    int     rc, saveCompiling, paused;

    ejs = cp->ejs;
    saveCompiling = ejs->compiling;
    ejs->compiling = 1;
    
    paused = ejsBlockGC(ejs);
    rc = compileInner(cp, argc, argv);
    ejsUnblockGC(ejs, paused);
    ejs->compiling = saveCompiling;
    return rc;
}


static int compileInner(EcCompiler *cp, int argc, char **argv)
{
    Ejs         *ejs;
    EjsModule   *mp;
    MprList     *nodes;
    EjsBlock    *block;
    EcLocation  loc;
    cchar       *ext;
    char        *msg;
    int         next, i, j, nextModule, lflags, rc, paused;

    ejs = cp->ejs;
    if ((nodes = mprCreateList(-1, 0)) == 0) {
        return EJS_ERR;
    }
    cp->nodes = nodes;

    /*
        Warn about source files mentioned multiple times.
        TODO OPT. This is slow.
     */
    for (i = 0; i < argc; i++) {
        for (j = 0; j < argc; j++) {
            if (i == j) {
                continue;
            }
            if (mprSamePath(argv[i], argv[j])) {
                compileError(cp, "Loading source %s multiple times. Ignoring extra copies.", argv[i]);
                return EJS_ERR;
            }
        }
        if (cp->outputFile && mprSamePath(cp->outputFile, argv[i])) {
            compileError(cp, "Output file is the same as input file: %s", argv[i]);
            return EJS_ERR;
        }
    }

    /*
        Compile source files and load any module files
     */
    for (i = 0; i < argc && !cp->fatalError; i++) {
        ext = mprGetPathExt(argv[i]);
        if (scaselesscmp(ext, "mod") == 0 || scaselesscmp(ext, ME_SHOBJ) == 0) {
            nextModule = mprGetListLength(ejs->modules);
            lflags = cp->strict ? EJS_LOADER_STRICT : 0;
            if ((rc = ejsLoadModule(cp->ejs, ejsCreateStringFromAsc(ejs, argv[i]), -1, -1, lflags)) < 0) {
                msg = sfmt("Error initializing module %s\n%s", argv[i], ejsGetErrorMsg(cp->ejs, 1));
                memset(&loc, 0, sizeof(EcLocation));
                loc.filename = sclone(argv[i]);
                if (rc == MPR_ERR_CANT_INITIALIZE) {
                    ecError(cp, "Error", &loc, msg);
                } else {
                    ecError(cp, "Error", &loc, msg);
                }
                cp->nodes = NULL;
                return EJS_ERR;
            }
            if (cp->merge) {
                /*
                    If merging, we must emit the loaded module into the output. So add to the compiled modules list.
                 */
                for (next = nextModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
                    if (mprLookupItem(cp->modules, mp) < 0 && mprAddItem(cp->modules, mp) < 0) {
                        compileError(cp, "Cannot add module %s", mp->name);
                    }
                }
            }
            mprAddItem(nodes, 0);
        } else  {
            paused = ejsBlockGC(ejs);
            mprAddItem(nodes, ecParseFile(cp, argv[i]));
            ejsUnblockGC(ejs, paused);
        }
    }
    /*
        Allocate the eval frame stack. This is used for property lookups. We have one dummy block at the top always.
     */
    block = ejsCreateBlock(ejs, 0);
    mprSetName(block, "Compiler");
    ejsPushBlock(ejs, block);
    
    /*
        Process the internal representation and generate code
     */
    paused = ejsBlockGC(ejs);
    if (!cp->parseOnly && cp->errorCount == 0) {
        ecResetParser(cp);
        if (ecAstProcess(cp) < 0) {
            ejsPopBlock(ejs);
            cp->nodes = NULL;
            ejsUnblockGC(ejs, paused);
            return EJS_ERR;
        }
        if (cp->errorCount == 0) {
            ecResetParser(cp);
            if (ecCodeGen(cp) < 0) {
                ejsPopBlock(ejs);
                cp->nodes = NULL;
                ejsUnblockGC(ejs, paused);
                return EJS_ERR;
            }
        }
    }
    ejsPopBlock(ejs);

    /*
        Add compiled modules to the interpreter
     */
    for (next = 0; ((mp = (EjsModule*) mprGetNextItem(cp->modules, &next)) != 0); ) {
        if (mp->code) {
            ejsAddModule(cp->ejs, mp);
        }
    }
    cp->nodes = NULL;
    ejsUnblockGC(ejs, paused);
    if (!paused) {
        mprYield(0);
    }
    return (cp->errorCount > 0) ? EJS_ERR: 0;
}


PUBLIC int ejsInitCompiler(EjsService *service)
{
    service->loadScriptLiteral = loadScriptLiteral;
    service->loadScriptFile = loadScriptFile;
    return 0;
}


/*
    Load a script file. This indirect routine is used by the core VM to compile a file when required.
 */
static EjsObj *loadScriptFile(Ejs *ejs, cchar *path, cchar *cache)
{
    if (ejsLoadScriptFile(ejs, path, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW) < 0) {
        return 0;
    }
    return ejs->result;
}


/*
    Function for ejs->loadScriptLiteral. This indirect routine is used by the core VM to compile a script when required.
 */
static EjsObj *loadScriptLiteral(Ejs *ejs, EjsString *script, cchar *cache)
{
    if (ejsLoadScriptLiteral(ejs, script, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW) < 0) {
        return 0;
    }
    return ejs->result;
}


PUBLIC int ejsLoadScriptFile(Ejs *ejs, cchar *path, cchar *cache, int flags)
{
    EcCompiler      *ec;

    if ((ec = ecCreateCompiler(ejs, flags)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(ec);
    if (cache) {
        ec->noout = 0;
        ecSetOutputFile(ec, cache);
    } else {
        ec->noout = 1;
    }
    if (ecCompile(ec, 1, (char**) &path) < 0) {
        if (flags & EC_FLAGS_THROW && !ejs->exception) {
            ejsThrowSyntaxError(ejs, "%s", ec->errorMsg ? ec->errorMsg : "Cannot parse script");
        }
        mprRemoveRoot(ec);
        return EJS_ERR;
    }
    mprRemoveRoot(ec);
    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    Load and initialize a script literal
 */
PUBLIC int ejsLoadScriptLiteral(Ejs *ejs, EjsString *script, cchar *cache, int flags)
{
    EcCompiler      *cp;
    cchar           *path;

    if ((cp = ecCreateCompiler(ejs, flags)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(cp);
    if (cache) {
        cp->noout = 0;
        ecSetOutputFile(cp, cache);
    } else {
        cp->noout = 1;
    }
    //  UNICODE -- should this API be multi or unicode
    if (ecOpenMemoryStream(cp, ejsToMulti(ejs, script), script->length) < 0) {
        mprError("Cannot open memory stream");
        mprRemoveRoot(cp);
        return EJS_ERR;
    }
    path = "__script__";
    if (ecCompile(cp, 1, (char**) &path) < 0) {
        if (flags & EC_FLAGS_THROW) {
            ejsThrowSyntaxError(ejs, "%s", cp->errorMsg ? cp->errorMsg : "Cannot parse script");
        }
        mprRemoveRoot(cp);
        return EJS_ERR;
    }
    ecCloseStream(cp);
    mprRemoveRoot(cp);
    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    One-line embedding. Evaluate a file. This will compile and interpret the given Ejscript source file.
 */
PUBLIC int ejsEvalFile(cchar *path)
{
    Ejs     *ejs;

    mprCreate(0, 0, 0);
    if ((ejs = ejsCreateVM(0, 0, 0)) == 0) {
        mprDestroy(0);
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(ejs);
    if (ejsLoadModules(ejs, 0, 0) < 0) {
        mprDestroy(0);
        return MPR_ERR_CANT_READ;
    }
    if (ejsLoadScriptFile(ejs, path, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG) < 0) {
        ejsReportError(ejs, "Error in program");
        mprDestroy(0);
        return MPR_ERR;
    }
    mprDestroy();
    return 0;
}


/*
    One-line embedding. Evaluate a script. This will compile and interpret the given script.
 */
PUBLIC int ejsEvalScript(cchar *script)
{
    Ejs     *ejs;

    mprCreate(0, 0, 0);
    if ((ejs = ejsCreateVM(0, 0, 0)) == 0) {
        mprDestroy(0);
        return MPR_ERR_MEMORY;
    }
    mprAddRoot(ejs);
    if (ejsLoadModules(ejs, 0, 0) < 0) {
        mprDestroy(0);
        return MPR_ERR_CANT_READ;
    }
    if (ejsLoadScriptLiteral(ejs, ejsCreateStringFromAsc(ejs, script), NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG) < 0) {
        ejsReportError(ejs, "Error in program");
        mprDestroy(0);
        return MPR_ERR;
    }
    mprDestroy();
    return 0;
}


static void compileError(EcCompiler *cp, cchar *fmt, ...)
{
    va_list     args;


    cp->errorCount++;
    cp->error = 1;
    va_start(args, fmt);
    ecError(cp, "Error", NULL, fmt, args);
    va_end(args);
}


PUBLIC void ecError(EcCompiler *cp, cchar *severity, EcLocation *loc, cchar *fmt, ...)
{
    va_list     args;

    va_start(args, fmt);
    ecErrorv(cp, severity, loc, fmt, args);
    va_end(args);
}


/*
    Create a line of spaces with an "^" pointer at the current parse error.
 */
static char *makeHighlight(EcCompiler *cp, wchar *source, int col)
{
    wchar       *up, *sp;
    char        *dest, *dp;
    int         tabCount, len, i;

    tabCount = 0;

    for (up = source, len = 0; *up; up++) {
        if (*up == '\t') {
            tabCount++;
        }
        len++;
    }
    len = (int) len + (tabCount * cp->tabWidth);
    len = max(len, col);

    /*
        Allow for "^" to be after the last char, plus one null.
     */
    if ((dest = mprAlloc(len + 2)) == NULL) {
        assert(dest);
        return 0;
    }
    for (i = 0, dp = dest, sp = source; *sp; sp++, i++) {
        if (*sp== '\t') {
            *dp++ = *sp;
        } else {
            *dp++ = ' ';
        }
    }
    /*
        Cover the case where the ^ must go after the end of the input
     */
    if (col >= 0) {
        dest[col] = '^';
        if (dp == &dest[col]) {
            ++dp;
        }
        *dp = '\0';
    }
    return dest;
}


PUBLIC void ecErrorv(EcCompiler *cp, cchar *severity, EcLocation *loc, cchar *fmt, va_list args)
{
    cchar   *appName;
    char    *pointer, *errorMsg, *msg;

    appName = mprGetAppName(cp);
    msg = sfmtv(fmt, args);

    if (loc) {
        if (loc->source) {
            pointer = makeHighlight(cp, loc->source, loc->column);
            errorMsg = sfmt("%s: %s: %s: %d: %s\n  %w  \n  %s", appName, severity, loc->filename, 
                loc->lineNumber, msg, loc->source, pointer);
        } else if (loc->lineNumber >= 0) {
            errorMsg = sfmt("%s: %s: %s: %d: %s", appName, severity, loc->filename, loc->lineNumber, msg);
        } else {
            errorMsg = sfmt("%s: %s: %s: 0: %s", appName, severity, loc->filename, msg);
        }
    } else {
        errorMsg = sfmt("%s: %s: %s", appName, severity, msg);
    }
    cp->errorMsg = srejoin(cp->errorMsg, errorMsg, NULL);
    mprBreakpoint();
}


PUBLIC void ecSetRequire(EcCompiler *cp, MprList *modules)
{
    cp->require = modules;
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/compiler/ecLex.c"
 */
/************************************************************************/

/**
    ecLex.c - Lexical analyzer

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/*
    TODO - must preserve inter-token white space for XML literals
 */

/********************************** Includes **********************************/



/*********************************** Locals ***********************************/

typedef struct ReservedWord {
    void    *name;
    int     groupMask;
    int     tokenId;
    int     subId;
} ReservedWord;


/*
    Reserved keyword table
    The "true", "false", "null" and "undefined" are handled as global variables
 */
static ReservedWord keywords[] =
{
  { "break",            G_RESERVED,         T_BREAK,                    0, },
  { "case",             G_RESERVED,         T_CASE,                     0, },
  { "cast",             G_CONREV,           T_CAST,                     0, },
  { "catch",            G_RESERVED,         T_CATCH,                    0, },
  { "class",            G_RESERVED,         T_CLASS,                    0, },
  { "const",            G_CONREV,           T_CONST,                    0, },
  { "continue",         G_RESERVED,         T_CONTINUE,                 0, },
  { "default",          G_CONREV,           T_DEFAULT,                  0, },
  { "delete",           G_RESERVED,         T_DELETE,                   0, },
  { "do",               G_RESERVED,         T_DO,                       0, },
  { "dynamic",          G_CONREV,           T_ATTRIBUTE,                T_DYNAMIC, },
  { "each",             G_CONREV,           T_EACH,                     0, },
  { "else",             G_RESERVED,         T_ELSE,                     0, },
  { "enumerable",       G_CONREV,           T_ATTRIBUTE,                T_ENUMERABLE, },
  { "extends",          G_RESERVED,         T_EXTENDS,                  0, },
  { "false",            G_RESERVED,         T_FALSE,                    0, },
  { "final",            G_CONREV,           T_ATTRIBUTE,                T_FINAL, },
  { "finally",          G_RESERVED,         T_FINALLY,                  0, },
  { "for",              G_RESERVED,         T_FOR,                      0, },
  { "function",         G_RESERVED,         T_FUNCTION,                 0, },
  { "get",              G_CONREV,           T_GET,                      0, },
  { "goto",             G_CONREV,           T_GOTO,                     0, },
  { "if",               G_RESERVED,         T_IF,                       0, },
  { "implements",       G_CONREV,           T_IMPLEMENTS,               0, },
  { "in",               G_RESERVED,         T_IN,                       0, },
  { "instanceof",       G_RESERVED,         T_INSTANCEOF,               0, },
  { "interface",        G_CONREV,           T_INTERFACE,                0, },
  { "internal",         G_CONREV,           T_RESERVED_NAMESPACE,       T_INTERNAL, },
  { "intrinsic",        G_CONREV,           T_RESERVED_NAMESPACE,       T_INTRINSIC, },
  { "is",               G_CONREV,           T_IS,                       0, },
  { "let",              G_CONREV,           T_LET,                      0, },
  { "module",           G_CONREV,           T_MODULE,                   0, },
  { "namespace",        G_CONREV,           T_NAMESPACE,                0, },
  { "native",           G_CONREV,           T_ATTRIBUTE,                T_NATIVE, },
  { "new",              G_RESERVED,         T_NEW,                      0, },
  { "null",             G_RESERVED,         T_NULL,                     0, },
  { "override",         G_CONREV,           T_ATTRIBUTE,                T_OVERRIDE, },
  { "private",          G_CONREV,           T_RESERVED_NAMESPACE,       T_PRIVATE, },
  { "protected",        G_CONREV,           T_RESERVED_NAMESPACE,       T_PROTECTED, },
  { "public",           G_CONREV,           T_RESERVED_NAMESPACE,       T_PUBLIC, },
  { "require",          G_CONREV,           T_REQUIRE,                  0, },
  { "return",           G_RESERVED,         T_RETURN,                   0, },
  { "set",              G_CONREV,           T_SET,                      0, },
  { "standard",         G_CONREV,           T_STANDARD,                 0, },
  { "static",           G_CONREV,           T_ATTRIBUTE,                T_STATIC, },
  { "strict",           G_CONREV,           T_STRICT,                   0, },
  { "super",            G_RESERVED,         T_SUPER,                    0, },
  { "switch",           G_RESERVED,         T_SWITCH,                   0, },
  { "this",             G_RESERVED,         T_THIS,                     0, },
  { "throw",            G_RESERVED,         T_THROW,                    0, },
  { "true",             G_RESERVED,         T_TRUE,                     0, },
  { "try",              G_RESERVED,         T_TRY,                      0, },
  { "typeof",           G_RESERVED,         T_TYPEOF,                   0, },
  { "var",              G_RESERVED,         T_VAR,                      0, },
  { "undefined",        G_CONREV,           T_UNDEFINED,                0, },
  { "use",              G_CONREV,           T_USE,                      0, },
  { "void",             G_RESERVED,         T_VOID,                     0, },
  { "while",            G_RESERVED,         T_WHILE,                    0, },
  { "with",             G_RESERVED,         T_WITH,                     0, },

#if UNUSED && KEEP
  /*
        Reserved but not implemented
   */
  { "abstract",         G_RESERVED,         T_ABSTRACT,                 0, },
  { "callee",           G_CONREV,           T_CALLEE,                   0, },
  { "enum",             G_RESERVED,         T_ENUM,                     T_ENUM, },
  { "generator",        G_CONREV,           T_GENERATOR,                0, },
  { "has",              G_CONREV,           T_HAS,                      0, },
  { "like",             G_CONREV,           T_LIKE,                     0, },
  { "readonly",         G_RESERVED,         T_ATTRIBUTE,                T_READONLY, },
  { "synchronized",     G_RESERVED,         T_ATTRIBUTE,                T_SYNCHRONIZED, },
  { "type",             G_CONREV,           T_TYPE,                     0, },
  { "volatile",         G_CONREV,           T_VOLATILE,                 0, },
  { "yield",            G_CONREV,           T_YIELD,                    0, },
#endif
  { 0,                  0,                  0, },
};

/***************************** Forward Declarations ***************************/

static int  addCharToToken(EcToken *tp, int c);
static int  addFormattedStringToToken(EcToken *tp, char *fmt, ...);
static int  addStringToToken(EcToken *tp, char *str);
static int  decodeNumber(EcCompiler *cp, int radix, int length);
static int  finalizeToken(EcToken *tp);
static int  initializeToken(EcToken *tp, EcStream *stream);
static int  setTokenID(EcToken *tp, int tokenId, int subId, int groupMask);
static int  makeNumberToken(EcCompiler *cp, EcToken *tp, int c);
static int  makeAlphaToken(EcCompiler *cp, EcToken *tp, int c);
static int  getComment(EcCompiler *cp, EcToken *tp, int c);
static int  getNextChar(EcStream *stream);
static int  makeQuotedToken(EcCompiler *cp, EcToken *tp, int c);
static int  makeSubToken(EcToken *tp, int c, int tokenId, int subId, int groupMask);
static int  makeToken(EcToken *tp, int c, int tokenId, int groupMask);
static void putBackChar(EcStream *stream, int c);

/************************************ Code ************************************/

PUBLIC void ecInitLexer(EcCompiler *cp)
{
    ReservedWord    *rp;
    int             size;

    size = sizeof(keywords) / sizeof(ReservedWord);
    if ((cp->keywords = mprCreateHash(size, MPR_HASH_UNICODE | MPR_HASH_STATIC_KEYS | MPR_HASH_STATIC_VALUES)) == 0) {
        return;
    }
    for (rp = keywords; rp->name; rp++) {
#if ME_CHAR_LEN > 1
        rp->name = amtow(cp->keywords, rp->name, NULL);
#endif
        mprAddKey(cp->keywords, rp->name, rp);
    }
}


static void manageToken(EcToken *tp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(tp->text);
        ecMarkLocation(&tp->loc);
    }
}


static EcToken *getLexToken(EcCompiler *cp)
{
    EcToken     *tp;

    if ((tp = cp->putback) != 0) {
        cp->putback = tp->next;
        cp->token = tp;
    } else {
        if ((cp->token = mprAllocObj(EcToken, manageToken)) == 0) {
            return 0;
        }
        initializeToken(cp->token, cp->stream);
    }
    return cp->token;
}


PUBLIC int ecGetToken(EcCompiler *cp)
{
    EcToken     *tp;
    EcStream    *stream;
    int         c;

    if ((tp = getLexToken(cp)) == NULL) {
        return T_ERR;
    }
    if (tp->tokenId) {
        return tp->tokenId;
    }
    stream = cp->stream;

    while (1) {
        c = getNextChar(stream);
        /*
            Overloadable operators
            + - ~ * / % < > <= >= == << >> >>> & | === != !==
            TODO FUTURE, we could allow also:  ".", "[", "(" and unary !, ^
         */
        switch (c) {
        default:
            if (isdigit((uchar) c)) {
                return makeNumberToken(cp, tp, c);

            } else if (c == '\\') {
                c = getNextChar(stream);
                if (c == '\n') {
                    break;
                }
                putBackChar(stream, c);
                c = '\n';
            }
            if (isalpha((uchar) c) || c == '_' || c == '\\' || c == '$') {
                return makeAlphaToken(cp, tp, c);
            }
            return makeToken(tp, 0, T_ERR, 0);

        case -1:
            return makeToken(tp, 0, T_ERR, 0);

        case 0:
            if (stream->flags & EC_STREAM_EOL) {
                return makeToken(tp, 0, T_NOP, 0);
            }
            return makeToken(tp, 0, T_EOF, 0);

        case ' ':
        case '\f':
        case '\t':
        case '\v':
        case 0xA0:      /* No break space */
            break;

        case '\r':
        case '\n':
            break;

        case '"':
        case '\'':
        case '`':
            return makeQuotedToken(cp, tp, c);

        case '#':
            return makeToken(tp, c, T_HASH, 0);

        case '[':
            //  EJS extension to consider this an operator
            return makeToken(tp, c, T_LBRACKET, G_OPERATOR);

        case ']':
            return makeToken(tp, c, T_RBRACKET, 0);

        case '(':
            //  EJS extension to consider this an operator
            return makeToken(tp, c, T_LPAREN, G_OPERATOR);

        case ')':
            return makeToken(tp, c, T_RPAREN, 0);

        case '{':
            return makeToken(tp, c, T_LBRACE, 0);

        case '}':
            return makeToken(tp, c, T_RBRACE, 0);

        case '@':
            return makeToken(tp, c, T_AT, 0);

        case ';':
            return makeToken(tp, c, T_SEMICOLON, 0);

        case ',':
            return makeToken(tp, c, T_COMMA, 0);

        case '?':
            return makeToken(tp, c, T_QUERY, 0);

        case '~':
            return makeToken(tp, c, T_TILDE, G_OPERATOR);

        case '+':
            c = getNextChar(stream);
            if (c == '+') {
                addCharToToken(tp, '+');
                return makeToken(tp, c, T_PLUS_PLUS, G_OPERATOR);
            } else if (c == '=') {
                addCharToToken(tp, '+');
                return makeSubToken(tp, c, T_ASSIGN, T_PLUS_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '+', T_PLUS, G_OPERATOR);

        case '-':
            c = getNextChar(stream);
            if (isdigit((uchar) c)) {
                putBackChar(stream, c);
                return makeToken(tp, '-', T_MINUS, G_OPERATOR);

            } else if (c == '-') {
                addCharToToken(tp, '-');
                return makeToken(tp, c, T_MINUS_MINUS, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '-');
                return makeSubToken(tp, c, T_ASSIGN, T_MINUS_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '-', T_MINUS, G_OPERATOR);

        case '*':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '*');
                return makeSubToken(tp, c, T_ASSIGN, T_MUL_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '*', T_MUL, G_OPERATOR);

        case '/':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '/');
                return makeSubToken(tp, c, T_ASSIGN, T_DIV_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);

            } else if (c == '>') {
                addCharToToken(tp, '/');
                return makeToken(tp, c, T_SLASH_GT, G_OPERATOR);

            } else if (c == '*' || c == '/') {
                /*
                    C and C++ comments
                 */
                if (getComment(cp, tp, c) < 0) {
                    return tp->tokenId;
                }
                /*
                    Doc comments are: [slash]**. The second "*' becomes the first char of the comment.
                    Don't regard: [slash]*** (three stars) as a comment.
                 */
                if (cp->doc) {
                    if (tp->text && tp->text[0] == '*' && tp->text[1] != '*') {
                        cp->docToken = mprMemdup(tp->text, tp->length * sizeof(wchar));
                    }
                }
                initializeToken(tp, stream);
                break;
            }
            putBackChar(stream, c);
            return makeToken(tp, '/', T_DIV, G_OPERATOR);

        case '%':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '%');
                return makeSubToken(tp, c, T_ASSIGN, T_MOD_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '%', T_MOD, G_OPERATOR);

        case '.':
            c = getNextChar(stream);
            if (c == '.') {
                c = getNextChar(stream);
                if (c == '.') {
                    addStringToToken(tp, "..");
                    return makeToken(tp, c, T_ELIPSIS, 0);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '.');
                return makeToken(tp, '.', T_DOT_DOT, 0);
#if FUTURE
            } else if (c == '<') {
                addCharToToken(tp, '.');
                return makeToken(tp, c, T_DOT_LESS, 0);
#endif
            } else if (isdigit((uchar) c)) {
                putBackChar(stream, c);
                return makeNumberToken(cp, tp, '.');
            }
            putBackChar(stream, c);
            //  EJS extension to consider this an operator
            return makeToken(tp, '.', T_DOT, G_OPERATOR);

        case ':':
            c = getNextChar(stream);
            if (c == ':') {
                addCharToToken(tp, ':');
                return makeToken(tp, c, T_COLON_COLON, 0);
            }
            putBackChar(stream, c);
            return makeToken(tp, ':', T_COLON, 0);

        case '!':
            c = getNextChar(stream);
            if (c == '=') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "!=");
                    return makeToken(tp, c, T_STRICT_NE, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '!');
                return makeToken(tp, '=', T_NE, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '!', T_LOGICAL_NOT, G_OPERATOR);

        case '&':
            c = getNextChar(stream);
            if (c == '&') {
                addCharToToken(tp, '&');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '&');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_AND_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '&', T_LOGICAL_AND, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '&');
                return makeSubToken(tp, c, T_ASSIGN, T_BIT_AND_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '&', T_BIT_AND, G_OPERATOR);

        case '<':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LE, G_OPERATOR);
            } else if (c == '<') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "<<");
                    return makeSubToken(tp, c, T_ASSIGN, T_LSH_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LSH, G_OPERATOR);

            } else if (c == '/') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LT_SLASH, 0);
            }
            putBackChar(stream, c);
            return makeToken(tp, '<', T_LT, G_OPERATOR);

        case '=':
            c = getNextChar(stream);
            if (c == '=') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "==");
                    return makeToken(tp, c, T_STRICT_EQ, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '=');
                return makeToken(tp, c, T_EQ, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '=', T_ASSIGN, G_OPERATOR);

        case '>':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_GE, G_OPERATOR);
            } else if (c == '>') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, ">>");
                    return makeSubToken(tp, c, T_ASSIGN, T_RSH_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                } else if (c == '>') {
                    c = getNextChar(stream);
                    if (c == '=') {
                        addStringToToken(tp, ">>>");
                        return makeSubToken(tp, c, T_ASSIGN, T_RSH_ZERO_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                    }
                    putBackChar(stream, c);
                    addStringToToken(tp, ">>");
                    return makeToken(tp, '>', T_RSH_ZERO, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '>');
                return makeToken(tp, '>', T_RSH, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '>', T_GT, G_OPERATOR);

        case '^':
            c = getNextChar(stream);
            if (c == '^') {
                addCharToToken(tp, '^');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '^');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_XOR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '^', T_LOGICAL_XOR, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '^');
                return makeSubToken(tp, '=', T_ASSIGN, T_BIT_XOR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '^', T_BIT_XOR, G_OPERATOR);

        case '|':
            c = getNextChar(stream);
            if (c == '|') {
                addCharToToken(tp, '|');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '|');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_OR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '|', T_LOGICAL_OR, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '|');
                return makeSubToken(tp, '=', T_ASSIGN, T_BIT_OR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);

            }
            putBackChar(stream, c);
            return makeToken(tp, '|', T_BIT_OR, G_OPERATOR);
        }
    }
}


PUBLIC int ecGetRegExpToken(EcCompiler *cp, wchar *prefix)
{
    EcToken     *token, *tp;
    EcStream    *stream;
    wchar       *pp;
    int         c;

    stream = cp->stream;
    tp = token = cp->token;
    assert(tp != 0);

    initializeToken(tp, stream);

    for (pp = prefix; pp && *pp; pp++) {
        addCharToToken(tp, *pp);
    }
    while (1) {
        c = getNextChar(stream);
        switch (c) {
        case -1:
            return makeToken(tp, 0, T_ERR, 0);

        case 0:
            if (stream->flags & EC_STREAM_EOL) {
                return makeToken(tp, 0, T_NOP, 0);
            }
            return makeToken(tp, 0, T_EOF, 0);

        case '/':
            addCharToToken(tp, '/');
            while (1) {
                c = getNextChar(stream);
                if (c != 'g' && c != 'i' && c != 'm' && c != 'y' && c != 'x' && c != 'X' && c != 'U' && c != 's') {
                    putBackChar(stream, c);
                    break;
                }
                addCharToToken(tp, c);
            }
            return makeToken(tp, 0, T_REGEXP, 0);

        case '\\':
            c = getNextChar(stream);
            if (c == '\r' || c == '\n' || c == 0) {
                ecError(cp, "Warning", &stream->loc, "Illegal newline in regular expression");
                return makeToken(tp, 0, T_ERR, 0);
            }
            addCharToToken(tp, '\\');
            addCharToToken(tp, c);
            break;

        case '\r':
        case '\n':
            ecError(cp, "Warning", &stream->loc, "Illegal newline in regular expression");
            return makeToken(tp, 0, T_ERR, 0);

        default:
            addCharToToken(tp, c);
        }
    }
}


/*
    Put back the current lexer token
 */
PUBLIC int ecPutToken(EcCompiler *cp)
{
    ecPutSpecificToken(cp, cp->token);
    cp->token = 0;
    return 0;
}


/*
    Put the given (specific) token back on the input queue. The current input token is unaffected.
 */
PUBLIC int ecPutSpecificToken(EcCompiler *cp, EcToken *tp)
{
    assert(tp);
    assert(tp->tokenId > 0);

    tp->next = cp->putback;
    cp->putback = tp;
    return 0;
}


PUBLIC EcToken *ecTakeToken(EcCompiler *cp)
{
    EcToken *token;

    token = cp->token;
    cp->token = 0;
    return token;
}


/*
    Hex:        0(x|X)[DIGITS]
    Octal:      0[DIGITS]
    Float:      [DIGITS].[DIGITS][(e|E)[+|-]DIGITS]
 */
static int makeNumberToken(EcCompiler *cp, EcToken *tp, int c)
{
    EcStream    *stream;

    stream = cp->stream;
    if (c == '0') {
        c = getNextChar(stream);
        if (tolower((uchar) c) == 'x') {
            /* Hex */
            addCharToToken(tp, '0');
            do {
                addCharToToken(tp, c);
                c = getNextChar(stream);
            } while (isxdigit(c));
            putBackChar(stream, c);
            setTokenID(tp, T_NUMBER, -1, 0);
            return finalizeToken(tp);

        } else if ('0' <= c && c <= '7') {
            /* Octal */
            addCharToToken(tp, '0');
            do {
                addCharToToken(tp, c);
                c = getNextChar(stream);
            } while ('0' <= c && c <= '7');
            putBackChar(stream, c);
            setTokenID(tp, T_NUMBER, -1, 0);
            return finalizeToken(tp);

        } else {
            putBackChar(stream, c);
            c = '0';
        }
    }

    /*
        Float
     */
    while (isdigit((uchar) c)) {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (c == '.') {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    while (isdigit((uchar) c)) {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (tolower((uchar) c) == 'e') {
        addCharToToken(tp, c);
        c = getNextChar(stream);
        if (c == '+' || c == '-') {
            addCharToToken(tp, c);
            c = getNextChar(stream);
        }
        while (isdigit((uchar) c)) {
            addCharToToken(tp, c);
            c = getNextChar(stream);
        }
    }
    putBackChar(stream, c);
    setTokenID(tp, T_NUMBER, -1, 0);
    return finalizeToken(tp);
}


static int makeAlphaToken(EcCompiler *cp, EcToken *tp, int c)
{
    ReservedWord    *rp;
    EcStream        *stream;

    /*
        We know that c is an alpha already
     */
    stream = cp->stream;

    while (isalnum((uchar) c) || c == '_' || c == '$' || c == '\\') {
        if (c == '\\') {
            c = getNextChar(stream);
            if (c == '\n' || c == '\r') {
                break;
            } else if (c == 'u') {
                c = decodeNumber(cp, 16, 4);
                //  TODO - for now, mask back to 8 bits.
                c = c & 0xff;
            }
        }
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (c) {
        putBackChar(stream, c);
    }
    rp = (ReservedWord*) mprLookupKey(cp->keywords, tp->text);
    if (rp) {
        setTokenID(tp, rp->tokenId, rp->subId, rp->groupMask);
    } else {
        setTokenID(tp, T_ID, -1, 0);
    }
    return finalizeToken(tp);
}


static int makeQuotedToken(EcCompiler *cp, EcToken *tp, int c)
{
    EcStream    *stream;
    int         quoteType;

    stream = cp->stream;
    quoteType = c;

    for (c = getNextChar(stream); c && c != quoteType; c = getNextChar(stream)) {
        if (c == 0) {
            return makeToken(tp, 0, T_ERR, 0);
        }
        if (c == '\\') {
            c = getNextChar(stream);
            switch (c) {
            case '\\':
                break;
            case '\'':
            case '\"':
                break;
            case 'b':
                c = '\b';
                break;
            case 'f':
                c = '\f';
                break;
            case 'n':
                c = '\n';
                break;
            case 'r':
                c = '\r';
                break;
            case 't':
                c = '\t';
                break;
            case 'u':
                c = decodeNumber(cp, 16, 4);
                break;
            case 'x':
                c = decodeNumber(cp, 16, 2);
                break;
            case 'v':
                c = '\v';
                break;
            case '0':
                c = decodeNumber(cp, 8, 3);
                break;
            default:
                break;
            }
        }
        addCharToToken(tp, c);
    }
    assert(tp->text);
    setTokenID(tp, T_STRING, -1, 0);
    return finalizeToken(tp);
}


static int makeToken(EcToken *tp, int c, int tokenId, int groupMask)
{
    if (c && addCharToToken(tp, c) < 0) {
        return T_ERR;
    }
    setTokenID(tp, tokenId, -1, groupMask);
    return finalizeToken(tp);
}


static int makeSubToken(EcToken *tp, int c, int tokenId, int subId, int groupMask)
{
    if (addCharToToken(tp, c) < 0) {
        return T_ERR;
    }
    setTokenID(tp, tokenId, subId, groupMask);
    return finalizeToken(tp);
}


static int decodeNumber(EcCompiler *cp, int radix, int length)
{
    char        buf[16];
    int         i, c, lowerc;

    for (i = 0; i < length; i++) {
        c = getNextChar(cp->stream);
        if (c == 0) {
            break;
        }
        if (radix <= 10) {
            if (!isdigit((uchar) c)) {
                break;
            }
        } else if (radix == 16) {
            lowerc = tolower((uchar) c);
            if (!isdigit((uchar) lowerc) && !('a' <= lowerc && lowerc <= 'f')) {
                break;
            }
        }
        buf[i] = c;
    }
    if (i < length) {
        putBackChar(cp->stream, c);
    }
    buf[i] = '\0';
    return (int) stoiradix(buf, radix, NULL);
}


/*
    C, C++ and doc style comments. Return token or zero for no token.
 */
static int getComment(EcCompiler *cp, EcToken *tp, int c)
{
    EcStream    *stream;
    int         form, startLine;

    startLine = cp->stream->loc.lineNumber;
    stream = cp->stream;
    form = c;

    for (form = c; c > 0;) {
        c = getNextChar(stream);
        if (c <= 0) {
            /*
                Unterminated Comment
             */
            addFormattedStringToToken(tp, "Unterminated comment starting on line %d", startLine);
            makeToken(tp, 0, form == '/' ? T_EOF: T_ERR, 0);
            return 1;
        }
        if (form == '/') {
            if (c == '\n' || c == '\r') {
                break;
            }
        } else {
            if (c == '*') {
                c = getNextChar(stream);
                if (c == '/') {
                    break;
                }
                addCharToToken(tp, '*');
                putBackChar(stream, c);

            } else if (c == '/') {
                c = getNextChar(stream);
                if (c == '*') {
                    /*
                        Nested comment
                     */
                    if (cp->warnLevel > 0) {
                        ecError(cp, "Warning", &stream->loc, "Possible nested comment");
                    }
                }
                addCharToToken(tp, '/');
            }
        }
        addCharToToken(tp, c);
    }
    return 0;
}


static int initializeToken(EcToken *tp, EcStream *stream)
{
    tp->stream = stream;
    tp->loc = tp->stream->loc;
    tp->length = 0;
    tp->loc.lineNumber = 0;
    tp->tokenId = 0;
    if (tp->text == 0) {
        tp->size = EC_TOKEN_INCR;
        if ((tp->text = mprAlloc(tp->size * sizeof(wchar))) == 0) {
            return MPR_ERR_MEMORY;
        }
        tp->text[0] = '\0';
    }
    return 0;
}


static int finalizeToken(EcToken *tp)
{
    if (tp->loc.lineNumber == 0) {
        tp->loc = tp->stream->loc;
    }
    return tp->tokenId;
}


static int addCharToToken(EcToken *tp, int c)
{
    if (tp->length >= (tp->size - 1)) {
        tp->size += EC_TOKEN_INCR;
        if ((tp->text = mprRealloc(tp->text, tp->size * sizeof(wchar))) == 0) {
            return MPR_ERR_MEMORY;
        }
    }
    tp->text[tp->length++] = c;
    tp->text[tp->length] = '\0';
    if (tp->loc.lineNumber == 0) {
        tp->loc = tp->stream->loc;
    }
    return 0;
}


static int addStringToToken(EcToken *tp, char *str)
{
    char    *cp;

    for (cp = str; *cp; cp++) {
        if (addCharToToken(tp, *cp) < 0) {
            return MPR_ERR_MEMORY;
        }
    }
    return 0;
}


static int addFormattedStringToToken(EcToken *tp, char *fmt, ...)
{
    va_list     args;
    char        *buf;

    va_start(args, fmt);
    buf = sfmtv(fmt, args);
    addStringToToken(tp, buf);
    va_end(args);
    return 0;
}


static int setTokenID(EcToken *tp, int tokenId, int subId, int groupMask)
{
    assert(tp);

    tp->tokenId = tokenId;
    tp->subId = subId;
    tp->groupMask = groupMask;
    return tokenId;
}


static int getNextChar(EcStream *stream)
{
    wchar       c, *next, *start;

    if (stream->nextChar >= stream->end && stream->getInput) {
        if (stream->getInput(stream) < 0) {
            return 0;
        }
    }
    if (stream->nextChar < stream->end) {
        c = *stream->nextChar++;
        if (c == '\n') {
            stream->lastLoc = stream->loc;
            stream->loc.lineNumber++;
            stream->loc.column = 0;
            stream->loc.source = 0;
        } else {
            stream->loc.column++;
        }
        if (stream->loc.source == 0) {
            for (start = stream->nextChar - 1; isspace((uchar) *start); start++) ;
            for (next = start; *next && *next != '\n'; next++) ;
            stream->loc.source = wsub(start, 0, next - start);
        }
        return c;
    }
    return 0;
}


static void putBackChar(EcStream *stream, int c)
{
    if (stream->buf < stream->nextChar && c) {
        stream->nextChar--;
        assert(c == (int) *stream->nextChar);
        if (c == '\n') {
            stream->loc = stream->lastLoc;
            stream->loc.column = 0;
        } else {
            stream->loc.column--;
        }
        assert(stream->loc.column >= 0);
    }
}


PUBLIC void ecManageStream(EcStream *sp, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        ecMarkLocation(&sp->loc);
        ecMarkLocation(&sp->lastLoc);
        mprMark(sp->buf);
    }
}


PUBLIC void *ecCreateStream(EcCompiler *cp, ssize size, cchar *path, void *manager)
{
    EcLocation  *loc;
    EcStream    *sp;

    if ((sp = mprAllocBlock(size, MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        return NULL;
    }
    mprSetManager(sp, manager);
    sp->compiler = cp;
    cp->stream = sp;
    loc = &sp->loc;
    loc->column = 0;
    loc->source = 0;
    loc->lineNumber = 1;
    loc->filename = sclone(path);
    cp->putback = NULL;
    return sp;
}


PUBLIC void ecSetStreamBuf(EcStream *sp, cchar *contents, ssize len)
{
    wchar       *buf;

    if (contents) {
#if ME_CHAR_LEN > 1
        buf = amtow(cp, contents, &len);
#else
        buf = (wchar*) contents;
        if (len <= 0) {
            len = strlen(buf);
        }
#endif
        sp->buf = buf;
        sp->nextChar = buf;
        sp->end = &buf[len];
        putBackChar(sp, getNextChar(sp));
    }
}


PUBLIC void manageFileStream(EcFileStream *fs, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        ecManageStream((EcStream*) fs, flags);
        mprMark(fs->file);

    } else if (flags & MPR_MANAGE_FREE) {
        mprCloseFile(fs->file);
    }
}


PUBLIC int ecOpenFileStream(EcCompiler *cp, cchar *path)
{
    EcFileStream    *fs;
    MprPath         info;
    char            *contents;

    if ((fs = ecCreateStream(cp, sizeof(EcFileStream), path, manageFileStream)) == 0) {
        return MPR_ERR_MEMORY;
    }
    if ((fs->file = mprOpenFile(path, O_RDONLY | O_BINARY, 0666)) == 0) {
        return MPR_ERR_CANT_OPEN;
    }
    if (mprGetPathInfo(path, &info) < 0 || info.size < 0) {
        mprCloseFile(fs->file);
        return MPR_ERR_CANT_ACCESS;
    }
    if ((contents = mprAlloc((int) info.size + 1)) == 0) {
        mprCloseFile(fs->file);
        return MPR_ERR_MEMORY;
    }
    if (mprReadFile(fs->file, contents, (int) info.size) != (int) info.size) {
        mprCloseFile(fs->file);
        return MPR_ERR_CANT_READ;
    }
    contents[info.size] = '\0';
    ecSetStreamBuf((EcStream*) fs, contents, (ssize) info.size);
    mprCloseFile(fs->file);
    fs->file = 0;
    return 0;
}


PUBLIC int ecOpenMemoryStream(EcCompiler *cp, cchar *contents, ssize len)
{
    EcMemStream     *ms;

    if ((ms = ecCreateStream(cp, sizeof(EcMemStream), "memory", ecManageStream)) == 0) {
        return MPR_ERR_MEMORY;
    }
    ecSetStreamBuf((EcStream*) ms, contents, len);
    return 0;
}


PUBLIC int ecOpenConsoleStream(EcCompiler *cp, EcStreamGet getInput, cchar *contents)
{
    EcConsoleStream     *cs;

    if ((cs = ecCreateStream(cp, sizeof(EcConsoleStream), "console", ecManageStream)) == 0) {
        return MPR_ERR_MEMORY;
    }
    cs->stream.getInput = getInput;
    ecSetStreamBuf((EcStream*) cs, sclone(contents), contents ? strlen(contents) : 0);
    return 0;
}


PUBLIC void ecCloseStream(EcCompiler *cp)
{
    cp->stream = 0;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/compiler/ecModuleWrite.c"
 */
/************************************************************************/

/**
    ejsModuleWrite.c - Routines to encode and emit Ejscript byte code.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/****************************** Forward Declarations **************************/

static void createBlockSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsBlock *vp);
static void createClassSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsPot *klass);
static void createDebugSection(EcCompiler *cp, EjsFunction *fun);
static void createDependencySection(EcCompiler *cp);
static void createDocSection(EcCompiler *cp, cchar *tag, EjsPot *block, int slotNum);
static void createExceptionSection(EcCompiler *cp, EjsFunction *mp);
static void createFunctionSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsFunction *fun, int isSetter);
static void createGlobalProperties(EcCompiler *cp);
static void createGlobalType(EcCompiler *cp, EjsType *klass);
static void createPropertySection(EcCompiler *cp, EjsPot *block, int slotNum, EjsObj *vp);
static void createSection(EcCompiler *cp, EjsPot *block, int slotNum);
static int reserveRoom(EcCompiler *cp, int room);

static int sumNum(int value);
static int sumString(EjsString *name);

/*********************************** Code *************************************/
/*
    Write out the module file header
 */
PUBLIC int ecCreateModuleHeader(EcCompiler *cp)
{
    EjsModuleHdr    hdr;

    memset(&hdr, 0, sizeof(hdr));
    hdr.magic = ejsSwapInt32(cp->ejs, EJS_MODULE_MAGIC);
    hdr.fileVersion = ejsSwapInt32(cp->ejs, EJS_MODULE_VERSION);
    ecEncodeBlock(cp, (uchar*) &hdr, sizeof(hdr));
    return (cp->fatalError) ? EJS_ERR : 0;
}


/*
    Create a module section. This writes all classes, functions, variables and blocks contained by the module.
 */
PUBLIC int ecCreateModuleSection(EcCompiler *cp)
{
    EjsConstants    *constants;
    EjsModule       *mp;
    EcState         *state;
    MprBuf          *buf;
    int             checksumOffset;

    state = cp->state;
    buf = state->code->buf;
    mp = state->currentModule;
    constants = mp->constants;

    mprTrace(7, "Create module section %s", mp->name);

    ecEncodeByte(cp, EJS_SECT_MODULE);
    ecEncodeConst(cp, mp->name);
    ecEncodeNum(cp, mp->version);

    /*
        Remember this location for the module checksum. Reserve 4 bytes.
     */
    checksumOffset = (int) (mprGetBufEnd(buf) - buf->data);
    ecEncodeInt32(cp, 0);

    /*
        Write the constant pool and lock it against further updates.
     */
    mp->constants->locked = 1;
    ecEncodeNum(cp, constants->poolLength);
    ecEncodeNum(cp, constants->indexCount);
    ecEncodeBlock(cp, (uchar*) constants->pool, (int) constants->poolLength);

    createDependencySection(cp);
    if (mp->hasInitializer) {
        createFunctionSection(cp, NULL, -1, mp->initializer, 0);
    }
    createGlobalProperties(cp);
    ecEncodeByte(cp, EJS_SECT_MODULE_END);

    if (cp->fatalError) {
        return MPR_ERR_CANT_WRITE;
    }
    mp->checksum += (sumString(mp->name) & EJS_ENCODE_MAX_WORD);
    ecEncodeInt32AtPos(cp, checksumOffset, mp->checksum);
    return 0;
}


static void createDependencySection(EcCompiler *cp)
{
    EjsModule   *module, *mp;
    int         i, count, version;

    mp = cp->state->currentModule;
    assert(mp);

    /*
        If merging, don't need references to dependent modules as they are aggregated onto the output
     */
    if (mp->dependencies && !cp->merge) {
        count = mprGetListLength(mp->dependencies);
        for (i = 0; i < count; i++) {
            module = (EjsModule*) mprGetItem(mp->dependencies, i);

            if (module->compiling && cp->outputFile) {
                continue;
            }
            if (mp->name == module->name) {
                /* A module can't depend on itself */
                continue;
            }
            ecEncodeByte(cp, EJS_SECT_DEPENDENCY);
            ecEncodeConst(cp, module->name);
            ecEncodeNum(cp, module->checksum);

            if (!cp->bind) {
                ecEncodeNum(cp, module->minVersion);
                ecEncodeNum(cp, module->maxVersion);
            } else {
                version = EJS_MAKE_COMPAT_VERSION(module->version);
                ecEncodeNum(cp, version);
                ecEncodeNum(cp, version);
            }
            if (cp->fatalError) {
                return;
            }
            mp->checksum += sumString(module->name);
            mprTrace(7, "    dependency section for %s from module %s", module->name, mp->name);
        }
    }
}


/*
    Emit all global classes, functions, variables and blocks.
 */
static void createGlobalProperties(EcCompiler *cp)
{
    Ejs             *ejs;
    EjsName         *prop;
    EjsModule       *mp;
    EjsObj          *vp;
    int             next, slotNum;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    if (mp->globalProperties == 0) {
        return;
    }
    for (next = 0; (prop = (EjsName*) mprGetNextItem(mp->globalProperties, &next)) != 0; ) {
        slotNum = ejsLookupProperty(ejs, ejs->global, *prop);
        if (slotNum < 0) {
            cp->fatalError = 1;
            mprError("Code generation error. Cannot find global property %s.", prop->name);
            return;
        }
        vp = ejsGetProperty(ejs, ejs->global, slotNum);
        if (VISITED(vp)) {
            continue;
        }
        if (ejsIsType(ejs, vp)) {
            createGlobalType(cp, (EjsType*) vp);
        } else {
            createSection(cp, ejs->global, slotNum);
        }
    }
    for (next = 0; (prop = (EjsName*) mprGetNextItem(mp->globalProperties, &next)) != 0; ) {
        slotNum = ejsLookupProperty(ejs, ejs->global, *prop);
        vp = ejsGetProperty(ejs, ejs->global, slotNum);
        SET_VISITED(vp, 0);
    }
}


/*
    Recursively emit a class and its base classes
 */
static void createGlobalType(EcCompiler *cp, EjsType *type)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsType         *iface;
    int             next, slotNum;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    if (VISITED(type) || type->module != mp) {
        return;
    }
    SET_VISITED(type, 1);

    if (type->baseType && !VISITED(type->baseType)) {
        createGlobalType(cp, type->baseType);
    }
    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            createGlobalType(cp, iface);
        }
    }
    slotNum = ejsLookupProperty(ejs, ejs->global, type->qname);
    assert(slotNum >= 0);

    createSection(cp, ejs->global, slotNum);
}


static void createSection(EcCompiler *cp, EjsPot *block, int slotNum)
{
    Ejs         *ejs;
    EjsTrait    *trait;
    EjsName     qname;
    EjsFunction *fun;
    EjsObj      *vp;

    ejs = cp->ejs;
    vp = ejsGetProperty(ejs, block, slotNum);
    qname = ejsGetPropertyName(ejs, block, slotNum);
    trait = ejsGetPropertyTraits(ejs, block, slotNum);

    /*
        hoistBlockVar will delete hoisted properties but will not (yet) compact to reclaim the slot.
     */
    if (slotNum < 0 || trait == 0 || vp == 0 || qname.name->value[0] == '\0') {
        return;
    }
    assert(qname.name);

    if (ejsIsType(ejs, vp)) {
        createClassSection(cp, block, slotNum, (EjsPot*) vp);

    } else if (ejsIsFunction(ejs, vp)) {
        fun = (EjsFunction*) vp;
        createFunctionSection(cp, block, slotNum, fun, 0);
        if (trait->attributes & EJS_TRAIT_SETTER) {
            assert(fun->setter);
            createFunctionSection(cp, block, slotNum, fun->setter, 1);
        }

    } else if (ejsIsBlock(ejs, vp)) {
        createBlockSection(cp, block, slotNum, (EjsBlock*) vp);

    } else {
        createPropertySection(cp, block, slotNum, vp);
    }
}


/*
    Create a type section in the module file.
 */
static void createClassSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsPot *klass)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsType         *type, *iface;
    EjsPot          *prototype;
    EjsTrait        *trait;
    EjsName         qname;
    int             next, attributes, interfaceCount, instanceTraits, count;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    createDocSection(cp, "class", ejs->global, slotNum);
    qname = ejsGetPropertyName(ejs, ejs->global, slotNum);
    assert(qname.name);

    mprTrace(7, "    type section %@ for module %@", qname.name, mp->name);
    
    type = ejsGetProperty(ejs, ejs->global, slotNum);
    assert(type);
    assert(ejsIsType(ejs, type));

    ecEncodeByte(cp, EJS_SECT_CLASS);
    ecEncodeConst(cp, qname.name);
    ecEncodeConst(cp, qname.space);

    trait = ejsGetPropertyTraits(ejs, ejs->global, slotNum);
    attributes = (trait) ? trait->attributes : 0;
    attributes &= ~EJS_TYPE_FIXUP;

    if (type->hasConstructor) {
        attributes |= EJS_TYPE_HAS_CONSTRUCTOR;
    }
    if (type->hasInitializer) {
        attributes |= EJS_TYPE_HAS_TYPE_INITIALIZER;
    }
    if (type->hasInstanceVars) {
        attributes |= EJS_TYPE_HAS_INSTANCE_VARS;
    }
    if (type->callsSuper) {
        attributes |= EJS_TYPE_CALLS_SUPER;
    }
    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            if (!iface->isInterface) {
                attributes |= EJS_TYPE_FIXUP;
                break;
            }
        }
    }
    ecEncodeNum(cp, attributes);
    ecEncodeNum(cp, (cp->bind) ? slotNum : -1);

    assert(type != type->baseType);
    if (type->baseType) {
        ecEncodeGlobal(cp, (EjsObj*) type->baseType, type->baseType->qname);
    } else {
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
    }
    ecEncodeNum(cp, ejsGetLength(ejs, (EjsObj*) type));

    instanceTraits = ejsGetLength(ejs, (EjsObj*) type->prototype);
    assert(instanceTraits >= 0);
    ecEncodeNum(cp, instanceTraits);
    
    interfaceCount = (type->implements) ? mprGetListLength(type->implements) : 00;
    assert(interfaceCount >= 0);
    ecEncodeNum(cp, interfaceCount);

    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            ecEncodeGlobal(cp, (EjsObj*) iface, iface->qname);
        }
    }
    if (cp->fatalError) {
        return;
    }    
    if (type->hasConstructor) {
        assert(type->constructor.isConstructor);
        assert(type->constructor.block.pot.isFunction);
        createFunctionSection(cp, block, slotNum, (EjsFunction*) type, 0);
    }
    /*
        Loop over type traits
     */
    count = ejsGetLength(ejs, type); 
    for (slotNum = 0; slotNum < count; slotNum++) {
        createSection(cp, (EjsPot*) type, slotNum);
    }
    /*
        Loop over prototype (instance) properties.
     */
    prototype = type->prototype;
    if (prototype) {
        count = ejsGetLength(ejs, prototype);
        for (slotNum = 0; slotNum < count; slotNum++) {
            trait = ejsGetPropertyTraits(ejs, prototype, slotNum);
            if (slotNum < type->numInherited) {
                if (trait && !(trait->attributes & EJS_FUN_OVERRIDE)) {
                    continue;
                }
            }
            createSection(cp, prototype, slotNum);
        }
    }
    mp->checksum += sumNum(ejsGetLength(ejs, type) + instanceTraits + interfaceCount);
    mp->checksum += sumString(type->qname.name);
    ecEncodeByte(cp, EJS_SECT_CLASS_END);
}


/*
    NOTE: static methods and methods are both stored in the typeTraits.
    The difference is in how the methods are called by the VM op codes.
 */
static void createFunctionSection(EcCompiler *cp, EjsPot *block, int slotNum, EjsFunction *fun, int isSetter)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsTrait        *trait;
    EjsName         qname;
    EjsCode         *code;
    EjsType         *resultType;
    EjsPot          *activation;
    int             i, attributes, numProp;

    assert(fun);

    mp = cp->state->currentModule;
    ejs = cp->ejs;
    activation = fun->activation;
    numProp = (activation) ? activation->numProp: 0;
    code = fun->body.code;
    
    if (block && slotNum >= 0) {
        qname = ejsGetPropertyName(ejs, block, slotNum);
        createDocSection(cp, "fun", block, slotNum);
        trait = ejsGetPropertyTraits(ejs, block, slotNum);
        attributes = trait->attributes;
        if (fun->isInitializer) {
            attributes |= EJS_FUN_INITIALIZER;
        }
        if (fun->moduleInitializer) {
            attributes |= EJS_FUN_MODULE_INITIALIZER;
        }
        if (trait->attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER)) {
            if (isSetter) {
                attributes &= ~EJS_TRAIT_GETTER;
            } else {
                attributes &= ~EJS_TRAIT_SETTER;
            }
        }
    } else {
        attributes = EJS_FUN_MODULE_INITIALIZER;
        qname = N(EJS_EJS_NAMESPACE, EJS_INITIALIZER_NAME);
    }
    if (fun->isConstructor) {
        assert(fun->block.pot.isFunction);
        attributes |= EJS_FUN_CONSTRUCTOR;
    }
    if (fun->rest) {
        attributes |= EJS_FUN_REST_ARGS;
    }
    if (fun->fullScope) {
        attributes |= EJS_FUN_FULL_SCOPE;
    }
    if (fun->hasReturn) {
        attributes |= EJS_FUN_HAS_RETURN;
    }
    resultType = fun->resultType;

    ecEncodeByte(cp, EJS_SECT_FUNCTION);
    ecEncodeConst(cp, qname.name);
    ecEncodeConst(cp, qname.space);
    ecEncodeNum(cp, attributes);
    ecEncodeByte(cp, fun->strict);
    if (resultType) {
        ecEncodeGlobal(cp, resultType, resultType->qname);
    } else {
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
    }
    ecEncodeNum(cp, (cp->bind || (block != ejs->global)) ? slotNum: -1);
    ecEncodeNum(cp, numProp);
    ecEncodeNum(cp, fun->numArgs);
    ecEncodeNum(cp, fun->numDefault);

    if (code) {
        assert(code->codeLen > 0);
        ecEncodeNum(cp, code->numHandlers);
        ecEncodeNum(cp, code->codeLen);
        ecEncodeBlock(cp, code->byteCode, code->codeLen);
        if (code->numHandlers > 0) {
            createExceptionSection(cp, fun);
        }
        if (code->debug) {
            createDebugSection(cp, fun);
        }
    } else {
        ecEncodeNum(cp, 0);
        ecEncodeNum(cp, 0);
    }
    /*
        Recursively write args, locals and any nested functions and blocks.
     */
    attributes = 0;
    for (i = 0; i < numProp; i++) {
        createSection(cp, activation, i);
    }
    ecEncodeByte(cp, EJS_SECT_FUNCTION_END);
    mp->checksum += sumNum(fun->numArgs + numProp - fun->numArgs);
    if (code && code->numHandlers) {
        mp->checksum += sumNum(code->numHandlers);
    }
    if (ejsContainsAsc(ejs, qname.name, "--fun_") >= 0) {
        /* Don't sum the name for dynamic functions */
    } else {
        mp->checksum += sumString(qname.name);
    }
}


/*
    NOTE: static methods and methods are both stored in the typeTraits.
    The difference is in how the methods are called by the VM op codes.
 */
static void createExceptionSection(EcCompiler *cp, EjsFunction *fun)
{
    EjsEx       *ex;
    EjsCode     *code;
    int         i;

    assert(fun);

    code = fun->body.code;
    ecEncodeByte(cp, EJS_SECT_EXCEPTION);

    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        ecEncodeByte(cp, ex->flags);
        ecEncodeNum(cp, ex->tryStart);
        ecEncodeNum(cp, ex->tryEnd);
        ecEncodeNum(cp, ex->handlerStart);
        ecEncodeNum(cp, ex->handlerEnd);
        ecEncodeNum(cp, ex->numBlocks);
        ecEncodeNum(cp, ex->numStack);
        if (ex->catchType) {
            ecEncodeGlobal(cp, ex->catchType, ex->catchType->qname);
        } else {
            ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
        }
    }
}


static void createDebugSection(EcCompiler *cp, EjsFunction *fun)
{
    EjsDebug    *debug;
    EjsLine     *line;
    int         i, patchSizeOffset, startDebug;

    assert(fun);
    debug = fun->body.code->debug;

    ecEncodeByte(cp, EJS_SECT_DEBUG);
    patchSizeOffset = ecGetCodeOffset(cp);
    ecEncodeInt32(cp, 0);

    startDebug = ecGetCodeOffset(cp);
    ecEncodeNum(cp, debug->numLines);
    for (i = 0; i < debug->numLines; i++) {
        line = &debug->lines[i];
        ecEncodeNum(cp, line->offset);
        ecEncodeWideAsMulti(cp, line->source);
    }
    ecEncodeInt32AtPos(cp, patchSizeOffset, ecGetCodeOffset(cp) - startDebug);
}


static void createBlockSection(EcCompiler *cp, EjsPot *parent, int slotNum, EjsBlock *block)
{
    Ejs             *ejs;
    EjsName         qname;
    int             i;

    ejs = cp->ejs;
    ecEncodeByte(cp, EJS_SECT_BLOCK);
    qname = ejsGetPropertyName(ejs, parent, slotNum);
    ecEncodeConst(cp, qname.name);
    ecEncodeNum(cp, (cp->bind || (block != ejs->global)) ? slotNum : -1);
    ecEncodeNum(cp, block->pot.numProp);

    /*
        Now emit all the properties
     */
    for (i = 0; i < block->pot.numProp; i++) {
        createSection(cp, (EjsPot*) block, i);
    }
    ecEncodeByte(cp, EJS_SECT_BLOCK_END);
}


static void createPropertySection(EcCompiler *cp, EjsPot *block, int slotNum, EjsObj *vp)
{
    Ejs         *ejs;
    EjsTrait    *trait;
    EjsName     qname;
    EjsModule   *mp;
    int         attributes;

    ejs = cp->ejs;
    mp = cp->state->currentModule;
    qname = ejsGetPropertyName(ejs, block, slotNum);
    
    createDocSection(cp, "var", block, slotNum);

    assert(qname.name->value[0] != '\0');
    trait = ejsGetPropertyTraits(ejs, block, slotNum);
    attributes = trait->attributes;

    mprTrace(7, "    global property section %@", qname.name);

    if (trait->type) {
        if (trait->type == EST(Namespace) || (!ejs->initialized && trait->type->qname.name == EST(Namespace)->qname.name)){
            attributes |= EJS_PROP_HAS_VALUE;
        }
    }
    ecEncodeByte(cp, EJS_SECT_PROPERTY);
    ecEncodeName(cp, qname);

    ecEncodeNum(cp, attributes);
    ecEncodeNum(cp, (cp->bind || (block != ejs->global)) ? slotNum : -1);
    if (trait->type) {
        ecEncodeGlobal(cp, trait->type, trait->type->qname);
    } else {
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
    }

    if (attributes & EJS_PROP_HAS_VALUE) {
        if (vp && ejsIs(ejs, vp, Namespace)) {
            ecEncodeConst(cp, ((EjsNamespace*) vp)->value);
        } else {
            ecEncodeConst(cp, 0);
        }
    }
    mp->checksum += sumString(qname.name);
}


static void createDocSection(EcCompiler *cp, cchar *tag, EjsPot *block, int slotNum)
{
    Ejs         *ejs;
    EjsDoc      *doc;
    char        key[32];

    ejs = cp->ejs;
    assert(slotNum >= 0);
    
    if (!(ejs->flags & EJS_FLAG_DOC)) {
        return;
    }
    if (ejs->doc == 0) {
        ejs->doc = mprCreateHash(EJS_DOC_HASH_SIZE, 0);
    }
    fmt(key, sizeof(key), "%s %Lx %d", tag, PTOL(block), slotNum);
    if ((doc = mprLookupKey(ejs->doc, key)) == 0) {
        return;
    }
    ecEncodeByte(cp, EJS_SECT_DOC);
    ecEncodeConst(cp, doc->docString);
}


/****************************** Constant Management ***************************/
/*
    Add a constant to the constant pool. Grow if required and return the
    constant string offset into the pool.
 */
PUBLIC int ecAddStringConstant(EcCompiler *cp, EjsString *sp)
{
    Ejs     *ejs;
    int     offset;

    ejs = cp->ejs;
    if (sp == 0) {
        sp = ESV(empty);
    }
    offset = ecAddModuleConstant(cp, cp->state->currentModule, ejsToMulti(cp->ejs, sp));
    if (offset < 0) {
        cp->fatalError = 1;
        assert(offset > 0);
        return EJS_ERR;
    }
    return offset;
}


PUBLIC int ecAddCStringConstant(EcCompiler *cp, cchar *str)
{
    int    offset;

    if (str == 0) {
        str = "";
    }
    offset = ecAddModuleConstant(cp, cp->state->currentModule, str);
    if (offset < 0) {
        cp->fatalError = 1;
        assert(offset > 0);
        return EJS_ERR;
    }
    return offset;
}


PUBLIC int ecAddNameConstant(EcCompiler *cp, EjsName qname)
{
    if (ecAddStringConstant(cp, qname.name) < 0 || ecAddStringConstant(cp, qname.space) < 0) {
        return EJS_ERR;
    }
    return 0;
}


PUBLIC void ecAddFunctionConstants(EcCompiler *cp, EjsPot *obj, int slotNum)
{
    EjsFunction     *fun;

    fun = ejsGetProperty(cp->ejs, obj, slotNum);
    if (fun->resultType) {
        ecAddNameConstant(cp, fun->resultType->qname);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, "fun", obj, slotNum);
    }
    ecAddConstants(cp, fun);
    if (fun->activation) {
        ecAddConstants(cp, fun->activation);
    }
}


PUBLIC void ecAddConstants(EcCompiler *cp, EjsAny *block)
{
    Ejs         *ejs;
    EjsName     qname;
    EjsTrait    *trait;
    EjsObj      *vp;
    int         i, numTraits;

    ejs = cp->ejs;
    
    if (VISITED(block)) {
        return;
    }
    SET_VISITED(block, 1);

    numTraits = ejsGetLength(ejs, block);
    for (i = 0; i < numTraits; i++) {
        qname = ejsGetPropertyName(ejs, block, i);
        ecAddNameConstant(cp, qname);
        trait = ejsGetPropertyTraits(ejs, block, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, trait->type->qname);
        }
        vp = ejsGetProperty(ejs, block, i);
        if (vp != block) {
            if (ejsIsFunction(ejs, vp)) {
                ecAddFunctionConstants(cp, block, i);
            } else if (ejsIsBlock(ejs, vp)) {
                ecAddConstants(cp, vp);
            }
        }
    }
    SET_VISITED(block, 0);
}


PUBLIC int ecAddDocConstant(EcCompiler *cp, cchar *tag, void *vp, int slotNum)
{
    Ejs         *ejs;
    EjsDoc      *doc;
    char        key[32];

    ejs = cp->ejs;

    assert(ejs->doc);
    assert(vp);
    assert(slotNum >= 0);

    fmt(key, sizeof(key), "%s %Lx %d", tag, PTOL(vp), slotNum);
    doc = (EjsDoc*) mprLookupKey(ejs->doc, key);
    if (doc && doc->docString) {
        if (ecAddStringConstant(cp, doc->docString) < 0) {
            assert(0);
            return EJS_ERR;
        }
    }
    return 0;
}


/*
    Add a constant and encode the offset.
 */
PUBLIC int ecAddModuleConstant(EcCompiler *cp, EjsModule *mp, cchar *str)
{
    EjsConstants    *constants;
    MprKey          *kp;
    int             index;

    assert(mp);

    if (str == 0) {
        assert(0);
        return 0;
    }
    constants = mp->constants;
    if (constants->table && (kp = mprLookupKeyEntry(constants->table, str)) != 0) {
        return PTOI(kp->data);
    }
    index = ejsAddConstant(cp->ejs, mp, str);
    // mprTrace(0, "%6d %s", index, str);
    mprAddKey(constants->table, str, ITOP(index));
    return index;
}


/****************************** Value Emitters ********************************/
/*
    Emit an encoded string ored with flags. The name index is shifted by 2.
 */
static void encodeTypeName(EcCompiler *cp, EjsString *name, int flags)
{
    int        offset;

    assert(name);

    offset = ecAddModuleConstant(cp, cp->state->currentModule, ejsToMulti(cp->ejs, name));
    if (offset < 0) {
        cp->fatalError = 1;
        assert(offset > 0);
    } else {
        ecEncodeNum(cp, offset << 2 | flags);
    }
}


/*
    Encode a global variable (usually a type). The encoding is untyped: 0, bound type: slot number, unbound or 
    unresolved type: name.
 */
PUBLIC void ecEncodeGlobal(EcCompiler *cp, EjsAny *obj, EjsName qname)
{
    Ejs         *ejs;
    int         slotNum;

    ejs = cp->ejs;
    slotNum = -1;

    if (obj == 0) {
        assert(0);
        ecEncodeNum(cp, EJS_ENCODE_GLOBAL_NOREF);
        return;
    }
    /*
        If binding globals, we can encode the slot number of the type.
     */
    slotNum = ejsLookupProperty(ejs, ejs->global, qname);

    //  TODO - don't bind for Appweb all-in-one. ejs.web can load at different places 
    if (slotNum < ES_global_NUM_CLASS_PROP /* || cp->bind */) {
        if (slotNum >= 0) {
            ecEncodeNum(cp, (slotNum << 2) | EJS_ENCODE_GLOBAL_SLOT);
            return;
        }
    }
    encodeTypeName(cp, qname.name, EJS_ENCODE_GLOBAL_NAME);
    ecEncodeConst(cp, qname.space);
}


/**************************** Value Encoding Routines *************************/
/*
    Reserve a small amount of room sufficient for the next encoding
 */
static int reserveRoom(EcCompiler *cp, int room)
{
    EcCodeGen       *code;

    code = cp->state->code;
    assert(code);

    if (mprGetBufSpace(code->buf) < room) {
        if (mprGrowBuf(code->buf, -1) < 0) {
            cp->fatalError = 1;
            assert(0);
            return MPR_ERR_MEMORY;
        }
    }
    return 0;
}


/*
    Encode an Ejscript instruction operation code
 */
PUBLIC void ecEncodeOpcode(EcCompiler *cp, int code)
{
    assert(code < 240);
    assert(cp);

    cp->lastOpcode = code;
    ecEncodeByte(cp, code);
}


/*
    Encode a <name><namespace> pair
 */
PUBLIC void ecEncodeName(EcCompiler *cp, EjsName qname)
{
    assert(qname.name);

    ecEncodeConst(cp, qname.name);
    ecEncodeConst(cp, qname.space);
}


PUBLIC void ecEncodeConst(EcCompiler *cp, EjsString *sp)
{
    Ejs     *ejs;
    cchar   *str;
    int     offset;

    assert(cp);
    ejs = cp->ejs;

    if (sp == 0) {
        sp = ESV(empty);
    }
    str = ejsToMulti(cp->ejs, sp);
    offset = ecAddModuleConstant(cp, cp->state->currentModule, str);
    if (offset < 0) {
        cp->error = 1;
        cp->fatalError = 1;
        return;
    }
    assert(offset >= 0);
    ecEncodeNum(cp, offset);
}


PUBLIC void ecEncodeByte(EcCompiler *cp, int value)
{
    EcCodeGen   *code;
    uchar       *pc;

    assert(cp);
    code = cp->state->code;

    if (reserveRoom(cp, sizeof(uchar)) < 0) {
        return;
    }
    pc = (uchar*) mprGetBufEnd(code->buf);
    *pc++ = value;
    mprAdjustBufEnd(code->buf, sizeof(uchar));
}


PUBLIC void ecEncodeMulti(EcCompiler *cp, cchar *str)
{
    int    len;

    assert(cp);

    len = (int) strlen(str) + 1;
    assert(len > 0);
    ecEncodeNum(cp, len);
    ecEncodeBlock(cp, (uchar*) str, len);
}


PUBLIC void ecEncodeWideAsMulti(EcCompiler *cp, wchar *str)
{
    char    *mstr;
    ssize   len;

    assert(cp);

    mstr = awtom(str, &len);
    //  UNICODE - why calculate len again?
    len = strlen(mstr) + 1;
    assert(len > 0);
    ecEncodeNum(cp, (int) len);
    ecEncodeBlock(cp, (uchar*) str, (int) len);
}


PUBLIC void ecEncodeNum(EcCompiler *cp, int64 number)
{
    MprBuf      *buf;
    int         len;

    assert(cp);
    buf = cp->state->code->buf;
    if (reserveRoom(cp, sizeof(int64) + 2) < 0) {
        return;
    }
    len = ejsEncodeNum(cp->ejs, (uchar*) mprGetBufEnd(buf), number);
    mprAdjustBufEnd(buf, len);
}


PUBLIC void ecEncodeDouble(EcCompiler *cp, double value)
{
    MprBuf      *buf;
    int         len;

    assert(cp);
    buf = cp->state->code->buf;
    if (reserveRoom(cp, sizeof(double) + 4) < 0) {
        return;
    }
    len = ejsEncodeDouble(cp->ejs, (uchar*) mprGetBufEnd(buf), value);
    mprAdjustBufEnd(buf, len);
}


/*
    Encode a 32-bit number. Always emit exactly 4 bytes.
 */
PUBLIC void ecEncodeInt32(EcCompiler *cp, int number)
{
    MprBuf      *buf;
    int         len;

    assert(cp);
    buf = cp->state->code->buf;

    if (reserveRoom(cp, sizeof(int) / sizeof(char)) < 0) {
        return;
    }
    len = ejsEncodeInt32(cp->ejs, (uchar*) mprGetBufEnd(buf), number);
    assert(len == 4);
    mprAdjustBufEnd(buf, len);
}


PUBLIC void ecEncodeByteAtPos(EcCompiler *cp, int offset, int value)
{
    ejsEncodeByteAtPos(cp->ejs, (uchar*) mprGetBufStart(cp->state->code->buf) + offset, value);
}


PUBLIC void ecEncodeInt32AtPos(EcCompiler *cp, int offset, int value)
{
    if (abs(value) > EJS_ENCODE_MAX_WORD) {
        mprError("Code generation error. Word %d exceeds maximum %d", value, EJS_ENCODE_MAX_WORD);
        cp->fatalError = 1;
        return;
    }
    ejsEncodeInt32AtPos(cp->ejs, (uchar*) mprGetBufStart(cp->state->code->buf) + offset, value);
}


PUBLIC void ecEncodeBlock(EcCompiler *cp, cuchar *buf, int len)
{
    EcCodeGen   *code;

    code = cp->state->code;

    if (reserveRoom(cp, len) < 0) {
        return;
    }
    if (mprPutBlockToBuf(code->buf, (char*) buf, len) != len) {
        cp->fatalError = 1;
    }
}


uint ecGetCodeOffset(EcCompiler *cp)
{
    EcCodeGen   *code;

    code = cp->state->code;
    return (uint) ((uchar*) mprGetBufEnd(code->buf) - (uchar*) mprGetBufStart(code->buf));
}


PUBLIC int ecGetCodeLen(EcCompiler *cp, uchar *mark)
{
    EcCodeGen   *code;

    code = cp->state->code;
    return (int) (((uchar*) mprGetBufEnd(code->buf)) - mark);
}


/*
    Copy the code at "pos" of length "size" the distance specified by "dist". Dist may be postitive or negative.
 */
PUBLIC void ecCopyCode(EcCompiler *cp, uchar *pos, int size, int dist)
{
    mprMemcpy((char*) &pos[dist], size, (char*) pos, size);
}


PUBLIC void ecAdjustCodeLength(EcCompiler *cp, int adj)
{
    EcCodeGen   *code;

    code = cp->state->code;
    mprAdjustBufEnd(code->buf, adj);
}


#if UNUSED && KEEP
static int swapWordField(EcCompiler *cp, int word)
{
    if (mprGetEndian(cp) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF000000) >> 24) | ((word & 0xFF0000) >> 8) | ((word & 0xFF00) << 8) | ((word & 0xFF) << 24);
}


static int swapShortField(EcCompiler *cp, int word)
{
    if (mprGetEndian(cp) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF) << 8) | ((word & 0xFF00) >> 8);
}

static int swapCodePoint(EcCompiler *cp, int word)
{
#if ME_CHAR_LEN == 4
    return swapWordField(cp, word);
#elif ME_CHAR_LEN == 2
    return swapShortField(cp, word);
#else
    return word;
#endif 
}
#endif /* UNUSED */


/*
    Simple checksum of name and slots. Not meant to be rigorous.
 */
static int sumNum(int value)
{
    return value;
}


static int sumString(EjsString *name)
{
    wchar   *cp;
    int     checksum;

    checksum = 0;
    if (name) {
        for (cp = name->value; *cp; cp++) {
            checksum += *cp;
        }
    }
    return checksum;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/compiler/ecParser.c"
 */
/************************************************************************/

/**
    ecParser. Parse ejscript source files.

    Parse source and create an internal abstract syntax tree of nodes representing the program.

    The Abstract Syntax Tree (AST) is comprised of a linked set of EcNodes. EjsNodes have a left and right pointer.
    Node with a list of children are represented by right hand links.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************** Defines ***********************************/

#define peekToken(cp)   peekAheadToken(cp, 1)

/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(a)        if (ecEnterState(a) < 0) { return 0; } else

#undef LEAVE
#define LEAVE(cp, np)   ecLeaveStateWithResult(cp, np)

/***************************** Forward Declarations ***************************/

static void     addAscToLiteral(EcCompiler *cp, EcNode *np, cchar *str, ssize len);
static void     addCharsToLiteral(EcCompiler *cp, EcNode *np, wchar *str, ssize len);
static void     addTokenToLiteral(EcCompiler *cp, EcNode *np);
static void     appendDocString(EcCompiler *cp, EcNode *np, EcNode *parameter, EcNode *value);
static EcNode   *appendNode(EcNode *top, EcNode *np);
static void     applyAttributes(EcCompiler *cp, EcNode *np, EcNode *attributes, EjsString *namespaceName);
static void     copyDocString(EcCompiler *cp, EcNode *np, EcNode *from);
static EcNode   *compileInput(EcCompiler *cp, cchar *path);
static EcNode   *createAssignNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent);
static EcNode   *createBinaryNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent);
static EcNode   *createNameNode(EcCompiler *cp, EjsName name);
static EcNode   *createNamespaceNode(EcCompiler *cp, EjsString *name, bool isDefault, bool isLiteral);
static EcNode   *createNode(EcCompiler *cp, int kind, EjsString *name);
static void     dummy(int junk);
static EcNode   *expected(EcCompiler *cp, cchar *str);
static int      getToken(EcCompiler *cp);
static EjsString *tokenString(EcCompiler *cp);
static EcNode   *insertNode(EcNode *top, EcNode *np, int pos);
static EcNode   *linkNode(EcNode *np, EcNode *node);
static EcNode   *parseAnnotatableDirective(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseArgumentList(EcCompiler *cp);
static EcNode   *parseArguments(EcCompiler *cp);
static EcNode   *parseArrayComprehension(EcCompiler *cp, EcNode *literalElement);
static EcNode   *parseArrayPattern(EcCompiler *cp);
static EcNode   *parseArrayType(EcCompiler *cp);
static EcNode   *parseAssignmentExpression(EcCompiler *cp);
static EcNode   *parseAttribute(EcCompiler *cp);
static EcNode   *parseAttributeName(EcCompiler *cp);
static EcNode   *parseBlock(EcCompiler *cp);
static EcNode   *parseBlockStatement(EcCompiler *cp);
static EcNode   *parseBrackets(EcCompiler *cp);
static EcNode   *parseBreakStatement(EcCompiler *cp);
static EcNode   *parseCaseElements(EcCompiler *cp);
static EcNode   *parseCaseLabel(EcCompiler *cp);
static EcNode   *parseCatchClause(EcCompiler *cp);
static EcNode   *parseCatchClauses(EcCompiler *cp);
static EcNode   *parseClassBody(EcCompiler *cp);
static EcNode   *parseClassDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseClassInheritance(EcCompiler *cp);
static EcNode   *parseClassName(EcCompiler *cp);
static EcNode   *parseComprehensionExpression(EcCompiler *cp, EcNode *literalElement);
static EcNode   *parseConstructorSignature(EcCompiler *cp, EcNode *np);
static EcNode   *parseConstructorInitializer(EcCompiler *cp);
static EcNode   *parseContinueStatement(EcCompiler *cp);
static EcNode   *parseDirective(EcCompiler *cp);
static EcNode   *parseDirectives(EcCompiler *cp);
static EcNode   *parseDoStatement(EcCompiler *cp);
static EcNode   *parseDirectivesPrefix(EcCompiler *cp);
static EcNode   *parseElementList(EcCompiler *cp, EcNode *newNode);
static EcNode   *parseElementListPattern(EcCompiler *cp);
static EcNode   *parseElements(EcCompiler *cp, EcNode *newNode);
static EcNode   *parseElementTypeList(EcCompiler *cp);
static EcNode   *parseFieldList(EcCompiler *cp, EcNode *np);
static EcNode   *parseEmptyStatement(EcCompiler *cp);
static EcNode   *parseError(EcCompiler *cp, cchar *fmt, ...);
static EcNode   *parseExpressionStatement(EcCompiler *cp);
static EcNode   *parseFieldListPattern(EcCompiler *cp);
static EcNode   *parseFieldPattern(EcCompiler *cp, EcNode *np);
static EcNode   *parseFieldName(EcCompiler *cp);
static EcNode   *parseForStatement(EcCompiler *cp);
static EcNode   *parseFunctionDeclaration(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseFunctionDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseFunctionBody(EcCompiler *cp, EcNode *fun);
static EcNode   *parseFunctionExpression(EcCompiler *cp);
static EcNode   *parseFunctionExpressionBody(EcCompiler *cp);
static EcNode   *parseFunctionName(EcCompiler *cp);
static EcNode   *parseFunctionSignature(EcCompiler *cp, EcNode *np);
static EcNode   *parseHashStatement(EcCompiler *cp);
static EcNode   *parseIdentifier(EcCompiler *cp);
static EcNode   *parseIfStatement(EcCompiler *cp);
static EcNode   *parseInterfaceBody(EcCompiler *cp);
static EcNode   *parseInterfaceInheritance(EcCompiler *cp);
static EcNode   *parseInitializerList(EcCompiler *cp, EcNode *np);
static EcNode   *parseInitializer(EcCompiler *cp);
static EcNode   *parseParameter(EcCompiler *cp, bool rest);
static EcNode   *parseParameterInit(EcCompiler *cp, EcNode *args);
static EcNode   *parseInterfaceDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseLabeledStatement(EcCompiler *cp);
static EcNode   *parseLeftHandSideExpression(EcCompiler *cp);
static EcNode   *parseLetBindingList(EcCompiler *cp);
static EcNode   *parseLetExpression(EcCompiler *cp);
static EcNode   *parseLetStatement(EcCompiler *cp);
static EcNode   *parseLiteralElement(EcCompiler *cp);
static EcNode   *parseLiteralField(EcCompiler *cp);
static EcNode   *parseListExpression(EcCompiler *cp);
static EcNode   *parseNamespaceAttribute(EcCompiler *cp);
static EcNode   *parseNamespaceDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseNamespaceInitialisation(EcCompiler *cp, EcNode *nameNode);
static EcNode   *parseNonemptyParameters(EcCompiler *cp, EcNode *list);
static EcNode   *parseNullableTypeExpression(EcCompiler *cp);
static EcNode   *parseObjectPattern(EcCompiler *cp);
static EcNode   *parseOptionalExpression(EcCompiler *cp);
static EcNode   *parseOverloadedOperator(EcCompiler *cp);
static EcNode   *parseParenListExpression(EcCompiler *cp);
static EcNode   *parseParameterisedTypeName(EcCompiler *cp);
static EcNode   *parseParameterKind(EcCompiler *cp);
static EcNode   *parseParameters(EcCompiler *cp, EcNode *args);
static EcNode   *parsePath(EcCompiler *cp, EcNode *lhs);
static EcNode   *parsePattern(EcCompiler *cp);
static EcNode   *parsePragmaItems(EcCompiler *cp, EcNode *np);
static EcNode   *parsePragmaItem(EcCompiler *cp);
static EcNode   *parsePragmas(EcCompiler *cp, EcNode *np);
static EcNode   *parsePrimaryExpression(EcCompiler *cp);
static EcNode   *parsePrimaryName(EcCompiler *cp);
static EcNode   *parseProgram(EcCompiler *cp, cchar *path);
static EcNode   *parsePropertyName(EcCompiler *cp);
static EcNode   *parsePropertyOperator(EcCompiler *cp);
static EcNode   *parseQualifiedNameIdentifier(EcCompiler *cp);
static EcNode   *parseRegularExpression(EcCompiler *cp);
static EcNode   *parseRequireItem(EcCompiler *cp);
static EcNode   *parseRequireItems(EcCompiler *cp, EcNode *np);
static EcNode   *parseReservedNamespace(EcCompiler *cp);
static EcNode   *parseRestArgument(EcCompiler *cp);
static EcNode   *parseRestParameter(EcCompiler *cp);
static EcNode   *parseResultType(EcCompiler *cp);
static EcNode   *parseReturnStatement(EcCompiler *cp);
static EcNode   *parseSimplePattern(EcCompiler *cp);
static EcNode   *parseSimpleQualifiedName(EcCompiler *cp);
static EcNode   *parseStatement(EcCompiler *cp);
static EcNode   *parseSubstatement(EcCompiler *cp);
static EcNode   *parseSuperInitializer(EcCompiler *cp);
static EcNode   *parseSwitchStatement(EcCompiler *cp);
static EcNode   *parseThrowStatement(EcCompiler *cp);
static EcNode   *parseTryStatement(EcCompiler *cp);
static EcNode   *parseTypeDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseTypeExpression(EcCompiler *cp);
static EcNode   *parseTypeIdentifierList(EcCompiler *cp);
static EcNode   *parseTypeInitialisation(EcCompiler *cp);
static EcNode   *parseModuleBody(EcCompiler *cp);
static EcNode   *parseModuleName(EcCompiler *cp);
static EcNode   *parseModuleDefinition(EcCompiler *cp);
static EcNode   *parseUsePragma(EcCompiler *cp, EcNode *np);
static EcNode   *parseVariableBinding(EcCompiler *cp, EcNode *np, EcNode *attributes);
static EcNode   *parseVariableBindingList(EcCompiler *cp, EcNode *list, EcNode *attributes);
static EcNode   *parseVariableDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseVariableDefinitionKind(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseVariableInitialisation(EcCompiler *cp);
static int       parseVersion(EcCompiler *cp, int parseMax);
static EcNode   *parseWhileStatement(EcCompiler *cp);
static EcNode   *parseWithStatement(EcCompiler *cp);
PUBLIC struct EcNode   *parseXMLAttribute(EcCompiler *cp, EcNode *np);
PUBLIC struct EcNode   *parseXMLAttributes(EcCompiler *cp, EcNode *np);
PUBLIC struct EcNode   *parseXMLElement(EcCompiler *cp, EcNode *np);
PUBLIC struct EcNode   *parseXMLElementContent(EcCompiler *cp, EcNode *np);
PUBLIC struct EcNode   *parseXMLTagContent(EcCompiler *cp, EcNode *np);
PUBLIC struct EcNode   *parseXMLTagName(EcCompiler *cp, EcNode *np);
static EcNode   *parseYieldExpression(EcCompiler *cp);
static int      peekAheadToken(EcCompiler *cp, int ahead);
static EcToken  *peekAheadTokenStruct(EcCompiler *cp, int ahead);
static void     putSpecificToken(EcCompiler *cp, EcToken *token);
static void     putToken(EcCompiler *cp);
static EcNode   *removeNode(EcNode *np, EcNode *child);
static void     setNodeDoc(EcCompiler *cp, EcNode *np);
static EcNode   *unexpected(EcCompiler *cp);

#if ME_DEBUG
static void     updateDebug(EcCompiler *cp);
#else
#define         updateDebug(cp)
#endif

#if ME_DEBUG
/*
    Just for debugging. Generated via tokens.ksh
 */
char *tokenNames[] = {
    "",
    "assign",
    "at",
    "attribute",
    "bit_and",
    "bit_and_assign",
    "bit_or",
    "bit_or_assign",
    "bit_xor",
    "bit_xor_assign",
    "break",
    "call",
    "callee",
    "case",
    "cast",
    "catch",
    "cdata_end",
    "cdata_start",
    "class",
    "colon",
    "colon_colon",
    "comma",
    "const",
    "context_reserved_id",
    "continue",
    "debugger",
    "decrement",
    "default",
    "delete",
    "div",
    "div_assign",
    "do",
    "dot",
    "dot_dot",
    "dot_less",
    "double",
    "dynamic",
    "each",
    "elipsis",
    "else",
    "enumerable",
    "eof",
    "eq",
    "err",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "ge",
    "generator",
    "get",
    "goto",
    "gt",
    "has",
    "hash",
    "id",
    "if",
    "implements",
    "in",
    "include",
    "increment",
    "instanceof",
    "int",
    "interface",
    "internal",
    "intrinsic",
    "is",
    "lbrace",
    "lbracket",
    "le",
    "let",
    "logical_and",
    "logical_and_assign",
    "logical_not",
    "logical_or",
    "logical_or_assign",
    "logical_xor",
    "logical_xor_assign",
    "lparen",
    "lsh",
    "lsh_assign",
    "lt",
    "lt_slash",
    "minus",
    "minus_assign",
    "minus_minus",
    "mod",
    "module",
    "mod_assign",
    "mul",
    "mul_assign",
    "namespace",
    "native",
    "ne",
    "new",
    "nop",
    "null",
    "number",
    "number_word",
    "override",
    "plus",
    "plus_assign",
    "plus_plus",
    "private",
    "protected",
    "prototype",
    "public",
    "query",
    "rbrace",
    "rbracket",
    "regexp",
    "require",
    "reserved_namespace",
    "return",
    "rparen",
    "rsh",
    "rsh_assign",
    "rsh_zero",
    "rsh_zero_assign",
    "semicolon",
    "set",
    "slash_gt",
    "standard",
    "static",
    "strict",
    "strict_eq",
    "strict_ne",
    "string",
    "super",
    "switch",
    "this",
    "throw",
    "tilde",
    "to",
    "true",
    "try",
    "type",
    "typeof",
    "uint",
    "undefined",
    "use",
    "var",
    "void",
    "while",
    "with",
    "xml_comment_end",
    "xml_comment_start",
    "xml_pi_end",
    "xml_pi_start",
    "yield",
    0,
};


/*
    Just for debugging. Generated via tokens.ksh
 */
char *nodes[] = {
    "",
    "n_args",
    "n_assign_op",
    "n_attributes",
    "n_binary_op",
    "n_binary_type_op",
    "n_block",
    "n_break",
    "n_call",
    "n_case_elements",
    "n_case_label",
    "n_catch",
    "n_catch_arg",
    "n_catch_clauses",
    "n_class",
    "n_continue",
    "n_dassign",
    "n_directives",
    "n_do",
    "n_dot",
    "n_end_function",
    "n_expressions",
    "n_field",
    "n_for",
    "n_for_in",
    "n_function",
    "n_goto",
    "n_hash",
    "n_if",
    "n_literal",
    "n_module",
    "n_new",
    "n_nop",
    "n_object_literal",
    "n_parameter",
    "n_postfix_op",
    "n_pragma",
    "n_pragmas",
    "n_program",
    "n_qname",
    "n_ref",
    "n_return",
    "n_spread",
    "n_super",
    "n_switch",
    "n_this",
    "n_throw",
    "n_try",
    "n_type_identifiers",
    "n_unary_op",
    "n_use_module",
    "n_use_namespace",
    "n_value",
    "n_var",
    "n_var_definition",
    "n_void",
    "n_with",
    0,
};

#endif  /* ME_DEBUG */

/************************************ Code ************************************/
/*
    Compile the input stream and parse all directives into the given nodes reference.
 */
static EcNode *compileInput(EcCompiler *cp, cchar *path)
{
    EcNode      *np;

    assert(cp);

    if (ecEnterState(cp) < 0) {
        return 0;
    }
    cp->fileState = cp->state;
    cp->fileState->strict = cp->strict;
    cp->blockState = cp->state;

    if (cp->shbang) {
        if (getToken(cp) == T_HASH && peekToken(cp) == T_LOGICAL_NOT) {
            while (cp->token->loc.lineNumber <= 1 && cp->token->tokenId != T_EOF && cp->token->tokenId != T_NOP) {
                getToken(cp);
            }
        }
        putToken(cp);
    }
    np = parseProgram(cp, path);
    assert(np || cp->error);
    np = ecLeaveStateWithResult(cp, np);
    cp->fileState = 0;

    if (cp->errorCount > 0) {
        return 0;
    }
    return np;
}


/*
    Compile a source file and parse all directives into the given nodes reference.
    This may be called with the input stream already setup to parse a script.
 */
PUBLIC EcNode *ecParseFile(EcCompiler *cp, char *path)
{
    EcNode  *np;
    int     opened;

    assert(path);

    opened = 0;
    path = mprNormalizePath(path);
    if (cp->stream == 0) {
        if (ecOpenFileStream(cp, path) < 0) {
            parseError(cp, "Cannot open %s", path);
            return 0;
        }
        opened = 1;
    }
    np = compileInput(cp, path);
    if (opened) {
        ecCloseStream(cp);
    }
    return np;
}


/*
    Lookup a module of the right version
    If max is <= 0, then accept any version from min upwards.
    This allows the caller to provide -1, -1 to match all versions.
    If both are equal, then only that version is acceptable.
 */
PUBLIC EjsModule *ecLookupModule(EcCompiler *cp, EjsString *name, int minVersion, int maxVersion)
{
    EjsModule   *mp, *best;
    int         next;

    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    best = 0;
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(cp->modules, &next)) != 0; ) {
        if (minVersion <= mp->version && mp->version <= maxVersion) {
            if (ejsCompareString(cp->ejs, mp->name, name) == 0) {
                if (best == 0 || best->version < mp->version) {
                    best = mp;
                }
            }
        }
    }
    return best;
}


PUBLIC int ecAddModule(EcCompiler *cp, EjsModule *mp)
{
    assert(cp->modules);
    return mprAddItem(cp->modules, mp);
}


PUBLIC int ecRemoveModule(EcCompiler *cp, EjsModule *mp)
{
    assert(cp->modules);
    return mprRemoveItem(cp->modules, mp);
}


PUBLIC int ecResetModuleList(EcCompiler *cp)
{
    cp->modules = mprCreateList(-1, 0);
    if (cp->modules == 0) {
        return EJS_ERR;
    }
    return 0;
}


PUBLIC void ecResetParser(EcCompiler *cp)
{
    cp->token = 0;
}


/************************************* Parser Productions *************************/
/*
    XMLComment (ECMA-357)

    Input Sequences
        <!-- XMLCommentCharacters -->

    AST
 */
static EcNode *parseXMLComment(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_XML_COMMENT_START) { }
    if (getToken(cp) != T_XML_COMMENT_END) {
        return expected(cp, "-->");
    }
    return LEAVE(cp, np);
}


/*
    XMLCdata (ECMA-357)

    Input Sequences
        <![CDATA[ XMLCDataCharacters ]]>

    AST
 */
static EcNode *parseXMLCdata(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_CDATA_START) { }
    if (getToken(cp) != T_CDATA_END) {
        return expected(cp, "]]>");
    }
    return LEAVE(cp, np);
}


/*
    XMLPI (ECMA-357)

    Input Sequences
        <? .... ?>

    AST
 */
static EcNode *parseXMLPI(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_XML_PI_START) { }
    if (getToken(cp) != T_XML_PI_END) {
        return expected(cp, "?>");
    }
    return LEAVE(cp, np);
}


/*
    XMLMarkup (ECMA-357)
        XMLComment
        XMLCDATA
        XMLPI

    Input Sequences
        <!--
        [CDATA
        <?

    AST
 */
static EcNode *parseXMLMarkup(EcCompiler *cp, EcNode *np)
{
    switch (peekToken(cp)) {
    case T_XML_COMMENT_START:
        return parseXMLComment(cp);

    case T_CDATA_START:
        return parseXMLCdata(cp);

    case T_XML_PI_START:
        return parseXMLPI(cp);

    default:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
}


/*
    XMLText (ECMA-357)

    Input Sequences
        SourceCharacters but no { or <

    AST
 */
static EcNode *parseXMLText(EcCompiler *cp, EcNode *np)
{
    wchar   *p;
    int     count;

    //  TODO This is discarding text white space. Need a low level getXmlToken routine
    //  or need lexer to preserved inter-token white space somewhere.
  
    peekToken(cp);
    for (count = 0; np; count++) {
        for (p = cp->peekToken->text; p && *p; p++) {
            if (*p == '{' || *p == '<') {
                if (cp->peekToken->text < p) {
                    addCharsToLiteral(cp, np, cp->token->text, (p - cp->token->text));
                    if (getToken(cp) == T_EOF || cp->token->tokenId == T_ERR || cp->token->tokenId == T_NOP) {
                        return 0;
                    }
                }
                return np;
            }
        }
        if (getToken(cp) == T_EOF || cp->token->tokenId == T_ERR || cp->token->tokenId == T_NOP) {
            return 0;
        }
        if (isalnum((uchar) cp->token->text[0]) && count > 0) {
            addAscToLiteral(cp, np, " ", 1);
        }
        addTokenToLiteral(cp, np);
        peekToken(cp);
    }
    return np;
}


/*
    XMLName (ECMA-357)
        XMLNameStart
        XMLName XMLNamePart

    Input Sequences
        UnicodeLetter
        _       underscore
        :       colon

    AST
 */
static EcNode *parseXMLName(EcCompiler *cp, EcNode *np)
{
    int         c;

    ENTER(cp);

    getToken(cp);
    if (cp->token == 0 || cp->token->text == 0) {
        return LEAVE(cp, unexpected(cp));
    }
    c = cp->token->text[0];
    if (isalpha((uchar) c) || c == '_' || c == ':') {
        addTokenToLiteral(cp, np);
    } else {
        np = parseError(cp, "Not an XML Name \"%@\"", cp->token->text);
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributeValue (ECMA-357)
        XMLDoubleStringCharacters
        XMLSingleStringCharacters

    Input Sequences
        "
        '
    AST
        Add data to literal.data buffer
 */
static EcNode *parseXMLAttributeValue(EcCompiler *cp, EcNode *np)
{
    //  TODO - should be preserving whether the input was ' or ""
    if (getToken(cp) != T_STRING) {
        return expected(cp, "quoted string");
    }
    addAscToLiteral(cp, np, "\"", 1);
    addTokenToLiteral(cp, np);
    addAscToLiteral(cp, np, "\"", 1);
    return np;
}


/*
    Identifier (1)
        ID |
        ContextuallyReservedIdentifier

    Input Sequences
        ID
        ContextuallyReservedIdentifier

    AST
        N_QNAME
            name
                id
 */
static EcNode *parseIdentifier(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    tid = getToken(cp);
    if (cp->token->groupMask & G_CONREV) {
        tid = T_ID;
    }
    switch (tid) {
    case T_MUL:
    case T_ID:
        np = createNode(cp, N_QNAME, tokenString(cp));
        break;

    default:
        np = parseError(cp, "Not an identifier \"%s\"", cp->token->text);
    }
    return LEAVE(cp, np);
}


/*
    Qualifier (3)
        *
        Identifier
        ReservedNamespace
        "StringLiteral"

    Input Sequences:
        *
        ID

    AST
        N_ATTRIBUTES
            namespace
 */

static EcNode *parseQualifier(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_ID:
        np = parseIdentifier(cp);
        break;

    case T_STRING:
        getToken(cp);
        np = createNode(cp, N_QNAME, NULL);
        np->qname.space = tokenString(cp);
        np->literalNamespace = 1;
        break;

    case T_MUL:
        getToken(cp);
        np = createNode(cp, N_ATTRIBUTES, NULL);
        np->qname.space = tokenString(cp);
        break;

    case T_RESERVED_NAMESPACE:
        np = parseReservedNamespace(cp);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    ReservedNamespace (6)
        internal
        intrinsic
        private
        protected
        public

    Input
        internal
        intrinsic
        private
        protected
        public

    AST
        N_ATTRIBUTES
            namespace
            attributes
 */
static EcNode *parseReservedNamespace(EcCompiler *cp)
{
    EcNode      *np;
    int         attributes;

    ENTER(cp);

    if (getToken(cp) != T_RESERVED_NAMESPACE) {
        return LEAVE(cp, expected(cp, "reserved namespace"));
    }
    np = createNode(cp, N_ATTRIBUTES, NULL);

    attributes = 0;

    switch (cp->token->subId) {
    case T_INTRINSIC:
        break;

    case T_INTERNAL:
    case T_PRIVATE:
    case T_PROTECTED:
    case T_PUBLIC:
        np->specialNamespace = 1;
        break;

    default:
        return LEAVE(cp, parseError(cp, "Unknown reserved namespace %s", cp->token->text));
    }
    np->attributes = attributes;
    np->qname.space = tokenString(cp);
    return LEAVE(cp, np);
}


/*
    QualifiedNameIdentifier (11)
        Identifier
        ReservedIdentifier
        StringLiteral
        NumberLiteral
        Brackets
        OverloadedOperator

    Notes:
        Can be used to the right of a namespace qualifier. Eg. public::QualfiedNameIdentifier

    Input
        Identifier
        ReservedIdentifier
        Number
        "String"
        [
        Overloaded Operator

    AST
        N_QNAME
            name:
                namespace
                id
            left: N_EXPRESSIONS
 */
static EcNode *parseQualifiedNameIdentifier(EcCompiler *cp)
{
    EcNode      *np;
    EjsObj      *vp;
    int         tid, reservedWord;

    ENTER(cp);

    tid = peekToken(cp);
    reservedWord = (cp->peekToken->groupMask & G_RESERVED);

    if (reservedWord) {
        np = createNode(cp, N_QNAME, tokenString(cp));

    } else switch (tid) {
        case T_ID:
        case T_TYPE:
            np = parseIdentifier(cp);
            break;

        case T_NUMBER:
            getToken(cp);
            np = createNode(cp, N_QNAME, NULL);
            vp = ejsParse(cp->ejs, cp->token->text, -1);
            //  cant set literal.var in a QNAME. clashes with "name" union structure. Not marked.
            assert(0);
            np->literal.var = vp;
            break;

        case T_STRING:
            getToken(cp);
            np = createNode(cp, N_QNAME, NULL);
            vp = (EjsObj*) tokenString(cp);
            //  cant set literal.var in a QNAME. clashes with "name" union structure. Not marked.
            np->literal.var = vp;
            break;

        case T_LBRACKET:
            np = parseBrackets(cp);
            break;

        default:
            if (cp->token->groupMask == G_OPERATOR) {
                np = parseOverloadedOperator(cp);
            } else {
                getToken(cp);
                np = unexpected(cp);
            }
            break;
    }
    return LEAVE(cp, np);
}


/*
    SimpleQualifiedName (17)
        Identifier
        Qualifier :: QualifiedNameIdentifier

    Notes:
        Optionally namespace qualified name

    Input
        Identifier
        *

    AST
        N_QNAME
            name
                id
            qualifier: N_ATTRIBUTES
 */
static EcNode *parseSimpleQualifiedName(EcCompiler *cp)
{
    EcNode      *np, *name, *qualifier;

    ENTER(cp);

    if (peekToken(cp) == T_MUL || cp->peekToken->tokenId == T_STRING) {
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            qualifier = parseQualifier(cp);
            getToken(cp);
            np = parseQualifiedNameIdentifier(cp);
            if (np->kind == N_EXPRESSIONS) {
                name = np;
                np = createNode(cp, N_QNAME, NULL);
                np->name.nameExpr = linkNode(np, name);
            } else {
                np->literalNamespace = 1;
            }
            np->qname.space = qualifier->qname.space;

        } else {
            np = parseIdentifier(cp);
        }

    } else {
        np = parseIdentifier(cp);
        if (peekToken(cp) == T_COLON_COLON) {
            getToken(cp);
            qualifier = np;
            np = parseQualifiedNameIdentifier(cp);
            if (np) {
                if (np->kind == N_EXPRESSIONS) {
                    name = np;
                    np = createNode(cp, N_QNAME, NULL);
                    np->name.nameExpr = linkNode(np, name);
                }
                np->name.qualifierExpr = linkNode(np, qualifier);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ExpressionQualifiedName (15)
        ParenListExpression :: QualifiedNameIdentifier

    Input
        ( ListExpression ) :: *
        ( ListExpression ) :: Identifier
        ( ListExpression ) :: ReservedIdentifier
        ( ListExpression ) :: Number
        ( ListExpression ) :: String
        ( ListExpression ) :: [ ... ]
        ( ListExpression ) :: OverloadedOperator

    AST
        N_QNAME
            left: N_EXPRESSIONS
            qualifier: N_ATTRIBUTES
 */
static EcNode *parseExpressionQualifiedName(EcCompiler *cp)
{
    EcNode      *np, *qualifier;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, unexpected(cp));
    }
    qualifier = parseListExpression(cp);
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    if (getToken(cp) == T_COLON_COLON) {
        np = parseQualifiedNameIdentifier(cp);
        np->name.qualifierExpr = linkNode(np, qualifier);
    } else {
        np = expected(cp, "\"::\"");
    }
    return LEAVE(cp, np);
}


/*
    PropertyName (20)
        SimpleQualifiedName         |
        ExpressionQualifiedName

    Input
        Identifier
        *
        internal, intrinsic, private, protected, public
        (

    AST
        N_QNAME
            name
                namespace
                id
            left: N_EXPRESSIONS
            right: N_EXPRESSIONS
 */
static EcNode *parsePropertyName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_LPAREN) {
        np = parseExpressionQualifiedName(cp);
    } else {
        np = parseSimpleQualifiedName(cp);
    }
    return LEAVE(cp, np);
}


/*
    AttributeName (22)
        @ Brackets
        @ PropertyName

    Input
        @ [ ... ]
        @ PropertyName
            @ *
            @ ID
            @ Qualifier :: *
            @ Qualifier :: ID
            @ Qualifier :: ReservedIdentifier
            @ Qualifier :: Brackets
            @ ( ListExpression ) :: *
            @ ( ListExpression ) :: ID
            @ ( ListExpression ) :: ReservedIdentifier
            @ ( ListExpression ) :: [ ... ]

    AST
        N_QNAME
            name
                id
                namespace
                isAttribute
            left: N_EXPRESSIONS
 */
static EcNode *parseAttributeName(EcCompiler *cp)
{
    EcNode      *np;
    char        *attribute;

    ENTER(cp);

    if (getToken(cp) != T_AT) {
        return LEAVE(cp, expected(cp, "@ prefix"));
    }
    if (peekToken(cp) == T_LBRACKET) {
        np = createNode(cp, N_QNAME, tokenString(cp));
        np = appendNode(np, parseBrackets(cp));
    } else {
        np = parsePropertyName(cp);
    }
    if (np && np->kind == N_QNAME) {
        //  OPT. Better to allow lexer to keep @ in the id name and return T_AT with the entire attribute name.
        np->name.isAttribute = 1;
        attribute = sjoin("@", np->qname.name->value, NULL);
        np->qname.name = ejsCreateStringFromAsc(cp->ejs, attribute);
    }
    return LEAVE(cp, np);
}


/*
    QualifiedName (24)
        AttributeName
        PropertyName

    Input
        @ ...
        Identifier
        *
        internal, intrinsic, private, protected, public
        (

    AST
        N_QNAME
            name
                id
                namespace
                isAttribute
            left: listExpression
            right: bracketExpression
 */
static EcNode *parseQualifiedName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_AT) {
        np = parseAttributeName(cp);
    } else {
        np = parsePropertyName(cp);
    }
    return LEAVE(cp, np);
}


/*
    PrimaryName (26)
        Path . PropertyName
        PropertyName

    Input
        *
        internal, intrinsic, private, protected, public
        Identifier
        (

    AST
        N_QNAME
        N_DOT
 */
static EcNode *parsePrimaryName(EcCompiler *cp)
{
    EcNode      *np, *path;
    int         tid, id;

    ENTER(cp);

    np = 0;
    tid = peekToken(cp);
    if (cp->peekToken->groupMask & G_CONREV) {
        tid = T_ID;
    }
    if (tid == T_ID && peekAheadToken(cp, 2) == T_DOT) {
        EcToken     *tok;
        tok = peekAheadTokenStruct(cp, 3);
        id = tok->tokenId;
        if (tok->groupMask & G_CONREV) {
            id = T_ID;
        }
        if (id == T_ID || id == T_MUL || id == T_RESERVED_NAMESPACE || id == T_LPAREN) {
            path = parsePath(cp, 0);
            np = createNode(cp, N_DOT, NULL);
            np = appendNode(np, path);
            getToken(cp);
        }
    }
    if (np) {
        np = appendNode(np, parsePropertyName(cp));
    } else {
        np = parsePropertyName(cp);
    }
    return LEAVE(cp, np);
}


/*
    Path (28)
        Identifier |
        Path . Identifier

    Input
        ID
        ID. ... .ID

    AST
        N_QNAME
        N_DOT

    "dontConsumeLast" will be set if parsePath should not consume the last Identifier.
 */
static EcNode *parsePath(EcCompiler *cp, EcNode *lhs)
{
    EcNode      *np;
    EcToken     *tok;
    int         tid;

    ENTER(cp);

    if (lhs) {
        np = appendNode(createNode(cp, N_DOT, NULL), lhs);
        np = appendNode(np,  parseIdentifier(cp));
    } else {
        np = parseIdentifier(cp);
    }

    /*
        parsePath is called only from parsePrimaryName which requires that a ".PropertyName" be preserved.
        TODO - OPT. Perhaps hoist back into parsePrimaryName.
     */
    if (peekToken(cp) == T_DOT && peekAheadToken(cp, 2) == T_ID) {
        if (peekAheadToken(cp, 3) == T_DOT) {
            tok = peekAheadTokenStruct(cp, 4);
            tid = tok->tokenId;
            if (tok->groupMask & G_CONREV) {
                tid = T_ID;
            }
            if (tid == T_ID || tid == T_MUL || tid == T_RESERVED_NAMESPACE || tid == T_LPAREN) {
                getToken(cp);
                np = parsePath(cp, np);
            }
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    ParenExpression (30)
        ( AssignmentExpression )
        ( )                                 # EJS FIX

    Input
        (

    AST
        N_EXPR
        N_NOP
 */
static EcNode *parseParenExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, unexpected(cp));
    }
    if (peekToken(cp) != T_RPAREN) {
        np = parseAssignmentExpression(cp);
    } else {
        np = createNode(cp, N_NOP, NULL);
    }
    if (getToken(cp) != T_RPAREN) {
        np = expected(cp, ")");
    }
    return LEAVE(cp, np);
}
#endif


/*
    ParenListExpression (31)
        ( ListExpression )

    Input
        (

    AST
        N_EXPRESSIONS
 */
static EcNode *parseParenListExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = parseListExpression(cp);
    if (np && getToken(cp) != T_RPAREN) {
        np = expected(cp, ")");
    }
    return LEAVE(cp, np);
}


/*
    FunctionExpression (32)
        function Identifier FunctionSignature FunctionBody
        function FunctionSignature FunctionBody

    Input
        function id ( args ) { body }
        function ( args ) { body }

    AST
        N_FUNCTION
 */
static EcNode *parseFunctionExpression(EcCompiler *cp)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *np, *funRef;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_FUNCTION, NULL);
    np->function.isExpression = 1;

    if (peekToken(cp) == T_ID) {
        getToken(cp);
        np->qname.name = tokenString(cp);
    }
    if (np->qname.name == 0) {
        np->qname.name = ejsSprintf(cp->ejs, "--fun_%d-%d--", np->seqno, (int) mprGetTime());
    }
    np->qname.space = state->inFunction ? ESV(empty): cp->fileState->nspace;

    np = parseFunctionSignature(cp, np);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (STRICT_MODE(cp)) {
        if (np->function.resultType == 0) {
            return LEAVE(cp, parseError(cp,
                "Function has not defined a return type. Fuctions must be typed when declared in strict mode"));
        }
    }
    cp->state->currentFunctionNode = np;
    np->function.body = linkNode(np, parseFunctionExpressionBody(cp));

    if (np->function.body == 0) {
        return LEAVE(cp, 0);
    }
    /*
        The function must get linked into the top var block. It must not get processed inline at this point in the AST tree.
     */
    assert(cp->state->topVarBlockNode);
    appendNode(cp->state->topVarBlockNode, np);

    /*
        Create a name node to reference the function. This is the value of this function expression.
        The funRef->name will be filled in by the AST processing for the function node.
     */
    funRef = createNode(cp, N_QNAME, NULL);
    funRef->qname = np->qname;
    return LEAVE(cp, funRef);
}


/*
    FunctionExpressionBody (34)
        Block
        AssignmentExpression

    Input
        {
    AST
 */
static EcNode *parseFunctionExpressionBody(EcCompiler *cp)
{
    EcNode      *np, *ret;

    ENTER(cp);

    if (peekToken(cp) == T_LBRACE) {
        np = parseBlock(cp);
        if (np) {
            np = np->left;
        }
    } else {
        np = createNode(cp, N_DIRECTIVES, NULL);
        ret = createNode(cp, N_RETURN, NULL);
        ret->ret.blockless = 1;
        ret = appendNode(ret, parseAssignmentExpression(cp));
        np = appendNode(np, ret);
    }
    if (np) {
        assert(np->kind == N_DIRECTIVES);
    }
    np = appendNode(np, createNode(cp, N_END_FUNCTION, NULL));
    return LEAVE(cp, np);
}


/*
    ObjectLiteral (36)
        { FieldList }
        { FieldList } : NullableTypeExpression

    Input
        { LiteralField , ... }

    AST
        N_EXPRESSIONS
 */
static EcNode *parseObjectLiteral(EcCompiler *cp)
{
    Ejs     *ejs;
    EcNode  *typeNode, *np;

    ENTER(cp);

    ejs = cp->ejs;
    np = createNode(cp, N_OBJECT_LITERAL, NULL);
    if (getToken(cp) != T_LBRACE) {
        return LEAVE(cp, unexpected(cp));
    }
    if ((np = parseFieldList(cp, np)) == 0) {
        return LEAVE(cp, 0);
    }
    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        typeNode = parseNullableTypeExpression(cp);
    } else {
        typeNode = createNode(cp, N_QNAME, EST(Object)->qname.name);
    }
    np->objectLiteral.typeNode = linkNode(np, typeNode);
    np->objectLiteral.isArray = 0;

    if (getToken(cp) != T_RBRACE) {
        return LEAVE(cp, unexpected(cp));
    }
    return LEAVE(cp, np);
}


/*
    FieldList (41)
        EMPTY
        LiteralField
        LiteralField , LiteralField

    Input
        LiteralField , ...

    AST
 */
static EcNode *parseFieldList(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    while (peekToken(cp) != T_RBRACE && !cp->error) {
        if (peekToken(cp) != T_COMMA) {
            np = appendNode(np, parseLiteralField(cp));
        } else {
            getToken(cp);
        }
    }
    return LEAVE(cp, np);
}


/*
    LiteralField (42)
        FieldKind FieldName : AssignmentExpression
        get Identifier FunctionSignature FunctionBody
        set Identifier FunctionSignature FunctionBody
        Identifier FunctionSignature FunctionBody
    Input

    AST
 */
static EcNode *parseLiteralField(EcCompiler *cp)
{
    EcNode  *fp, *np, *id, *funRef, *fieldName;

    ENTER(cp);
    np = 0;
    
    getToken(cp);
    if ((cp->token->tokenId == T_GET || cp->token->tokenId == T_SET) && peekToken(cp) != T_COLON) {
        /*
            get NAME() {}
         */
        fp = createNode(cp, N_FUNCTION, NULL);
        if (cp->token->tokenId == T_GET) {
            fp->function.getter = 1;
            fp->attributes |= EJS_TRAIT_GETTER;
        } else {
            fp->function.setter = 1;
            fp->attributes |= EJS_TRAIT_SETTER;
        }
        id = parseIdentifier(cp);
        if (id == 0) {
            return LEAVE(cp, 0);
        }
        cp->state->currentFunctionNode = fp;
        if ((fp = parseFunctionSignature(cp, fp)) == 0) {
            return LEAVE(cp, 0);
        }
        fp->function.body = linkNode(fp, parseFunctionBody(cp, fp));
        if (fp->function.body == 0) {
            return LEAVE(cp, 0);
        }

        np = createNode(cp, N_FIELD, NULL);
        np->field.fieldKind = FIELD_KIND_FUNCTION;
        np->field.index = -1;
        np->attributes = fp->attributes;
        /*
            The function must get linked into the current var block. It must not get processed inline at
            this point in the AST tree because it must not use the block scope. Create a name based on the
            object literal seqno. This permits setters and getters to share the same name and thus when
            ejsDefineProperty is called -- they will get cross-linked.
         */
        fp->qname.name = ejsSprintf(cp->ejs, "--fun_%d-%d--", fp->seqno, (int) mprGetTime());
        fp->qname.space = cp->fileState->nspace;
        assert(cp->state->topVarBlockNode);
        appendNode(cp->state->topVarBlockNode, fp);
        /*
            Must clear the getter|setter attributes so it can be loaded without invoking the accessor.
            The NEW_OBJECT opcode will call ejsDefineProperty which will restore the attributes.
         */
        fp->attributes &= ~(EJS_TRAIT_GETTER | EJS_TRAIT_SETTER);

        fieldName = createNode(cp, N_QNAME, id->qname.name);
        np->field.fieldName = linkNode(np, fieldName);

        funRef = createNode(cp, N_QNAME, fp->qname.name);
        np->field.expr = linkNode(np, funRef);

    } else if (cp->token->tokenId == T_ID && peekToken(cp) == T_LPAREN) {
        /*
            NAME() {}
         */
        fp = createNode(cp, N_FUNCTION, NULL);
        putToken(cp);
        if ((id = parseIdentifier(cp)) == 0) {
            return LEAVE(cp, 0);
        }
        cp->state->currentFunctionNode = fp;
        fp = parseFunctionSignature(cp, fp);
        fp->function.body = linkNode(fp, parseFunctionBody(cp, fp));
        if (fp->function.body == 0) {
            return LEAVE(cp, 0);
        }
        np = createNode(cp, N_FIELD, NULL);
        np->field.fieldKind = FIELD_KIND_FUNCTION;
        np->field.index = -1;
        np->attributes = fp->attributes;
        /*
            The function must get linked into the current var block. It must not get processed inline at
            this point in the AST tree because it must not use the block scope. Create a name based on the
            object literal seqno. This permits setters and getters to share the same name and thus when
            ejsDefineProperty is called -- they will get cross-linked.
         */
        fp->qname.name = ejsSprintf(cp->ejs, "--fun_%d-%d--", fp->seqno, (int) mprGetTime());
        fp->qname.space = cp->fileState->nspace;
        assert(cp->state->topVarBlockNode);
        appendNode(cp->state->topVarBlockNode, fp);
        fieldName = createNode(cp, N_QNAME, id->qname.name);
        np->field.fieldName = linkNode(np, fieldName);
        funRef = createNode(cp, N_QNAME, fp->qname.name);
        np->field.expr = linkNode(np, funRef);

    } else {
        if (cp->token->tokenId == T_CONST) {
            np = createNode(cp, N_FIELD, NULL);
            np->field.varKind = KIND_CONST;
            np->attributes |= EJS_TRAIT_READONLY;
        } else {
            putToken(cp);
            np = createNode(cp, N_FIELD, NULL);
        }
        np->field.index = -1;
        np->field.fieldKind = FIELD_KIND_VALUE;
        if ((np->field.fieldName = linkNode(np, parseFieldName(cp))) == 0) {
            np = 0;
        } else {
            if (peekToken(cp) == T_COLON) {
                getToken(cp);
                np->field.expr = linkNode(np, parseAssignmentExpression(cp));
                
            } else if (np->field.fieldName->kind == N_QNAME) {
                np->field.expr = linkNode(np, createNode(cp, N_QNAME, NULL));
                np->field.expr->qname.name = np->field.fieldName->qname.name;

            } else if (np->field.fieldName->kind != N_LITERAL) {
                np = expected(cp, ": value");
            }
        }
    }
    return LEAVE(cp, np);
}


#if ROLLED_UP
/*
    FieldKind (45)
        EMPTY
        const

    Input

    AST
 */
static EcNode *parseFieldKind(EcCompiler *cp, EcNode *np)
{
    EcNode  *np;

    ENTER(cp);

    if (peekToken(cp) == T_CONST) {
        getToken(cp);
        np->def.varKind = KIND_CONST;
    }
    return LEAVE(cp, np);
}
#endif


/*
    FieldName (47)
        PropertyName
        StringLiteral
        NumberLiteral
        ReservedIdentifier

    Input

    AST
 */
static EcNode *parseFieldName(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_ID:
    case T_NUMBER:
    case T_STRING:
        np = parsePrimaryExpression(cp);
        break;

    default:
        np = parsePropertyName(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    ArrayLiteral (51)
        [ Elements ]

    ArrayLiteral (52)
        [ Elements ] : NullableTypeExpression

    Input sequence
        [

    AST
        N_EXPRESSIONS
            N_NEW
                N_QNAME
            N_EXPRESSIONS
                N_ASSIGN_OP
                    N_DOT
                        N_PARENT
                        N_LITERAL
                    ANY
 */
static EcNode *parseArrayLiteral(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np, *typeNode;

    ENTER(cp);

    ejs = cp->ejs;
    np = createNode(cp, N_OBJECT_LITERAL, NULL);
    np->objectLiteral.isArray = 1;

    if (getToken(cp) != T_LBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    } else {
        np = parseElements(cp, np);
        typeNode = 0;
        if (getToken(cp) != T_RBRACKET) {
            np = parseError(cp, "Expecting \"[\"");
        } else {
            if (peekToken(cp) == T_COLON) {
                typeNode = parseArrayType(cp);
                if (typeNode == 0) {
                    return LEAVE(cp, 0);
                }
            }
        }
        if (np) {
            if (typeNode == 0) {
                typeNode = createNode(cp, N_QNAME, EST(Array)->qname.name);
            }
            np->objectLiteral.typeNode = linkNode(np, typeNode);
        }
    }
    return LEAVE(cp, np);
}


/*
    Elements (54)
        ElementList
        ArrayComprehension

    Input sequence

    AST
        N_EXPRESSIONS
            N_ASSIGN_OP
                N_DOT
                    N_REF
                    N_LITERAL
                ANY
 */
static EcNode *parseElements(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_FOR || cp->peekToken->tokenId == T_LET || cp->peekToken->tokenId == T_IF) {
        np = parseArrayComprehension(cp, np);
    } else {
        np = parseElementList(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    ElementList (56)
        EMPTY
        LiteralElement
        , ElementList
        LiteralElement , ElementList

    Input sequence

    AST
        N_EXPRESSIONS
            N_ASSIGN_OP
                N_DOT
                    N_REF
                    N_LITERAL
                ANY
 */
static EcNode *parseElementList(EcCompiler *cp, EcNode *np)
{
    EcNode      *elt;
    int         index;

    ENTER(cp);

    for (index = 0; np; ) {
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
            index++;
        } else if (cp->peekToken->tokenId == T_RBRACKET) {
            break;
        } else {
            if ((elt = parseLiteralElement(cp)) != 0) {
                assert(elt->kind == N_FIELD);
                elt->field.index = index;
                if (peekToken(cp) != T_COMMA && cp->peekToken->tokenId != T_RBRACKET) {
                    getToken(cp);
                    return LEAVE(cp, unexpected(cp));
                }
            }
            np = appendNode(np, elt);
        }
    }
    return LEAVE(cp, np);
}


/*
    LiteralElement (60)
        AssignmentExpression -noList, allowin-

    Input sequence

    AST
        N_ASSIGN_OP
            N_DOT
                N_REF
                N_LITERAL (empty - caller must set node->var)
            ANY
 */
static EcNode *parseLiteralElement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = createNode(cp, N_FIELD, NULL);
    np->field.varKind = KIND_CONST;
    np->attributes |= EJS_TRAIT_READONLY;
    np->field.fieldKind = FIELD_KIND_VALUE;
    np->field.expr = linkNode(np, parseAssignmentExpression(cp));
    return LEAVE(cp, np);
}


/*
    ArrayComprehension (42)
        AssignmentExpression ComprehensionExpression
 */
static EcNode *parseArrayComprehension(EcCompiler *cp, EcNode *literalElement)
{
    EcNode      *np;

    ENTER(cp);

    np = parseAssignmentExpression(cp);
    np = parseComprehensionExpression(cp, np);
    return LEAVE(cp, np);
}


/*
    ComprehensionExpression (43)
        for (TypedPattern in CommaExpression) ComprehensionClause
        for each (TypedPattern in CommaExpression) ComprehensionClause
        let ParenExpression ComprehensionClause
        if ParenExpression ComprehensionClause
 */
static EcNode *parseComprehensionExpression(EcCompiler *cp, EcNode *literalElement)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    return LEAVE(cp, np);
}


#if UNUSED
/*
    ForInExpressionList (62)
        ForExpression
        ForExpressionList ForExpression

    Input sequence

    AST
 */
static EcNode *parseForInExpressionList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    ForInExpression (64)
        for ( ForInBinding in ListExpression -allowin- )
        for each ( ForInBinding in ListExpression -allowin- )
        ForExpressionList ForExpression

    Input sequence

    AST
 */
static EcNode *parseForInExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    OptionalIfCondition (66)
        EMPTY
        if ParenListExpression

    Input
        this

    AST
 */


/*
    XMLInitializer (68)
        XMLMarkup
        XMLElement
        < > XMLElementContent </ >

    Input
        <!--
        [CDATA
        <?
        <

    AST
        Add data to literal.data buffer
 */
PUBLIC struct EcNode *parseXMLInitializer(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;

    ENTER(cp);
    ejs = cp->ejs;

    np = createNode(cp, N_LITERAL, NULL);
    np->literal.data = mprCreateBuf(0, 0);

    if (EST(XML) == 0) {
        return LEAVE(cp, parseError(cp, "No XML support configured"));
    }
    np->literal.var = (EjsObj*) ejsCreateObj(ejs, EST(XML), 0);

    switch (peekToken(cp)) {
    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        return parseXMLMarkup(cp, np);

    case T_LT:
        if (peekAheadToken(cp, 2) == T_GT) {
            getToken(cp);
            getToken(cp);
            addAscToLiteral(cp, np, "<>", 2);
            np = parseXMLElementContent(cp, np);
            if (getToken(cp) != T_LT_SLASH) {
                return LEAVE(cp, expected(cp, "</"));
            }
            if (getToken(cp) != T_GT) {
                return LEAVE(cp, expected(cp, ">"));
            }
            addAscToLiteral(cp, np, "</>", 3);
        } else {
            return parseXMLElement(cp, np);
        }
        break;

    default:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
    np = 0;
    return LEAVE(cp, np);
}


/*
    XMLElementContent (71)
        { ListExpression } XMLElementContent
        XMLMarkup XMLElementContent
        XMLText XMLElementContent
        XMLElement XMLElementContent
        EMPTY
    Input
        {
        <!--
        [CDATA
        <?
        <
        Text
    AST
 */
PUBLIC struct EcNode *parseXMLElementContent(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (np == 0) {
        return LEAVE(cp, np);
    }
    
    switch (peekToken(cp)) {
    case T_LBRACE:
        getToken(cp);
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
        np = parseXMLElementContent(cp, np);
        break;

    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        np = parseXMLMarkup(cp, np);
        break;

    case T_LT:
        np = parseXMLElement(cp, np);
        np = parseXMLElementContent(cp, np);
        break;

    case T_LT_SLASH:
        break;

    case T_EOF:
    case T_ERR:
    case T_NOP:
        return LEAVE(cp, 0);

    default:
        np = parseXMLText(cp, np);
        np = parseXMLElementContent(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLElement (76)
        < XMLTagContent XMLWhitespace />
        < XMLTagContent XMLWhitespace > XMLElementContent </ XMLTagName XMLWhitespace >

    Input
        <

    AST
        Add data to literal.data buffer
 */
PUBLIC struct EcNode *parseXMLElement(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (getToken(cp) != T_LT) {
        return LEAVE(cp, expected(cp, "<"));
    }
    addTokenToLiteral(cp, np);

    np = parseXMLTagContent(cp, np);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (getToken(cp) == T_SLASH_GT) {
        addTokenToLiteral(cp, np);
        return LEAVE(cp, np);

    } else if (cp->token->tokenId != T_GT) {
        return LEAVE(cp, unexpected(cp));
    }

    addTokenToLiteral(cp, np);

    np = parseXMLElementContent(cp, np);
    if (getToken(cp) != T_LT_SLASH) {
        return LEAVE(cp, expected(cp, "</"));
    }
    addTokenToLiteral(cp, np);

    np = parseXMLTagName(cp, np);
    if (getToken(cp) != T_GT) {
        return LEAVE(cp, expected(cp, ">"));
    }
    addTokenToLiteral(cp, np);
    return LEAVE(cp, np);
}


/*
    XMLTagContent (79)
        XMLTagName XMLAttributes

    Input
        {
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
PUBLIC struct EcNode *parseXMLTagContent(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    np = parseXMLTagName(cp, np);
    if (np) {
        np = parseXMLAttributes(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLTagName (80)
        { ListExpression }
        XMLName

    Input
        {
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
PUBLIC struct EcNode *parseXMLTagName(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (peekToken(cp) == T_LBRACE) {
        getToken(cp);
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        np = parseXMLName(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributes (82)
        XMLWhitespace { ListExpression }
        XMLAttribute XMLAttributes
        EMPTY
    Input

    AST
        Add data to literal.data buffer
 */
PUBLIC struct EcNode *parseXMLAttributes(EcCompiler *cp, EcNode *np)
{
    int         tid;

    ENTER(cp);

    tid = peekToken(cp);
    if (tid == T_LBRACE) {
        parseListExpression(cp);
        if (peekToken(cp) == T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        while (tid != T_GT && tid != T_SLASH_GT) {
            if ((np = parseXMLAttribute(cp, np)) == 0) {
                break;
            }
            tid = peekToken(cp);
        }
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributes (85)
        XMLWhitespace XMLName XMLWhitespace = XMLWhitepace { ListExpression (allowIn) }
        XMLWhitespace XMLName XMLWhitespace = XMLAttributeValue

    Input
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
PUBLIC struct EcNode *parseXMLAttribute(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    addAscToLiteral(cp, np, " ", 1);
    np = parseXMLName(cp, np);

    if (getToken(cp) != T_ASSIGN) {
        return LEAVE(cp, expected(cp, "="));
    }
    addAscToLiteral(cp, np, "=", 1);

    if (peekToken(cp) == T_LBRACE) {
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        np = parseXMLAttributeValue(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    ThisExpression (87)
        this
        this callee
        this generator
        this function
    Input
        this

    AST
 */
static EcNode *parseThisExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_THIS) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_THIS, NULL);
    peekToken(cp);
    
    if (cp->token->loc.lineNumber == cp->peekToken->loc.lineNumber) {
        switch (peekToken(cp)) {
        case T_TYPE:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_TYPE;
            break;

        case T_FUNCTION:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_FUNCTION;
            break;

        case T_CALLEE:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_CALLEE;
            break;

        case T_GENERATOR:
            getToken(cp);
            np->thisNode.thisKind = EC_THIS_GENERATOR;
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    PrimaryExpression (90)
        null
        true
        false
        NumberLiteral
        StringLiteral
        RegularExpression
        ThisExpression
        XMLInitializer
        ParenListExpression
        ArrayLiteral
        ObjectLiteral
        FunctionExpression
        AttributeName
        PrimaryName

    Input sequence
        null
        true
        false
        this
        function
        Identifier
        ContextuallyReservedIdentifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <

    AST
        N_FUNCTION
        N_NEW           (array / object literals)
        N_LITERAL
        N_QNAME
        N_THIS
 */
static EcNode *parsePrimaryExpression(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np, *qualifier, *name;
    EjsObj      *vp;
    int         tid;

    ENTER(cp);

    ejs = cp->ejs;
    tid = peekToken(cp);
    if (cp->peekToken->groupMask & G_CONREV) {
        tid = T_ID;
    }
    np = 0;
    switch (tid) {
    case T_STRING:
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            np = parsePrimaryName(cp);
        } else {
            getToken(cp);
            vp = (EjsObj*) tokenString(cp);
            np = createNode(cp, N_LITERAL, tokenString(cp));
            np->literal.var = vp;
        }
        break;

    case T_ID:
        np = parsePrimaryName(cp);
        break;

    case T_AT:
        np = appendNode(np, parseAttributeName(cp));
        break;

    case T_NUMBER:
        getToken(cp);
        vp = ejsParse(cp->ejs, cp->token->text, -1);
        np = createNode(cp, N_LITERAL, tokenString(cp));
        np->literal.var = vp;
        break;

    case T_NULL:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            np->literal.var = ESV(null);
        }
        break;

    case T_UNDEFINED:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            np->literal.var = ESV(undefined);
        }
        break;

    case T_TRUE:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            vp = (EjsObj*) ejsCreateBoolean(cp->ejs, 1);
            np->literal.var = vp;
        }
        break;

    case T_FALSE:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = createNode(cp, N_LITERAL, tokenString(cp));
            vp = (EjsObj*) ejsCreateBoolean(cp->ejs, 0);
            np->literal.var = vp;
        }
        break;

    case T_THIS:
        np = parseThisExpression(cp);
        break;

    case T_LPAREN:
        np = parseParenListExpression(cp);
        if (peekToken(cp) == T_COLON_COLON) {
            getToken(cp);
            qualifier = np;
            if ((np = parseQualifiedNameIdentifier(cp)) != 0) {
                if (np->kind == N_EXPRESSIONS) {
                    name = np;
                    np = createNode(cp, N_QNAME, tokenString(cp));
                    np->name.nameExpr = linkNode(np, name);
                }
                np->name.qualifierExpr = linkNode(np, qualifier);
            }
        }
        break;

    case T_LBRACKET:
        np = parseArrayLiteral(cp);
        break;

    case T_LBRACE:
        np = parseObjectLiteral(cp);
        break;

    case T_FUNCTION:
        np = parseFunctionExpression(cp);
        break;

    case T_VOID:
    case T_NAMESPACE:
    case T_TYPEOF:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME, tokenString(cp));
        } else {
            np = unexpected(cp);
        }
        break;

    case T_LT:
    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        np = parseXMLInitializer(cp);
        break;

    case T_DIV:
    case T_SLASH_GT:
        np = parseRegularExpression(cp);
        break;

    case T_ERR:
    default:
        getToken(cp);
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


static EcNode *parseRegularExpression(EcCompiler *cp)
{
    EcNode      *np;
    EjsObj      *vp;
    wchar       *prefix;
    int         id;

    ENTER(cp);

    /* Flush peek ahead buffer */
    while (cp->putback) {
        getToken(cp);
    }
    prefix = wclone(cp->token->text);
    id = ecGetRegExpToken(cp, prefix);
    cp->peekToken = 0;
    updateDebug(cp);

    if (id != T_REGEXP) {
        return LEAVE(cp, parseError(cp, "Cannot parse regular expression"));
    }
    if ((vp = (EjsObj*) ejsParseRegExp(cp->ejs, tokenString(cp))) == NULL) {
        return LEAVE(cp, parseError(cp, "Cannot compile regular expression"));
    }
    np = createNode(cp, N_LITERAL, NULL);
    np->literal.var = vp;
    return LEAVE(cp, np);
}


/*
    SuperExpression (104)
        super
        super ParenExpression

    Input
        super

    AST
        N_SUPER

    NOTES:
        Using Arguments instead of ParenExpression so we can have multiple args.
 */
static EcNode *parseSuperExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_SUPER) {
        np = unexpected(cp);

    } else {
        if (peekToken(cp) == T_LPAREN) {
            np = createNode(cp, N_SUPER, NULL);
            np = appendNode(np, parseArguments(cp));
        } else {
            np = createNode(cp, N_SUPER, NULL);
        }
    }
    return LEAVE(cp, np);
}


/*
    Arguments (106)
        ( )
        ( ArgumentList )

    Input
        (

    AST
        N_ARGS
 */
static EcNode *parseArguments(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        np = parseError(cp, "Expecting \"(\"");

    } else if (peekToken(cp) == T_RPAREN) {
        getToken(cp);
        np = createNode(cp, N_ARGS, NULL);

    } else {
        np = parseArgumentList(cp);
        if (np && getToken(cp) != T_RPAREN) {
            np = parseError(cp, "Expecting \")\"");
        }
    }
    return LEAVE(cp, np);
}


/*
    ArgumentList (118)
        AssignmentExpression
        ArgumentList , AssignmentExpression

    Input

    AST N_ARGS
        children: arguments
 */
static EcNode *parseArgumentList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_ARGS, NULL);

    if (np && peekToken(cp) == T_ELIPSIS) {
        np = appendNode(np, parseRestArgument(cp));
    } else {
        np = appendNode(np, parseAssignmentExpression(cp));
    }
    while (np && peekToken(cp) == T_COMMA) {
        getToken(cp);
        if (np && peekToken(cp) == T_ELIPSIS) {
            np = appendNode(np, parseRestArgument(cp));
        } else {
            np = appendNode(np, parseAssignmentExpression(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    RestArgument (NEW)
        ...
        ... Parameter

    Input

    AST
 */
static EcNode *parseRestArgument(EcCompiler *cp)
{
    EcNode      *np, *spreadArg;

    ENTER(cp);

    if (getToken(cp) == T_ELIPSIS) {
        spreadArg = createNode(cp, N_SPREAD, NULL);
        np = appendNode(spreadArg, parseAssignmentExpression(cp));
        if (peekToken(cp) == T_COMMA) {
            np = unexpected(cp);
        }
    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    PropertyOperator (110)
        . ReservedIdentifier
        . PropertyName
        . AttributeName
        .. QualifiedName
        . ParenListExpression
        . ParenListExpression :: QualifiedNameIdentifier
        Brackets
        TypeApplication

    Input
        .
        ..
        [

    AST
        N_DOT
 */
static EcNode *parsePropertyOperator(EcCompiler *cp)
{
    EcNode      *np, *qualifier, *name;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_DOT:
        np = createNode(cp, N_DOT, NULL);
        getToken(cp);
        switch (peekToken(cp)) {
        case T_LPAREN:
            name = parseParenListExpression(cp);
            if (peekToken(cp) == T_COLON_COLON) {
                qualifier = name;
                getToken(cp);
                name = parseQualifiedNameIdentifier(cp);
                name->name.qualifierExpr = linkNode(name, qualifier);
            }
            np = appendNode(np, name);
            break;

        /* TODO - should handle all contextually reserved identifiers here */
        case T_TYPE:
        case T_ID:
        case T_GET:
        case T_SET:
        case T_STRING:
        case T_REQUIRE:
        case T_RESERVED_NAMESPACE:
        case T_MUL:
            if (cp->token->groupMask & G_RESERVED) {
                np = appendNode(np, parseIdentifier(cp));
            } else {
                np = appendNode(np, parsePropertyName(cp));
            }
            break;

        case T_AT:
            np = appendNode(np, parseAttributeName(cp));
            break;

        case T_SUPER:
            getToken(cp);
            np = appendNode(np, createNode(cp, N_SUPER, NULL));
            break;

        default:
            if (cp->token->groupMask & G_RESERVED) {
                np = appendNode(np, parseIdentifier(cp));
            } else {
                np = appendNode(np, parsePropertyName(cp));
            }
            break;
        }
        break;

    case T_LBRACKET:
        np = createNode(cp, N_DOT, NULL);
        np = appendNode(np, parseBrackets(cp));
        break;

    case T_DOT_DOT:
        getToken(cp);
        np = createNode(cp, N_DOT, NULL);
        name = parseQualifiedName(cp);
        if (name && name->kind == N_QNAME) {
            name->qname.name = ejsSprintf(cp->ejs, ".%@", name->qname.name);
        }
        np = appendNode(np, name);
        break;

    default:
        getToken(cp);
        np = parseError(cp, "Expecting property operator . .. or [");
        break;
    }
    return LEAVE(cp, np);
}


/*
    Brackets (125)
        [ ListExpression ]
        [ SliceExpression ]

    Input
        [

    AST
        N_EXPRESSIONS
 */
static EcNode *parseBrackets(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    //  TODO - not yet implementing SliceExpression
    if (getToken(cp) != T_LBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    }

    if (peekToken(cp) == T_COLON) {
        /*
            Slice expression
         */
        /* First optional expression in a slice expression is empty */
        np = parseOptionalExpression(cp);
        if (getToken(cp) != T_COLON) {
            np = parseError(cp, "Expecting \":\"");
        }
        np = appendNode(np, parseOptionalExpression(cp));

    } else {

        np = parseListExpression(cp);

        if (peekToken(cp) == T_COLON) {
            /*
                Slice expression
             */
            np = appendNode(np, parseOptionalExpression(cp));
            if (peekToken(cp) != T_COLON) {
                getToken(cp);
                np = parseError(cp, "Expecting \":\"");
            }
            np = appendNode(np, parseOptionalExpression(cp));
        }
    }

    if (getToken(cp) != T_RBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    }
    return LEAVE(cp, np);
}


/*
    TypeApplication (120)
        .< TypeExpressionList >

    Input
        .<

    AST
 */
#if FUTURE
/*
    SliceExpression (121)
        OptionalExpression : OptionalExpression
        OptionalExpression : OptionalExpression : OptionalExpression

    Input

    AST
 */
static EcNode *parseSliceExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    OptionalExpression (123)
        ListExpression -allowin-
        EMPTY

    Input

    AST
 */
static EcNode *parseOptionalExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseListExpression(cp);
    return LEAVE(cp, np);
}


/*
    MemberExpression (125) -a,b-
        PrimaryExpression -a,b-
        new MemberExpression Arguments
        SuperExpression PropertyOperator
        MemberExpression PropertyOperator

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseMemberExpression(EcCompiler *cp)
{
    EcNode      *np, *newNode;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_SUPER:
        np = parseSuperExpression(cp);
        if (peekToken(cp) == T_DOT || cp->peekToken->tokenId == T_DOT_DOT ||
                cp->peekToken->tokenId == T_LBRACKET) {
            np = insertNode(parsePropertyOperator(cp), np, 0);
        }
        break;

    case T_NEW:
        getToken(cp);
        newNode = createNode(cp, N_NEW, NULL);
        newNode = appendNode(newNode, parseMemberExpression(cp));
        np = createNode(cp, N_NEW, NULL);
        np = appendNode(np, newNode);
        np = appendNode(np, parseArguments(cp));
        break;

    default:
        np = parsePrimaryExpression(cp);
        break;
    }
    while (np && (peekToken(cp) == T_DOT || cp->peekToken->tokenId == T_DOT_DOT ||
            cp->peekToken->tokenId == T_LBRACKET)) {
#if 1
        if (np->loc.lineNumber == cp->peekToken->loc.lineNumber) {
            np = insertNode(parsePropertyOperator(cp), np, 0);
        } else {
            break;
        }
#else
        np = insertNode(parsePropertyOperator(cp), np, 0);
#endif
    }
    return LEAVE(cp, np);
}


/*
    CallExpression (129) -a,b-
        MemberExpression Arguments
        CallExpression Arguments
        CallExpression PropertyOperator

    Input

    AST
        N_CALL

    "me" is to to an already parsed member expression
 */
static EcNode *parseCallExpression(EcCompiler *cp, EcNode *me)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;

    while (1) {
        peekToken(cp);
        if (me && me->loc.lineNumber != cp->peekToken->loc.lineNumber) {
            return LEAVE(cp, np);
        }
        switch (peekToken(cp)) {
        case T_LPAREN:
            np = createNode(cp, N_CALL, NULL);
            np = appendNode(np, me);
            np = appendNode(np, parseArguments(cp));
            if (np && cp->token) {
                np->loc.lineNumber = cp->token->loc.lineNumber;
            }
            break;

        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            if (me == 0) {
                getToken(cp);
                return LEAVE(cp, unexpected(cp));
            }
            np = insertNode(parsePropertyOperator(cp), me, 0);
            if (np && cp->token) {
                np->loc.lineNumber = cp->token->loc.lineNumber;
            }
            break;

        default:
            if (np == 0) {
                getToken(cp);
                return LEAVE(cp, unexpected(cp));
            }
            return LEAVE(cp, np);
        }
        if (np == 0) {
            return LEAVE(cp, np);
        }
        me = np;
    }
    return LEAVE(cp, np);
}


/*
    NewExpression (132)
        MemberExpression
        new NewExpression

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseNewExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_NEW) {
        getToken(cp);
        np = createNode(cp, N_NEW, NULL);
        np = appendNode(np, parseNewExpression(cp));

    } else {
        np = parseMemberExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    LeftHandSideExpression (134) -a,b-
        NewExpression
        CallExpression

    Where NewExpression is:
        MemberExpression
        new NewExpression

    Where CallExpression is:
        MemberExpression Arguments
        CallExpression Arguments
        CallExpression PropertyOperator

    Where MemberExpression is:
        PrimaryExpression -a,b-
        new MemberExpression Arguments
        SuperExpression PropertyOperator
        MemberExpression PropertyOperator

    So look ahead problem on MemberExpression. We don't know if it is a newExpression or a CallExpression. This requires
    large lookahead. So, refactored to be:

    LeftHandSideExpression (136) -a,b-
        new MemberExpression LeftHandSidePrime
        MemberExpression LeftHandSidePrime

    and where LeftHandSidePrime is:
        Arguments LeftHandSidePrime
        PropertyOperator LeftHandSidePrime
        EMPTY

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    Also:
        new MemberExpression
        MemberExpression
        MemberExpression (
        MemberExpression .
        MemberExpression ..
        MemberExpression [

    AST
        N_CALL
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseLeftHandSideExpression(EcCompiler *cp)
{
    EcNode      *np, *callNode;

    ENTER(cp);

    if (peekToken(cp) == T_NEW) {
        np = parseNewExpression(cp);
    } else {
        np = parseMemberExpression(cp);
    }
    if (np) {
        /*
            Refactored CallExpression processing
         */
        switch (peekToken(cp)) {
        case T_LPAREN:
        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            if (cp->token->loc.lineNumber == cp->peekToken->loc.lineNumber) {
                /*
                    May have multiline function expression: x = (function ..... multiple lines)() 
                 */
                np->loc.lineNumber = cp->token->loc.lineNumber;
                np = parseCallExpression(cp, np);
            }
            break;

        default:
            if (np->kind == N_NEW) {
                /*
                    Create a dummy call to the constructor
                 */
                callNode = createNode(cp, N_CALL, NULL);
                np = appendNode(callNode, np);
                np = appendNode(np, createNode(cp, N_ARGS, NULL));
            }
            break;
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    LeftHandSidePrime (psudo) -a,b-
        Arguments LeftHandSidePrime
        PropertyOperator LeftHandSidePrime
        EMPTY

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseLeftHandSidePrime(EcCompiler *cp, EcNode *np)
{
    EcNode      *callNode;

    ENTER(cp);

    do {
        switch (peekToken(cp)) {
        case T_LPAREN:
#if UNUSED
            callNode = createNode(cp, N_CALL, NULL);
            np = appendNode(callNode, np);
            np = appendNode(np, parseArguments(cp));
#endif
            break;

        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            np = appendNode(np, parsePropertyOperator(cp));
            break;

        default:
            return LEAVE(cp, np);
        }

    } while (np);

    return LEAVE(cp, np);
}
#endif


/*
    UnaryTypeExpression (136)
        LeftHandSideExpression
        type NullableTypeExpression

    Input
        type

    AST
 */
static EcNode *parseUnaryTypeExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    if (peekToken(cp) == T_TYPE) {
        getToken(cp);
        np = parseNullableTypeExpression(cp);
    } else {
        np = parseLeftHandSideExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    PostfixExpression (138)
        UnaryTypeExpression
        LeftHandSideExpression [no line break] ++
        LeftHandSideExpression [no line break] --

    Input

    AST
 */
static EcNode *parsePostfixExpression(EcCompiler *cp)
{
    EcNode      *parent, *np;

    ENTER(cp);

    if (peekToken(cp) == T_TYPE) {
        np = parseUnaryTypeExpression(cp);
    } else {
        np = parseLeftHandSideExpression(cp);
        if (np) {
            if (peekToken(cp) == T_PLUS_PLUS || cp->peekToken->tokenId == T_MINUS_MINUS) {
                getToken(cp);
                parent = createNode(cp, N_POSTFIX_OP, NULL);
                np = appendNode(parent, np);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    UnaryExpression (141)
        PostfixExpression
        delete PostfixExpression
        void UnaryExpression
        typeof UnaryExpression
        ++ PostfixExpression
        -- PostfixExpression
        + UnaryExpression
        - UnaryExpression
        ~ UnaryExpression           (bitwise not)
        ! UnaryExpression

    Input

    AST
 */
static EcNode *parseUnaryExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_DELETE:
    case T_LOGICAL_NOT:
    case T_PLUS:
    case T_PLUS_PLUS:
    case T_MINUS:
    case T_MINUS_MINUS:
    case T_TILDE:
    case T_TYPEOF:
    case T_VOID:
        getToken(cp);
        np = createNode(cp, N_UNARY_OP, NULL);
        np = appendNode(np, parseUnaryExpression(cp));
        break;

    default:
        np = parsePostfixExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    MultiplicativeExpression (152) -a,b-
        UnaryExpression
        MultiplicativeExpression * UnaryExpression
        MultiplicativeExpression / UnaryExpression
        MultiplicativeExpression % UnaryExpression

    Input

    AST
 */
static EcNode *parseMultiplicativeExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);
    
    np = parseUnaryExpression(cp);
    while (np) {
        switch (peekToken(cp)) {
        case T_MUL:
        case T_DIV:
        case T_MOD:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseUnaryExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    assert(cp > 0);
    return LEAVE(cp, np);
}


/*
    AdditiveExpression (156)
        MultiplicativeExpression
        AdditiveExpression + MultiplicativeExpression
        AdditiveExpression - MultiplicativeExpression

    Input

    AST
 */
static EcNode *parseAdditiveExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;
    
    ENTER(cp);

    np = parseMultiplicativeExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_PLUS:
        case T_MINUS:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseMultiplicativeExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    ShiftExpression (159) -a,b-
        AdditiveExpression
        ShiftExpression << AdditiveExpression
        ShiftExpression >> AdditiveExpression
        ShiftExpression >>> AdditiveExpression

    Input

    AST
 */
static EcNode *parseShiftExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseAdditiveExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LSH:
        case T_RSH:
        case T_RSH_ZERO:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseAdditiveExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    RelationalExpression (163) -allowin-
        ShiftExpression
        RelationalExpression < ShiftExpression
        RelationalExpression > ShiftExpression
        RelationalExpression <= ShiftExpression
        RelationalExpression >= ShiftExpression
        RelationalExpression [in] ShiftExpression
        RelationalExpression instanceOf ShiftExpression
        RelationalExpression cast ShiftExpression
        RelationalExpression to ShiftExpression
        RelationalExpression is ShiftExpression
        RelationalExpression like ShiftExpression

    Input

    AST
 */
static EcNode *parseRelationalExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseShiftExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_IN:
            if (cp->state->noin) {
                return LEAVE(cp, np);
            }
            /* Fall through */

        case T_LT:
        case T_LE:
        case T_GT:
        case T_GE:
        case T_INSTANCEOF:
        case T_IS:
        case T_CAST:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseShiftExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    EqualityExpression (182)
        RelationalExpression
        EqualityExpression == RelationalExpression
        EqualityExpression != RelationalExpression
        EqualityExpression === RelationalExpression
        EqualityExpression !== RelationalExpression

    Input

    AST
 */
static EcNode *parseEqualityExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseRelationalExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_EQ:
        case T_NE:
        case T_STRICT_EQ:
        case T_STRICT_NE:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseRelationalExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseAndExpression (187)
        EqualityExpression
        BitwiseAndExpression & EqualityExpression

    Input

    AST
 */
static EcNode *parseBitwiseAndExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseEqualityExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_AND:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseEqualityExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseXorExpression (189)
        BitwiseAndExpression
        BitwiseXorExpression ^ BitwiseAndExpression

    Input

    AST
 */
static EcNode *parseBitwiseXorExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseAndExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_XOR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseBitwiseAndExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseOrExpression (191)
        BitwiseXorExpression
        BitwiseOrExpression | BitwiseXorExpression

    Input

    AST
 */
static EcNode *parseBitwiseOrExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseXorExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_OR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseBitwiseXorExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    LogicalAndExpression (193)
        BitwiseOrExpression
        LogicalAndExpression && BitwiseOrExpression

    Input

    AST
 */
static EcNode *parseLogicalAndExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseOrExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LOGICAL_AND:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseBitwiseOrExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    LogicalOrExpression (195)
        LogicalAndExpression
        LogicalOrExpression || LogicalOrExpression

    Input

    AST
 */
static EcNode *parseLogicalOrExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseLogicalAndExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LOGICAL_OR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP, NULL);
            np = createBinaryNode(cp, np, parseLogicalOrExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    ConditionalExpression (197) -allowList,b-
        LetExpression -b-
        YieldExpression -b-
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    ConditionalExpression (197) -noList,b-
        SimpleYieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    Input
        let
        yield
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        delete
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_EXPRESSIONS
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseConditionalExpression(EcCompiler *cp)
{
    EcNode      *np, *cond;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LET:
        np = parseLetExpression(cp);
        break;

    case T_YIELD:
        np = parseYieldExpression(cp);
        break;

    default:
        np = parseLogicalOrExpression(cp);
        if (np) {
            if (peekToken(cp) == T_QUERY) {
                getToken(cp);
                cond = np;
                np = createNode(cp, N_IF, NULL);
                np->tenary.cond = linkNode(np, cond);
                np->tenary.thenBlock = linkNode(np, parseAssignmentExpression(cp));
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    np->tenary.elseBlock = linkNode(np, parseAssignmentExpression(cp));
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    NonAssignmentExpression -allowList,b- (199)
        LetExpression
        YieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    NonAssignmentExpression -noList,b-
        SimpleYieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    Input

    AST
 */
static EcNode *parseNonAssignmentExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LET:
        np = parseLetExpression(cp);
        break;

    case T_YIELD:
        np = parseYieldExpression(cp);
        break;

    default:
        np = parseLogicalOrExpression(cp);
        if (np) {
            if (peekToken(cp) == T_QUERY) {
                getToken(cp);
                np = parseAssignmentExpression(cp);
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    np = parseAssignmentExpression(cp);
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    LetExpression (204)
        let ( LetBindingList ) ListExpression

    Input
        let

    AST
 */
static EcNode *parseLetExpression(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    
    if (getToken(cp) != T_LET) {
        return LEAVE(cp, expected(cp, "let"));
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = parseLetBindingList(cp);
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    //  TODO - was return 0
    return np;
}


/*
    LetBindingList (205)
        EMPTY
        NonemptyLetBindingList -allowList-

    Input

    AST
 */
static EcNode *parseLetBindingList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


#if UNUSED
/*
    NonemptyLetBindingList (207) -a-
        VariableBinding -a,allowin-
        VariableBinding -noList,allowin- , NonemptyLetBindingList -a-

    Input

    AST
 */
static EcNode *parseNonemptyLetBindingList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    YieldExpression (209)
        yield
        yield [no line break] ListExpression

    Input

    AST
 */
static EcNode *parseYieldExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    Rewrite compound assignment. Eg. given x += 3  rewrite as
        x = x + 3;
 */
static EcNode *rewriteCompoundAssignment(EcCompiler *cp, int subId, EcNode *lhs, EcNode *rhs)
{
    EcNode      *np, *parent;

    ENTER(cp);

    /*
        Map the operator token to its non-assignment counterpart
     */
    np = createNode(cp, N_BINARY_OP, NULL);
    np->tokenId = subId - 1;

    np = appendNode(np, lhs);
    np = appendNode(np, rhs);
    parent = createNode(cp, N_ASSIGN_OP, NULL);
    np = createAssignNode(cp, lhs, np, parent);

    return LEAVE(cp, np);
}


static void fixDassign(EcCompiler *cp, EcNode *np)
{
    EcNode      *elt;
    int         next;
    
    for (next = 0; (elt = mprGetNextItem(np->children, &next)) != 0 && !cp->error; ) {
        fixDassign(cp, elt);
    }
    if (np->kind == N_OBJECT_LITERAL) {
        np->kind = N_DASSIGN;
        np->kindName = "n_dassign";
    } else if (np->kind == N_FIELD) {
        if (np->field.expr) {
            fixDassign(cp, np->field.expr);
        }
    }
}


/*
    AssignmentExpression (211)
        ConditionalExpression
        Pattern -a,b-allowin- = AssignmentExpression -a,b-
        SimplePattern -a,b-allowExpr- CompoundAssignmentOperator
                AssignmentExpression -a,b-

    Where
        SimplePattern is:
            LeftHandSideExpression -a,b-
            Identifier
        ConditionalExpression is:
            LetExpression -b-
            YieldExpression -b-
            LogicalOrExpression -a,b-

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new
        let
        yield

    AST
        N_CALL
        N_EXPRESSIONS
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
        N_DELETE
 */

static EcNode *parseAssignmentExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;
    int         subId;

    ENTER(cp);

    np = parseConditionalExpression(cp);
    if (np) {
        if (peekToken(cp) == T_ASSIGN) {
            getToken(cp);
            if (np->kind == N_OBJECT_LITERAL || np->kind == N_EXPRESSIONS) {
                fixDassign(cp, np );
            }
            subId = cp->token->subId;
            if (cp->token->groupMask & G_COMPOUND_ASSIGN) {
                np = rewriteCompoundAssignment(cp, subId, np, parseAssignmentExpression(cp));

            } else {
                parent = createNode(cp, N_ASSIGN_OP, NULL);
                np = createAssignNode(cp, np, parseAssignmentExpression(cp), parent);
            }
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TODO - refactored
    CompoundAssignmentOperator (227)
        *=
        /=
        %=
        +=
        -=
        <<=
        >>=
        >>>=
        &=
        ^=
        |=
        &&=
        ||=

    Input (see above)

    AST
 */
static EcNode *parseCompoundAssignmentOperator(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    ListExpression (227)
        AssignmentExpression -allowList,b-
        ListExpression -b- , AssignmentExpression -allowList,b-

    Input
        x = ...

    AST
        N_EXPRESSIONS
 */
static EcNode *parseListExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_EXPRESSIONS, NULL);
    assert(np);
    do {
        np = appendNode(np, parseAssignmentExpression(cp));
    } while (np && getToken(cp) == T_COMMA);
    if (np) {
        putToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    Pattern -a,b,g- (231)
        SimplePattern -a,b-g-
        ObjectPattern
        ArrayPattern

    Input
        Identifier
        {
        [

    AST
 */
static EcNode *parsePattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LBRACKET:
        np = parseArrayPattern(cp);
        break;

    case T_LBRACE:
        np = parseObjectPattern(cp);
        break;

    default:
        np = parseSimplePattern(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    SimplePattern -a,b,noExpr- (232)
        Identifier

    SimplePattern -a,b,noExpr- (233)
        LeftHandSideExpression -a,b-

    Input

    AST
        N_QNAME
        N_LIST_EXPRESSION
 */
static EcNode *parseSimplePattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseLeftHandSideExpression(cp);
    if (np == 0 && peekToken(cp) == T_ID) {
        np = parseIdentifier(cp);
    }
    return LEAVE(cp, np);
}


/*
    ObjectPattern -g- (234)
        { FieldListPattern }

    Input

    AST
 */
static EcNode *parseObjectPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    if (getToken(cp) != T_LBRACE) {
        return LEAVE(cp, expected(cp, "{"));
    }
    np = parseFieldListPattern(cp);
    if (getToken(cp) != T_RBRACE) {
        return LEAVE(cp, expected(cp, "}"));
    }
    return LEAVE(cp, np);
}


/*
    FieldListPattern -g- (248)
        EMPTY
        FieldPattern
        FieldPattern , FieldPattern

    Input

    AST
 */
static EcNode *parseFieldListPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_DASSIGN, NULL);
    while (1) {
        np = appendNode(np, parseFieldPattern(cp, np));
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
        } else {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    FieldPattern -g- (251)
        FieldName
        FieldName : Pattern -noList,allowin,g-

    Input

    AST
 */
static EcNode *parseFieldPattern(EcCompiler *cp, EcNode *np)
{
    EcNode      *typeNode, *elt;

    ENTER(cp);
    elt = parseFieldName(cp);
    np = appendNode(np, elt);
    if (peekToken(cp) == ':') {
        getToken(cp);
        typeNode = parsePattern(cp);
        if (typeNode) {
            elt->typeNode = linkNode(np, typeNode);
        }
    }
    return LEAVE(cp, np);
}


/*
    ArrayPattern (240)
        [ ElementListPattern ]

    Input

    AST
 */
static EcNode *parseArrayPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    if (getToken(cp) != T_LBRACKET) {
        return LEAVE(cp, expected(cp, "["));
    }
    np = parseElementListPattern(cp);
    if (getToken(cp) != T_RBRACKET) {
        return LEAVE(cp, expected(cp, "]"));
    }
    return LEAVE(cp, np);
}


/*
    ElementListPattern -g- (253)
        EMPTY
        ElementPattern
        , ElementListPattern
        ElementPattern , ElementListPattern

    Input

    AST
 */
static EcNode *parseElementListPattern(EcCompiler *cp)
{
    EcNode      *np, *elt;
    int         index;

    ENTER(cp);
    
    np = createNode(cp, N_DASSIGN, NULL);
    np->objectLiteral.isArray = 1;
    
    for (index = 0; np; index++) {
        if (peekToken(cp) != T_COMMA) {
            elt = createNode(cp, N_FIELD, NULL);
            elt->attributes |= EJS_TRAIT_READONLY;
            elt->field.varKind = KIND_CONST;
            elt->field.fieldKind = FIELD_KIND_VALUE;
            elt->field.expr = linkNode(np, parsePattern(cp));
            elt->qname.name = elt->field.expr->qname.name;
            elt->field.index = index;
            np = appendNode(np, elt);
        }
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
        } else {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    TypedIdentifier (258)
        SimplePattern -noList,noin,noExpr-
        SimplePattern -a,b,noExpr- : TypeExpression

    Input

    AST
 */
static EcNode *parseTypedIdentifier(EcCompiler *cp)
{
    EcNode      *np, *typeNode;

    ENTER(cp);

    np = parseSimplePattern(cp);

    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        typeNode = parseNullableTypeExpression(cp);
        if (typeNode) {
            np->typeNode = linkNode(np, typeNode);
            /* Accumulate EJS_TRAIT_MATCH | EJS_TRAIT_NULLABLE */
            np->attributes |= typeNode->attributes;
        } else {
            np = parseError(cp, "Expecting type");
        }
    }
    return LEAVE(cp, np);
}


/*
    TypedPattern (248)
        SimplePattern -a,b,noExpr-
        SimplePattern -a,b,noExpr- : NullableTypeExpression
        ObjectPattern -noExpr-
        ObjectPattern -noExpr- : TypeExpression
        ArrayPattern -noExpr-
        ArrayPattern -noExpr- : TypeExpression

    Input

    AST
 */
static EcNode *parseTypedPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = parseSimplePattern(cp);
    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        np->typeNode = linkNode(np, parseNullableTypeExpression(cp));
    }
    if (np && np->kind != N_QNAME) {
        return LEAVE(cp, unexpected(cp));
    }
    return LEAVE(cp, np);
}


/*
    NullableTypeExpression (266)
        null
        undefined
        TypeExpression
        TypeExpression ?    # Nullable
        TypeExpression !    # Non-Nullable (throws)
        TypeExpression ~    # Cast nulls

    Input

    AST
 */
static EcNode *parseNullableTypeExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_NULL:
    case T_UNDEFINED:
        np = createNode(cp, N_QNAME, tokenString(cp));
        np->name.isType = 1;
        break;

    default:
        np = parseTypeExpression(cp);
        if (peekToken(cp) == T_QUERY) {
            /* Allow Nulls */
            getToken(cp);
        } else if (cp->peekToken->tokenId == T_LOGICAL_NOT) {
            /* Don't allow nulls */
            getToken(cp);
            np->attributes |= EJS_TRAIT_THROW_NULLS;
        } else if (cp->peekToken->tokenId == T_TILDE) {
            /* Cast nulls to type */
            getToken(cp);
            np->attributes |= EJS_TRAIT_CAST_NULLS;
        } else {
            /* Default is same as Type! */
            np->attributes |= EJS_TRAIT_THROW_NULLS;
        }
        break;
    }
    return LEAVE(cp, np);
}


/*
    TypeExpression (271)
        FunctionType
        UnionType
        RecordType
        ArrayType
        PrimaryName

    Input
        function
        (
        {
        [
        Identifier

    AST
        N_QNAME
        N_DOT
 */
static EcNode *parseTypeExpression(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;

    ENTER(cp);

    ejs = cp->ejs;

    switch (peekToken(cp)) {
#if UNUSED
    case T_FUNCTION:
        np = appendNode(np, parseFunctionType(cp));
        break;

    case T_LPAREN:
        np = appendNode(np, parseUnionType(cp));
        break;

    case T_LBRACE:
        np = appendNode(np, parseRecordType(cp));
        break;

    case T_LBRACKET:
        appendNode(np, parseFunctionType(cp));
        break;
#endif

    case T_MUL:
        getToken(cp);
        np = createNode(cp, N_QNAME, EST(Object)->qname.name);
        np->name.isType = 1;
        break;

    case T_STRING:
    case T_ID:
        np = parsePrimaryName(cp);
        if (np) {
            np->name.isType = 1;
        }
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    FunctionType (276)
        function FunctionSignatureType

    Input sequnces
        function ...

    AST
 */
static EcNode *parseFunctionType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    FunctionSignatureType (277)
        TypeParameters ( ParametersType ) ResultType
        TypeParameters ( this : PrimaryName ) ResultType
        TypeParameters ( this : PrimaryName , NonemptyParameters )
                ResultType

    Input sequnces
        function ...

    AST
 */
static EcNode *parseFunctionSignatureType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    ParametersType (280)
        EMPTY
        NonemptyParametersType

    Input

    AST
 */
static EcNode *parseParametersType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    NonemptyParametersType (282)
        ParameterInitType
        ParameterInitType , NonemptyParametersType
        RestParameterType

    Input

    AST
 */
static EcNode *parseNonemptyParametersType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    ParameterInitType (285)
        ParameterType
        ParameterType =

    Input

    AST
 */
static EcNode *parseParameterInitType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    RestParameterType (288)
        ...
        ... ParameterType

    Input
        ...

    AST
 */
static EcNode *parseRestParameterType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    UnionType (290)
        ( TypeExpressionList )

    Input
        (

    AST
 */
static EcNode *parseUnionType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    RecordType (291)
        { FieldTypeList }

    Input
        {

    AST
 */
static EcNode *parseRecordType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    FieldTypeList (292)
        EMPTY
        NonemptyFieldTypeList

    Input

    AST
 */
static EcNode *parseFieldTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    NonemptyFieldTypeList (294)
        FieldType
        FieldType , NonemptyFieldTypeList

    Input

    AST
 */
static EcNode *parseNonemptyFieldTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    FieldType (296)
        FieldName : NullableTypeExpression

    Input

    AST
 */
static EcNode *parseFieldType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    ArrayType (297)
        [ ElementTypeList ]

    Input

    AST
 */
static EcNode *parseArrayType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LBRACKET) {
        np = expected(cp, "[");
    } else {
        np = parseElementTypeList(cp);
        if (np) {
            if (getToken(cp) != T_LBRACKET) {
                np = expected(cp, "[");
            }
        }
    }

    return LEAVE(cp, np);
}


/*
    ElementTypeList (298)
        EMPTY
        NullableTypeExpression
        , ElementTypeList
        NullableTypeExpression , ElementTypeList

    Input

    AST
 */
static EcNode *parseElementTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


#if FUTURE
/*
    TypeExpressionList (302)
        NullableTypeExpression
        TypeExpressionList , NullableTypeExpression

    Input

    AST
 */
static EcNode *parseTypeExpressionList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Statement (289) -t,o-
        Block -t-
        BreakStatement Semicolon -o-
        ContinueStatement Semicolon -o-
        DefaultXMLNamespaceStatement Semicolon -o-
        DoStatement Semicolon -o-
        ExpresssionStatement Semicolon -o-
        ForStatement -o-
        IfStatement -o-
        LabeledStatement -o-
        LetStatement -o-
        ReturnStatement Semicolon -o-
        SwitchStatement
        SwitchTypeStatement
        ThrowStatement Semicolon -o-
        TryStatement
        WhileStatement -o-
        WithStatement -o-

    Input
        EMPTY
        {
        (
        .
        ..
        [
        (
        @
        break
        continue
        ?? DefaultXML
        do
        for
        if
        let
        return
        switch
        throw
        try
        while
        with
        null
        true
        false
        this
        function
        Identifier
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_HASH
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE

 */
static EcNode *parseStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         expectSemi, tid;

    ENTER(cp);

    expectSemi = 0;
    np = 0;

    switch ((tid = peekToken(cp))) {
    case T_AT:
    case T_DELETE:
    case T_DIV:
    case T_DOT:
    case T_DOT_DOT:
    case T_FALSE:
    case T_FUNCTION:
    case T_LBRACKET:
    case T_LOGICAL_NOT:
    case T_LPAREN:
    case T_MINUS_MINUS:
    case T_NEW:
    case T_NUMBER:
    case T_NULL:
    case T_PLUS_PLUS:
    case T_STRING:
    case T_SUPER:
    case T_THIS:
    case T_TRUE:
    case T_TYPEOF:
    case T_RESERVED_NAMESPACE:
    case T_REQUIRE:                             /* require used as an identifier */
        np = parseExpressionStatement(cp);
        expectSemi++;
        break;

    case T_BREAK:
        np = parseBreakStatement(cp);
        expectSemi++;
        break;

    case T_CONTINUE:
        np = parseContinueStatement(cp);
        expectSemi++;
        break;

    case T_DO:
        np = parseDoStatement(cp);
        expectSemi++;
        break;

    case T_FOR:
        np = parseForStatement(cp);
        break;

    case T_HASH:
        np = parseHashStatement(cp);
        break;

    case T_ID:
        if (tid == T_ID && peekAheadToken(cp, 2) == T_COLON) {
            np = parseLabeledStatement(cp);
        } else {
            np = parseExpressionStatement(cp);
            expectSemi++;
        }
        break;

    case T_IF:
        np = parseIfStatement(cp);
        break;

    case T_LBRACE:
        np = parseBlockStatement(cp);
        break;

    case T_LET:
        np = parseLetStatement(cp);
        break;

    case T_RETURN:
        np = parseReturnStatement(cp);
        expectSemi++;
        break;

    case T_SWITCH:
        np = parseSwitchStatement(cp);
        break;

    case T_THROW:
        np = parseThrowStatement(cp);
        expectSemi++;
        break;

    case T_TRY:
        np = parseTryStatement(cp);
        break;

    case T_WHILE:
        np = parseWhileStatement(cp);
        break;

    case T_WITH:
        np = parseWithStatement(cp);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }

    if (np && expectSemi) {
        if (getToken(cp) != T_SEMICOLON) {
            if (np->loc.lineNumber < cp->token->loc.lineNumber || cp->token->tokenId == T_EOF || 
                    cp->token->tokenId == T_NOP || cp->token->tokenId == T_RBRACE) {
                putToken(cp);
            } else {
                np = unexpected(cp);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    Substatement -o- (320)
        EmptyStatement
        Statement -o-

    Statement:
        Block -t-
        BreakStatement Semicolon -o-
        ContinueStatement Semicolon -o-
        DefaultXMLNamespaceStatement Semicolon -o-
        DoStatement Semicolon -o-
        ExpresssionStatement Semicolon -o-
        ForStatement -o-
        IfStatement -o-
        LabeledStatement -o-
        LetStatement -o-
        ReturnStatement Semicolon -o-
        SwitchStatement
        SwitchTypeStatement
        ThrowStatement Semicolon -o-
        TryStatement
        WhileStatement -o-
        WithStatement -o-

    Input
        EMPTY
        {
        (
        .
        ..
        [
        (
        @
        break
        continue
        ?? DefaultXML
        do
        for
        if
        let
        return
        switch
        throw
        try
        while
        with
        null
        true
        false
        this
        function
        Identifier
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_NOP
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE
 */

static EcNode *parseSubstatement(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    np = 0;

    /*
        TODO: Missing: DefaultXML
     */
    switch ((tid = peekToken(cp))) {
    case T_AT:
    case T_BREAK:
    case T_CONTINUE:
    case T_DELETE:
    case T_DO:
    case T_DOT:
    case T_DOT_DOT:
    case T_FALSE:
    case T_FOR:
    case T_FUNCTION:
    case T_IF:
    case T_LBRACE:
    case T_LBRACKET:
    case T_LET:
    case T_LPAREN:
    case T_NEW:
    case T_NUMBER:
    case T_NULL:
    case T_RETURN:
    case T_STRING:
    case T_SUPER:
    case T_SWITCH:
    case T_THIS:
    case T_THROW:
    case T_TRUE:
    case T_TRY:
    case T_WHILE:
    case T_WITH:
        np = parseStatement(cp);
        break;

    case T_ID:
        if (peekAheadToken(cp, 2) == T_COLON) {
            /* Labeled expression */
            np = parseStatement(cp);
        } else {
            np = parseStatement(cp);
        }
        break;

    default:
        np = createNode(cp, N_NOP, NULL);
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    Semicolon -abbrev- (322)
        ;
        VirtualSemicolon
        EMPTY

    Semicolon -noshortif- (325)
        ;
        VirtualSemicolon
        EMPTY

    Input

    AST
 */
static EcNode *parseSemicolon(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    EmptyStatement (33)
        ;

    Input
        EMPTY

    AST
        N_NOP
 */
static EcNode *parseEmptyStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = createNode(cp, N_NOP, NULL);
    return LEAVE(cp, np);
}


/*
    ExpressionStatement (331)
        [lookahead !function,{}] ListExpression -allowin-

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        delete
        Identifier
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_DELETE
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_EXPRESSIONS
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseExpressionStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);
    tid = peekToken(cp);
    if (tid == T_FUNCTION || tid == T_LBRACE) {
        np = createNode(cp, 0, NULL);
    } else {
        np = parseListExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    BlockStatement (318)
        Block

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseBlockStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseBlock(cp);
    return LEAVE(cp, np);
}


/*
    LabeledStatement -o- (319)
        Identifier : Substatement

    Input

    AST
 */
static EcNode *parseLabeledStatement(EcCompiler *cp)
{
    getToken(cp);
    return parseError(cp, "Labeled statements are not yet implemented");
}


/*
    IfStatement -abbrev- (320)
        if ParenListExpression Substatement
        if ParenListExpression Substatement else Substatement

    IfStatement -full- (322)
        if ParenListExpression Substatement
        if ParenListExpression Substatement else Substatement

    IfStatement -noShortif- (324)
        if ParenListExpression Substatement else Substatement

    Input
        if ...

    AST
 */
static EcNode *parseIfStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_IF) {
        return LEAVE(cp, parseError(cp, "Expecting \"if\""));
    }
    if (peekToken(cp) != T_LPAREN) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    np = createNode(cp, N_IF, NULL);
    if ((np->tenary.cond = linkNode(np, parseParenListExpression(cp))) == 0) {
        return LEAVE(cp, 0);
    }
    if ((np->tenary.thenBlock = linkNode(np, parseSubstatement(cp))) == 0) {
        return LEAVE(cp, 0);
    }
    if (peekToken(cp) == T_ELSE) {
        getToken(cp);
        np->tenary.elseBlock = linkNode(np, parseSubstatement(cp));
    }
    return LEAVE(cp, np);
}


/*
    SwitchStatement (328)
        switch ParenListExpression { CaseElements }
        switch type ( ListExpression -allowList,allowin- : TypeExpression )
                { TypeCaseElements }

    Input
        switch ...

    AST
        N_SWITCH
            N_EXPRESSIONS           ( ListExpression )
            N_CASE_ELEMENTS
 */
static EcNode *parseSwitchStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_SWITCH, NULL);

    if (getToken(cp) != T_SWITCH) {
        np = unexpected(cp);
    } else {
        if (peekToken(cp) != T_TYPE) {
            np = appendNode(np, parseParenListExpression(cp));
            if (getToken(cp) != T_LBRACE) {
                np = parseError(cp, "Expecting \"{\"");
            } else {
                np = appendNode(np, parseCaseElements(cp));
                if (getToken(cp) != T_RBRACE) {
                    np = parseError(cp, "Expecting \"{\"");
                }
            }

        } else {
#if FUTURE
            //  switch type
            getToken(cp);
            if (getToken(cp) != T_LPAREN) {
                np = parseError(cp, "Expecting \"(\"");
            } else {
                x = parseListExpression(cp);
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    x = parseTypeExpression(cp);
                    if (getToken(cp) != T_RPAREN) {
                        np = parseError(cp, "Expecting \")\"");
                    } else  if (getToken(cp) != T_LBRACE) {
                        np = parseError(cp, "Expecting \"{\"");
                    } else {
                        x = parseTypeCaseElements(cp);
                        if (getToken(cp) != T_RBRACE) {
                            np = parseError(cp, "Expecting \"}\"");
                        }
                    }
                }
                parseListExpression(cp);
            }
#endif
        }
    }
    return LEAVE(cp, np);
}


/*
    CaseElements (342)
        EMPTY
        CaseLabel
        CaseLabel CaseElementsPrefix CaseLabel
        CaseLabel CaseElementsPrefix Directive -abbrev-

    Refactored as:
        EMPTY
        CaseLable Directives
        CaseElements

    Input
        case
        default

    AST
        N_CASE_ELEMENTS
            N_CASE_LABEL: kind, expression
 */
static EcNode *parseCaseElements(EcCompiler *cp)
{
    EcNode      *np, *caseLabel, *directives;

    ENTER(cp);

    np = createNode(cp, N_CASE_ELEMENTS, NULL);

    while (np && (peekToken(cp) == T_CASE || cp->peekToken->tokenId == T_DEFAULT)) {
        caseLabel = parseCaseLabel(cp);
        directives = createNode(cp, N_DIRECTIVES, NULL);
        caseLabel = appendNode(caseLabel, directives);

        while (caseLabel && directives && peekToken(cp) != T_CASE && cp->peekToken->tokenId != T_DEFAULT) {
            if (cp->peekToken->tokenId == T_RBRACE) {
                break;
            }
            directives = appendNode(directives, parseDirective(cp));
        }
        np = appendNode(np, caseLabel);
    }
    return LEAVE(cp, np);
}


#if UNUSED && NOT_REQUIRED
/*
    CaseElementsPrefix (346)
        EMPTY
        CaseElementsPrefix CaseLabel
        CaseElementsPrefix Directive -full-

    Input

    AST
 */
static EcNode *parseCaseElementsPrefix(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    CaseLabel (349)
        case ListExpression -allowin- :
        default :

    Input
        case .. :
        default :

    AST
        N_CASE_LABEL  kind, expression
 */
static EcNode *parseCaseLabel(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;

    if (peekToken(cp) == T_CASE) {
        getToken(cp);
        np = createNode(cp, N_CASE_LABEL, NULL);
        np->caseLabel.kind = EC_SWITCH_KIND_CASE;
        if ((np->caseLabel.expression = linkNode(np, parseListExpression(cp))) == 0) {
            return LEAVE(cp, np);
        }
    } else if (cp->peekToken->tokenId == T_DEFAULT) {
        getToken(cp);
        np = createNode(cp, N_CASE_LABEL, NULL);
        np->caseLabel.kind = EC_SWITCH_KIND_DEFAULT;
    }
    if (getToken(cp) != T_COLON) {
        np = expected(cp, ":");
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TypeCaseElements (351)
        TypeCaseElement
        TypeCaseElement TypeCaseElement

    Input

    AST
 */
static EcNode *parseTypeCaseElements(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    TypeCaseElement (353)
        case ( TypedPattern -noList,noIn- ) Block -local-
        default Block -local-

    Input

    AST
 */
static EcNode *parseTypeCaseElement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    DoStatement (355)
        do Substatement -abbrev- while ParenListExpresison

    Input
        do

    AST
        N_FOR
 */
static EcNode *parseDoStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_DO, NULL);

    if (getToken(cp) != T_DO) {
        return LEAVE(cp, unexpected(cp));
    }
    np->forLoop.body = linkNode(np, parseSubstatement(cp));

    if (getToken(cp) != T_WHILE) {
        np = expected(cp, "while");
    } else {
        np->forLoop.cond = linkNode(np, parseParenListExpression(cp));
    }
    return LEAVE(cp, np);
}


/*
    WhileStatement (356)
        while ParenListExpresison Substatement -o-

    Input
        while

    AST
        N_FOR
 */
static EcNode *parseWhileStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_WHILE) {
        return LEAVE(cp, parseError(cp, "Expecting \"while\""));
    }
    /*
        Convert into a "for" AST
     */
    np = createNode(cp, N_FOR, NULL);
    np->forLoop.cond = linkNode(np, parseParenListExpression(cp));
    np->forLoop.body = linkNode(np, parseSubstatement(cp));
    return LEAVE(cp, np);
}


/*
    ForStatement -o- (357)
        for ( ForInitializer ; OptionalExpression ; OptionalExpression )
                Substatement
        for ( ForInBinding in ListExpression -allowin- ) Substatement
        for each ( ForInBinding in ListExpression -allowin- ) Substatement

    Where:

    ForIntializer (360)
        EMPTY
        ListExpression -noin-
        VariableDefinition -noin-

    ForInBinding (363)
        Pattern -allowList,noIn,allowExpr-
        VariableDefinitionKind VariableBinding -allowList,noIn-

    VariableDefinition -b- (429)
        VariableDefinitionKind VariableBindingList -allowList,b-

    VariableDefinitionKind (430)
        const
        let
        let const
        var

    MemberExpression Input tokens
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    Input
        for ( 'const|let|let const|var' '[|{'

    AST
        N_FOR
        N_FOR_IN
 */
static EcNode *parseForStatement(EcCompiler *cp)
{
    EcNode      *np, *initializer, *body, *iterGet, *block, *callGet, *dot;
    Ejs         *ejs;
    int         each, forIn;

    ENTER(cp);

    ejs = cp->ejs;
    initializer = 0;
    np = 0;
    forIn = 0;
    each = 0;

    if (getToken(cp) != T_FOR) {
        return LEAVE(cp, parseError(cp, "Expecting \"for\""));
    }
    if (peekToken(cp) == T_EACH) {
        each++;
        getToken(cp);
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    if (peekToken(cp) == T_ID && peekAheadToken(cp, 2) == T_IN) {
        /*
            For in forces the variable to be a let scoped var
         */
        initializer = createNode(cp, N_VAR_DEFINITION, NULL);
        if (initializer) {
            initializer->def.varKind = KIND_LET;
            initializer = parseVariableBindingList(cp, initializer, 0);
        }

    } else if (peekToken(cp) == T_CONST || cp->peekToken->tokenId == T_LET || cp->peekToken->tokenId == T_VAR) {
        initializer = parseVariableDefinition(cp, 0);

    } else if (cp->peekToken->tokenId != T_SEMICOLON) {
        cp->state->noin = 1;
        initializer = parseListExpression(cp);
    }
    if (initializer == 0 && cp->error) {
        return LEAVE(cp, 0);
    }
    if (initializer && mprGetListLength(initializer->children) > 2) {
        return LEAVE(cp, parseError(cp, "Too many iteration variables"));
    }
    if (getToken(cp) == T_SEMICOLON) {
        forIn = 0;
        np = createNode(cp, N_FOR, NULL);
        np->forLoop.initializer = linkNode(np, initializer);
        if (peekToken(cp) != T_SEMICOLON) {
            np->forLoop.cond = linkNode(np, parseOptionalExpression(cp));
        }
        if (getToken(cp) != T_SEMICOLON) {
            np = parseError(cp, "Expecting \";\"");
        } else if (peekToken(cp) != T_RPAREN) {
            np->forLoop.perLoop = linkNode(np, parseOptionalExpression(cp));
        }

    } else if (cp->token->tokenId == T_IN) {
        forIn = 1;
        np = createNode(cp, N_FOR_IN, NULL);
        np->forInLoop.iterVar = linkNode(np, initializer);

        /*
            Create a "listExpression.get/values" node
         */
        dot = createNode(cp, N_DOT, NULL);
        iterGet = appendNode(dot, parseListExpression(cp));
        iterGet = appendNode(iterGet, createNameNode(cp, N(EJS_ITERATOR_NAMESPACE, (each) ? "getValues" : "get")));

        /*
            Create a call node for "get"
         */
        callGet = createNode(cp, N_CALL, NULL);
        callGet = appendNode(callGet, iterGet);
        callGet = appendNode(callGet, createNode(cp, N_ARGS, NULL));
        np->forInLoop.iterGet = linkNode(np, callGet);

        np->forInLoop.iterNext = linkNode(np, createNode(cp, N_NOP, NULL));

        if (np->forInLoop.iterVar == 0 || np->forInLoop.iterGet == 0) {
            return LEAVE(cp, 0);
        }

    } else {
        return LEAVE(cp, unexpected(cp));
    }
    if (getToken(cp) != T_RPAREN) {
        np = parseError(cp, "Expecting \")\"");
    }
    body = linkNode(np, parseSubstatement(cp));
    if (body == 0) {
        return LEAVE(cp, body);
    }

    /*
        Fixup the body block and move it outside the entire for loop.
     */
    if (body->kind == N_BLOCK) {
        block = body;
        body = removeNode(block, block->left);
    } else {
        block = createNode(cp, N_BLOCK, NULL);
    }
    if (forIn) {
        np->forInLoop.body = linkNode(np, body);
        np->forInLoop.each = each;
    } else {
        if (each) {
            return LEAVE(cp, parseError(cp, "\"for each\" can only be used with \"for .. in\""));
        }
        assert(np != body);
        np->forLoop.body = linkNode(np, body);
    }

    /*
        Now make the for loop node a child of the outer block. Block will initially be a child of np, so must re-parent first
     */
    assert(block != np);
    np = appendNode(block, np);
    return LEAVE(cp, np);
}


#if UNUSED
/*
    ForIntializer (360)
        EMPTY
        ListExpression -noin-
        VariableDefinition -noin-

    Input

    AST
 */
static EcNode *parseForInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    ForInBinding (363)
        Pattern -allowList,noIn,allowExpr-
        VariableDefinitionKind VariableBinding -allowList,noIn-

    Input

    AST
 */
static EcNode *parseForInBinding(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    HashStatement (EJS)
        # ListExpression

    Input
        # expression directive

    AST
        N_HASH
 */
static EcNode *parseHashStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_HASH) {
        return LEAVE(cp, parseError(cp, "Expecting \"#\""));
    }
    np = createNode(cp, N_HASH, NULL);
    np->hash.expr = linkNode(np, parseListExpression(cp));
    np->hash.body = linkNode(np, parseDirective(cp));
    return LEAVE(cp, np);
}


/*
    LetStatement (367)
        let ( LetBindingList ) Substatement -o-

    Input

    AST
 */
static EcNode *parseLetStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    WithStatement -o- (368)
        with ( ListExpression -allowin- ) Substatement -o-
        with ( ListExpression -allowin- : TypeExpression ) Substatement -o-

    Input

    AST
 */
static EcNode *parseWithStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_WITH) {
        return LEAVE(cp, expected(cp, "with"));
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = createNode(cp, N_WITH, NULL);
    np->with.object = linkNode(np, parseListExpression(cp));

    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    np->with.statement = linkNode(np, parseSubstatement(cp));
    return LEAVE(cp, np);
}


/*
    ContinueStatement (370)
        continue
        continue [no line break] Identifier

    Input
        continue

    AST
        N_CONTINUE
 */
static EcNode *parseContinueStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         lineNumber;

    ENTER(cp);

    if (getToken(cp) != T_CONTINUE) {
        np = expected(cp, "continue");
    } else {
        np = createNode(cp, N_CONTINUE, NULL);
        lineNumber = cp->token->loc.lineNumber;
        if (peekToken(cp) == T_ID && lineNumber == cp->peekToken->loc.lineNumber) {
            np = appendNode(np, parseIdentifier(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    BreakStatement (372)
        break
        break [no line break] Identifier

    Input
        break

    AST
        N_BREAK
 */
static EcNode *parseBreakStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         lineNumber;

    ENTER(cp);

    if (getToken(cp) != T_BREAK) {
        np = expected(cp, "break");
    } else {
        np = createNode(cp, N_BREAK, NULL);
        lineNumber = cp->token->loc.lineNumber;
        if (peekToken(cp) == T_ID && lineNumber == cp->peekToken->loc.lineNumber) {
            np = appendNode(np, parseIdentifier(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    ReturnStatement (374)
        return
        return [no line break] ListExpression -allowin-

    Input
        return ...

    AST
        N_RETURN
 */
static EcNode *parseReturnStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_RETURN) {
        np = unexpected(cp);
    } else {
        if (cp->state->currentFunctionNode == 0) {
            np = parseError(cp, "Return statement outside function");
        } else {
            np = createNode(cp, N_RETURN, NULL);
            if (peekToken(cp) != T_SEMICOLON && np->loc.lineNumber == cp->peekToken->loc.lineNumber) {
                np = appendNode(np, parseListExpression(cp));
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ThrowStatement (376)
        throw ListExpression -allowin-

    Input
        throw ...

    AST
 */
static EcNode *parseThrowStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_THROW) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_THROW, NULL);
    np = appendNode(np, parseListExpression(cp));
    return LEAVE(cp, np);
}


/*
    TryStatement (377)
        try Block -local- CatchClauses
        try Block -local- CatchClauses finally Block -local-
        try Block -local- finally Block -local-

    Input
        try ...

    AST
 */
static EcNode *parseTryStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    /*
        Just ignore try / catch for now
     */
    if (getToken(cp) != T_TRY) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_TRY, NULL);
    if (np) {
        np->exception.tryBlock = linkNode(np, parseBlock(cp));
        if (peekToken(cp) == T_CATCH) {
            np->exception.catchClauses = linkNode(np, parseCatchClauses(cp));
        }
        if (peekToken(cp) == T_FINALLY) {
            getToken(cp);
            np->exception.finallyBlock = linkNode(np, parseBlock(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    CatchClauses (380)
        CatchClause
        CatchClauses CatchClause

    Input
        catch
 */
static EcNode *parseCatchClauses(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_CATCH) {
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_CATCH_CLAUSES, NULL);
    do {
        np = appendNode(np, parseCatchClause(cp));
    } while (peekToken(cp) == T_CATCH);
    return LEAVE(cp, np);
}


/*
    CatchClause (382)
        catch ( Parameter ) Block -local-

    Input
        catch

    AST
        T_CATCH
 */
static EcNode *parseCatchClause(EcCompiler *cp)
{
    EcNode      *np, *block, *arg, *varDef, *assign, *name;

    ENTER(cp);


    if (getToken(cp) != T_CATCH) {
        return LEAVE(cp, unexpected(cp));
    }

    np = createNode(cp, N_CATCH, NULL);

    /*
        EJS enhancement: allow no (Parameter)
     */
    varDef = 0;
    arg = 0;
    if (peekToken(cp) == T_LPAREN) {
        getToken(cp);
        varDef = parseParameter(cp, 0);
        if (getToken(cp) != T_RPAREN) {
            return LEAVE(cp, unexpected(cp));
        }
        if (varDef) {
            assert(varDef->kind == N_VAR_DEFINITION);
            varDef->def.varKind = KIND_LET;
            arg = varDef->left;
            removeNode(varDef, arg);
            assert(arg->kind == N_QNAME);
            arg->kind = N_VAR;
            arg->name.varKind = KIND_LET;
            arg->kindName = "n_var";
            arg->qname.space = cp->state->nspace;

            /* Create assignment node */
            name = createNode(cp, N_QNAME, arg->qname.name);
            assign = appendNode(createNode(cp, N_ASSIGN_OP, NULL), name);
            assign = appendNode(assign, createNode(cp, N_CATCH_ARG, NULL));
            arg = appendNode(arg, assign);
            varDef = appendNode(varDef, arg);
#if UNUSED
            parent = createNode(cp, N_ASSIGN_OP, NULL);
            arg = createAssignNode(cp, arg, createNode(cp, N_CATCH_ARG, NULL), parent);
            varDef = appendNode(varDef, arg);
#endif
        }
    }
    np->catchBlock.arg = varDef;

    block = parseBlock(cp);
    if (block) {
        if (varDef) {
            block = insertNode(block, varDef, 0);
        }
    }
    np = appendNode(np, block);
    return LEAVE(cp, np);
}


/* -t- == global, class, interface, local */

/*
    Directives -t- (367)
        EMPTY
        DirectivesPrefix Directive -t,abbrev-

    Input
        #
        import
        use
        {
        (
        break
        continue
        ?? DefaultXML
        do
        ?? ExpressionS
        for
        if
        label :
        let
        new
        return
        switch
        throw
        try
        while
        with
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type
        module

    AST
        N_DIRECTIVES
 */
static EcNode *parseDirectives(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *saveState;
    EcState     *state;

    ENTER(cp);

    np = createNode(cp, N_DIRECTIVES, NULL);
    state = cp->state;
    state->topVarBlockNode = np;

    saveState = cp->directiveState;
    cp->directiveState = state;
    state->blockNestCount++;

    do {
        switch (peekToken(cp)) {
        case T_ERR:
            cp->directiveState = saveState;
            getToken(cp);
            return LEAVE(cp, unexpected(cp));

        case T_EOF:
            cp->directiveState = saveState;
            return LEAVE(cp, np);

        case T_REQUIRE:
            if (peekAheadToken(cp, 2) != T_ID && peekAheadToken(cp, 2) != T_STRING) {
                np = appendNode(np, parseDirective(cp));
            } else {
                np = appendNode(np, parseDirectivesPrefix(cp));
            }
            break;

        case T_USE:
            np = appendNode(np, parseDirectivesPrefix(cp));
            break;

        case T_RBRACE:
            if (state->blockNestCount == 1) {
                getToken(cp);
            }
            cp->directiveState = saveState;
            return LEAVE(cp, np);

        case T_SEMICOLON:
            getToken(cp);
            break;

        case T_ATTRIBUTE:
        case T_BREAK:
        case T_CLASS:
        case T_CONST:
        case T_CONTINUE:
        case T_DELETE:
        case T_DIV:
        case T_DO:
        case T_DOT:
        case T_FALSE:
        case T_FOR:
        case T_FINAL:
        case T_FUNCTION:
        case T_HASH:
        case T_ID:
        case T_IF:
        case T_INTERFACE:
        case T_MINUS_MINUS:
        case T_LBRACKET:
        case T_LBRACE:
        case T_LPAREN:
        case T_LET:
        case T_NAMESPACE:
        case T_NATIVE:
        case T_NEW:
        case T_LOGICAL_NOT:
        case T_NUMBER:
        case T_RESERVED_NAMESPACE:
        case T_RETURN:
        case T_PLUS_PLUS:
        case T_STRING:
        case T_SUPER:
        case T_SWITCH:
        case T_THIS:
        case T_THROW:
        case T_TRUE:
        case T_TRY:
        case T_TYPEOF:
        case T_VAR:
        case T_WHILE:
        case T_MODULE:
        case T_WITH:
            np = appendNode(np, parseDirective(cp));
            break;

        case T_NOP:
            if (state->blockNestCount == 1) {
                getToken(cp);
                break;
            } else {
                /*
                    NOP tokens are injected when reading from the console. If nested, eat all input and continue.
                 */
                ecResetInput(cp);
            }
            break;

        default:
            getToken(cp);
            np = unexpected(cp);
            cp->directiveState = saveState;
            return LEAVE(cp, np);
        }

        if (cp->error && !cp->fatalError) {
            np = ecResetError(cp, np, 1);
        }
    } while (np && (!cp->interactive || state->blockNestCount > 1));

    cp->directiveState = saveState;
    return LEAVE(cp, np);
}


/*
    DirectivesPrefix -t- (369)
        EMPTY
        Pragmas
        DirectivesPrefix Directive -t,full-

    Rewritten as:
        DirectivesPrefix

    Input
        use
        import

    AST
        N_PRAGMAS
 */
static EcNode *parseDirectivesPrefix(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_PRAGMAS, NULL);
    do {
        switch (peekToken(cp)) {
        case T_ERR:
            return LEAVE(cp, unexpected(cp));

        case T_EOF:
            return LEAVE(cp, np);

        case T_USE:
        case T_REQUIRE:
            np = parsePragmas(cp, np);
            break;

        default:
            return LEAVE(cp, np);
        }
        if (!(peekToken(cp) == T_REQUIRE && (peekAheadToken(cp, 2) == T_ID || peekAheadToken(cp, 2) == T_STRING))) {
            break;
        }
    } while (np);
    return LEAVE(cp, np);
}


/*
    Scan ahead and see if this is an annotatable directive
 */
static int isAttribute(EcCompiler *cp)
{
    int     i, tid;

    /*
        Assume we have just seen an ID. Handle the following patterns:
            nspace var
            nspace function
            nspace class
            nspace interface
            nspace let
            nspace const
            nspace type
            nspace namespace
            a.nspace namespace
            a.b.c.nspace::nspace namespace
     */
    for (i = 2; i < EC_MAX_LOOK_AHEAD + 2; i++) {
        peekAheadToken(cp, i);
        tid = cp->peekToken->tokenId;
        switch (tid) {
        case T_ATTRIBUTE:
        case T_CLASS:
        case T_CONST:
        case T_FUNCTION:
        case T_INTERFACE:
        case T_LET:
        case T_MUL:
        case T_NAMESPACE:
        case T_RESERVED_NAMESPACE:
        case T_TYPE:
        case T_VAR:
            return 1;

        case T_COLON_COLON:
        case T_DOT:
            break;

        default:
            return 0;
        }

        /*
            Just saw a "." or "::".  Make sure this is part of a PropertyName
         */
        tid = peekAheadToken(cp, ++i);
        if (tid != T_ID && tid != T_RESERVED_NAMESPACE && tid == T_MUL && tid != T_STRING && tid != T_NUMBER &&
                tid != T_LBRACKET && !(cp->peekToken->groupMask & G_RESERVED)) {
            return 0;
        }
    }
    return 0;
}


/*
    Directive -t,o- (372)
        EmptyStatement
        Statement
        AnnotatableDirective -t,o-

    Input
        #
        {
        break
        continue
        ?? DefaultXML
        do
        ?? Expressions
        for
        if
        label :
        let
        return
        switch
        throw
        try
        while
        with
        *
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type

    AST
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_HASH
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE
 */
static EcNode *parseDirective(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_EOF:
        getToken(cp);
        return LEAVE(cp, 0);

    case T_ERR:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));

    /* EmptyStatement */
    case T_SEMICOLON:
        getToken(cp);
        np = parseEmptyStatement(cp);
        break;

    /* Statement */
    /*
        TBD -- missing:
            - DefaultXMLNamespaceStatement
            - ExpressionStatement
            - LabeledStatement
     */
    case T_LBRACE:
    case T_BREAK:
    case T_CONTINUE:
    case T_DELETE:
    case T_DO:
    case T_FOR:
    case T_HASH:
    case T_IF:
    case T_RETURN:
    case T_SUPER:
    case T_SWITCH:
    case T_THROW:
    case T_TRY:
    case T_WHILE:
    case T_WITH:
        np = parseStatement(cp);
        break;

    case T_ID:
        if (isAttribute(cp)) {
            np = parseAnnotatableDirective(cp, 0);
        } else {
            np = parseStatement(cp);
        }
        break;

    case T_RESERVED_NAMESPACE:
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            np = parseStatement(cp);
            break;
        }
        /* Fall through */
                
    /* AnnotatableDirective */
    case T_ATTRIBUTE:
    case T_CLASS:
    case T_CONST:
    case T_FUNCTION:
    case T_INTERFACE:
    case T_LET:
    case T_MUL:
    case T_NAMESPACE:
    case T_TYPE:
    case T_MODULE:
    case T_VAR:
        np = parseAnnotatableDirective(cp, 0);
        break;

    case T_STRING:
        //  TDOO - should we test let ...?
        if (peekAheadToken(cp, 2) == T_VAR || peekAheadToken(cp, 2) == T_CLASS || peekAheadToken(cp, 2) == T_FUNCTION) {
            np = parseAnnotatableDirective(cp, 0);
        } else {
            np = parseStatement(cp);
        }
        break;

#if FUTURE
    /* IncludeDirective */
    case T_INCLUDE:
        np = parseIncludeStatement(cp);
        break;
#endif

    default:
        np = parseStatement(cp);
    }
    return LEAVE(cp, np);
}


/*
    AnnotatableDirective -global,o- (375)
        Attributes [no line break] AnnotatableDirective -t,o-
        VariableDefinition -allowin- Semicolon -o-
        FunctionDefinition -global-
        ClassDefinition
        InterfaceDefintion
        NamespaceDefinition Semicolon -o-
        TypeDefinition Semicolon
        PackageDefinition
        ModuleDefinition

    AnnotatableDirective -interface,o- (384)
        Attributes [no line break] AnnotatableDirective -t,o-
        FunctionDeclaration Semicolon -o-
        TypeDefinition Semicolon -o-

    AnnotatableDirective -t,o- (387)
        Attributes [no line break] AnnotatableDirective -t,o-
        VariableDefinition -allowin- Semicolon -o-
        FunctionDeclaration -t-
        NamespaceDefintion Semicolon -o-
        TypeDefinition Semicolon -o-

    Input
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type
        module
        package

    AST
        N_CLASS
        N_FUNCTION
        N_QNAME
        N_NAMESPACE
        N_VAR_DEFINITION
        N_MODULE??
 */
static EcNode *parseAnnotatableDirective(EcCompiler *cp, EcNode *attributes)
{
    EcState     *state;
    EcNode      *nextAttribute, *np;
    int         expectSemi;

    ENTER(cp);

    np = 0;
    expectSemi = 0;
    state = cp->state;

    switch (peekToken(cp)) {

    /* Attributes AnnotatableDirective */
    case T_STRING:
    case T_ATTRIBUTE:
    case T_RESERVED_NAMESPACE:
    case T_ID:
        nextAttribute = parseAttribute(cp);
        if (nextAttribute) {
            getToken(cp);
            if (nextAttribute->loc.lineNumber < cp->token->loc.lineNumber) {
                /* Must be no line break after the attribute */
                return LEAVE(cp, unexpected(cp));
            }
            putToken(cp);
            /*
                Aggregate the attributes and pass in. Must do this to allow "private static var a, b, c"
             */
            if (attributes) {
                nextAttribute->attributes |= attributes->attributes;
                if (attributes->qname.space && nextAttribute->qname.space) {
                    return LEAVE(cp, parseError(cp, "Cannot define multiple namespaces for directive"));
                }
                if (attributes->qname.space) {
                    nextAttribute->qname.space = attributes->qname.space;
                }
            }
            np = parseAnnotatableDirective(cp, nextAttribute);
        }
        break;

    case T_CONST:
    case T_LET:
    case T_VAR:
        np = parseVariableDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_FUNCTION:
        if (state->inInterface) {
            np = parseFunctionDeclaration(cp, attributes);
        } else {
            np = parseFunctionDefinition(cp, attributes);
        }
        break;

    case T_CLASS:
#if OLD && UNUSED
        if (state->inClass == 0) {
            /* Nested classes are not supported */
            np = parseClassDefinition(cp, attributes);
        } else {
            getToken(cp);
            np = unexpected(cp);
        }
#else
            np = parseClassDefinition(cp, attributes);
#endif
        break;

    case T_INTERFACE:
        if (state->inClass == 0) {
            np = parseInterfaceDefinition(cp, attributes);
        } else {
            np = unexpected(cp);
        }
        break;

    case T_NAMESPACE:
        np = parseNamespaceDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_TYPE:
        np = parseTypeDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_MODULE:
        np = parseModuleDefinition(cp);
        break;

    default:
        getToken(cp);
        np = parseError(cp, "Unknown directive \"%s\"", cp->token->text);
    }
    if (np && expectSemi) {
        if (getToken(cp) != T_SEMICOLON) {
            if (np->loc.lineNumber < cp->token->loc.lineNumber || cp->token->tokenId == T_EOF) {
                putToken(cp);
            } else if (cp->token->tokenId != T_NOP) {
                np = unexpected(cp);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    Attribute -global- (391)
        NamespaceAttribute
        dynamic
        final
        native
        [ AssignmentExpression allowList,allowIn]

    Attribute -class- (396)
        NamespaceAttribute
        final
        native
        override
        prototype
        static
        [ AssignmentExpression allowList,allowIn]

    Attribute -interface- (419)
        NamespaceAttribute

    Attribute -local- (420)
        NamespaceAttribute

    Input -common-
        NamespaceAttribute
            Path . Identifier
            Identifier
            public
            internal
        final
        native
        [

    Input -global-
        NamespaceAttribute -global-
            intrinsic
        dynamic

    Input -class-
        NamespaceAttribute -class-
            intrinsic
            private
            protected
        override
        prototype
        static

    AST
        N_ATTRIBUTES
            attribute
                flags
            attributes
 */
static EcNode *parseAttribute(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *state;
    int         inClass, inInterface, subId;

    ENTER(cp);

    state = cp->state;
    inClass =state->inClass ? 1 : 0;
    inInterface = state->inInterface ? 1 : 0;
    np = 0;

    if (state->inFunction) {
        np = parseNamespaceAttribute(cp);
        return LEAVE(cp, np);
    }

    peekToken(cp);
    subId = cp->peekToken->subId;
    switch (cp->peekToken->tokenId) {
    case T_ID:
    case T_RESERVED_NAMESPACE:
    case T_STRING:
        if (!inClass && (subId == T_PRIVATE || subId ==  T_PROTECTED)) {
            getToken(cp);
            return LEAVE(cp, parseError(cp, "Cannot use private or protected in this context"));
        }
        np = parseNamespaceAttribute(cp);
        break;

    case T_ATTRIBUTE:
        getToken(cp);
        np = createNode(cp, N_ATTRIBUTES, NULL);
        switch (cp->token->subId) {
        case T_DYNAMIC:
            if (inClass || inInterface) {
                np = unexpected(cp);
            } else {
                np->attributes |= EJS_TYPE_DYNAMIC_INSTANCES;
            }
            break;

        case T_FINAL:
            np->attributes |= EJS_TYPE_FINAL;
            break;

        case T_NATIVE:
            np->attributes |= EJS_PROP_NATIVE;
            break;

#if UNUSED
        case T_ORPHAN:
            if (inClass || inInterface) {
                np = unexpected(cp);
            } else {
                np->attributes |= EJS_TYPE_ORPHAN;
            }
            break;
#endif
        case T_OVERRIDE:
            if (inClass || inInterface) {
                np->attributes |= EJS_FUN_OVERRIDE;
            } else {
                np = unexpected(cp);
            }
            break;

#if UNUSED
        case T_SHARED:
            np->attributes |= EJS_PROP_SHARED;
            break;
#endif

        case T_STATIC:
            if (inClass || inInterface) {
                np->attributes |= EJS_PROP_STATIC;
            } else {
                np = unexpected(cp);
            }
            break;

        case T_ENUMERABLE:
            np->attributes |= EJS_PROP_ENUMERABLE;
            break;

        default:
            np = parseError(cp, "Unknown or invalid attribute in this context %s", cp->token->text);
        }
        break;

    case T_LBRACKET:
        np = appendNode(np, parseAssignmentExpression(cp));
        break;

    default:
        np = parseError(cp, "Unknown or invalid attribute in this context %s", cp->token->text);
        break;
    }
    return LEAVE(cp, np);
}


/*
    NamespaceAttribute -global- (405)
        public
        internal
        intrinsic
        PrimaryName

    NamespaceAttribute -class- (409)
        ReservedNamespace
        PrimaryName

    Input -common-
        Identifier
        internal
        public

    Input -global-
        intrinsic

    Input -class-
        intrinsic
        private
        protected

    AST
        N_ATTRIBUTES
            attribute
                flags
            left: N_QNAME | N_DOT
 */
static EcNode *parseNamespaceAttribute(EcCompiler *cp)
{
    EcNode      *np, *qualifier;
    int         inClass, subId;

    ENTER(cp);

    inClass = (cp->state->inClass) ? 1 : 0;
    peekToken(cp);
    subId = cp->peekToken->subId;

    np = createNode(cp, N_ATTRIBUTES, NULL);
    np->loc.lineNumber = cp->peekToken->loc.lineNumber;

    switch (cp->peekToken->tokenId) {
    case T_RESERVED_NAMESPACE:
        if (!inClass && (subId == T_PRIVATE || subId ==  T_PROTECTED)) {
            getToken(cp);
            return LEAVE(cp, unexpected(cp));
        }
        qualifier = parseReservedNamespace(cp);
        np->attributes = qualifier->attributes;
        np->specialNamespace = qualifier->specialNamespace;
        np->qname.space = qualifier->qname.space;
        break;

    case T_ID:
        qualifier = parsePrimaryName(cp);
        if (qualifier->kind == N_QNAME) {
            np->attributes = qualifier->attributes;
            np->qname.space = qualifier->qname.name;
        } else {
            /*
                This is a N_DOT expression compile-time constant expression.
             */
            assert(0);
#if UNUSED
            np->qualifierNode = linkNode(np, qualifier);
#endif
        }
        break;

    case T_STRING:
        getToken(cp);
        np->qname.space = tokenString(cp);
        np->literalNamespace = 1;
        break;

    case T_ATTRIBUTE:
        getToken(cp);
        np = parseError(cp, "Attribute \"%s\" not supported on local variables", cp->token->text);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    VariableDefinition -b- (411)
        VariableDefinitionKind VariableBindingList -allowList,b-

    Input
        const
        let
        let const
        var

    AST
        N_VAR_DEFINITION
            def: varKind
 */
static EcNode *parseVariableDefinition(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;

    ENTER(cp);
    np = parseVariableDefinitionKind(cp, attributes);
    np = parseVariableBindingList(cp, np, attributes);
    return LEAVE(cp, np);
}


/*
    VariableDefinitionKind (412)
        const
        let
        let const
        var

    Input

    AST
        N_VAR_DEFINITION
            def: varKind
 */
static EcNode *parseVariableDefinitionKind(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_VAR_DEFINITION, NULL);
    setNodeDoc(cp, np);

    switch (getToken(cp)) {
    case T_CONST:
        np->def.varKind = KIND_CONST;
        np->attributes |= EJS_TRAIT_READONLY;
        break;

    case T_LET:
        if (attributes && attributes->attributes & EJS_PROP_STATIC) {
            np = parseError(cp, "Static and let are not a valid combination. Use var instead.");

        } else {
            np->def.varKind = KIND_LET;
            if (peekToken(cp) == T_CONST) {
                np->def.varKind |= KIND_CONST;
                np->attributes |= EJS_TRAIT_READONLY;
            }
        }
        break;

    case T_VAR:
        np->def.varKind = KIND_VAR;
        break;

    default:
        np = parseError(cp, "Bad variable definition kind");
    }
    return LEAVE(cp, np);
}


/*
    VariableBindingList -a,b- (416)
        VariableBinding
        VariableBindingList -noList,b- , VariableBinding -a,b-

    Input

    AST
 */
static EcNode *parseVariableBindingList(EcCompiler *cp, EcNode *varList, EcNode *attributes)
{
    ENTER(cp);

    varList = parseVariableBinding(cp, varList, attributes);
    while (varList && peekToken(cp) == T_COMMA) {
        getToken(cp);
        varList = parseVariableBinding(cp, varList, attributes);
    }
    return LEAVE(cp, varList);
}


/*
    VariableBinding -a,b- (418)
        TypedIdentifier (258)
        TypedPattern (260) -noList,noIn- VariableInitialisation -a,b-

    TypedIdentifier (258)
        SimplePattern -noList,noin,noExpr-
        SimplePattern -a,b,noExpr- : TypeExpression

    TypedPattern (260)
        SimplePattern -a,b,noExpr-
        SimplePattern -a,b,noExpr- : NullableTypeExpression
        ObjectPattern -noExpr-
        ObjectPattern -noExpr- : TypeExpression
        ArrayPattern -noExpr-
        ArrayPattern -noExpr- : TypeExpression

    Input

    AST
        N_QNAME variableId
        N_ASSIGN
            left: N_QNAME variableId
            right: N_LITERAL

 */
static EcNode *parseVariableBinding(EcCompiler *cp, EcNode *np, EcNode *attributes)
{
    EcNode      *var, *assign, *elt, *initialize, *name;
    int         next;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LBRACKET:
    case T_LBRACE:
        if ((initialize = parsePattern(cp)) == 0) {
            return LEAVE(cp, parseError(cp, "Bad destructuring variable declaration"));            
        }
        for (next = 0; (elt = mprGetNextItem(initialize->children, &next)) != 0 && !cp->error; ) {
            assert(elt->kind == N_FIELD);
            if (elt->field.expr->kind != N_QNAME) {
                return LEAVE(cp, parseError(cp, "Bad destructuring variable declaration"));
            }
            var = createNode(cp, N_VAR, NULL);
            var->qname = elt->field.expr->qname;
            var->name.varKind = np->def.varKind;
            var->attributes |= np->attributes;
            applyAttributes(cp, var, attributes, 0); 
            copyDocString(cp, var, np);
            np = appendNode(np, var);
        }
        if (peekToken(cp) == T_ASSIGN) {
            getToken(cp);
            assign = createNode(cp, N_ASSIGN_OP, NULL);
            assign = createAssignNode(cp, initialize, parseAssignmentExpression(cp), assign);
            np = appendNode(np, assign);
        }
        break;

    default:
        if ((var = parseTypedIdentifier(cp)) == 0) {
            return LEAVE(cp, var);
        }
        assert(var->qname.name);
        if (var->kind != N_QNAME) {
            return LEAVE(cp, parseError(cp, "Bad variable name"));
        }
        if (STRICT_MODE(cp)) {
            if (var->typeNode == 0) {
                parseError(cp, "Variable untyped. Variables must be typed when declared in strict mode");
                var = ecResetError(cp, var, 0);
                /* Keep parsing */
            }
        }
        var->kind = N_VAR;
        var->kindName = "n_var";
        var->name.varKind = np->def.varKind;
        var->attributes |= np->attributes;
        applyAttributes(cp, var, attributes, 0);
        copyDocString(cp, var, np);

        if (peekToken(cp) == T_ASSIGN) {
            name = createNode(cp, N_QNAME, tokenString(cp));
            name->qname = var->qname;
            assign = appendNode(createNode(cp, N_ASSIGN_OP, NULL), name);
            assign = appendNode(assign, parseVariableInitialisation(cp));
            var = appendNode(var, assign);
        }
        np = appendNode(np, var);
        break;
    }
    return LEAVE(cp, np);
}


/*
    VariableInitialisation -a,b- (426)
        = AssignmentExpression -a,b-

    Input
        =

    AST
        N_EXPRESSIONS
 */
static EcNode *parseVariableInitialisation(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) == T_ASSIGN) {
        np = parseAssignmentExpression(cp);
    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    FunctionDeclaration (421)                                   # For interfaces
        function FunctionName FunctionSignature

    Notes:
        This is for function declarations in interfaces only.

    Input
        function

    AST
        N_FUNCTION
            function: name, getter, setter, block,
                children: parameters
 */
static EcNode *parseFunctionDeclaration(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    cp->state->defaultNamespace = NULL;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, parseError(cp, "Expecting \"function\""));
    }
    tid = peekToken(cp);
    if (tid != T_ID && tid != T_GET && tid != T_SET) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Expecting function or class name"));
    }
    np = parseFunctionName(cp);
    if (np) {
        setNodeDoc(cp, np);
        applyAttributes(cp, np, attributes, 0);
        np = parseFunctionSignature(cp, np);
        if (np) {
            np->function.isMethod = 1;
            if (STRICT_MODE(cp)) {
                if (np->function.resultType == 0) {
                    np = parseError(cp, 
                        "Function has not defined a return type. Fuctions must be typed when declared in strict mode");
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    FunctionDefinition -class- (424)
        function ClassName ConstructorSignature FunctionBody -allowin-
        function FunctionName FunctionSignature FunctionBody -allowin-

    FunctionDeclaration -t- (442)
        function FunctionName FunctionSignature FunctionBody -allowin-
        let function FunctionName FunctionSignature FunctionBody -allowin-
        const function FunctionName FunctionSignature FunctionBody -allowin-

    Input
        function
        let
        const

    AST N_FUNCTION
        function: name, getter, setter, block,
            children: parameters
 */
static EcNode *parseFunctionDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcNode      *np, *className;
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    state->defaultNamespace = NULL;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, parseError(cp, "Expecting \"function\""));
    }
    if (getToken(cp) != T_ID && !(cp->token->groupMask & (G_CONREV | G_OPERATOR))) {
        return LEAVE(cp, parseError(cp, "Expecting function or class name"));
    }
    if (cp->state->currentClassName.name && 
            ejsCompareWide(cp->ejs, cp->state->currentClassName.name, cp->token->text, cp->token->length) == 0) {
        /*
            Constructor
         */
        np = createNode(cp, N_FUNCTION, NULL);
        putToken(cp);
        setNodeDoc(cp, np);
        applyAttributes(cp, np, attributeNode, ejsCreateStringFromAsc(cp->ejs, EJS_PUBLIC_NAMESPACE));
        className = parseClassName(cp);

        if (className) {
            np->qname.name = className->qname.name;
            np->function.isConstructor = 1;
            cp->state->currentClassNode->klass.constructor = np;
        }
        if (np) {
            np = parseConstructorSignature(cp, np);
            if (np) {
                cp->state->currentFunctionNode = np;
                if (!(np->attributes & EJS_PROP_NATIVE)) {
                    np->function.body = linkNode(np, parseFunctionBody(cp, np));
                    if (np->function.body == 0) {
                        return LEAVE(cp, 0);
                    }
                }
                np->function.isMethod = 1;
            }
        }

    } else {
        putToken(cp);
        np = parseFunctionName(cp);
        if (np) {
            setNodeDoc(cp, np);
            applyAttributes(cp, np, attributeNode, 0);
            np = parseFunctionSignature(cp, np);
            if (np) {
                cp->state->currentFunctionNode = np;
                if (attributeNode && (attributeNode->attributes & EJS_PROP_NATIVE)) {
                    if (peekToken(cp) == T_LBRACE) {
                        return LEAVE(cp, parseError(cp, "Native functions declarations must not have bodies"));
                    }

                } else {
#if UNUSED
                    if (peekToken(cp) != T_LBRACE) {
                        np->function.noBlock = 1;
                    }
#endif
                    np->function.body = linkNode(np, parseFunctionBody(cp, np));
                    if (np->function.body == 0) {
                        return LEAVE(cp, 0);
                    }
                }
                if (state->inClass && !state->inFunction && state->classState->blockNestCount == (state->blockNestCount - 1)) {
                    np->function.isMethod = 1;
                }
            }

            if (STRICT_MODE(cp)) {
                if (np->function.resultType == 0) {
                    parseError(cp, "Function has not defined a return type. Functions must be typed in strict mode");
                    np = ecResetError(cp, np, 0);
                    /* Keep parsing */
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    FunctionName (427)
        Identifier
        OverloadedOperator
        get Identifier
        set Identifier

    Input
        Identifier
        get
        set
        + - ~ * / % < > <= >= == << >> >>> & | === != !==

    AST N_FUNCTION
        function: name, getter, setter
 */
static EcNode *parseFunctionName(EcCompiler *cp)
{
    EcNode      *name, *np;
    int         accessorId, tid;

    ENTER(cp);

    tid = peekToken(cp);
    if (tid != T_GET && tid != T_SET) {
        if (cp->peekToken->groupMask & G_CONREV) {
            tid = T_ID;
        }
    }

    switch (tid) {
    case T_GET:
    case T_SET:
    case T_DELETE:
        getToken(cp);
        accessorId = cp->token->tokenId;

        tid = peekToken(cp);
        if (cp->peekToken->groupMask & G_CONREV) {
            tid = T_ID;
        }
        if (tid == T_LPAREN) {
            /*
                Function is called get() or set(). So put back the name and fall through to T_ID
             */
            putToken(cp);

        } else {
            if (tid != T_ID) {
                getToken(cp);
                return LEAVE(cp, parseError(cp, "Expecting identifier"));
            }
            name = parseIdentifier(cp);
            np = createNode(cp, N_FUNCTION, NULL);
            if (accessorId == T_GET) {
                np->function.getter = 1;
                np->attributes |= EJS_TRAIT_GETTER;
            } else {
                np->function.setter = 1;
                np->attributes |= EJS_TRAIT_SETTER;
            }
            np->qname.name = name->qname.name;
            break;
        }
        /* Fall through */

    case T_ID:
        name = parseIdentifier(cp);
        np = createNode(cp, N_FUNCTION, NULL);
        np->qname.name = name->qname.name;
        break;

    default:
        getToken(cp);
        if (cp->token->groupMask == G_OPERATOR) {
            putToken(cp);
            np = parseOverloadedOperator(cp);
        } else {
            np = unexpected(cp);
        }
    }
    return LEAVE(cp, np);
}


/*
    OverloadedOperator (431)
        + - ~ * / % < > <= >= == << >> >>> & | === != !==

    Input
        + - ~ * / % < > <= >= == << >> >>> & | === != !==
        [ . (  =        EJS exceptions

    AST
        N_QNAME
 */
static EcNode *parseOverloadedOperator(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (getToken(cp)) {
    /*
        EJS extensions
     */
    case T_LBRACKET:
    case T_LPAREN:
    case T_DOT:
    case T_ASSIGN:
        /* Fall through */

    case T_PLUS:
    case T_MINUS:
    case T_TILDE:
    case T_MUL:
    case T_DIV:
    case T_MOD:
    case T_LT:
    case T_GT:
    case T_LE:
    case T_GE:
    case T_EQ:
    case T_LSH:
    case T_RSH:
    case T_RSH_ZERO:
    case T_BIT_AND:
    case T_BIT_OR:
    case T_STRICT_EQ:
    case T_NE:
    case T_STRICT_NE:
        /* Node holds the token */
        np = createNode(cp, N_FUNCTION, NULL);
        np->qname.name = tokenString(cp);
        break;

    default:
        np = unexpected(cp);
        break;
    }

    return LEAVE(cp, np);
}


/*
    FunctionSignature (450) (See also FunctionSignatureType)
        TypeParameters ( Parameters ) ResultType
        TypeParameters ( this : PrimaryName ) ResultType
        TypeParameters ( this : PrimaryName , NonemptyParameters )
                ResultType

    Input
        .< TypeParameterList >

    AST
 */
static EcNode *parseFunctionSignature(EcCompiler *cp, EcNode *np)
{
    EcNode      *parameters;

    if (np == 0) {
        return np;
    }
    ENTER(cp);
    assert(np->kind == N_FUNCTION);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    np->function.parameters = linkNode(np, createNode(cp, N_ARGS, NULL));

    //  TODO - should accep
    if (peekToken(cp) == T_ID || cp->peekToken->tokenId == T_ELIPSIS || cp->peekToken->groupMask & G_CONREV) {
        if (mcmp(cp->peekToken->text, "this") == 0) {
            ;
        } else {
            parameters = parseParameters(cp, np->function.parameters);
            if (parameters == 0) {
                while (getToken(cp) != T_RPAREN && cp->token->tokenId != T_EOF);
                return LEAVE(cp, 0);
            }
            np->function.parameters = linkNode(np, parameters);
        }
    }
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \")\""));
    }
    if (np) {
        if (peekToken(cp) == T_COLON) {
            np->function.resultType = linkNode(np, parseResultType(cp));
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TypeParameters (453)
        EMPTY
        .< TypeParameterList >
    Input

    AST
 */
static EcNode *parseTypeParameters(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    TypeParametersList (455)
        Identifier
        Identifier , TypeParameterList

    Input

    AST
 */
static EcNode *parseTypeParameterList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Parameters (457)
        EMPTY
        NonemptyParameters

    Input

    AST
 */
static EcNode *parseParameters(EcCompiler *cp, EcNode *args)
{
    ENTER(cp);

    if (peekToken(cp) != T_RPAREN) {
        args = parseNonemptyParameters(cp, args);
    }
    return LEAVE(cp, args);
}


/*
    NonemptyParameters (459)
        ParameterInit
        ParameterInit , NonemptyParameters
        RestParameter

    Input
        Identifier
        ...

    AST
        N_ARGS
            N_VAR_DEFN
                N_QNAME
                N_ASSIGN_OP
                    N_QNAME, N_LITERAL

 */
static EcNode *parseNonemptyParameters(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_ELIPSIS) {
        np = appendNode(np, parseRestParameter(cp));

    } else {
        np = appendNode(np, parseParameterInit(cp, np));
        if (np) {
            if (peekToken(cp) == T_COMMA) {
                getToken(cp);
                np = parseNonemptyParameters(cp, np);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ParameterInit (462)
        Parameter
        Parameter = NonAssignmentExpression -noList,allowIn-

    Input

    AST
 */
static EcNode *parseParameterInit(EcCompiler *cp, EcNode *args)
{
    EcNode      *np, *assignOp, *lastArg;

    ENTER(cp);

    np = parseParameter(cp, 0);

    if (peekToken(cp) == T_ASSIGN) {
        getToken(cp);
        /*
            Insert a N_ASSIGN_OP node under the VAR_DEFN
         */
        assignOp = createNode(cp, N_ASSIGN_OP, NULL);
        assignOp = appendNode(assignOp, np->left);
        assert(mprGetListLength(np->children) == 1);

        mprRemoveItemAtPos(np->children, 0);
        assignOp = appendNode(assignOp, parseNonAssignmentExpression(cp));
        np = appendNode(np, assignOp);

        if (assignOp) {
            appendDocString(cp, args->parent, assignOp->left, assignOp->right);
        }

    } else if (args->children) {
        lastArg = (EcNode*) mprGetLastItem(args->children);
        if (lastArg && lastArg->left->kind == N_ASSIGN_OP) {
            np = parseError(cp, "Cannot have required parameters after parameters with initializers");
        }
    }
    return LEAVE(cp, np);
}


/*
    Parameter (464)
        ParameterKind TypedPattern -noList,noIn-

    Input

    AST
 */
static EcNode *parseParameter(EcCompiler *cp, bool rest)
{
    Ejs         *ejs;
    EcNode      *np, *parameter;

    ENTER(cp);

    ejs = cp->ejs;
    np = parseParameterKind(cp);
    parameter = parseTypedPattern(cp);
    if (parameter) {
        parameter->qname.space = ESV(empty);
    }
    np = appendNode(np, parameter);
    if (parameter) {
        if (STRICT_MODE(cp)) {
            if (parameter->typeNode == 0 && !rest) {
                parseError(cp, "Parameter untyped. Parameters must be typed when declared in strict mode.");
                np = ecResetError(cp, np, 0);
                /* Keep parsing */
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ParameterKind (465)
        EMPTY
        const

    Input

    AST
 */
static EcNode *parseParameterKind(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_VAR_DEFINITION, NULL);

    if (peekToken(cp) == T_CONST) {
        getToken(cp);
        np->def.varKind = KIND_CONST;
        np->attributes |= EJS_TRAIT_READONLY;
    }
    return LEAVE(cp, np);
}


/*
    RestParameter (467)
        ...
        ... Parameter

    Input

    AST
 */
static EcNode *parseRestParameter(EcCompiler *cp)
{
    EcNode      *np, *varNode;

    ENTER(cp);

    if (getToken(cp) == T_ELIPSIS) {
        np = parseParameter(cp, 1);
        if (np && np->left) {
            if (np->left->kind == N_QNAME) {
                varNode = np->left;
            } else if (np->left->kind == N_ASSIGN_OP) {
                varNode = np->left->left;
            } else {
                varNode = 0;
                assert(0);
            }
            if (varNode) {
                assert(varNode->kind == N_QNAME);
                varNode->name.isRest = 1;
            }
        }

    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    ResultType (469)
        EMPTY
        : void
        : NullableTypeExpression

    Input

    AST
        N_DOT
        N_QNAME
        N_VOID

    NOTE: we do not handle EMPTY here. Caller must handle.
 */
static EcNode *parseResultType(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;

    ENTER(cp);

    ejs = cp->ejs;

    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        if (peekToken(cp) == T_VOID) {
            getToken(cp);
            np = createNode(cp, N_QNAME, EST(Void)->qname.name);
            np->name.isType = 1;

        } else {
            np = parseNullableTypeExpression(cp);
        }

    } else {
        /*  Don't handle EMPTY here */
        getToken(cp);
        np = unexpected(cp);;
    }
    return LEAVE(cp, np);
}


/*
    ConstructorSignature (472)
        TypeParameters ( Parameters )
        TypeParameters ( Parameters ) : ConstructorInitializer

    Input

    AST
 */
static EcNode *parseConstructorSignature(EcCompiler *cp, EcNode *np)
{
    if (np == 0) {
        return np;
    }
    ENTER(cp);

    assert(np->kind == N_FUNCTION);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    np->function.parameters = linkNode(np, createNode(cp, N_ARGS, NULL));
    np->function.parameters = linkNode(np, parseParameters(cp, np->function.parameters));

    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \")\""));
    }
    if (np) {
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->function.constructorSettings = linkNode(np, parseConstructorInitializer(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    ConstructorInitializer (462)
        InitializerList
        InitializerList SuperInitializer
        SuperInitializer

    Input
        TDB
        super

    AST
        N_DIRECTIVES
 */
static EcNode *parseConstructorInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_DIRECTIVES, NULL);

    if (peekToken(cp) != T_SUPER) {
        np = parseInitializerList(cp, np);
    }
    if (peekToken(cp) == T_SUPER) {
        np = appendNode(np, parseSuperInitializer(cp));
    }
    return LEAVE(cp, np);
}


/*
    InitializerList (465)
        Initializer
        InitializerList , Initializer

    Input
        TBD

    AST
        N_DIRECTIVES
 */
static EcNode *parseInitializerList(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    assert(np && np->kind == N_DIRECTIVES);

    while (1) {
        np = appendNode(np, parseInitializer(cp));
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
        } else {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    Initializer (467)
        Pattern -noList,noIn,noExpr- VariableInitialisation -nolist,allowIn-

    Input
        TBD

    AST
        N_ASSIGN
 */
static EcNode *parseInitializer(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parsePattern(cp);

    if (peekToken(cp) != T_ASSIGN) {
        return LEAVE(cp, expected(cp, "="));
    }
    parent = createNode(cp, N_ASSIGN_OP, NULL);
    np = createAssignNode(cp, np, parseVariableInitialisation(cp), parent);
    return LEAVE(cp, np);
}


/*
    SuperInitializer (481)
        super Arguments

    Input
        super

    AST
        N_SUPER
 */
static EcNode *parseSuperInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_SUPER) {
        return LEAVE(cp, expected(cp, "super"));
    }
    np = createNode(cp, N_SUPER, NULL);
    np = appendNode(np, parseArguments(cp));
    return LEAVE(cp, np);
}


/*
    FunctionBody -b- (469)
        Block -local-
        AssignmentExpression -b-

    Input
        {
        (

    AST
 */
static EcNode *parseFunctionBody(EcCompiler *cp, EcNode *fun)
{
    Ejs         *ejs;
    EcNode      *np, *end, *ret;

    ENTER(cp);

    ejs = cp->ejs;
    cp->state->inFunction = 1;
    cp->state->nspace = ESV(empty);

    if (peekToken(cp) == T_LBRACE) {
        np = parseBlock(cp);
        if (np) {
            np = np->left;
        }

    } else {
        /*
            Create a return for block-less functions
         */
        np = createNode(cp, N_DIRECTIVES, NULL);
        ret = createNode(cp, N_RETURN, NULL);
        ret->ret.blockless = 1;
        ret = appendNode(ret, parseAssignmentExpression(cp));
        np = appendNode(np, ret);
    }
    if (np) {
        end = createNode(cp, N_END_FUNCTION, NULL);
        np = appendNode(np, end);
    }
    return LEAVE(cp, np);
}


/*
    ClassDefinition (484)
        class ClassName ClassInheritance ClassBody

    Input
        class id ...

    AST
        N_CLASS
            name
                id
            extends: id

 */
static EcNode *parseClassDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *np, *classNameNode, *inheritance, *constructor;
    int         tid;

    ENTER(cp);

    state = cp->state;

    if (getToken(cp) != T_CLASS) {
        return LEAVE(cp, expected(cp, "class"));
    }
    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }
    np = createNode(cp, N_CLASS, NULL);
    state->currentClassNode = np;
    state->topVarBlockNode = np;
    state->classState = state;
    state->defaultNamespace = NULL;

    classNameNode = parseClassName(cp);
    if (classNameNode == 0) {
        return LEAVE(cp, 0);
    }
    applyAttributes(cp, np, attributeNode, 0);
    setNodeDoc(cp, np);

    np->qname.name = classNameNode->qname.name;
    state->currentClassName = np->qname;
    state->inClass = 1;

    tid = peekToken(cp);
    if (tid == T_EXTENDS || tid == T_IMPLEMENTS) {
        inheritance = parseClassInheritance(cp);
        if (inheritance->klass.extends) {
            np->klass.extends = inheritance->klass.extends;
        }
        if (inheritance->klass.implements) {
            np->klass.implements = inheritance->klass.implements;
        }
    }
    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "{"));
    }

    np = appendNode(np, parseClassBody(cp));

    if (np && np->klass.constructor == 0) {
        /*
            Create a default constructor because the user did not supply a constructor. We always
            create a constructor node even if one is not required (or generated). This makes binding easier later.
         */
        constructor = createNode(cp, N_FUNCTION, NULL);
        np->klass.constructor = linkNode(np, constructor);
        constructor->qname.name = np->qname.name;
        applyAttributes(cp, constructor, 0, ejsCreateStringFromAsc(cp->ejs, EJS_PUBLIC_NAMESPACE));
        constructor->function.isMethod = 1;
        constructor->function.isConstructor = 1;
        constructor->function.isDefault = 1;
    }
    return LEAVE(cp, np);
}


/*
    ClassName (485)
        ParameterisedTypeName
        ParameterisedTypeName !
    Input

    AST
 */
static EcNode *parseClassName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = parseParameterisedTypeName(cp);
    if (peekToken(cp) == T_LOGICAL_NOT) {
        getToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    ParameterisedTypeName (487)
        Identifier
        Identifier TypeParameters

    Input

    AST
 */
static EcNode *parseParameterisedTypeName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }
    np = parseIdentifier(cp);

#if FUTURE
    if (peekToken(cp) == T_DOT_LESS) {
        np = parseTypeParameters(cp);
    }
#endif
    return LEAVE(cp, np);
}


/*
    ClassInheritance (489)
        EMPTY
        extends PrimaryName
        implements TypeIdentifierList
        extends PrimaryName implements TypeIdentifierList

    Input

    AST N_CLASS
        extends: id
        left: implements list if ids
 */
static EcNode *parseClassInheritance(EcCompiler *cp)
{
    EcNode      *np, *id;

    ENTER(cp);

    np = createNode(cp, N_CLASS, NULL);

    switch (getToken(cp)) {
    case T_EXTENDS:
        id = parsePrimaryName(cp);
        if (id) {
            np->klass.extends = id->qname.name;
        }
        if (peekToken(cp) == T_IMPLEMENTS) {
            getToken(cp);
            np->klass.implements = linkNode(np, parseTypeIdentifierList(cp));
        }
        break;

    case T_IMPLEMENTS:
        np->klass.implements = linkNode(np, parseTypeIdentifierList(cp));
        break;

    default:
        putToken(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    TypeIdentifierList (493)
        PrimaryName
        PrimaryName , TypeIdentifierList

    Input

    AST
 */
static EcNode *parseTypeIdentifierList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_TYPE_IDENTIFIERS, NULL);
    while (peekToken(cp) == T_ID) {
        np = appendNode(np, parsePrimaryName(cp));
        if (peekToken(cp) != T_COMMA) {
            break;
        }
        getToken(cp);
    }

    /*
        Discard the first NOP node
     */
    return LEAVE(cp, np);
}


/*
    ClassBody (495)
        Block -class-

    Input

    AST
 */
static EcNode *parseClassBody(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    cp->state->inFunction = 0;

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "class body { }"));
    }
    np = parseBlock(cp);
    if (np) {
        np = np->left;
        assert(np->kind == N_DIRECTIVES);
    }
    return LEAVE(cp, np);
}


/*
    InterfaceDefinition (496)
        interface ClassName InterfaceInheritance InterfaceBody

    Input

    AST
 */
static EcNode *parseInterfaceDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *np, *classNameNode, *inheritance;

    ENTER(cp);
    
    state = cp->state;

    np = 0;
    if (getToken(cp) != T_INTERFACE) {
        return LEAVE(cp, expected(cp, "interface"));
    }
    
    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }

    np = createNode(cp, N_CLASS, NULL);
    state->currentClassNode = np;
    state->topVarBlockNode = np;
    state->classState = state;
    state->defaultNamespace = NULL;
    
    classNameNode = parseClassName(cp);
    if (classNameNode == 0) {
        return LEAVE(cp, 0);
    }

    applyAttributes(cp, np, attributeNode, 0);
    setNodeDoc(cp, np);
    
    np->qname.name = classNameNode->qname.name;
    np->klass.isInterface = 1;
    state->currentClassName.name = np->qname.name;
    state->inInterface = 1;
    
    if (peekToken(cp) == T_EXTENDS) {
        inheritance = parseInterfaceInheritance(cp);
        if (inheritance->klass.extends) {
            np->klass.extends = inheritance->klass.extends;
        }
    }

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "{"));
    }

    np = appendNode(np, parseInterfaceBody(cp));

    return LEAVE(cp, np);
}


/*
    InterfaceInheritance (497)
        EMPTY
        extends TypeIdentifierList

    Input

    AST
 */
static EcNode *parseInterfaceInheritance(EcCompiler *cp)
{
    EcNode      *np, *id;

    ENTER(cp);

    np = createNode(cp, N_CLASS, NULL);

    if (peekToken(cp) == T_EXTENDS) {
        id = parseTypeIdentifierList(cp);
        if (id) {
            np->klass.extends = id->qname.name;
        }
    }
    return LEAVE(cp, np);
}


/*
    InterfaceBody (499)
        Block -interface-

    Input

    AST
 */
static EcNode *parseInterfaceBody(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "interface body { }"));
    }

    np = parseBlock(cp);
    if (np) {
        np = np->left;
        assert(np->kind == N_DIRECTIVES);
    }

    return LEAVE(cp, np);
}


/*
    NamespaceDefinition (500)
        namespace Identifier NamespaceInitialisation

    Input
        namespace

    AST
        N_NAMESPACE
 */
static EcNode *parseNamespaceDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *varDefNode, *assignNode, *varNode, *typeNode, *namespaceNode, *nameNode;
    EjsObj      *vp;

    ENTER(cp);
    state = cp->state;
    if (state->inClass || state->inFunction) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Namespace definitions are not permitted inside classes or functions"));
    }
    if (getToken(cp) != T_NAMESPACE) {
        return LEAVE(cp, unexpected(cp));
    }

    /*
        Handle namespace definitions like:
            let NAME : Namespace = NAMESPACE_LITERAL
     */
    if ((varNode = parseIdentifier(cp)) == 0) {
        return LEAVE(cp, varNode);
    }
    assert(varNode->kind == N_QNAME);
    varNode->kind = N_VAR;
    varNode->kindName = "n_var";
    varNode->name.varKind = KIND_VAR;
    varNode->name.isNamespace = 1;
    setNodeDoc(cp, varNode);

    /*
        Hand-craft a "Namespace" type node
     */
    typeNode = createNode(cp, N_QNAME, tokenString(cp));
    typeNode->qname.name = ejsCreateStringFromAsc(cp->ejs, "Namespace");
    varNode->typeNode = linkNode(varNode, typeNode);
    applyAttributes(cp, varNode, attributeNode, 0);

    if (peekToken(cp) == T_ASSIGN) {
        namespaceNode = parseNamespaceInitialisation(cp, varNode);
    } else {
        /*
            Create a namespace literal node from which to assign.
         */
        namespaceNode = createNode(cp, N_LITERAL, NULL);
        vp = (EjsObj*) ejsCreateNamespace(cp->ejs, varNode->qname.name);
        namespaceNode->literal.var = vp;
        varNode->name.nsvalue = vp;
    }
    /*
        Create an assignment node
     */
    nameNode = createNode(cp, N_QNAME, tokenString(cp));
    nameNode->qname = varNode->qname;
    assignNode = appendNode(createNode(cp, N_ASSIGN_OP, NULL), nameNode);
    assignNode = appendNode(assignNode, namespaceNode);
    varNode = appendNode(varNode, assignNode);

    varDefNode = createNode(cp, N_VAR_DEFINITION, NULL);
    varDefNode->def.varKind = KIND_VAR;
    varDefNode = appendNode(varDefNode, varNode);

    return LEAVE(cp, varDefNode);
}


/*
    NamespaceInitialisation (501)
        EMPTY
        = StringLiteral
        = not supported SimpleQualifiedName

    AST
        N_LITERAL
        N_QNAME
        N_DOT
 */
static EcNode *parseNamespaceInitialisation(EcCompiler *cp, EcNode *nameNode)
{
    EcNode      *np;
    EjsObj      *vp;

    ENTER(cp);

    if (getToken(cp) != T_ASSIGN) {
        return LEAVE(cp, unexpected(cp));
    }
    if (peekToken(cp) != T_STRING) {
        return LEAVE(cp, expected(cp, "Namespace initializers must be literal strings"));
    }
    getToken(cp);
    np = createNode(cp, N_LITERAL, tokenString(cp));
    vp = (EjsObj*) ejsCreateNamespace(cp->ejs, nameNode->qname.name);
    np->literal.var = vp;

    if (peekToken(cp) != T_SEMICOLON && cp->peekToken->tokenId != T_EOF && 
            cp->peekToken->loc.lineNumber == cp->token->loc.lineNumber) {
        return LEAVE(cp, expected(cp, "Namespace initializers must be simple literal strings"));
    }
#if UNUSED
    } else {
        np = parsePrimaryName(cp);
    }
#endif
    return LEAVE(cp, np);
}


/*
    TypeDefinition (504)
        type ParameterisedTypeName TypeInitialisation

    Input

    AST
 */
static EcNode *parseTypeDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcNode      *np;

    ENTER(cp);
    np = parseTypeInitialisation(cp);
    return LEAVE(cp, np);
}


/*
    TypeInitialisation (505)
        = NullableTypeExpression

    Input

    AST
 */
static EcNode *parseTypeInitialisation(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


/*
    ModuleDefinition (493)
        module ModuleBody
        module ModuleName ModuleBody

    Input
        module ...

    AST
        N_MODULE
 */
static EcNode *parseModuleDefinition(EcCompiler *cp)
{
    EcNode      *np, *moduleName, *body;
    EjsString   *nspace;
    cchar       *name;
    int         next, isDefault, pos, version;

    ENTER(cp);
    version = 0;

    if (getToken(cp) != T_MODULE) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_MODULE, NULL);

    if (peekToken(cp) == T_ID) {
        isDefault = 0;
        moduleName = parseModuleName(cp);
        if (moduleName == 0) {
            return LEAVE(cp, 0);
        }
        version = 0;
        if (peekToken(cp) == T_STRING || cp->peekToken->tokenId == T_NUMBER) {
            if ((version = parseVersion(cp, 0)) < 0) {
                expected(cp, "A version number NUM[.NUM[.NUM]]");
                return 0;
            }
        }
        np->module.name = moduleName->qname.name;
        if (version) {
            nspace = ejsSprintf(cp->ejs, "%@-%d", moduleName->qname.name, version);
        } else if (cp->modver) { 
            nspace = ejsSprintf(cp->ejs, "%@-%d", moduleName->qname.name, cp->modver);
            version = cp->modver;
        } else {
            nspace = moduleName->qname.name;
        }
    } else {
        isDefault = 1;
        nspace = cp->fileState->nspace;
    }
    assert(nspace);
    
    if (isDefault) {
        /*
            No module name. Set the namespace to the unique internal namespace name.
         */
        np->module.name = ejsCreateStringFromAsc(cp->ejs, EJS_DEFAULT_MODULE);
    }
    np->qname.name = np->module.name;
    np->module.version = version;
    cp->state->currentModule = ejsCreateModule(cp->ejs, np->qname.name, np->module.version, NULL);
    cp->state->defaultNamespace = nspace;

    body = parseModuleBody(cp);
    if (body == 0) {
        return LEAVE(cp, 0);
    }
    /* 
        Append the module namespace and also modules provided via ec/ejs --require switch
     */
    pos = 0;
    if (!isDefault) {
        body = insertNode(body, createNamespaceNode(cp, cp->fileState->nspace, 0, 1), pos++);
    }
    body = insertNode(body, createNamespaceNode(cp, nspace, 1, 1), pos++);
    for (next = 0; (name = mprGetNextItem(cp->require, &next)) != 0; ) {
        body = insertNode(body, createNamespaceNode(cp, ejsCreateStringFromAsc(cp->ejs, name), 0, 1), pos++);
    }
    assert(body->kind == N_BLOCK);
    np = appendNode(np, body);
    return LEAVE(cp, np);
}


/*
    ModuleName (494)
        Identifier
        ModuleName . Identifier

    Input
        ID
        ID. ... .ID

    AST
        N_QNAME
            name: name
 */
static EcNode *parseModuleName(EcCompiler *cp)
{
    EcNode      *np, *idp;
    EjsString   *name;

    ENTER(cp);

    np = parseIdentifier(cp);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    name = np->qname.name;

    while (np && getToken(cp) == T_DOT) {
        /*
            Stop if not "identifier"
         */
        if (peekAheadToken(cp, 1) != T_ID) {
            break;
        }
        idp = parseIdentifier(cp);
        if (idp == 0) {
            return LEAVE(cp, idp);
        }
        np = appendNode(np, idp);
        name = ejsSprintf(cp->ejs, "%@.%@", name, idp->qname.name);
    }
    putToken(cp);
    np->qname.name = name;
    return LEAVE(cp, np);
}


/*
    ModuleBody (496)
        Block -global-

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseModuleBody(EcCompiler *cp)
{
    return parseBlock(cp);
}


/*
    Pragma (505)
        UsePragma Semicolon |
        ImportPragma Semicolon

    Input
        use ...
        import ...

    AST
        N_IMPORT
        N_PRAGMAS
 */
static EcNode *parsePragma(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    switch (peekToken(cp)) {
    case T_USE:
    case T_REQUIRE:
        np = parseUsePragma(cp, np);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    Pragmas (497)
        Pragma
        Pragmas Pragma

    Input
        use ...
        require
        import

    AST
        N_PRAGMAS
            N_IMPORT
            N_PRAGMA
 */
static EcNode *parsePragmas(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

#if OLD
    while (peekToken(cp) == T_USE || cp->peekToken->tokenId == T_REQUIRE) {
        np = parsePragma(cp, np);
        if (np == 0) {
            break;
        }
    }
    return LEAVE(cp, np);
#else
    //  TODO - does this allow multiple pragmas?
    return LEAVE(cp, parsePragma(cp, np));
#endif
}


/*
    UsePragma (501)
        use PragmaItems
        require

    Input
        use ...

    AST
        N_PRAGMAS
 */
static EcNode *parseUsePragma(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_REQUIRE) {
        getToken(cp);
        np = parseRequireItems(cp, np);
    } else if (peekToken(cp) == T_USE) {
        getToken(cp);
        np = parsePragmaItems(cp, np);
    } else{
        getToken(cp);
        np = parseError(cp, "Expecting \"use\" or \"require\"");
    }
    return LEAVE(cp, np);
}


static EcNode *parseRequireItems(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    do {
        np = appendNode(np, parseRequireItem(cp));
    } while (peekToken(cp) == T_COMMA);
    return LEAVE(cp, np);
}


//  TODO - should return an EcNode
/*
    Parse "NUM[.NUM[.NUM]]" and return a version number. Return < 0 on parse errors.
 */
static int parseVersion(EcCompiler *cp, int parseMax)
{
    wchar       *str, *p, *next;
    int         major, minor, patch;

    if (parseMax) {
        major = minor = patch = EJS_VERSION_FACTOR - 1;
    } else {
        major = minor = patch = 0;
    }
    if (getToken(cp) != T_STRING && cp->token->tokenId != T_NUMBER) {
        return MPR_ERR_BAD_VALUE;
    }
    str = wclone(cp->token->text);
    if ((p = mtok(str, ".", &next)) != 0) {
        major = (int) wtoi(p);
    }
    if ((p = mtok(next, ".", &next)) != 0) {
        minor = (int) wtoi(p);
    }
    if ((p = mtok(next, ".", &next)) != 0) {
        patch = (int) wtoi(p);
    }
    return EJS_MAKE_VERSION(major, minor, patch);
}


//  TODO - should return an EcNode
/*
    Parse [version:version]. Valid forms include:
        [version]
        [:version]
        [version:version]
 */
static int parseVersions(EcCompiler *cp, int *minVersion, int *maxVersion)
{
    *minVersion = 0;
    *maxVersion = EJS_MAX_VERSION;

    getToken(cp);
    if (peekToken(cp) != T_COLON) {
        if ((*minVersion= parseVersion(cp, 0)) < 0) {
            expected(cp, "A version number NUM[.NUM[.NUM]]");
            return MPR_ERR_BAD_VALUE;
        }
    }
    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        if ((*maxVersion = parseVersion(cp, 1)) < 0) {
            expected(cp, "A version number NUM[.NUM[.NUM]]");
            return MPR_ERR_BAD_VALUE;
        }
    }
    if (getToken(cp) != T_RBRACKET) {
        expected(cp, "]");
    }
    return 0;
}


static EcNode *parseRequireItem(EcCompiler *cp)
{
    EcNode      *np, *ns, *moduleName;
    int         minVersion, maxVersion;

    ENTER(cp);
    
    np = createNode(cp, N_USE_MODULE, NULL);
    ns = createNode(cp, N_USE_NAMESPACE, NULL);
    np->useModule.minVersion = 0;
    np->useModule.maxVersion = EJS_MAX_VERSION;

    if ((moduleName = parseModuleName(cp)) != 0) {
        np->qname.name = moduleName->qname.name;
    }
    /*
        Optional [version:version]
     */
    if (peekToken(cp) == T_LBRACKET) {
        if (parseVersions(cp, &minVersion, &maxVersion) < 0) {
            return 0;
        }
        np->useModule.minVersion = minVersion;
        np->useModule.maxVersion = maxVersion;
    }

    ns->qname.name = np->qname.name;
    ns->name.isLiteral = 1;
    np = appendNode(np, ns);
    return LEAVE(cp, np);
}


/*
    PragmaItems (502)
        PragmaItem
        PragmaItems , PragmaItem

    Input
        decimal
        default
        namespace
        standard
        strict
        module

    AST
        N_PRAGMAS
        N_MODULE
 */
static EcNode *parsePragmaItems(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    do {
        np = appendNode(np, parsePragmaItem(cp));
    } while (peekToken(cp) == T_COMMA);
    return LEAVE(cp, np);
}


/*
    PragmaItem (504)
        decimal LeftHandSideExpression
        default namespace PrimaryName
        // default number [decimal | default | double | int | long | uint | ulong]
        namespace PrimaryName
        standard
        strict
        module ModuleName OptionalStringLiteral

    Input
        See above

    AST
        N_PRAGMA
        N_MODULE
 */
static EcNode *parsePragmaItem(EcCompiler *cp)
{
    EcNode      *np, *ns;
    EcState     *upper;
    EjsModule   *module;

    ENTER(cp);

    np = createNode(cp, N_PRAGMA, NULL);
    np->pragma.strict = cp->fileState->strict;
    module = 0;

    /*
        PragmaIdentifiers (737)
     */
    switch (getToken(cp)) {
#if UNUSED
    case T_DECIMAL:
        np->pragma.decimalContext = linkNode(np, parseLeftHandSideExpression(cp));
        break;
#endif
    case T_MODULE:
        /* TODO DEPRECATED */
        np = parseRequireItem(cp);
        break;

    case T_DEFAULT:
        getToken(cp);
        if (cp->token->tokenId == T_NAMESPACE) {
            if (peekToken(cp) == T_MODULE) {
                getToken(cp);
                module = cp->state->currentModule;
                if (module == 0) {
                    np = parseError(cp, "No open module");
                    break;
                }
                np = createNode(cp, N_USE_NAMESPACE, NULL);
                if (module->version) {
                    np->qname.name = ejsSprintf(cp->ejs, "%@-%d", module->name, module->version);
                    np->name.isLiteral = 1;
                } else {
                    np->qname.name = module->name;
                    np->name.isLiteral = 1;
                }
                np->name.isLiteral = 1;

            } else if (peekToken(cp) == T_STRING) {
                getToken(cp);
                np = createNode(cp, N_USE_NAMESPACE, tokenString(cp));
                np->name.isLiteral = 1;

            } else {
                ns = parsePrimaryName(cp);
                if (ns) {
                    assert(ns->qname.name);
                    np = createNode(cp, N_USE_NAMESPACE, ns->qname.name);
                }
            }
            if (np) {
                /*
                    Must apply this default namespace upwards to all blocks below the blockState. It will define the
                    new namespace value. Note that functions and classes null this so it does not propagate into classes or
                    functions.
                 */
                for (upper = cp->state->next; upper; upper = upper->next) {
                    upper->defaultNamespace = np->qname.name;
                    if (upper == cp->blockState) {
                        break;
                    }
                }
                cp->blockState->nspace = np->qname.name;
                np->name.isDefault = 1;
            }
        }
        break;

    case T_STANDARD:
        cp->fileState->strict = np->pragma.strict = 0;
        break;

    case T_STRICT:
        cp->fileState->strict = np->pragma.strict = 1;
        break;

    case T_NAMESPACE:
        if (peekToken(cp) == T_STRING) {
            getToken(cp);
            np = createNode(cp, N_USE_NAMESPACE, tokenString(cp));
            np->name.isLiteral = 1;

        } else {
            np = createNode(cp, N_USE_NAMESPACE, NULL);
            ns = parsePrimaryName(cp);
            if (ns) {
                np = appendNode(np, ns);
                if (ns->kind == N_DOT) {
                    np->qname.name = ns->right->qname.name;
                } else {
                    np->qname.name = ns->qname.name;
                }
            }
        }
        break;

    default:
        np = parseError(cp, "Unknown pragma identifier");
    }
    return LEAVE(cp, np);
}


/*
    Block -t- (514)
        { Directives }

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseBlock(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *state, *saveState;

    ENTER(cp);

    state = cp->state;
    saveState = cp->blockState;
    cp->blockState = state;

    if (getToken(cp) != T_LBRACE) {
        // putToken(cp);
        np = parseError(cp, "Expecting \"{\"");

    } else {
        np = createNode(cp, N_BLOCK, NULL);
        np = appendNode(np, parseDirectives(cp));
        if (np) {
            if (getToken(cp) != T_RBRACE) {
                // putToken(cp);
                np = parseError(cp, "Expecting \"}\"");
            }
        }
    }
    cp->blockState = saveState;
    return LEAVE(cp, np);
}


/*
    Program (515)
        Directives -global-

    Input
        AnyDirective

    AST N_PROGRAM
        N_DIRECTIVES ...

 */
static EcNode *parseProgram(EcCompiler *cp, cchar *path)
{
    Ejs         *ejs;
    EcState     *state;
    EcNode      *np, *module, *block, *require, *namespace;
    EjsString   *name;
    cchar       *requireName;
    char        *md5, *apath;
    int         next;

    ENTER(cp);
    
    ejs = cp->ejs;
    state = cp->state;
    state->strict = cp->strict;

    np = createNode(cp, N_PROGRAM, ejsCreateStringFromAsc(cp->ejs, EJS_PUBLIC_NAMESPACE));

    if (cp->visibleGlobals && ejs->state->internal) {
        np->qname.name = ejs->state->internal->value;
    } else if (path) {
        apath = mprGetAbsPath(path);
        md5 = mprGetMD5(apath);
        np->qname.name = ejsSprintf(cp->ejs, "%s-%s-%d", EJS_INTERNAL_NAMESPACE, md5, cp->uid++);
    } else {
        np->qname.name = ejsCreateStringFromAsc(cp->ejs, EJS_INTERNAL_NAMESPACE);
    }
    state->nspace = np->qname.name;
    assert(state->nspace);
        
    cp->fileState->nspace = state->nspace;

    /*
        Create the default module node
     */
    module = createNode(cp, N_MODULE, NULL);
    module->qname.name = ejsCreateStringFromAsc(cp->ejs, EJS_DEFAULT_MODULE);

    /*
        Create a block to hold the namespaces. Add a require node for the default module and add modules specified 
        via --require switch
     */
    block = createNode(cp, N_BLOCK, NULL);
    namespace = createNamespaceNode(cp, cp->fileState->nspace, 0, 1);
    namespace->name.isInternal = 1;
    block = appendNode(block, namespace);
    for (next = 0; (requireName = mprGetNextItem(cp->require, &next)) != 0; ) {
        name = ejsCreateStringFromAsc(cp->ejs, requireName);
        require = createNode(cp, N_USE_MODULE, NULL);
        require->qname.name = name;
        require->useModule.minVersion = 0;
        require->useModule.maxVersion = EJS_MAX_VERSION;
        require = appendNode(require, createNamespaceNode(cp, name, 0, 1));
        block = appendNode(block, require);
    }
    block = appendNode(block, parseDirectives(cp));
    module = appendNode(module, block);
    np = appendNode(np, module);

    if (!cp->interactive && peekToken(cp) != T_EOF) {
        if (np) {
            np = unexpected(cp);
        }
        return LEAVE(cp, np);
    }

    /*
        Reset the line number to prevent debug source lines preceeding these elements
     */
    if (np) {
        np->loc.lineNumber = 0;
    }
    if (module) {
        module->loc.lineNumber = 0;
    }
    if (block) {
        block->loc.lineNumber = 0;
    }
    return LEAVE(cp, np);
}


#if UNUSED
static EcNode *parseBreak(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseContinue(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseDo(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseFor(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseIf(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseLet(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseReturn(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseSwitch(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseThrow(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    return LEAVE(cp, np);
}


static EcNode *parseTry(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseWhile(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseWith(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseVarDefinition(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseFunctionDefinition(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}


static EcNode *parseInclude(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


#if NOT_USED_IN_GRAMMAR
static EcNode *parseSuper(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    assert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Recover from a parse error to allow parsing to continue.
 */
PUBLIC EcNode *ecResetError(EcCompiler *cp, EcNode *np, bool eatInput)
{
    int     tid, count;

    assert(cp->error);

    if (cp->error) {
        if (!cp->fatalError && cp->errorCount < EC_MAX_ERRORS) {
            cp->error = 0;
            np = createNode(cp, N_DIRECTIVES, NULL);
        }
    }

    /*
        Try to resync by eating input up to the next statement / directive
     */
    //  TODO - workaround
    count = 0;
    while (!cp->interactive && count++ < 50) {
        tid = peekToken(cp);
        if (tid == T_SEMICOLON || tid == T_RBRACE || tid == T_RBRACKET || tid == T_RPAREN || tid == T_ERR || tid == T_EOF)  {
            break;
        }
        if (np && np->loc.lineNumber < cp->peekToken->loc.lineNumber) {
            /* Virtual semicolon */
            break;
        }
        getToken(cp);
    }
    return np;
}


#if FUTURE
/*
    Returns an allocated buffer. Caller must free.
 */
static char *detab(EcCompiler *cp, char *src)
{
    char    *p, *dest;
    int     tabCount;

    tabCount = 0;

    for (p = src; *p; p++) {
        if (*p == '\t') {
            tabCount++;
        }
    }

    dest = ejsAlloc(cp->ejs, strlen(src) + 1 + (tabCount * cp->tabWidth));
    if (dest == 0) {
        assert(dest);
        return src;
    }
    for (p = dest; *src; src++) {
        if (*src== '\t') {
            *p++ = ' ';
            *p++ = ' ';
            *p++ = ' ';
            *p++ = ' ';
        } else {
            *p++ = *src;
        }
    }
    *p = '\0';

    return dest;
}
#endif


#if ME_DEBUG
static void updateDebug(EcCompiler *cp)
{
    assert(cp);

    if (cp->token) {
        cp->token->name = tokenNames[cp->token->tokenId];
    }
    if (cp->peekToken) {
        cp->peekToken->name = tokenNames[cp->peekToken->tokenId];
    }
}
#endif


/*
    Get the next input token. May have been previous obtained and putback.
 */
static int getToken(EcCompiler *cp)
{
    int         id;

    if (cp->fatalError) {
        return T_ERR;
    }
    id = ecGetToken(cp);
    cp->peekToken = 0;
    return id;
}


/*
    Peek ahead (K) tokens and return the token id
 */
static int peekAheadToken(EcCompiler *cp, int ahead)
{
    EcToken     *token;

    token = peekAheadTokenStruct(cp, ahead);
    if (token == 0) {
        return EJS_ERR;
    }
    return token->tokenId;
}


PUBLIC int ecPeekToken(EcCompiler *cp)
{
    return peekAheadToken(cp, 1);
}


/*
    Peek ahead (K) tokens and return the token.
 */
static EcToken *peekAheadTokenStruct(EcCompiler *cp, int ahead)
{
    EcToken     *token, *currentToken, *tokens[EC_MAX_LOOK_AHEAD];
    int         i;

    assert(ahead > 0 && ahead <= EC_MAX_LOOK_AHEAD);
    if (ahead == 1) {
        /* Fast look ahead of one token.  */
        if (cp->putback) {
            cp->peekToken = cp->putback;
            return cp->putback;
        }
    }
    /*
        takeToken will take the current token and remove it from the input
        We must preserve the current token throughout.
     */
    currentToken = ecTakeToken(cp);
    for (i = 0; i < ahead; i++) {
        if (ecGetToken(cp) < 0) {
            assert(0);
            return 0;
        }
        tokens[i] = ecTakeToken(cp);
    }
    /*
        Peek at the token of interest
     */
    token = tokens[i - 1];
    for (i = ahead - 1; i >= 0; i--) {
        putSpecificToken(cp, tokens[i]);
    }
    if (currentToken) {
        ecPutSpecificToken(cp, currentToken);
        ecGetToken(cp);
    }
    cp->peekToken = token;
    updateDebug(cp);
    return token;
}


static void putToken(EcCompiler *cp)
{
    ecPutToken(cp);
    updateDebug(cp);
}


static void putSpecificToken(EcCompiler *cp, EcToken *token)
{
    ecPutSpecificToken(cp, token);
}


static void setNodeDoc(EcCompiler *cp, EcNode *np)
{
    Ejs     *ejs;

    ejs = cp->ejs;

    if (ejs->flags & EJS_FLAG_DOC && cp->doc) {
        np->doc = ejsCreateStringFromAsc(ejs, cp->docToken);
        cp->docToken = 0;
    }
}


static void appendDocString(EcCompiler *cp, EcNode *np, EcNode *parameter, EcNode *value)
{
    EjsString   *defaultValue;
    Ejs         *ejs;
    char        arg[ME_MAX_BUFFER];
    int         found;
    
    ejs = cp->ejs;

    if (!(ejs->flags & EJS_FLAG_DOC)) {
        return;
    }
    if (np == 0 || parameter == 0 || parameter->kind != N_QNAME || value == 0) {
        return;
    }
    defaultValue = 0;
    if (value->kind == N_QNAME) {
        defaultValue = value->qname.name;
    } else if (value->kind == N_UNARY_OP) {
        if (value->left->kind == N_LITERAL) {
            if (value->tokenId == T_MINUS) {
                defaultValue = ejsSprintf(ejs, "-%@", ejsToString(ejs, value->left->literal.var));
            }
        }
    } else if (value->kind == N_LITERAL) {
        defaultValue = ejsToString(ejs, value->literal.var);
    }
    if (defaultValue == 0) {
        defaultValue = ejsCreateStringFromAsc(ejs, "expression");
    }
    if (np->doc) {
        found = 0;
        fmt(arg, sizeof(arg), "@param %@ ", parameter->qname.name);
        if (ejsContainsAsc(ejs, np->doc, arg) >= 0 || ejsContainsAsc(ejs, np->doc, "@duplicate") >= 0) {
            found++;
        } else {
            fmt(arg, sizeof(arg), "@params %@ ", parameter->qname.name);
            if (ejsContainsAsc(ejs, np->doc, arg) >= 0) {
                found++;
            }
        }
        if (found) {
            np->doc = ejsSprintf(ejs, "%@\n@default %@ %@", np->doc, parameter->qname.name, defaultValue);
        } else {
            np->doc = ejsSprintf(ejs, "%@\n@param %@\n@default %@ %@", np->doc, parameter->qname.name,
                parameter->qname.name, defaultValue);
        }
    }
}


static void copyDocString(EcCompiler *cp, EcNode *np, EcNode *from)
{
    Ejs     *ejs;

    ejs = cp->ejs;

    if (ejs->flags & EJS_FLAG_DOC && from->doc) {
        np->doc = from->doc;
        from->doc = 0;
    }
}


/*
    This is used outside the parser. It must reset the line number as the
    node will not correspond to any actual source code line;
 */
PUBLIC EcNode *ecCreateNode(EcCompiler *cp, int kind)
{
    EcNode  *node;

    node = createNode(cp, kind, NULL);
    if (node) {
        node->loc.lineNumber = -1;
        node->loc.source = 0;
    }
    return node;
}


static EcNode *createNameNode(EcCompiler *cp, EjsName qname)
{
    EcNode      *np;

    if ((np = createNode(cp, N_QNAME, NULL)) != NULL) {
        np->qname = qname;
    }
    return np;
}


static EcNode *createNamespaceNode(EcCompiler *cp, EjsString *name, bool isDefault, bool isLiteral)
{
    EcNode      *np;
    
    np = createNode(cp, N_USE_NAMESPACE, name);
    np->name.isDefault = isDefault;
    np->name.isLiteral = isLiteral;
    return np;
}


/*
    This is used outside the parser.
 */
PUBLIC EcNode *ecLinkNode(EcNode *np, EcNode *child)
{
    return linkNode(np, child);
}


/*
    Create a binary tree node.
 */
static EcNode *createBinaryNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent)
{
    assert(cp);
    assert(lhs);
    assert(parent);

    /*
        appendNode will return the parent if no error
     */
    parent = appendNode(parent, lhs);
    parent = appendNode(parent, rhs);

    return parent;
}


static EcNode *createAssignNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent)
{
    assert(cp);
    assert(lhs);
    assert(parent);

    return appendNode(appendNode(parent, lhs), rhs);
}


/*
    Add a child node. If an allocation error, return 0, otherwise return the
    parent node.
 */
static EcNode *appendNode(EcNode *np, EcNode *child)
{
    MprList         *list;
    int             index;

    if (child == 0 || np == 0) {
        return 0;
    }
    assert(np != child);
    list = np->children;

    if ((index = mprAddItem(np->children, child)) < 0) {
        return 0;
    }
    if (index == 0) {
        np->left = list->items[index];
    } else if (index == 1) {
        np->right = list->items[index];
    }
    child->parent = np;
    return np;
}


PUBLIC EcNode *ecAppendNode(EcNode *np, EcNode *child)
{
    return appendNode(np, child);
}


PUBLIC EcNode *ecChangeNode(EcCompiler *cp, EcNode *np, EcNode *oldNode, EcNode *newNode)
{
    EcNode      *child;
    int         next;

    for (next = 0; (child = mprGetNextItem(np->children, &next)) != 0; ) {
        if (child == oldNode) {
            mprSetItem(np->children, next - 1, newNode);
            if (next == 1) {
                np->left = mprGetItem(np->children, next - 1);
            } else if (next == 2) {
                np->right = mprGetItem(np->children, next - 1);
            }
            newNode->parent = np;
            return np;
        }
    }
    assert(0);
    return 0;
}


/*
    Link a node. This only steals the node.
 */
static EcNode *linkNode(EcNode *np, EcNode *node)
{
    if (node == 0 || np == 0) {
        return 0;
    }
    node->parent = np;
    return node;
}


/*
    Insert a child node. If an allocation error, return 0, otherwise return the parent node.
 */
static EcNode *insertNode(EcNode *np, EcNode *child, int pos)
{
    MprList     *list;
    int         index, len;

    if (child == 0 || np == 0) {
        return 0;
    }
    list = np->children;

    index = mprInsertItemAtPos(list, pos, child);
    if (index < 0) {
        return 0;
    }
    len = mprGetListLength(list);
    if (len > 0) {
        np->left = (EcNode*) list->items[0];
    }
    if (len > 1) {
        np->right = (EcNode*) list->items[1];
    }
    child->parent = np;
    return np;
}


/*
    Remove a child node and return it.
 */
static EcNode *removeNode(EcNode *np, EcNode *child)
{
    int         index;

    if (child == 0 || np == 0) {
        return 0;
    }
    index = mprRemoveItem(np->children, child);
    assert(index >= 0);

    if (index == 0) {
        np->left = np->right;
    } else if (index == 1) {
        np->right = 0;
    }
    child->parent = 0;
    return child;
}


static EcNode *unexpected(EcCompiler *cp)
{
    int     junk = 0;

    /*
        This is just to avoid a Vxworks 5.4 linker bug. The link crashes when this function has no local vars.
     */
    dummy(junk);
    return parseError(cp, "Unexpected input \"%s\"", cp->token->text);
}


static EcNode *expected(EcCompiler *cp, cchar *str)
{
    return parseError(cp, "Expected input \"%s\"", str);
}


static void applyAttributes(EcCompiler *cp, EcNode *np, EcNode *attributeNode, EjsString *overrideNamespace)
{
    EcState     *state;
    EjsString   *nspace;
    int         attributes;

    state = cp->state;

    attributes = 0;
    nspace = 0;

    if (attributeNode) {
        /*
            Attribute node passed in.
         */
        attributes = attributeNode->attributes;
        if (attributeNode->qname.space) {
            nspace = attributeNode->qname.space;
        }
        if (attributeNode->literalNamespace) {
            np->literalNamespace = 1;
        }
    } else {
        /*
            "space"::var
         */
        if (np->qname.space) {
            nspace = np->qname.space;
        }
    }
    if (nspace == 0) {
        if (overrideNamespace) {
            nspace = overrideNamespace;
        } else if (cp->blockState->defaultNamespace) {
            nspace = cp->blockState->defaultNamespace;
        } else {
            nspace = cp->blockState->nspace;
        }
    }
    assert(nspace);

    if (state->inFunction) {
        ;
    } else if (state->inClass) {
        if (ejsCompareAsc(cp->ejs, nspace, EJS_INTERNAL_NAMESPACE) == 0) {
            nspace = cp->fileState->nspace;
        } else if (ejsCompareAsc(cp->ejs, nspace, EJS_PRIVATE_NAMESPACE) == 0 || 
                   ejsCompareAsc(cp->ejs, nspace, EJS_PROTECTED_NAMESPACE) == 0) {
            nspace = ejsFormatReservedNamespace(cp->ejs, &state->currentClassName, nspace);
        }
    } else {
        if (cp->visibleGlobals && !(attributeNode && attributeNode->qname.space)) {
            nspace = ejsCreateStringFromAsc(cp->ejs, EJS_EMPTY_NAMESPACE);
        } else if (ejsCompareAsc(cp->ejs, nspace, EJS_INTERNAL_NAMESPACE) == 0) {
            nspace = cp->fileState->nspace;
        }
    }
    assert(nspace);
    np->qname.space = nspace;

    mprTrace(7, "Parser apply attributes namespace = \"%@\", current line %w", nspace, np->loc.source);
    assert(np->qname.space);
    np->attributes |= attributes;
}


static void addTokenToLiteral(EcCompiler *cp, EcNode *np)
{
    MprBuf      *buf;

    if (np) {
        buf = np->literal.data;
        mprPutBlockToBuf(buf, (char*) cp->token->text, cp->token->length * sizeof(wchar));
        mprAddNullToBuf(buf);
    }
}


static void addCharsToLiteral(EcCompiler *cp, EcNode *np, wchar *str, ssize count)
{
    MprBuf      *buf;

    if (np) {
        buf = np->literal.data;
        mprPutBlockToBuf(buf, (char*) str, count * sizeof(wchar));
        mprAddNullToBuf(buf);
    }
}


static void addAscToLiteral(EcCompiler *cp, EcNode *np, cchar *str, ssize count)
{
    MprBuf      *buf;
    wchar       c;
    int         i;

    if (np) {
        buf = np->literal.data;
        for (i = 0; i < count; i++) {
            c = (uchar) str[i];
            mprPutBlockToBuf(buf, (char*) &c, sizeof(wchar));
        }
        mprAddNullToBuf(buf);
    }
}


/*
    Reset the input. Eat all tokens, clear errors, exceptions and the result value. Used by ejs for console input.
 */
PUBLIC void ecResetInput(EcCompiler *cp)
{
    Ejs         *ejs;
    EcToken     *tp;

    ejs = cp->ejs;
    cp->stream->flags &= ~EC_STREAM_EOL;
    cp->error = 0;
    cp->ejs->exception = 0;
    cp->ejs->result = ESV(undefined);
    while ((tp = cp->putback) != 0 && (tp->tokenId == T_EOF || tp->tokenId == T_NOP)) {
        ecGetToken(cp);
    }
}


PUBLIC void ecSetOptimizeLevel(EcCompiler *cp, int level)
{
    cp->optimizeLevel = level;
}


PUBLIC void ecSetWarnLevel(EcCompiler *cp, int level)
{
    cp->warnLevel = level;
}


PUBLIC void ecSetStrictMode(EcCompiler *cp, int enabled)
{
    cp->strict = enabled;
}


PUBLIC void ecSetTabWidth(EcCompiler *cp, int width)
{
    cp->tabWidth = width;
}


PUBLIC void ecSetOutputFile(EcCompiler *cp, cchar *outputFile)
{
    if (outputFile) {
        //  UNICODE
        cp->outputFile = sclone(outputFile);
    }
}


PUBLIC void ecSetOutputDir(EcCompiler *cp, cchar *outputDir)
{
    if (outputDir) {
        //  UNICODE
        cp->outputDir = sclone(outputDir);
    }
}


PUBLIC void ecSetCertFile(EcCompiler *cp, cchar *certFile)
{
    //  UNICODE
    cp->certFile = sclone(certFile);
}


static EjsString *tokenString(EcCompiler *cp)
{
    Ejs     *ejs;

    ejs = cp->ejs;
    if (cp->token) {
        return ejsCreateString(cp->ejs, cp->token->text, cp->token->length);
    }
    return ESV(empty);
}


PUBLIC void ecMarkLocation(EcLocation *loc)
{
    mprMark(loc->source);
    mprMark(loc->filename);
}


static void manageNode(EcNode *node, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        ejsMarkName(&node->qname);
        ecMarkLocation(&node->loc);
        mprMark(node->blockRef);
        mprMark(node->namespaceRef);
        mprMark(node->typeNode);
        mprMark(node->children);
        mprMark(node->namespaces);
        mprMark(node->code);
        mprMark(node->doc);

        switch (node->kind) {
        case N_ARGS:
            break;

        case N_ASSIGN_OP:
            break;

        case N_BINARY_OP:
            break;

        case N_BLOCK:
            break;

        case N_BREAK:
            break;

        case N_CALL:
            break;

        case N_CLASS:
            mprMark(node->klass.implements);
            mprMark(node->klass.constructor);
            mprMark(node->klass.staticProperties);
            mprMark(node->klass.instanceProperties);
            mprMark(node->klass.classMethods);
            mprMark(node->klass.methods);
            mprMark(node->klass.ref);
            mprMark(node->klass.initializer);
            mprMark(node->klass.publicSpace);
            mprMark(node->klass.internalSpace);
            mprMark(node->klass.extends);
            break;

        case N_CASE_LABEL:
            mprMark(node->caseLabel.expression);
            mprMark(node->caseLabel.expressionCode);
            break;

        case N_CASE_ELEMENTS:
            break;

        case N_CATCH:
            mprMark(node->catchBlock.arg);
            break;

        case N_CATCH_ARG:
            break;

        case N_CATCH_CLAUSES:
            break;
            
        case N_CONTINUE:
            break;

        case N_DASSIGN:
            mprMark(node->objectLiteral.typeNode)
            break;

        case N_DIRECTIVES:
            break;

        case N_DO:
            break;

        case N_DOT:
            break;

        case N_END_FUNCTION:
            break;

        case N_EXPRESSIONS:
            break;

        case N_FIELD:
            mprMark(node->field.expr);
            mprMark(node->field.fieldName);
            break;

        case N_FOR:
            mprMark(node->forLoop.body);
            mprMark(node->forLoop.cond);
            mprMark(node->forLoop.initializer);
            mprMark(node->forLoop.perLoop);
            mprMark(node->forLoop.condCode);
            mprMark(node->forLoop.bodyCode);
            mprMark(node->forLoop.perLoopCode);
            break;

        case N_FOR_IN:
            mprMark(node->forInLoop.iterVar);
            mprMark(node->forInLoop.iterGet);
            mprMark(node->forInLoop.iterNext);
            mprMark(node->forInLoop.body);
            mprMark(node->forInLoop.initCode);
            mprMark(node->forInLoop.bodyCode);
            break;

        case N_FUNCTION:
            mprMark(node->function.resultType);
            mprMark(node->function.body);
            mprMark(node->function.parameters);
            mprMark(node->function.constructorSettings);
#if UNUSED
            mprMark(node->function.expressionRef);
#endif
            mprMark(node->function.functionVar);
            break;

        case N_HASH:
            mprMark(node->hash.expr);
            mprMark(node->hash.body);
            break;

        case N_IF:
            mprMark(node->tenary.cond);
            mprMark(node->tenary.thenBlock);
            mprMark(node->tenary.elseBlock);
            mprMark(node->tenary.thenCode);
            mprMark(node->tenary.elseCode);
            break;

        case N_LITERAL:
            mprMark(node->literal.var);
            mprMark(node->literal.data);
            break;

        case N_MODULE:
            mprMark(node->module.ref);
            mprMark(node->module.filename);
            mprMark(node->module.name);
            break;
                
        case N_NEW:
            break;
                
        case N_NOP:
            break;

        case N_OBJECT_LITERAL:
            mprMark(node->objectLiteral.typeNode);
            break;

        case N_QNAME:
            mprMark(node->name.nameExpr);
            mprMark(node->name.qualifierExpr);
            mprMark(node->name.nsvalue);
            break;

        case N_POSTFIX_OP:
            break;

        case N_PRAGMA:
            break;

        case N_PRAGMAS:
            break;

        case N_PROGRAM:
            mprMark(node->program.dependencies);
            break;

        case N_REF:
            mprMark(node->ref.node);
            break;

        case N_RETURN:
            break;

        case N_SPREAD:
            break;

        case N_SUPER:
            break;

        case N_SWITCH:
            break;

        case N_THIS:
            break;

        case N_THROW:
            break;

        case N_TRY:
            mprMark(node->exception.tryBlock);
            mprMark(node->exception.catchClauses);
            mprMark(node->exception.finallyBlock);
            break;

        case N_TYPE_IDENTIFIERS:
            break;
                
        case N_UNARY_OP:
            break;

        case N_USE_NAMESPACE:
            break;

        case N_VAR:
            break;

        case N_VAR_DEFINITION:
            break;

        case N_USE_MODULE:
            break;

        case N_WITH:
            mprMark(node->with.object);
            mprMark(node->with.statement);
            break;

        default:
            assert(0);
        }
    }
}


/*
    Create a new node. This will be automatically freed when returning from a non-terminal production (ie. the state
    is destroyed). Returning results are preserved by stealing the node from the state memory context.

    NOTE: we are using a tree based memory allocator with destructors.
 */
static EcNode *createNode(EcCompiler *cp, int kind, EjsString *name)
{
    EcNode      *np;
    EcToken     *token;

    assert(cp->state);

    if ((np = mprAllocObj(EcNode, manageNode)) == 0) {
        return 0;
    }
    np->seqno = cp->nextSeqno++;
    np->qname.name = name;
    np->kind = kind;
    np->cp = cp;
    np->slotNum = -1;
    np->lookup.slotNum = -1;

    /*
        Remember the current input token. Don't do for initial program and module nodes.
     */
    if (cp->token == 0 && cp->state->blockNestCount > 0) {
        getToken(cp);
        putToken(cp);
        peekToken(cp);
    }
    token = cp->token;

    if (token) {
        np->tokenId = token->tokenId;
        np->groupMask = token->groupMask;
        np->subId = token->subId;
    }
    np->children = mprCreateList(-1, 0);
    if (token && token->loc.source) {
        np->loc = token->loc;
    }
#if ME_DEBUG
    np->kindName = nodes[kind];
    if (token && token->tokenId >= 0) {
        np->tokenName = tokenNames[token->tokenId];
    }
#endif
    return np;
}


/*
    Report an error. Return a null EcNode so callers can report an error and return the null in one statement.
 */
static EcNode *parseError(EcCompiler *cp, cchar *fmt, ...)
{
    EcToken     *tp;
    va_list     args;

    cp->errorCount++;
    cp->error = 1;
    tp = cp->token;
    va_start(args, fmt);
    if (tp) {
        ecErrorv(cp, "Error", &tp->loc, fmt, args);
    } else {
        ecErrorv(cp, "Error", NULL, fmt, args);
    }
    va_end(args);
    return 0;
}


#if UNUSED
PUBLIC EcNode *ecParseWarning(EcCompiler *cp, cchar *fmt, ...)
{
    EcToken     *tp;
    va_list     args;

    va_start(arg, fmt);
    cp->warningCount++;
    tp = cp->token;
    ecError(cp, "Warning", &tp->loc, fmt, args);
    va_end(args);
    return 0;
}
#endif


/*
    Just part of a VxWorks 5.4 compiler bug to avoid a linker crash
 */
static void dummy(int junk) { }

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/compiler/ecState.c"
 */
/************************************************************************/

/**
    ecState.c - Manage state for the parser

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Code ************************************/

static void manageState(EcState *state, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(state->next);
        mprMark(state->code);
        mprMark(state->currentClass);
        mprMark(state->currentClassNode);
        mprMark(state->currentFunction);
        mprMark(state->currentFunctionNode);
        mprMark(state->currentModule);
        mprMark(state->currentObjectNode);
        mprMark(state->defaultNamespace);
        mprMark(state->instanceCodeBuf);
        mprMark(state->letBlock);
        mprMark(state->letBlockNode);
        mprMark(state->nspace);
        mprMark(state->optimizedLetBlock);
        mprMark(state->staticCodeBuf);
        mprMark(state->topVarBlockNode);
        mprMark(state->varBlock);
    }
}


/*
    Enter a new level. For the parser, this is a new production rule. For the ASP processor or code generator, 
    it is a new AST node. Push old state and setup a new production state
 */
PUBLIC int ecEnterState(EcCompiler *cp)
{
    EcState     *state;

    if ((state = mprAllocBlock(sizeof(EcState), MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        return MPR_ERR_MEMORY;
    }
    mprSetManager(state, (MprManager) manageState);
    if (cp->state) {
        *state = *cp->state;
    }
    state->next = cp->state;
    cp->state = state;
    return 0;
}


PUBLIC void ecLeaveState(EcCompiler *cp)
{
    cp->state = cp->state->next;
}


/*
    Leave a level. Pop the state and pass back the current node.
 */
PUBLIC EcNode *ecLeaveStateWithResult(EcCompiler *cp, EcNode *np)
{
    ecLeaveState(cp);
    if (cp->fatalError || cp->error) {
        return 0;
    }
    return np;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/dtoa.c"
 */
/************************************************************************/

/* 
    Source from: http://www.netlib.org/fp/dtoa.c

    Changes wrapped with #if EMBEDTHIS
 */
/****************************************************************
 *
 * The author of this software is David M. Gay.
 *
 * Copyright (c) 1991, 2000, 2001 by Lucent Technologies.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR LUCENT MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 ***************************************************************/

/* Please send bug reports to David M. Gay (dmg at acm dot org,
 * with " at " changed at "@" and " dot " changed to ".").  */

/* On a machine with IEEE extended-precision registers, it is
 * necessary to specify double-precision (53-bit) rounding precision
 * before invoking strtod or dtoa.  If the machine uses (the equivalent
 * of) Intel 80x87 arithmetic, the call
 *  _control87(PC_53, MCW_PC);
 * does this with many compilers.  Whether this or another call is
 * appropriate depends on the compiler; for this to work, it may be
 * necessary to #include "float.h" or another system-dependent header
 * file.
 */

/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.
 *
 * This strtod returns a nearest machine number to the input decimal
 * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are
 * broken by the IEEE round-even rule.  Otherwise ties are broken by
 * biased rounding (add half and chop).
 *
 * Inspired loosely by William D. Clinger's paper "How to Read Floating
 * Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 92-101].
 *
 * Modifications:
 *
 *  1. We only require IEEE, IBM, or VAX double-precision
 *      arithmetic (not IEEE double-extended).
 *  2. We get by with floating-point arithmetic in a case that
 *      Clinger missed -- when we're computing d * 10^n
 *      for a small integer d and the integer n is not too
 *      much larger than 22 (the maximum integer k for which
 *      we can represent 10^k exactly), we may be able to
 *      compute (d*10^k) * 10^(e-k) with just one roundoff.
 *  3. Rather than a bit-at-a-time adjustment of the binary
 *      result in the hard case, we use floating-point
 *      arithmetic to determine the adjustment to within
 *      one bit; only in really hard cases do we need to
 *      compute a second residual.
 *  4. Because of 3., we don't need a large table of powers of 10
 *      for ten-to-e (just some small tables, e.g. of 10^k
 *      for 0 <= k <= 22).
 */

/*
 * #define IEEE_8087 for IEEE-arithmetic machines where the least
 *  significant byte has the lowest address.
 * #define IEEE_MC68k for IEEE-arithmetic machines where the most
 *  significant byte has the lowest address.
 * #define Long int on machines with 32-bit ints and 64-bit longs.
 * #define IBM for IBM mainframe-style floating-point arithmetic.
 * #define VAX for VAX-style floating-point arithmetic (D_floating).
 * #define No_leftright to omit left-right logic in fast floating-point
 *  computation of dtoa.
 * #define Honor_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3
 *  and strtod and dtoa should round accordingly.  Unless Trust_FLT_ROUNDS
 *  is also #defined, fegetround() will be queried for the rounding mode.
 *  Note that both FLT_ROUNDS and fegetround() are specified by the C99
 *  standard (and are specified to be consistent, with fesetround()
 *  affecting the value of FLT_ROUNDS), but that some (Linux) systems
 *  do not work correctly in this regard, so using fegetround() is more
 *  portable than using FLT_FOUNDS directly.
 * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3
 *  and Honor_FLT_ROUNDS is not #defined.
 * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines
 *  that use extended-precision instructions to compute rounded
 *  products and quotients) with IBM.
 * #define ROUND_BIASED for IEEE-format with biased rounding.
 * #define Inaccurate_Divide for IEEE-format with correctly rounded
 *  products but inaccurate quotients, e.g., for Intel i860.
 * #define NO_LONG_LONG on machines that do not have a "long long"
 *  integer type (of >= 64 bits).  On such machines, you can
 *  #define Just_16 to store 16 bits per 32-bit Long when doing
 *  high-precision integer arithmetic.  Whether this speeds things
 *  up or slows things down depends on the machine and the number
 *  being converted.  If long long is available and the name is
 *  something other than "long long", #define Llong to be the name,
 *  and if "unsigned Llong" does not work as an unsigned version of
 *  Llong, #define #ULLong to be the corresponding unsigned type.
 * #define KR_headers for old-style C function headers.
 * #define Bad_float_h if your system lacks a float.h or if it does not
 *  define some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP,
 *  FLT_RADIX, FLT_ROUNDS, and DBL_MAX.
 * #define MALLOC your_malloc, where your_malloc(n) acts like malloc(n)
 *  if memory is available and otherwise does something you deem
 *  appropriate.  If MALLOC is undefined, malloc will be invoked
 *  directly -- and assumed always to succeed.  Similarly, if you
 *  want something other than the system's free() to be called to
 *  recycle memory acquired from MALLOC, #define FREE to be the
 *  name of the alternate routine.  (FREE or free is only called in
 *  pathological cases, e.g., in a dtoa call after a dtoa return in
 *  mode 3 with thousands of digits requested.)
 * #define Omit_Private_Memory to omit logic (added Jan. 1998) for making
 *  memory allocations from a private pool of memory when possible.
 *  When used, the private pool is PRIVATE_MEM bytes long:  2304 bytes,
 *  unless #defined to be a different length.  This default length
 *  suffices to get rid of MALLOC calls except for unusual cases,
 *  such as decimal-to-binary conversion of a very long string of
 *  digits.  The longest string dtoa can return is about 751 bytes
 *  long.  For conversions by strtod of strings of 800 digits and
 *  all dtoa conversions in single-threaded executions with 8-byte
 *  pointers, PRIVATE_MEM >= 7400 appears to suffice; with 4-byte
 *  pointers, PRIVATE_MEM >= 7112 appears adequate.
 * #define NO_INFNAN_CHECK if you do not wish to have INFNAN_CHECK
 *  #defined automatically on IEEE systems.  On such systems,
 *  when INFNAN_CHECK is #defined, strtod checks
 *  for Infinity and NaN (case insensitively).  On some systems
 *  (e.g., some HP systems), it may be necessary to #define NAN_WORD0
 *  appropriately -- to the most significant word of a quiet NaN.
 *  (On HP Series 700/800 machines, -DNAN_WORD0=0x7ff40000 works.)
 *  When INFNAN_CHECK is #defined and No_Hex_NaN is not #defined,
 *  strtod also accepts (case insensitively) strings of the form
 *  NaN(x), where x is a string of hexadecimal digits and spaces;
 *  if there is only one string of hexadecimal digits, it is taken
 *  for the 52 fraction bits of the resulting NaN; if there are two
 *  or more strings of hex digits, the first is for the high 20 bits,
 *  the second and subsequent for the low 32 bits, with intervening
 *  white space ignored; but if this results in none of the 52
 *  fraction bits being on (an IEEE Infinity symbol), then NAN_WORD0
 *  and NAN_WORD1 are used instead.
 * #define MULTIPLE_THREADS if the system offers preemptively scheduled
 *  multiple threads.  In this case, you must provide (or suitably
 *  #define) two locks, acquired by ACQUIRE_DTOA_LOCK(n) and freed
 *  by FREE_DTOA_LOCK(n) for n = 0 or 1.  (The second lock, accessed
 *  in pow5mult, ensures lazy evaluation of only one copy of high
 *  powers of 5; omitting this lock would introduce a small
 *  probability of wasting memory, but would otherwise be harmless.)
 *  You must also invoke freedtoa(s) to free the value s returned by
 *  dtoa.  You may do so whether or not MULTIPLE_THREADS is #defined.
 * #define NO_IEEE_Scale to disable new (Feb. 1997) logic in strtod that
 *  avoids underflows on inputs whose result does not underflow.
 *  If you #define NO_IEEE_Scale on a machine that uses IEEE-format
 *  floating-point numbers and flushes underflows to zero rather
 *  than implementing gradual underflow, then you must also #define
 *  Sudden_Underflow.
 * #define USE_LOCALE to use the current locale's decimal_point value.
 * #define SET_INEXACT if IEEE arithmetic is being used and extra
 *  computation should be done to set the inexact flag when the
 *  result is inexact and avoid setting inexact when the result
 *  is exact.  In this case, dtoa.c must be compiled in
 *  an environment, perhaps provided by #include "dtoa.c" in a
 *  suitable wrapper, that defines two functions,
 *      int get_inexact(void);
 *      void clear_inexact(void);
 *  such that get_inexact() returns a nonzero value if the
 *  inexact bit is already set, and clear_inexact() sets the
 *  inexact bit to 0.  When SET_INEXACT is #defined, strtod
 *  also does extra computations to set the underflow and overflow
 *  flags when appropriate (i.e., when the result is tiny and
 *  inexact or when it is a numeric value rounded to +-infinity).
 * #define NO_ERRNO if strtod should not assign errno = ERANGE when
 *  the result overflows to +-Infinity or underflows to 0.
 * #define NO_HEX_FP to omit recognition of hexadecimal floating-point
 *  values by strtod.
 * #define NO_STRTOD_BIGCOMP (on IEEE-arithmetic systems only for now)
 *  to disable logic for "fast" testing of very long input strings
 *  to strtod.  This testing proceeds by initially truncating the
 *  input string, then if necessary comparing the whole string with
 *  a decimal expansion to decide close cases. This logic is only
 *  used for input more than STRTOD_DIGLIM digits long (default 40).
 */

#if EMBEDTHIS || 1
 #include    "me.h"
 #include    "osdep.h"
#endif
#ifndef ME_FLOAT
    #define ME_FLOAT 1
#endif
#if ME_FLOAT

#if EMBEDTHIS || 1
#include    "mpr.h"
    #define MULTIPLE_THREADS 1
    PUBLIC void ejsLockDtoa(int n);
    PUBLIC void ejsUnlockDtoa(int n);
    #if WINDOWS || WINCE
        typedef int int32_t;
        typedef unsigned int uint32_t;
    #endif
    #define Long int32_t
    #define ULong uint32_t
#if ME_ENDIAN == MPR_BIG_ENDIAN
    #define IEEE_MC68k 1
#else
    #define IEEE_8087 1
#endif
#if VXWORKS
    #undef MALLOC
    #undef FREE
    #undef LSB
    #undef Bcopy
#endif
#endif

#ifndef Long
#define Long long
#endif
#ifndef ULong
typedef unsigned Long ULong;
#endif

#if !EMBEDTHIS
#ifdef DEBUG
 #include "stdio.h"
#define Bug(x) {fprintf(stderr, "%s\n", x); exit(1);}
#endif

 #include "stdlib.h"
 #include "string.h"

#if FREEBSD
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
#endif

#ifdef USE_LOCALE
 #include "locale.h"
#endif

#ifdef Honor_FLT_ROUNDS
#ifndef Trust_FLT_ROUNDS
 #include <fenv.h>
#endif
#endif
#endif

#ifdef MALLOC
#ifdef KR_headers
extern char *MALLOC();
#else
extern void *MALLOC(ssize);
#endif
#else
#define MALLOC malloc
#endif

#ifndef Omit_Private_Memory
#ifndef PRIVATE_MEM
#define PRIVATE_MEM 2304
#endif
#define PRIVATE_mem ((PRIVATE_MEM+sizeof(double)-1)/sizeof(double))
static double private_mem[PRIVATE_mem], *pmem_next = private_mem;
#endif

#undef IEEE_Arith
#undef Avoid_Underflow
#ifdef IEEE_MC68k
#define IEEE_Arith
#endif
#ifdef IEEE_8087
#define IEEE_Arith
#endif

#ifdef IEEE_Arith
#ifndef NO_INFNAN_CHECK
#undef INFNAN_CHECK
#define INFNAN_CHECK
#endif
#else
#undef INFNAN_CHECK
#define NO_STRTOD_BIGCOMP
#endif

 #include "errno.h"

#ifdef Bad_float_h

#ifdef IEEE_Arith
#define DBL_DIG 15
#define DBL_MAX_10_EXP 308
#define DBL_MAX_EXP 1024
#define FLT_RADIX 2
#endif /*IEEE_Arith*/

#ifdef IBM
#define DBL_DIG 16
#define DBL_MAX_10_EXP 75
#define DBL_MAX_EXP 63
#define FLT_RADIX 16
#define DBL_MAX 7.2370055773322621e+75
#endif

#ifdef VAX
#define DBL_DIG 16
#define DBL_MAX_10_EXP 38
#define DBL_MAX_EXP 127
#define FLT_RADIX 2
#define DBL_MAX 1.7014118346046923e+38
#endif

#ifndef LONG_MAX
#define LONG_MAX 2147483647
#endif

#else /* ifndef Bad_float_h */
 #include "float.h"
#endif /* Bad_float_h */

#ifndef __MATH_H__
 #include "math.h"
#endif

#if EMBEDTHIS || 1
#define strtod own_strtod
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef CONST
#ifdef KR_headers
#define CONST /* blank */
#else
#define CONST const
#endif
#endif

#if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(VAX) + defined(IBM) != 1
Exactly one of IEEE_8087, IEEE_MC68k, VAX, or IBM should be defined.
#endif

typedef union { double d; ULong L[2]; } U;

#ifdef IEEE_8087
#define word0(x) (x)->L[1]
#define word1(x) (x)->L[0]
#else
#define word0(x) (x)->L[0]
#define word1(x) (x)->L[1]
#endif
#define dval(x) (x)->d

#ifndef STRTOD_DIGLIM
#define STRTOD_DIGLIM 40
#endif

#ifdef DIGLIM_DEBUG
extern int strtod_diglim;
#else
#define strtod_diglim STRTOD_DIGLIM
#endif

/* The following definition of Storeinc is appropriate for MIPS processors.
 * An alternative that might be better on some machines is
 * #define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)
 */
#if defined(IEEE_8087) + defined(VAX)
#define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b, \
((unsigned short *)a)[0] = (unsigned short)c, a++)
#else
#define Storeinc(a,b,c) (((unsigned short *)a)[0] = (unsigned short)b, \
((unsigned short *)a)[1] = (unsigned short)c, a++)
#endif

/* #define P DBL_MANT_DIG */
/* Ten_pmax = floor(P*log(2)/log(5)) */
/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */
/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */

#ifdef IEEE_Arith
#define Exp_shift  20
#define Exp_shift1 20
#define Exp_msk1    0x100000
#define Exp_msk11   0x100000
#define Exp_mask  0x7ff00000
#define P 53
#define Nbits 53
#define BBias 1023
#define Emax 1023
#define Emin (-1022)
#define Exp_1  0x3ff00000
#define Exp_11 0x3ff00000
#define Ebits 11
#define Frac_mask  0xfffff
#define Frac_mask1 0xfffff
#define Ten_pmax 22
#define Bletch 0x10
#define Bndry_mask  0xfffff
#define Bndry_mask1 0xfffff
#define LSB 1
#define Sign_bit 0x80000000
#define Log2P 1
#define Tiny0 0
#define Tiny1 1
#define Quick_max 14
#define Int_max 14
#ifndef NO_IEEE_Scale
#define Avoid_Underflow
#ifdef Flush_Denorm /* debugging option */
#undef Sudden_Underflow
#endif
#endif

#ifndef Flt_Rounds
#ifdef FLT_ROUNDS
#define Flt_Rounds FLT_ROUNDS
#else
#define Flt_Rounds 1
#endif
#endif /*Flt_Rounds*/

#ifdef Honor_FLT_ROUNDS
#undef Check_FLT_ROUNDS
#define Check_FLT_ROUNDS
#else
#define Rounding Flt_Rounds
#endif

#else /* ifndef IEEE_Arith */
#undef Check_FLT_ROUNDS
#undef Honor_FLT_ROUNDS
#undef SET_INEXACT
#undef  Sudden_Underflow
#define Sudden_Underflow
#ifdef IBM
#undef Flt_Rounds
#define Flt_Rounds 0
#define Exp_shift  24
#define Exp_shift1 24
#define Exp_msk1   0x1000000
#define Exp_msk11  0x1000000
#define Exp_mask  0x7f000000
#define P 14
#define Nbits 56
#define BBias 65
#define Emax 248
#define Emin (-260)
#define Exp_1  0x41000000
#define Exp_11 0x41000000
#define Ebits 8 /* exponent has 7 bits, but 8 is the right value in b2d */
#define Frac_mask  0xffffff
#define Frac_mask1 0xffffff
#define Bletch 4
#define Ten_pmax 22
#define Bndry_mask  0xefffff
#define Bndry_mask1 0xffffff
#define LSB 1
#define Sign_bit 0x80000000
#define Log2P 4
#define Tiny0 0x100000
#define Tiny1 0
#define Quick_max 14
#define Int_max 15
#else /* VAX */
#undef Flt_Rounds
#define Flt_Rounds 1
#define Exp_shift  23
#define Exp_shift1 7
#define Exp_msk1    0x80
#define Exp_msk11   0x800000
#define Exp_mask  0x7f80
#define P 56
#define Nbits 56
#define BBias 129
#define Emax 126
#define Emin (-129)
#define Exp_1  0x40800000
#define Exp_11 0x4080
#define Ebits 8
#define Frac_mask  0x7fffff
#define Frac_mask1 0xffff007f
#define Ten_pmax 24
#define Bletch 2
#define Bndry_mask  0xffff007f
#define Bndry_mask1 0xffff007f
#define LSB 0x10000
#define Sign_bit 0x8000
#define Log2P 1
#define Tiny0 0x80
#define Tiny1 0
#define Quick_max 15
#define Int_max 15
#endif /* IBM, VAX */
#endif /* IEEE_Arith */

#ifndef IEEE_Arith
#define ROUND_BIASED
#endif

#ifdef RND_PRODQUOT
#define rounded_product(a,b) a = rnd_prod(a, b)
#define rounded_quotient(a,b) a = rnd_quot(a, b)
#ifdef KR_headers
extern double rnd_prod(), rnd_quot();
#else
extern double rnd_prod(double, double), rnd_quot(double, double);
#endif
#else
#define rounded_product(a,b) a *= b
#define rounded_quotient(a,b) a /= b
#endif

#define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+BBias-1))
#define Big1 0xffffffff

#ifndef Pack_32
#define Pack_32
#endif

typedef struct BCinfo BCinfo;
 struct
BCinfo { int dp0, dp1, dplen, dsign, e0, inexact, nd, nd0, rounding, scale, uflchk; };

#ifdef KR_headers
#define FFFFFFFF ((((unsigned long)0xffff)<<16)|(unsigned long)0xffff)
#else
#define FFFFFFFF 0xffffffffUL
#endif

#ifdef NO_LONG_LONG
#undef ULLong
#ifdef Just_16
#undef Pack_32
/* When Pack_32 is not defined, we store 16 bits per 32-bit Long.
 * This makes some inner loops simpler and sometimes saves work
 * during multiplications, but it often seems to make things slightly
 * slower.  Hence the default is now to store 32 bits per Long.
 */
#endif
#else   /* long long available */
#ifndef Llong
#define Llong long long
#endif
#ifndef ULLong
#define ULLong unsigned Llong
#endif
#endif /* NO_LONG_LONG */

#ifndef MULTIPLE_THREADS
#define ACQUIRE_DTOA_LOCK(n)    /*nothing*/
#define FREE_DTOA_LOCK(n)   /*nothing*/
#else
#define ACQUIRE_DTOA_LOCK(n) ejsLockDtoa(n);
#define FREE_DTOA_LOCK(n) ejsUnlockDtoa(n);
#endif

#define Kmax 7

#ifdef __cplusplus
extern "C" double strtod(const char *s00, char **se);
extern "C" char *dtoa(double d, int mode, int ndigits,
            int *decpt, int *sign, char **rve);
#endif

 struct
Bigint {
    struct Bigint *next;
    int k, maxwds, sign, wds;
    ULong x[1];
    };

 typedef struct Bigint Bigint;

 static Bigint *freelist[Kmax+1];

 static Bigint *
Balloc
#ifdef KR_headers
    (k) int k;
#else
    (int k)
#endif
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    unsigned int len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    /* The k > Kmax case does not need ACQUIRE_DTOA_LOCK(0), */
    /* but this case seems very unlikely. */
    if (k <= Kmax && (rv = freelist[k]))
        freelist[k] = rv->next;
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (unsigned int) ((sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1) / sizeof(double));
        if (k <= Kmax && pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        } else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
        }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;
    }

 static void
Bfree
#ifdef KR_headers
    (v) Bigint *v;
#else
    (Bigint *v)
#endif
{
    if (v) {
        if (v->k > Kmax)
#ifdef FREE
            FREE((void*)v);
#else
            free((void*)v);
#endif
        else {
            ACQUIRE_DTOA_LOCK(0);
            v->next = freelist[v->k];
            freelist[v->k] = v;
            FREE_DTOA_LOCK(0);
            }
        }
    }

#define Bcopy(x,y) memcpy((char *)&x->sign, (char *)&y->sign, \
y->wds*sizeof(Long) + 2*sizeof(int))

 static Bigint *
multadd
#ifdef KR_headers
    (b, m, a) Bigint *b; int m, a;
#else
    (Bigint *b, int m, int a)   /* multiply by m and add a */
#endif
{
    int i, wds;
#ifdef ULLong
    ULong *x;
    ULLong carry, y;
#else
    ULong carry, *x, y;
#ifdef Pack_32
    ULong xi, z;
#endif
#endif
    Bigint *b1;

    wds = b->wds;
    x = b->x;
    i = 0;
    carry = a;
    do {
#ifdef ULLong
        y = *x * (ULLong)m + carry;
        carry = y >> 32;
        *x++ = (ULong) (y & FFFFFFFF);
#else
#ifdef Pack_32
        xi = *x;
        y = (xi & 0xffff) * m + carry;
        z = (xi >> 16) * m + (y >> 16);
        carry = z >> 16;
        *x++ = (z << 16) + (y & 0xffff);
#else
        y = *x * m + carry;
        carry = y >> 16;
        *x++ = y & 0xffff;
#endif
#endif
        }
        while(++i < wds);
    if (carry) {
        if (wds >= b->maxwds) {
            b1 = Balloc(b->k+1);
            Bcopy(b1, b);
            Bfree(b);
            b = b1;
            }
        b->x[wds++] = (ULong) carry;
        b->wds = wds;
        }
    return b;
    }

 static Bigint *
s2b
#ifdef KR_headers
    (s, nd0, nd, y9, dplen) CONST char *s; int nd0, nd, dplen; ULong y9;
#else
    (CONST char *s, int nd0, int nd, ULong y9, int dplen)
#endif
{
    Bigint *b;
    int i, k;
    Long x, y;

    x = (nd + 8) / 9;
    for(k = 0, y = 1; x > y; y <<= 1, k++) ;
#ifdef Pack_32
    b = Balloc(k);
    b->x[0] = y9;
    b->wds = 1;
#else
    b = Balloc(k+1);
    b->x[0] = y9 & 0xffff;
    b->wds = (b->x[1] = y9 >> 16) ? 2 : 1;
#endif

    i = 9;
    if (9 < nd0) {
        s += 9;
        do b = multadd(b, 10, *s++ - '0');
            while(++i < nd0);
        s += dplen;
        }
    else
        s += dplen + 9;
    for(; i < nd; i++)
        b = multadd(b, 10, *s++ - '0');
    return b;
    }

 static int
hi0bits
#ifdef KR_headers
    (x) ULong x;
#else
    (ULong x)
#endif
{
    int k = 0;

    if (!(x & 0xffff0000)) {
        k = 16;
        x <<= 16;
        }
    if (!(x & 0xff000000)) {
        k += 8;
        x <<= 8;
        }
    if (!(x & 0xf0000000)) {
        k += 4;
        x <<= 4;
        }
    if (!(x & 0xc0000000)) {
        k += 2;
        x <<= 2;
        }
    if (!(x & 0x80000000)) {
        k++;
        if (!(x & 0x40000000))
            return 32;
        }
    return k;
    }

 static int
lo0bits
#ifdef KR_headers
    (y) ULong *y;
#else
    (ULong *y)
#endif
{
    int k;
    ULong x = *y;

    if (x & 7) {
        if (x & 1)
            return 0;
        if (x & 2) {
            *y = x >> 1;
            return 1;
            }
        *y = x >> 2;
        return 2;
        }
    k = 0;
    if (!(x & 0xffff)) {
        k = 16;
        x >>= 16;
        }
    if (!(x & 0xff)) {
        k += 8;
        x >>= 8;
        }
    if (!(x & 0xf)) {
        k += 4;
        x >>= 4;
        }
    if (!(x & 0x3)) {
        k += 2;
        x >>= 2;
        }
    if (!(x & 1)) {
        k++;
        x >>= 1;
        if (!x)
            return 32;
        }
    *y = x;
    return k;
    }

 static Bigint *
i2b
#ifdef KR_headers
    (i) int i;
#else
    (int i)
#endif
{
    Bigint *b;

    b = Balloc(1);
    b->x[0] = i;
    b->wds = 1;
    return b;
    }

 static Bigint *
mult
#ifdef KR_headers
    (a, b) Bigint *a, *b;
#else
    (Bigint *a, Bigint *b)
#endif
{
    Bigint *c;
    int k, wa, wb, wc;
    ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
    ULong y;
#ifdef ULLong
    ULLong carry, z;
#else
    ULong carry, z;
#ifdef Pack_32
    ULong z2;
#endif
#endif

    if (a->wds < b->wds) {
        c = a;
        a = b;
        b = c;
        }
    k = a->k;
    wa = a->wds;
    wb = b->wds;
    wc = wa + wb;
    if (wc > a->maxwds)
        k++;
    c = Balloc(k);
    for(x = c->x, xa = x + wc; x < xa; x++)
        *x = 0;
    xa = a->x;
    xae = xa + wa;
    xb = b->x;
    xbe = xb + wb;
    xc0 = c->x;
#ifdef ULLong
    for(; xb < xbe; xc0++) {
        if ((y = *xb++)) {
            x = xa;
            xc = xc0;
            carry = 0;
            do {
                z = *x++ * (ULLong)y + *xc + carry;
                carry = z >> 32;
                *xc++ = (ULong) (z & FFFFFFFF);
                }
                while(x < xae);
            *xc = (ULong) carry;
            }
        }
#else
#ifdef Pack_32
    for(; xb < xbe; xb++, xc0++) {
        if (y = *xb & 0xffff) {
            x = xa;
            xc = xc0;
            carry = 0;
            do {
                z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
                carry = z >> 16;
                z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
                carry = z2 >> 16;
                Storeinc(xc, z2, z);
                }
                while(x < xae);
            *xc = carry;
            }
        if (y = *xb >> 16) {
            x = xa;
            xc = xc0;
            carry = 0;
            z2 = *xc;
            do {
                z = (*x & 0xffff) * y + (*xc >> 16) + carry;
                carry = z >> 16;
                Storeinc(xc, z, z2);
                z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
                carry = z2 >> 16;
                }
                while(x < xae);
            *xc = z2;
            }
        }
#else
    for(; xb < xbe; xc0++) {
        if (y = *xb++) {
            x = xa;
            xc = xc0;
            carry = 0;
            do {
                z = *x++ * y + *xc + carry;
                carry = z >> 16;
                *xc++ = (ULong) (z & 0xffff);
                }
                while(x < xae);
            *xc = carry;
            }
        }
#endif
#endif
    for(xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;
    c->wds = wc;
    return c;
    }

 static Bigint *p5s;

 static Bigint *
pow5mult
#ifdef KR_headers
    (b, k) Bigint *b; int k;
#else
    (Bigint *b, int k)
#endif
{
    Bigint *b1, *p5, *p51;
    int i;
    static int p05[3] = { 5, 25, 125 };

    if ((i = k & 3))
        b = multadd(b, p05[i-1], 0);

    if (!(k >>= 2))
        return b;
    if (!(p5 = p5s)) {
        /* first time */
#ifdef MULTIPLE_THREADS
        ACQUIRE_DTOA_LOCK(1);
        if (!(p5 = p5s)) {
            p5 = p5s = i2b(625);
            p5->next = 0;
            }
        FREE_DTOA_LOCK(1);
#else
        p5 = p5s = i2b(625);
        p5->next = 0;
#endif
        }
    for(;;) {
        if (k & 1) {
            b1 = mult(b, p5);
            Bfree(b);
            b = b1;
            }
        if (!(k >>= 1))
            break;
        if (!(p51 = p5->next)) {
#ifdef MULTIPLE_THREADS
            ACQUIRE_DTOA_LOCK(1);
            if (!(p51 = p5->next)) {
                p51 = p5->next = mult(p5,p5);
                p51->next = 0;
                }
            FREE_DTOA_LOCK(1);
#else
            p51 = p5->next = mult(p5,p5);
            p51->next = 0;
#endif
            }
        p5 = p51;
        }
    return b;
    }

 static Bigint *
lshift
#ifdef KR_headers
    (b, k) Bigint *b; int k;
#else
    (Bigint *b, int k)
#endif
{
    int i, k1, n, n1;
    Bigint *b1;
    ULong *x, *x1, *xe, z;

#ifdef Pack_32
    n = k >> 5;
#else
    n = k >> 4;
#endif
    k1 = b->k;
    n1 = n + b->wds + 1;
    for(i = b->maxwds; n1 > i; i <<= 1)
        k1++;
    b1 = Balloc(k1);
    x1 = b1->x;
    for(i = 0; i < n; i++)
        *x1++ = 0;
    x = b->x;
    xe = x + b->wds;
#ifdef Pack_32
    if (k &= 0x1f) {
        k1 = 32 - k;
        z = 0;
        do {
            *x1++ = *x << k | z;
            z = *x++ >> k1;
            }
            while(x < xe);
        if ((*x1 = z))
            ++n1;
        }
#else
    if (k &= 0xf) {
        k1 = 16 - k;
        z = 0;
        do {
            *x1++ = *x << k  & 0xffff | z;
            z = *x++ >> k1;
            }
            while(x < xe);
        if (*x1 = z)
            ++n1;
        }
#endif
    else do
        *x1++ = *x++;
        while(x < xe);
    b1->wds = n1 - 1;
    Bfree(b);
    return b1;
    }

 static int
cmp
#ifdef KR_headers
    (a, b) Bigint *a, *b;
#else
    (Bigint *a, Bigint *b)
#endif
{
    ULong *xa, *xa0, *xb, *xb0;
    int i, j;

    i = a->wds;
    j = b->wds;
#ifdef DEBUG
    if (i > 1 && !a->x[i-1])
        Bug("cmp called with a->x[a->wds-1] == 0");
    if (j > 1 && !b->x[j-1])
        Bug("cmp called with b->x[b->wds-1] == 0");
#endif
    if (i -= j)
        return i;
    xa0 = a->x;
    xa = xa0 + j;
    xb0 = b->x;
    xb = xb0 + j;
    for(;;) {
        if (*--xa != *--xb)
            return *xa < *xb ? -1 : 1;
        if (xa <= xa0)
            break;
        }
    return 0;
    }

 static Bigint *
diff
#ifdef KR_headers
    (a, b) Bigint *a, *b;
#else
    (Bigint *a, Bigint *b)
#endif
{
    Bigint *c;
    int i, wa, wb;
    ULong *xa, *xae, *xb, *xbe, *xc;
#ifdef ULLong
    ULLong borrow, y;
#else
    ULong borrow, y;
#ifdef Pack_32
    ULong z;
#endif
#endif

    i = cmp(a,b);
    if (!i) {
        c = Balloc(0);
        c->wds = 1;
        c->x[0] = 0;
        return c;
        }
    if (i < 0) {
        c = a;
        a = b;
        b = c;
        i = 1;
        }
    else
        i = 0;
    c = Balloc(a->k);
    c->sign = i;
    wa = a->wds;
    xa = a->x;
    xae = xa + wa;
    wb = b->wds;
    xb = b->x;
    xbe = xb + wb;
    xc = c->x;
    borrow = 0;
#ifdef ULLong
    do {
        y = (ULLong)*xa++ - *xb++ - borrow;
        borrow = y >> 32 & (ULong)1;
        *xc++ = (ULong) (y & FFFFFFFF);
        }
        while(xb < xbe);
    while(xa < xae) {
        y = *xa++ - borrow;
        borrow = y >> 32 & (ULong)1;
        *xc++ = (ULong) (y & FFFFFFFF);
        }
#else
#ifdef Pack_32
    do {
        y = (*xa & 0xffff) - (*xb & 0xffff) - borrow;
        borrow = (y & 0x10000) >> 16;
        z = (*xa++ >> 16) - (*xb++ >> 16) - borrow;
        borrow = (z & 0x10000) >> 16;
        Storeinc(xc, z, y);
        }
        while(xb < xbe);
    while(xa < xae) {
        y = (*xa & 0xffff) - borrow;
        borrow = (y & 0x10000) >> 16;
        z = (*xa++ >> 16) - borrow;
        borrow = (z & 0x10000) >> 16;
        Storeinc(xc, z, y);
        }
#else
    do {
        y = *xa++ - *xb++ - borrow;
        borrow = (y & 0x10000) >> 16;
        *xc++ = (ULong) (y & 0xffff);
        }
        while(xb < xbe);
    while(xa < xae) {
        y = *xa++ - borrow;
        borrow = (y & 0x10000) >> 16;
        *xc++ = (ULong) (y & 0xffff);
        }
#endif
#endif
    while(!*--xc)
        wa--;
    c->wds = wa;
    return c;
    }

 static double
ulp
#ifdef KR_headers
    (x) U *x;
#else
    (U *x)
#endif
{
    Long L;
    U u;

    L = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;
#ifndef Avoid_Underflow
#ifndef Sudden_Underflow
    if (L > 0) {
#endif
#endif
#ifdef IBM
        L |= Exp_msk1 >> 4;
#endif
        word0(&u) = L;
        word1(&u) = 0;
#ifndef Avoid_Underflow
#ifndef Sudden_Underflow
        }
    else {
        L = -L >> Exp_shift;
        if (L < Exp_shift) {
            word0(&u) = 0x80000 >> L;
            word1(&u) = 0;
            }
        else {
            word0(&u) = 0;
            L -= Exp_shift;
            word1(&u) = L >= 31 ? 1 : 1 << 31 - L;
            }
        }
#endif
#endif
    return dval(&u);
    }

 static double
b2d
#ifdef KR_headers
    (a, e) Bigint *a; int *e;
#else
    (Bigint *a, int *e)
#endif
{
    ULong *xa, *xa0, w, y, z;
    int k;
    U d;
#ifdef VAX
    ULong d0, d1;
#else
#define d0 word0(&d)
#define d1 word1(&d)
#endif

    xa0 = a->x;
    xa = xa0 + a->wds;
    y = *--xa;
#ifdef DEBUG
    if (!y) Bug("zero y in b2d");
#endif
    k = hi0bits(y);
    *e = 32 - k;
#ifdef Pack_32
    if (k < Ebits) {
        d0 = Exp_1 | y >> (Ebits - k);
        w = xa > xa0 ? *--xa : 0;
        d1 = y << ((32-Ebits) + k) | w >> (Ebits - k);
        goto ret_d;
        }
    z = xa > xa0 ? *--xa : 0;
    if (k -= Ebits) {
        d0 = Exp_1 | y << k | z >> (32 - k);
        y = xa > xa0 ? *--xa : 0;
        d1 = z << k | y >> (32 - k);
        }
    else {
        d0 = Exp_1 | y;
        d1 = z;
        }
#else
    if (k < Ebits + 16) {
        z = xa > xa0 ? *--xa : 0;
        d0 = Exp_1 | y << k - Ebits | z >> Ebits + 16 - k;
        w = xa > xa0 ? *--xa : 0;
        y = xa > xa0 ? *--xa : 0;
        d1 = z << k + 16 - Ebits | w << k - Ebits | y >> 16 + Ebits - k;
        goto ret_d;
        }
    z = xa > xa0 ? *--xa : 0;
    w = xa > xa0 ? *--xa : 0;
    k -= Ebits + 16;
    d0 = Exp_1 | y << k + 16 | z << k | w >> 16 - k;
    y = xa > xa0 ? *--xa : 0;
    d1 = w << k + 16 | y << k;
#endif
 ret_d:
#ifdef VAX
    word0(&d) = d0 >> 16 | d0 << 16;
    word1(&d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
    return dval(&d);
    }

 static Bigint *
d2b
#ifdef KR_headers
    (d, e, bits) U *d; int *e, *bits;
#else
    (U *d, int *e, int *bits)
#endif
{
    Bigint *b;
    int de, k;
    ULong *x, y, z;
#ifndef Sudden_Underflow
    int i;
#endif
#ifdef VAX
    ULong d0, d1;
    d0 = word0(d) >> 16 | word0(d) << 16;
    d1 = word1(d) >> 16 | word1(d) << 16;
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

#ifdef Pack_32
    b = Balloc(1);
#else
    b = Balloc(2);
#endif
    x = b->x;

    z = d0 & Frac_mask;
    d0 &= 0x7fffffff;   /* clear sign bit, which we ignore */
#ifdef Sudden_Underflow
    de = (int)(d0 >> Exp_shift);
#ifndef IBM
    z |= Exp_msk11;
#endif
#else
    if ((de = (int)(d0 >> Exp_shift)))
        z |= Exp_msk1;
#endif
#ifdef Pack_32
    if ((y = d1)) {
        if ((k = lo0bits(&y))) {
            x[0] = y | z << (32 - k);
            z >>= k;
            }
        else
            x[0] = y;
#ifndef Sudden_Underflow
        i =
#endif
            b->wds = (x[1] = z) ? 2 : 1;
        }
    else {
        k = lo0bits(&z);
        x[0] = z;
#ifndef Sudden_Underflow
        i =
#endif
            b->wds = 1;
        k += 32;
        }
#else
    if (y = d1) {
        if (k = lo0bits(&y))
            if (k >= 16) {
                x[0] = y | z << 32 - k & 0xffff;
                x[1] = z >> k - 16 & 0xffff;
                x[2] = z >> k;
                i = 2;
                }
            else {
                x[0] = y & 0xffff;
                x[1] = y >> 16 | z << 16 - k & 0xffff;
                x[2] = z >> k & 0xffff;
                x[3] = z >> k+16;
                i = 3;
                }
        else {
            x[0] = y & 0xffff;
            x[1] = y >> 16;
            x[2] = z & 0xffff;
            x[3] = z >> 16;
            i = 3;
            }
        }
    else {
#ifdef DEBUG
        if (!z)
            Bug("Zero passed to d2b");
#endif
        k = lo0bits(&z);
        if (k >= 16) {
            x[0] = z;
            i = 0;
            }
        else {
            x[0] = z & 0xffff;
            x[1] = z >> 16;
            i = 1;
            }
        k += 32;
        }
    while(!x[i])
        --i;
    b->wds = i + 1;
#endif
#ifndef Sudden_Underflow
    if (de) {
#endif
#ifdef IBM
        *e = (de - BBias - (P-1) << 2) + k;
        *bits = 4*P + 8 - k - hi0bits(word0(d) & Frac_mask);
#else
        *e = de - BBias - (P-1) + k;
        *bits = P - k;
#endif
#ifndef Sudden_Underflow
        }
    else {
        *e = de - BBias - (P-1) + 1 + k;
#ifdef Pack_32
        *bits = 32*i - hi0bits(x[i-1]);
#else
        *bits = (i+2)*16 - hi0bits(x[i]);
#endif
        }
#endif
    return b;
    }
#undef d0
#undef d1

 static double
ratio
#ifdef KR_headers
    (a, b) Bigint *a, *b;
#else
    (Bigint *a, Bigint *b)
#endif
{
    U da, db;
    int k, ka, kb;

    dval(&da) = b2d(a, &ka);
    dval(&db) = b2d(b, &kb);
#ifdef Pack_32
    k = ka - kb + 32*(a->wds - b->wds);
#else
    k = ka - kb + 16*(a->wds - b->wds);
#endif
#ifdef IBM
    if (k > 0) {
        word0(&da) += (k >> 2)*Exp_msk1;
        if (k &= 3)
            dval(&da) *= 1 << k;
        }
    else {
        k = -k;
        word0(&db) += (k >> 2)*Exp_msk1;
        if (k &= 3)
            dval(&db) *= 1 << k;
        }
#else
    if (k > 0)
        word0(&da) += k*Exp_msk1;
    else {
        k = -k;
        word0(&db) += k*Exp_msk1;
        }
#endif
    return dval(&da) / dval(&db);
    }

 static CONST double
tens[] = {
        1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
        1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
        1e20, 1e21, 1e22
#ifdef VAX
        , 1e23, 1e24
#endif
        };

 static CONST double
#ifdef IEEE_Arith
bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };
static CONST double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,
#ifdef Avoid_Underflow
        9007199254740992.*9007199254740992.e-256
        /* = 2^106 * 1e-256 */
#else
        1e-256
#endif
        };
/* The factor of 2^53 in tinytens[4] helps us avoid setting the underflow */
/* flag unnecessarily.  It leads to a song and dance at the end of strtod. */
#define Scale_Bit 0x10
#define n_bigtens 5
#else
#ifdef IBM
bigtens[] = { 1e16, 1e32, 1e64 };
static CONST double tinytens[] = { 1e-16, 1e-32, 1e-64 };
#define n_bigtens 3
#else
bigtens[] = { 1e16, 1e32 };
static CONST double tinytens[] = { 1e-16, 1e-32 };
#define n_bigtens 2
#endif
#endif

#undef Need_Hexdig
#ifdef INFNAN_CHECK
#ifndef No_Hex_NaN
#define Need_Hexdig
#endif
#endif

#ifndef Need_Hexdig
#ifndef NO_HEX_FP
#define Need_Hexdig
#endif
#endif

#ifdef Need_Hexdig /*{*/
static unsigned char hexdig[256];

 static void
#ifdef KR_headers
htinit(h, s, inc) unsigned char *h; unsigned char *s; int inc;
#else
htinit(unsigned char *h, unsigned char *s, int inc)
#endif
{
    int i, j;
    for(i = 0; (j = s[i]) !=0; i++)
        h[j] = i + inc;
    }

 static void
#ifdef KR_headers
hexdig_init()
#else
hexdig_init(void)
#endif
{
#define USC (unsigned char *)
    htinit(hexdig, USC "0123456789", 0x10);
    htinit(hexdig, USC "abcdef", 0x10 + 10);
    htinit(hexdig, USC "ABCDEF", 0x10 + 10);
    }
#endif /* } Need_Hexdig */

#ifdef INFNAN_CHECK

#ifndef NAN_WORD0
#define NAN_WORD0 0x7ff80000
#endif

#ifndef NAN_WORD1
#define NAN_WORD1 0
#endif

 static int
dmatch
#ifdef KR_headers
    (sp, t) char **sp, *t;
#else
    (CONST char **sp, char *t)
#endif
{
    int c, d;
    CONST char *s = *sp;

    while((d = *t++)) {
        if ((c = *++s) >= 'A' && c <= 'Z')
            c += 'a' - 'A';
        if (c != d)
            return 0;
        }
    *sp = s + 1;
    return 1;
    }

#ifndef No_Hex_NaN
 static void
hexnan
#ifdef KR_headers
    (rvp, sp) U *rvp; CONST char **sp;
#else
    (U *rvp, CONST char **sp)
#endif
{
    ULong c, x[2];
    CONST char *s;
    int c1, havedig, udx0, xshift;

    if (!hexdig['0'])
        hexdig_init();
    x[0] = x[1] = 0;
    havedig = xshift = 0;
    udx0 = 1;
    s = *sp;
    /* allow optional initial 0x or 0X */
    while((c = *(CONST unsigned char*)(s+1)) && c <= ' ')
        ++s;
    if (s[1] == '0' && (s[2] == 'x' || s[2] == 'X'))
        s += 2;
    while((c = *(CONST unsigned char*)++s)) {
        if ((c1 = hexdig[c]))
            c  = c1 & 0xf;
        else if (c <= ' ') {
            if (udx0 && havedig) {
                udx0 = 0;
                xshift = 1;
                }
            continue;
            }
#ifdef GDTOA_NON_PEDANTIC_NANCHECK
        else if (/*(*/ c == ')' && havedig) {
            *sp = s + 1;
            break;
            }
        else
            return; /* invalid form: don't change *sp */
#else
        else {
            do {
                if (/*(*/ c == ')') {
                    *sp = s + 1;
                    break;
                    }
                } while((c = *++s));
            break;
            }
#endif
        havedig = 1;
        if (xshift) {
            xshift = 0;
            x[0] = x[1];
            x[1] = 0;
            }
        if (udx0)
            x[0] = (x[0] << 4) | (x[1] >> 28);
        x[1] = (x[1] << 4) | c;
        }
    if ((x[0] &= 0xfffff) || x[1]) {
        word0(rvp) = Exp_mask | x[0];
        word1(rvp) = x[1];
        }
    }
#endif /*No_Hex_NaN*/
#endif /* INFNAN_CHECK */

#ifdef Pack_32
#define ULbits 32
#define kshift 5
#define kmask 31
#else
#define ULbits 16
#define kshift 4
#define kmask 15
#endif
#ifndef NO_HEX_FP /*{*/

 static void
#ifdef KR_headers
rshift(b, k) Bigint *b; int k;
#else
rshift(Bigint *b, int k)
#endif
{
    ULong *x, *x1, *xe, y;
    int n;

    x = x1 = b->x;
    n = k >> kshift;
    if (n < b->wds) {
        xe = x + b->wds;
        x += n;
        if (k &= kmask) {
            n = 32 - k;
            y = *x++ >> k;
            while(x < xe) {
                *x1++ = (y | (*x << n)) & 0xffffffff;
                y = *x++ >> k;
                }
            if ((*x1 = y) !=0)
                x1++;
            }
        else
            while(x < xe)
                *x1++ = *x++;
        }
    if ((b->wds = (int) (x1 - b->x)) == 0)
        b->x[0] = 0;
    }

 static ULong
#ifdef KR_headers
any_on(b, k) Bigint *b; int k;
#else
any_on(Bigint *b, int k)
#endif
{
    int n, nwds;
    ULong *x, *x0, x1, x2;

    x = b->x;
    nwds = b->wds;
    n = k >> kshift;
    if (n > nwds)
        n = nwds;
    else if (n < nwds && (k &= kmask)) {
        x1 = x2 = x[n];
        x1 >>= k;
        x1 <<= k;
        if (x1 != x2)
            return 1;
        }
    x0 = x;
    x += n;
    while(x > x0)
        if (*--x)
            return 1;
    return 0;
    }

enum {  /* rounding values: same as FLT_ROUNDS */
    Round_zero = 0,
    Round_near = 1,
    Round_up = 2,
    Round_down = 3
    };

 static Bigint *
#ifdef KR_headers
increment(b) Bigint *b;
#else
increment(Bigint *b)
#endif
{
    ULong *x, *xe;
    Bigint *b1;

    x = b->x;
    xe = x + b->wds;
    do {
        if (*x < (ULong)0xffffffffL) {
            ++*x;
            return b;
            }
        *x++ = 0;
        } while(x < xe);
    {
        if (b->wds >= b->maxwds) {
            b1 = Balloc(b->k+1);
            Bcopy(b1,b);
            Bfree(b);
            b = b1;
            }
        b->x[b->wds++] = 1;
        }
    return b;
    }

 void
#ifdef KR_headers
gethex(sp, rvp, rounding, sign)
    CONST char **sp; U *rvp; int rounding, sign;
#else
gethex( CONST char **sp, U *rvp, int rounding, int sign)
#endif
{
    Bigint *b;
    CONST unsigned char *decpt, *s0, *s, *s1;
    Long e, e1;
    ULong L, lostbits, *x;
    int big, denorm, esign, havedig, k, n, nbits, up, zret;
#ifdef IBM
    int j;
#endif
    enum {
#ifdef IEEE_Arith /*{{*/
        emax = 0x7fe - BBias - P + 1,
        emin = Emin - P + 1
#else /*}{*/
        emin = Emin - P,
#ifdef VAX
        emax = 0x7ff - BBias - P + 1
#endif
#ifdef IBM
        emax = 0x7f - BBias - P
#endif
#endif /*}}*/
        };
#ifdef USE_LOCALE
    int i;
#ifdef NO_LOCALE_CACHE
    const unsigned char *decimalpoint = (unsigned char*)
        localeconv()->decimal_point;
#else
    const unsigned char *decimalpoint;
    static unsigned char *decimalpoint_cache;
    if (!(s0 = decimalpoint_cache)) {
        s0 = (unsigned char*)localeconv()->decimal_point;
        if ((decimalpoint_cache = (unsigned char*)
                MALLOC(strlen((CONST char*)s0) + 1))) {
            strcpy((char*)decimalpoint_cache, (CONST char*)s0);
            s0 = decimalpoint_cache;
            }
        }
    decimalpoint = s0;
#endif
#endif

    if (!hexdig['0'])
        hexdig_init();
    havedig = 0;
    s0 = *(CONST unsigned char **)sp + 2;
    while(s0[havedig] == '0')
        havedig++;
    s0 += havedig;
    s = s0;
    decpt = 0;
    zret = 0;
    e = 0;
    if (hexdig[*s])
        havedig++;
    else {
        zret = 1;
#ifdef USE_LOCALE
        for(i = 0; decimalpoint[i]; ++i) {
            if (s[i] != decimalpoint[i])
                goto pcheck;
            }
        decpt = s += i;
#else
        if (*s != '.')
            goto pcheck;
        decpt = ++s;
#endif
        if (!hexdig[*s])
            goto pcheck;
        while(*s == '0')
            s++;
        if (hexdig[*s])
            zret = 0;
        havedig = 1;
        s0 = s;
        }
    while(hexdig[*s])
        s++;
#ifdef USE_LOCALE
    if (*s == *decimalpoint && !decpt) {
        for(i = 1; decimalpoint[i]; ++i) {
            if (s[i] != decimalpoint[i])
                goto pcheck;
            }
        decpt = s += i;
#else
    if (*s == '.' && !decpt) {
        decpt = ++s;
#endif
        while(hexdig[*s])
            s++;
        }/*}*/
    if (decpt)
        e = -(((Long)(s-decpt)) << 2);
 pcheck:
    s1 = s;
    big = esign = 0;
    switch(*s) {
      case 'p':
      case 'P':
        switch(*++s) {
          case '-':
            esign = 1;
            /* no break */
          case '+':
            s++;
          }
        if ((n = hexdig[*s]) == 0 || n > 0x19) {
            s = s1;
            break;
            }
        e1 = n - 0x10;
        while((n = hexdig[*++s]) !=0 && n <= 0x19) {
            if (e1 & 0xf8000000)
                big = 1;
            e1 = 10*e1 + n - 0x10;
            }
        if (esign)
            e1 = -e1;
        e += e1;
      }
    *sp = (char*)s;
    if (!havedig)
        *sp = (char*)s0 - 1;
    if (zret)
        goto retz1;
    if (big) {
        if (esign) {
#ifdef IEEE_Arith
            switch(rounding) {
              case Round_up:
                if (sign)
                    break;
                goto ret_tiny;
              case Round_down:
                if (!sign)
                    break;
                goto ret_tiny;
              }
#endif
            goto retz;
#ifdef IEEE_Arith
 ret_tiny:
#ifndef NO_ERRNO
            errno = ERANGE;
#endif
            word0(rvp) = 0;
            word1(rvp) = 1;
            return;
#endif /* IEEE_Arith */
            }
        switch(rounding) {
          case Round_near:
            goto ovfl1;
          case Round_up:
            if (!sign)
                goto ovfl1;
            goto ret_big;
          case Round_down:
            if (sign)
                goto ovfl1;
            goto ret_big;
          }
 ret_big:
        word0(rvp) = Big0;
        word1(rvp) = Big1;
        return;
        }
    n = (int) (s1 - s0) - 1;
    for(k = 0; n > (1 << (kshift-2)) - 1; n >>= 1)
        k++;
    b = Balloc(k);
    x = b->x;
    n = 0;
    L = 0;
#ifdef USE_LOCALE
    for(i = 0; decimalpoint[i+1]; ++i);
#endif
    while(s1 > s0) {
#ifdef USE_LOCALE
        if (*--s1 == decimalpoint[i]) {
            s1 -= i;
            continue;
            }
#else
        if (*--s1 == '.')
            continue;
#endif
        if (n == ULbits) {
            *x++ = L;
            L = 0;
            n = 0;
            }
        L |= (hexdig[*s1] & 0x0f) << n;
        n += 4;
        }
    *x++ = L;
    b->wds = n = (int) (x - b->x);
    n = ULbits*n - hi0bits(L);
    nbits = Nbits;
    lostbits = 0;
    x = b->x;
    if (n > nbits) {
        n -= nbits;
        if (any_on(b,n)) {
            lostbits = 1;
            k = n - 1;
            if (x[k>>kshift] & 1 << (k & kmask)) {
                lostbits = 2;
                if (k > 0 && any_on(b,k))
                    lostbits = 3;
                }
            }
        rshift(b, n);
        e += n;
        }
    else if (n < nbits) {
        n = nbits - n;
        b = lshift(b, n);
        e -= n;
        x = b->x;
        }
    if (e > Emax) {
 ovfl:
        Bfree(b);
 ovfl1:
#ifndef NO_ERRNO
        errno = ERANGE;
#endif
        word0(rvp) = Exp_mask;
        word1(rvp) = 0;
        return;
        }
    denorm = 0;
    if (e < emin) {
        denorm = 1;
        n = emin - e;
        if (n >= nbits) {
#ifdef IEEE_Arith /*{*/
            switch (rounding) {
              case Round_near:
                if (n == nbits && (n < 2 || any_on(b,n-1)))
                    goto ret_tiny;
                break;
              case Round_up:
                if (!sign)
                    goto ret_tiny;
                break;
              case Round_down:
                if (sign)
                    goto ret_tiny;
              }
#endif /* } IEEE_Arith */
            Bfree(b);
 retz:
#ifndef NO_ERRNO
            errno = ERANGE;
#endif
 retz1:
            rvp->d = 0.;
            return;
            }
        k = n - 1;
        if (lostbits)
            lostbits = 1;
        else if (k > 0)
            lostbits = any_on(b,k);
        if (x[k>>kshift] & 1 << (k & kmask))
            lostbits |= 2;
        nbits -= n;
        rshift(b,n);
        e = emin;
        }
    if (lostbits) {
        up = 0;
        switch(rounding) {
          case Round_zero:
            break;
          case Round_near:
            if (lostbits & 2
             && (lostbits & 1) | (x[0] & 1))
                up = 1;
            break;
          case Round_up:
            up = 1 - sign;
            break;
          case Round_down:
            up = sign;
          }
        if (up) {
            k = b->wds;
            b = increment(b);
            x = b->x;
            if (denorm) {
#if 0
                if (nbits == Nbits - 1
                 && x[nbits >> kshift] & 1 << (nbits & kmask))
                    denorm = 0; /* not currently used */
#endif
                }
            else if (b->wds > k
             || ((n = nbits & kmask) !=0
                 && hi0bits(x[k-1]) < 32-n)) {
                rshift(b,1);
                if (++e > Emax)
                    goto ovfl;
                }
            }
        }
#ifdef IEEE_Arith
    if (denorm)
        word0(rvp) = b->wds > 1 ? b->x[1] & ~0x100000 : 0;
    else
        word0(rvp) = (b->x[1] & ~0x100000) | ((e + 0x3ff + 52) << 20);
    word1(rvp) = b->x[0];
#endif
#ifdef IBM
    if ((j = e & 3)) {
        k = b->x[0] & ((1 << j) - 1);
        rshift(b,j);
        if (k) {
            switch(rounding) {
              case Round_up:
                if (!sign)
                    increment(b);
                break;
              case Round_down:
                if (sign)
                    increment(b);
                break;
              case Round_near:
                j = 1 << (j-1);
                if (k & j && ((k & (j-1)) | lostbits))
                    increment(b);
              }
            }
        }
    e >>= 2;
    word0(rvp) = b->x[1] | ((e + 65 + 13) << 24);
    word1(rvp) = b->x[0];
#endif
#ifdef VAX
    /* The next two lines ignore swap of low- and high-order 2 bytes. */
    /* word0(rvp) = (b->x[1] & ~0x800000) | ((e + 129 + 55) << 23); */
    /* word1(rvp) = b->x[0]; */
    word0(rvp) = ((b->x[1] & ~0x800000) >> 16) | ((e + 129 + 55) << 7) | (b->x[1] << 16);
    word1(rvp) = (b->x[0] >> 16) | (b->x[0] << 16);
#endif
    Bfree(b);
    }
#endif /*}!NO_HEX_FP*/

 static int
#ifdef KR_headers
dshift(b, p2) Bigint *b; int p2;
#else
dshift(Bigint *b, int p2)
#endif
{
    int rv = hi0bits(b->x[b->wds-1]) - 4;
    if (p2 > 0)
        rv -= p2;
    return rv & kmask;
    }

 static int
quorem
#ifdef KR_headers
    (b, S) Bigint *b, *S;
#else
    (Bigint *b, Bigint *S)
#endif
{
    int n;
    ULong *bx, *bxe, q, *sx, *sxe;
#ifdef ULLong
    ULLong borrow, carry, y, ys;
#else
    ULong borrow, carry, y, ys;
#ifdef Pack_32
    ULong si, z, zs;
#endif
#endif

    n = S->wds;
#ifdef DEBUG
    /*debug*/ if (b->wds > n)
    /*debug*/   Bug("oversize b in quorem");
#endif
    if (b->wds < n)
        return 0;
    sx = S->x;
    sxe = sx + --n;
    bx = b->x;
    bxe = bx + n;
    q = *bxe / (*sxe + 1);  /* ensure q <= true quotient */
#ifdef DEBUG
    /*debug*/ if (q > 9)
    /*debug*/   Bug("oversized quotient in quorem");
#endif
    if (q) {
        borrow = 0;
        carry = 0;
        do {
#ifdef ULLong
            ys = *sx++ * (ULLong)q + carry;
            carry = ys >> 32;
            y = *bx - (ys & FFFFFFFF) - borrow;
            borrow = y >> 32 & (ULong)1;
            *bx++ = (ULong) (y & FFFFFFFF);
#else
#ifdef Pack_32
            si = *sx++;
            ys = (si & 0xffff) * q + carry;
            zs = (si >> 16) * q + (ys >> 16);
            carry = zs >> 16;
            y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
            borrow = (y & 0x10000) >> 16;
            z = (*bx >> 16) - (zs & 0xffff) - borrow;
            borrow = (z & 0x10000) >> 16;
            Storeinc(bx, z, y);
#else
            ys = *sx++ * q + carry;
            carry = ys >> 16;
            y = *bx - (ys & 0xffff) - borrow;
            borrow = (y & 0x10000) >> 16;
            *bx++ = (ULong) (y & 0xffff);
#endif
#endif
            }
            while(sx <= sxe);
        if (!*bxe) {
            bx = b->x;
            while(--bxe > bx && !*bxe)
                --n;
            b->wds = n;
            }
        }
    if (cmp(b, S) >= 0) {
        q++;
        borrow = 0;
        carry = 0;
        bx = b->x;
        sx = S->x;
        do {
#ifdef ULLong
            ys = *sx++ + carry;
            carry = ys >> 32;
            y = *bx - (ys & FFFFFFFF) - borrow;
            borrow = y >> 32 & (ULong)1;
            *bx++ = (ULong) (y & FFFFFFFF);
#else
#ifdef Pack_32
            si = *sx++;
            ys = (si & 0xffff) + carry;
            zs = (si >> 16) + (ys >> 16);
            carry = zs >> 16;
            y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
            borrow = (y & 0x10000) >> 16;
            z = (*bx >> 16) - (zs & 0xffff) - borrow;
            borrow = (z & 0x10000) >> 16;
            Storeinc(bx, z, y);
#else
            ys = *sx++ + carry;
            carry = ys >> 16;
            y = *bx - (ys & 0xffff) - borrow;
            borrow = (y & 0x10000) >> 16;
            *bx++ = (ULong) (y & 0xffff);
#endif
#endif
            }
            while(sx <= sxe);
        bx = b->x;
        bxe = bx + n;
        if (!*bxe) {
            while(--bxe > bx && !*bxe)
                --n;
            b->wds = n;
            }
        }
    return q;
    }

#ifndef NO_STRTOD_BIGCOMP

 static double
sulp
#ifdef KR_headers
    (x, bc) U *x; BCinfo *bc;
#else
    (U *x, BCinfo *bc)
#endif
{
    U u;
    double rv;
    int i;

    rv = ulp(x);
    if (!bc->scale)
        return rv;
    i = 2*P + 1 - ((word0(x) & Exp_mask) >> Exp_shift);
    word0(&u) = Exp_1 + (i << Exp_shift);
    word1(&u) = 0;
    return rv * u.d;
    }

 static void
bigcomp
#ifdef KR_headers
    (rv, s0, bc)
    U *rv; CONST char *s0; BCinfo *bc;
#else
    (U *rv, CONST char *s0, BCinfo *bc)
#endif
{
    Bigint *b, *d;
    int b2, bbits, d2, dd, dig, dsign, i, j, nd, nd0, p2, p5, speccase;

    dd = 0;
    dsign = bc->dsign;
    nd = bc->nd;
    nd0 = bc->nd0;
    p5 = nd + bc->e0 - 1;
    speccase = 0;
#ifndef Sudden_Underflow
    if (rv->d == 0.) {  /* special case: value near underflow-to-zero */
                /* threshold was rounded to zero */
        b = i2b(1);
        p2 = Emin - P + 1;
        bbits = 1;
#ifdef Avoid_Underflow
        word0(rv) = (P+2) << Exp_shift;
#else
        word1(rv) = 1;
#endif
        i = 0;
#ifdef Honor_FLT_ROUNDS
        if (bc->rounding == 1)
#endif
            {
            speccase = 1;
            --p2;
            dsign = 0;
            goto have_i;
            }
        }
    else
#endif
        b = d2b(rv, &p2, &bbits);
#ifdef Avoid_Underflow
    p2 -= bc->scale;
#endif
    /* floor(log2(rv)) == bbits - 1 + p2 */
    /* Check for denormal case. */
    i = P - bbits;
    if (i > (j = P - Emin - 1 + p2)) {
#ifdef Sudden_Underflow
        Bfree(b);
        b = i2b(1);
        p2 = Emin;
        i = P - 1;
#ifdef Avoid_Underflow
        word0(rv) = (1 + bc->scale) << Exp_shift;
#else
        word0(rv) = Exp_msk1;
#endif
        word1(rv) = 0;
#else
        i = j;
#endif
        }
#ifdef Honor_FLT_ROUNDS
    if (bc->rounding != 1) {
        if (i > 0)
            b = lshift(b, i);
        if (dsign)
            b = increment(b);
        }
    else
#endif
        {
        b = lshift(b, ++i);
        b->x[0] |= 1;
        }
#ifndef Sudden_Underflow
 have_i:
#endif
    p2 -= p5 + i;
    d = i2b(1);
    /* Arrange for convenient computation of quotients:
     * shift left if necessary so divisor has 4 leading 0 bits.
     */
    if (p5 > 0)
        d = pow5mult(d, p5);
    else if (p5 < 0)
        b = pow5mult(b, -p5);
    if (p2 > 0) {
        b2 = p2;
        d2 = 0;
        }
    else {
        b2 = 0;
        d2 = -p2;
        }
    i = dshift(d, d2);
    if ((b2 += i) > 0)
        b = lshift(b, b2);
    if ((d2 += i) > 0)
        d = lshift(d, d2);

    /* Now b/d = exactly half-way between the two floating-point values */
    /* on either side of the input string.  Compute first digit of b/d. */

    if (!(dig = quorem(b,d))) {
        b = multadd(b, 10, 0);  /* very unlikely */
        dig = quorem(b,d);
        }

    /* EMBEDTHIS fix uninitialized var */
    dd = -1;

    /* Compare b/d with s0 */

    for(i = 0; i < nd0; ) {
        if ((dd = s0[i++] - '0' - dig))
            goto ret;
        if (!b->x[0] && b->wds == 1) {
            if (i < nd)
                dd = 1;
            goto ret;
            }
        b = multadd(b, 10, 0);
        dig = quorem(b,d);
        }
    for(j = bc->dp1; i++ < nd;) {
        if ((dd = s0[j++] - '0' - dig))
            goto ret;
        if (!b->x[0] && b->wds == 1) {
            if (i < nd)
                dd = 1;
            goto ret;
            }
        b = multadd(b, 10, 0);
        dig = quorem(b,d);
        }
    if (b->x[0] || b->wds > 1)
        dd = -1;
 ret:
    Bfree(b);
    Bfree(d);
#ifdef Honor_FLT_ROUNDS
    if (bc->rounding != 1) {
        if (dd < 0) {
            if (bc->rounding == 0) {
                if (!dsign)
                    goto retlow1;
                }
            else if (dsign)
                goto rethi1;
            }
        else if (dd > 0) {
            if (bc->rounding == 0) {
                if (dsign)
                    goto rethi1;
                goto ret1;
                }
            if (!dsign)
                goto rethi1;
            dval(rv) += 2.*sulp(rv,bc);
            }
        else {
            bc->inexact = 0;
            if (dsign)
                goto rethi1;
            }
        }
    else
#endif
    if (speccase) {
        if (dd <= 0)
            rv->d = 0.;
        }
    else if (dd < 0) {
        if (!dsign) /* does not happen for round-near */
retlow1:
            dval(rv) -= sulp(rv,bc);
        }
    else if (dd > 0) {
        if (dsign) {
 rethi1:
            dval(rv) += sulp(rv,bc);
            }
        }
    else {
        /* Exact half-way case:  apply round-even rule. */
        if (word1(rv) & 1) {
            if (dsign)
                goto rethi1;
            goto retlow1;
            }
        }

#ifdef Honor_FLT_ROUNDS
 ret1:
#endif
    return;
    }
#endif /* NO_STRTOD_BIGCOMP */

 double
strtod
#ifdef KR_headers
    (s00, se) CONST char *s00; char **se;
#else
    (CONST char *s00, char **se)
#endif
{
    int bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, e, e1;
    int esign, i, j, k, nd, nd0, nf, nz, nz0, sign;
    CONST char *s, *s0, *s1;
    double aadj, aadj1;
    Long L;
    U aadj2, adj, rv, rv0;
    ULong y, z;
    BCinfo bc;
    Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
#ifdef SET_INEXACT
    int oldinexact;
#endif
#ifdef Honor_FLT_ROUNDS /*{*/
#ifdef Trust_FLT_ROUNDS /*{{ only define this if FLT_ROUNDS really works! */
    bc.rounding = Flt_Rounds;
#else /*}{*/
    bc.rounding = 1;
    switch(fegetround()) {
      case FE_TOWARDZERO:   bc.rounding = 0; break;
      case FE_UPWARD:   bc.rounding = 2; break;
      case FE_DOWNWARD: bc.rounding = 3;
      }
#endif /*}}*/
#endif /*}*/
#ifdef USE_LOCALE
    CONST char *s2;
#endif

    sign = nz0 = nz = bc.dplen = bc.uflchk = 0;
    dval(&rv) = 0.;
    for(s = s00;;s++) switch(*s) {
        case '-':
            sign = 1;
            /* no break */
        case '+':
            if (*++s)
                goto break2;
            /* no break */
        case 0:
            goto ret0;
        case '\t':
        case '\n':
        case '\v':
        case '\f':
        case '\r':
        case ' ':
            continue;
        default:
            goto break2;
        }
 break2:
    if (*s == '0') {
#ifndef NO_HEX_FP /*{*/
        switch(s[1]) {
          case 'x':
          case 'X':
#ifdef Honor_FLT_ROUNDS
            gethex(&s, &rv, bc.rounding, sign);
#else
            gethex(&s, &rv, 1, sign);
#endif
            goto ret;
          }
#endif /*}*/
        nz0 = 1;
        while(*++s == '0') ;
        if (!*s)
            goto ret;
        }
    s0 = s;
    y = z = 0;
    for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
        if (nd < 9)
            y = 10*y + c - '0';
        else if (nd < 16)
            z = 10*z + c - '0';
    nd0 = nd;
    bc.dp0 = bc.dp1 = (int) (s - s0);
#ifdef USE_LOCALE
    s1 = localeconv()->decimal_point;
    if (c == *s1) {
        c = '.';
        if (*++s1) {
            s2 = s;
            for(;;) {
                if (*++s2 != *s1) {
                    c = 0;
                    break;
                    }
                if (!*++s1) {
                    s = s2;
                    break;
                    }
                }
            }
        }
#endif
    if (c == '.') {
        c = *++s;
        bc.dp1 = (int) (s - s0);
        bc.dplen = bc.dp1 - bc.dp0;
        if (!nd) {
            for(; c == '0'; c = *++s)
                nz++;
            if (c > '0' && c <= '9') {
                s0 = s;
                nf += nz;
                nz = 0;
                goto have_dig;
                }
            goto dig_done;
            }
        for(; c >= '0' && c <= '9'; c = *++s) {
 have_dig:
            nz++;
            if (c -= '0') {
                nf += nz;
                for(i = 1; i < nz; i++)
                    if (nd++ < 9)
                        y *= 10;
                    else if (nd <= DBL_DIG + 1)
                        z *= 10;
                if (nd++ < 9)
                    y = 10*y + c;
                else if (nd <= DBL_DIG + 1)
                    z = 10*z + c;
                nz = 0;
                }
            }
        }
 dig_done:
    e = 0;
    if (c == 'e' || c == 'E') {
        if (!nd && !nz && !nz0) {
            goto ret0;
            }
        s00 = s;
        esign = 0;
        switch(c = *++s) {
            case '-':
                esign = 1;
            case '+':
                c = *++s;
            }
        if (c >= '0' && c <= '9') {
            while(c == '0')
                c = *++s;
            if (c > '0' && c <= '9') {
                L = c - '0';
                s1 = s;
                while((c = *++s) >= '0' && c <= '9')
                    L = 10*L + c - '0';
                if (s - s1 > 8 || L > 19999)
                    /* Avoid confusion from exponents
                     * so large that e might overflow.
                     */
                    e = 19999; /* safe for 16 bit ints */
                else
                    e = (int)L;
                if (esign)
                    e = -e;
                }
            else
                e = 0;
            }
        else
            s = s00;
        }
    if (!nd) {
        if (!nz && !nz0) {
#ifdef INFNAN_CHECK
            /* Check for Nan and Infinity */
            if (!bc.dplen)
             switch(c) {
              case 'i':
              case 'I':
                if (dmatch(&s,"nf")) {
                    --s;
                    if (!dmatch(&s,"inity"))
                        ++s;
                    word0(&rv) = 0x7ff00000;
                    word1(&rv) = 0;
                    goto ret;
                    }
                break;
              case 'n':
              case 'N':
                if (dmatch(&s, "an")) {
                    word0(&rv) = NAN_WORD0;
                    word1(&rv) = NAN_WORD1;
#ifndef No_Hex_NaN
                    if (*s == '(') /*)*/
                        hexnan(&rv, &s);
#endif
                    goto ret;
                    }
              }
#endif /* INFNAN_CHECK */
 ret0:
            s = s00;
            sign = 0;
            }
        goto ret;
        }
    bc.e0 = e1 = e -= nf;

    /* Now we have nd0 digits, starting at s0, followed by a
     * decimal point, followed by nd-nd0 digits.  The number we're
     * after is the integer represented by those digits times
     * 10**e */

    if (!nd0)
        nd0 = nd;
    k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
    dval(&rv) = y;
    if (k > 9) {
#ifdef SET_INEXACT
        if (k > DBL_DIG)
            oldinexact = get_inexact();
#endif
        dval(&rv) = tens[k - 9] * dval(&rv) + z;
        }
    bd0 = 0;
    if (nd <= DBL_DIG
#ifndef RND_PRODQUOT
#ifndef Honor_FLT_ROUNDS
        && Flt_Rounds == 1
#endif
#endif
            ) {
        if (!e)
            goto ret;
        if (e > 0) {
            if (e <= Ten_pmax) {
#ifdef VAX
                goto vax_ovfl_check;
#else
#ifdef Honor_FLT_ROUNDS
                /* round correctly FLT_ROUNDS = 2 or 3 */
                if (sign) {
                    rv.d = -rv.d;
                    sign = 0;
                    }
#endif
                /* rv = */ rounded_product(dval(&rv), tens[e]);
                goto ret;
#endif
                }
            i = DBL_DIG - nd;
            if (e <= Ten_pmax + i) {
                /* A fancier test would sometimes let us do
                 * this for larger i values.
                 */
#ifdef Honor_FLT_ROUNDS
                /* round correctly FLT_ROUNDS = 2 or 3 */
                if (sign) {
                    rv.d = -rv.d;
                    sign = 0;
                    }
#endif
                e -= i;
                dval(&rv) *= tens[i];
#ifdef VAX
                /* VAX exponent range is so narrow we must
                 * worry about overflow here...
                 */
 vax_ovfl_check:
                word0(&rv) -= P*Exp_msk1;
                /* rv = */ rounded_product(dval(&rv), tens[e]);
                if ((word0(&rv) & Exp_mask)
                 > Exp_msk1*(DBL_MAX_EXP+BBias-1-P))
                    goto ovfl;
                word0(&rv) += P*Exp_msk1;
#else
                /* rv = */ rounded_product(dval(&rv), tens[e]);
#endif
                goto ret;
                }
            }
#ifndef Inaccurate_Divide
        else if (e >= -Ten_pmax) {
#ifdef Honor_FLT_ROUNDS
            /* round correctly FLT_ROUNDS = 2 or 3 */
            if (sign) {
                rv.d = -rv.d;
                sign = 0;
                }
#endif
            /* rv = */ rounded_quotient(dval(&rv), tens[-e]);
            goto ret;
            }
#endif
        }
    e1 += nd - k;

#ifdef IEEE_Arith
#ifdef SET_INEXACT
    bc.inexact = 1;
    if (k <= DBL_DIG)
        oldinexact = get_inexact();
#endif
#ifdef Avoid_Underflow
    bc.scale = 0;
#endif
#ifdef Honor_FLT_ROUNDS
    if (bc.rounding >= 2) {
        if (sign)
            bc.rounding = bc.rounding == 2 ? 0 : 2;
        else
            if (bc.rounding != 2)
                bc.rounding = 0;
        }
#endif
#endif /*IEEE_Arith*/

    /* Get starting approximation = rv * 10**e1 */

    if (e1 > 0) {
        if ((i = e1 & 15))
            dval(&rv) *= tens[i];
        if (e1 &= ~15) {
            if (e1 > DBL_MAX_10_EXP) {
 ovfl:
#ifndef NO_ERRNO
                errno = ERANGE;
#endif
                /* Can't trust HUGE_VAL */
#ifdef IEEE_Arith
#ifdef Honor_FLT_ROUNDS
                switch(bc.rounding) {
                  case 0: /* toward 0 */
                  case 3: /* toward -infinity */
                    word0(&rv) = Big0;
                    word1(&rv) = Big1;
                    break;
                  default:
                    word0(&rv) = Exp_mask;
                    word1(&rv) = 0;
                  }
#else /*Honor_FLT_ROUNDS*/
                word0(&rv) = Exp_mask;
                word1(&rv) = 0;
#endif /*Honor_FLT_ROUNDS*/
#ifdef SET_INEXACT
                /* set overflow bit */
                dval(&rv0) = 1e300;
                dval(&rv0) *= dval(&rv0);
#endif
#else /*IEEE_Arith*/
                word0(&rv) = Big0;
                word1(&rv) = Big1;
#endif /*IEEE_Arith*/
                goto ret;
                }
            e1 >>= 4;
            for(j = 0; e1 > 1; j++, e1 >>= 1)
                if (e1 & 1)
                    dval(&rv) *= bigtens[j];
        /* The last multiplication could overflow. */
            word0(&rv) -= P*Exp_msk1;
            dval(&rv) *= bigtens[j];
            if ((z = word0(&rv) & Exp_mask)
             > Exp_msk1*(DBL_MAX_EXP+BBias-P))
                goto ovfl;
            if (z > Exp_msk1*(DBL_MAX_EXP+BBias-1-P)) {
                /* set to largest number */
                /* (Can't trust DBL_MAX) */
                word0(&rv) = Big0;
                word1(&rv) = Big1;
                }
            else
                word0(&rv) += P*Exp_msk1;
            }
        }
    else if (e1 < 0) {
        e1 = -e1;
        if ((i = e1 & 15))
            dval(&rv) /= tens[i];
        if (e1 >>= 4) {
            if (e1 >= 1 << n_bigtens)
                goto undfl;
#ifdef Avoid_Underflow
            if (e1 & Scale_Bit)
                bc.scale = 2*P;
            for(j = 0; e1 > 0; j++, e1 >>= 1)
                if (e1 & 1)
                    dval(&rv) *= tinytens[j];
            if (bc.scale && (j = 2*P + 1 - ((word0(&rv) & Exp_mask)
                        >> Exp_shift)) > 0) {
                /* scaled rv is denormal; clear j low bits */
                if (j >= 32) {
                    if (j > 53)
                        goto undfl;
                    word1(&rv) = 0;
                    if (j >= 53)
                     word0(&rv) = (P+2)*Exp_msk1;
                    else
                     word0(&rv) &= 0xffffffff << (j-32);
                    }
                else
                    word1(&rv) &= 0xffffffff << j;
                }
#else
            for(j = 0; e1 > 1; j++, e1 >>= 1)
                if (e1 & 1)
                    dval(&rv) *= tinytens[j];
            /* The last multiplication could underflow. */
            dval(&rv0) = dval(&rv);
            dval(&rv) *= tinytens[j];
            if (!dval(&rv)) {
                dval(&rv) = 2.*dval(&rv0);
                dval(&rv) *= tinytens[j];
#endif
                if (!dval(&rv)) {
 undfl:
                    dval(&rv) = 0.;
#ifndef NO_ERRNO
                    errno = ERANGE;
#endif
                    goto ret;
                    }
#ifndef Avoid_Underflow
                word0(&rv) = Tiny0;
                word1(&rv) = Tiny1;
                /* The refinement below will clean
                 * this approximation up.
                 */
                }
#endif
            }
        }

    /* Now the hard part -- adjusting rv to the correct value.*/

    /* Put digits into bd: true value = bd * 10^e */

    bc.nd = nd;
#ifndef NO_STRTOD_BIGCOMP
    bc.nd0 = nd0;   /* Only needed if nd > strtod_diglim, but done here */
            /* to silence an erroneous warning about bc.nd0 */
            /* possibly not being initialized. */
    if (nd > strtod_diglim) {
        /* ASSERT(strtod_diglim >= 18); 18 == one more than the */
        /* minimum number of decimal digits to distinguish double values */
        /* in IEEE arithmetic. */
        i = j = 18;
        if (i > nd0)
            j += bc.dplen;
        for(;;) {
            if (--j <= bc.dp1 && j >= bc.dp0)
                j = bc.dp0 - 1;
            if (s0[j] != '0')
                break;
            --i;
            }
        e += nd - i;
        nd = i;
        if (nd0 > nd)
            nd0 = nd;
        if (nd < 9) { /* must recompute y */
            y = 0;
            for(i = 0; i < nd0; ++i)
                y = 10*y + s0[i] - '0';
            for(j = bc.dp1; i < nd; ++i)
                y = 10*y + s0[j++] - '0';
            }
        }
#endif
    bd0 = s2b(s0, nd0, nd, y, bc.dplen);

    for(;;) {
        bd = Balloc(bd0->k);
        Bcopy(bd, bd0);
        bb = d2b(&rv, &bbe, &bbbits);   /* rv = bb * 2^bbe */
        bs = i2b(1);

        if (e >= 0) {
            bb2 = bb5 = 0;
            bd2 = bd5 = e;
            }
        else {
            bb2 = bb5 = -e;
            bd2 = bd5 = 0;
            }
        if (bbe >= 0)
            bb2 += bbe;
        else
            bd2 -= bbe;
        bs2 = bb2;
#ifdef Honor_FLT_ROUNDS
        if (bc.rounding != 1)
            bs2++;
#endif
#ifdef Avoid_Underflow
        j = bbe - bc.scale;
        i = j + bbbits - 1; /* logb(rv) */
        if (i < Emin)   /* denormal */
            j += P - Emin;
        else
            j = P + 1 - bbbits;
#else /*Avoid_Underflow*/
#ifdef Sudden_Underflow
#ifdef IBM
        j = 1 + 4*P - 3 - bbbits + ((bbe + bbbits - 1) & 3);
#else
        j = P + 1 - bbbits;
#endif
#else /*Sudden_Underflow*/
        j = bbe;
        i = j + bbbits - 1; /* logb(rv) */
        if (i < Emin)   /* denormal */
            j += P - Emin;
        else
            j = P + 1 - bbbits;
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
        bb2 += j;
        bd2 += j;
#ifdef Avoid_Underflow
        bd2 += bc.scale;
#endif
        i = bb2 < bd2 ? bb2 : bd2;
        if (i > bs2)
            i = bs2;
        if (i > 0) {
            bb2 -= i;
            bd2 -= i;
            bs2 -= i;
            }
        if (bb5 > 0) {
            bs = pow5mult(bs, bb5);
            bb1 = mult(bs, bb);
            Bfree(bb);
            bb = bb1;
            }
        if (bb2 > 0)
            bb = lshift(bb, bb2);
        if (bd5 > 0)
            bd = pow5mult(bd, bd5);
        if (bd2 > 0)
            bd = lshift(bd, bd2);
        if (bs2 > 0)
            bs = lshift(bs, bs2);
        delta = diff(bb, bd);
        bc.dsign = delta->sign;
        delta->sign = 0;
        i = cmp(delta, bs);
#ifndef NO_STRTOD_BIGCOMP
        if (bc.nd > nd && i <= 0) {
            if (bc.dsign)
                break;  /* Must use bigcomp(). */
#ifdef Honor_FLT_ROUNDS
            if (bc.rounding != 1) {
                if (i < 0)
                    break;
                }
            else
#endif
                {
                bc.nd = nd;
                i = -1; /* Discarded digits make delta smaller. */
                }
            }
#endif
#ifdef Honor_FLT_ROUNDS
        if (bc.rounding != 1) {
            if (i < 0) {
                /* Error is less than an ulp */
                if (!delta->x[0] && delta->wds <= 1) {
                    /* exact */
#ifdef SET_INEXACT
                    bc.inexact = 0;
#endif
                    break;
                    }
                if (bc.rounding) {
                    if (bc.dsign) {
                        adj.d = 1.;
                        goto apply_adj;
                        }
                    }
                else if (!bc.dsign) {
                    adj.d = -1.;
                    if (!word1(&rv)
                     && !(word0(&rv) & Frac_mask)) {
                        y = word0(&rv) & Exp_mask;
#ifdef Avoid_Underflow
                        if (!bc.scale || y > 2*P*Exp_msk1)
#else
                        if (y)
#endif
                          {
                          delta = lshift(delta,Log2P);
                          if (cmp(delta, bs) <= 0)
                            adj.d = -0.5;
                          }
                        }
 apply_adj:
#ifdef Avoid_Underflow
                    if (bc.scale && (y = word0(&rv) & Exp_mask)
                        <= 2*P*Exp_msk1)
                      word0(&adj) += (2*P+1)*Exp_msk1 - y;
#else
#ifdef Sudden_Underflow
                    if ((word0(&rv) & Exp_mask) <=
                            P*Exp_msk1) {
                        word0(&rv) += P*Exp_msk1;
                        dval(&rv) += adj.d*ulp(dval(&rv));
                        word0(&rv) -= P*Exp_msk1;
                        }
                    else
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
                    dval(&rv) += adj.d*ulp(&rv);
                    }
                break;
                }
            adj.d = ratio(delta, bs);
            if (adj.d < 1.)
                adj.d = 1.;
            if (adj.d <= 0x7ffffffe) {
                /* adj = rounding ? ceil(adj) : floor(adj); */
                y = (ULong) adj.d;
                if (y != adj.d) {
                    if (!((bc.rounding>>1) ^ bc.dsign))
                        y++;
                    adj.d = y;
                    }
                }
#ifdef Avoid_Underflow
            if (bc.scale && (y = word0(&rv) & Exp_mask) <= 2*P*Exp_msk1)
                word0(&adj) += (2*P+1)*Exp_msk1 - y;
#else
#ifdef Sudden_Underflow
            if ((word0(&rv) & Exp_mask) <= P*Exp_msk1) {
                word0(&rv) += P*Exp_msk1;
                adj.d *= ulp(dval(&rv));
                if (bc.dsign)
                    dval(&rv) += adj.d;
                else
                    dval(&rv) -= adj.d;
                word0(&rv) -= P*Exp_msk1;
                goto cont;
                }
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
            adj.d *= ulp(&rv);
            if (bc.dsign) {
                if (word0(&rv) == Big0 && word1(&rv) == Big1)
                    goto ovfl;
                dval(&rv) += adj.d;
                }
            else
                dval(&rv) -= adj.d;
            goto cont;
            }
#endif /*Honor_FLT_ROUNDS*/

        if (i < 0) {
            /* Error is less than half an ulp -- check for
             * special case of mantissa a power of two.
             */
            if (bc.dsign || word1(&rv) || word0(&rv) & Bndry_mask
#ifdef IEEE_Arith
#ifdef Avoid_Underflow
             || (word0(&rv) & Exp_mask) <= (2*P+1)*Exp_msk1
#else
             || (word0(&rv) & Exp_mask) <= Exp_msk1
#endif
#endif
                ) {
#ifdef SET_INEXACT
                if (!delta->x[0] && delta->wds <= 1)
                    bc.inexact = 0;
#endif
                break;
                }
            if (!delta->x[0] && delta->wds <= 1) {
                /* exact result */
#ifdef SET_INEXACT
                bc.inexact = 0;
#endif
                break;
                }
            delta = lshift(delta,Log2P);
            if (cmp(delta, bs) > 0)
                goto drop_down;
            break;
            }
        if (i == 0) {
            /* exactly half-way between */
            if (bc.dsign) {
                if ((word0(&rv) & Bndry_mask1) == Bndry_mask1
                 &&  word1(&rv) == (
#ifdef Avoid_Underflow
            (bc.scale && (y = word0(&rv) & Exp_mask) <= 2*P*Exp_msk1)
        ? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
#endif
                           0xffffffff)) {
                    /*boundary case -- increment exponent*/
                    word0(&rv) = (word0(&rv) & Exp_mask)
                        + Exp_msk1
#ifdef IBM
                        | Exp_msk1 >> 4
#endif
                        ;
                    word1(&rv) = 0;
#ifdef Avoid_Underflow
                    bc.dsign = 0;
#endif
                    break;
                    }
                }
            else if (!(word0(&rv) & Bndry_mask) && !word1(&rv)) {
 drop_down:
                /* boundary case -- decrement exponent */
#ifdef Sudden_Underflow /*{{*/
                L = word0(&rv) & Exp_mask;
#ifdef IBM
                if (L <  Exp_msk1)
#else
#ifdef Avoid_Underflow
                if (L <= (bc.scale ? (2*P+1)*Exp_msk1 : Exp_msk1))
#else
                if (L <= Exp_msk1)
#endif /*Avoid_Underflow*/
#endif /*IBM*/
                    {
                    if (bc.nd >nd) {
                        bc.uflchk = 1;
                        break;
                        }
                    goto undfl;
                    }
                L -= Exp_msk1;
#else /*Sudden_Underflow}{*/
#ifdef Avoid_Underflow
                if (bc.scale) {
                    L = word0(&rv) & Exp_mask;
                    if (L <= (2*P+1)*Exp_msk1) {
                        if (L > (P+2)*Exp_msk1)
                            /* round even ==> */
                            /* accept rv */
                            break;
                        /* rv = smallest denormal */
                        if (bc.nd >nd) {
                            bc.uflchk = 1;
                            break;
                            }
                        goto undfl;
                        }
                    }
#endif /*Avoid_Underflow*/
                L = (word0(&rv) & Exp_mask) - Exp_msk1;
#endif /*Sudden_Underflow}}*/
                word0(&rv) = L | Bndry_mask1;
                word1(&rv) = 0xffffffff;
#ifdef IBM
                goto cont;
#else
                break;
#endif
                }
#ifndef ROUND_BIASED
            if (!(word1(&rv) & LSB))
                break;
#endif
            if (bc.dsign)
                dval(&rv) += ulp(&rv);
#ifndef ROUND_BIASED
            else {
                dval(&rv) -= ulp(&rv);
#ifndef Sudden_Underflow
                if (!dval(&rv)) {
                    if (bc.nd >nd) {
                        bc.uflchk = 1;
                        break;
                        }
                    goto undfl;
                    }
#endif
                }
#ifdef Avoid_Underflow
            bc.dsign = 1 - bc.dsign;
#endif
#endif
            break;
            }
        if ((aadj = ratio(delta, bs)) <= 2.) {
            if (bc.dsign)
                aadj = aadj1 = 1.;
            else if (word1(&rv) || word0(&rv) & Bndry_mask) {
#ifndef Sudden_Underflow
                if (word1(&rv) == Tiny1 && !word0(&rv)) {
                    if (bc.nd >nd) {
                        bc.uflchk = 1;
                        break;
                        }
                    goto undfl;
                    }
#endif
                aadj = 1.;
                aadj1 = -1.;
                }
            else {
                /* special case -- power of FLT_RADIX to be */
                /* rounded down... */

                if (aadj < 2./FLT_RADIX)
                    aadj = 1./FLT_RADIX;
                else
                    aadj *= 0.5;
                aadj1 = -aadj;
                }
            }
        else {
            aadj *= 0.5;
            aadj1 = bc.dsign ? aadj : -aadj;
#ifdef Check_FLT_ROUNDS
            switch(bc.rounding) {
                case 2: /* towards +infinity */
                    aadj1 -= 0.5;
                    break;
                case 0: /* towards 0 */
                case 3: /* towards -infinity */
                    aadj1 += 0.5;
                }
#else
            if (Flt_Rounds == 0)
                aadj1 += 0.5;
#endif /*Check_FLT_ROUNDS*/
            }
        y = word0(&rv) & Exp_mask;

        /* Check for overflow */

        if (y == Exp_msk1*(DBL_MAX_EXP+BBias-1)) {
            dval(&rv0) = dval(&rv);
            word0(&rv) -= P*Exp_msk1;
            adj.d = aadj1 * ulp(&rv);
            dval(&rv) += adj.d;
            if ((word0(&rv) & Exp_mask) >=
                    Exp_msk1*(DBL_MAX_EXP+BBias-P)) {
                if (word0(&rv0) == Big0 && word1(&rv0) == Big1)
                    goto ovfl;
                word0(&rv) = Big0;
                word1(&rv) = Big1;
                goto cont;
                }
            else
                word0(&rv) += P*Exp_msk1;
            }
        else {
#ifdef Avoid_Underflow
            if (bc.scale && y <= 2*P*Exp_msk1) {
                if (aadj <= 0x7fffffff) {
                    if ((z = (ULong) aadj) <= 0)
                        z = 1;
                    aadj = z;
                    aadj1 = bc.dsign ? aadj : -aadj;
                    }
                dval(&aadj2) = aadj1;
                word0(&aadj2) += (2*P+1)*Exp_msk1 - y;
                aadj1 = dval(&aadj2);
                }
            adj.d = aadj1 * ulp(&rv);
            dval(&rv) += adj.d;
#else
#ifdef Sudden_Underflow
            if ((word0(&rv) & Exp_mask) <= P*Exp_msk1) {
                dval(&rv0) = dval(&rv);
                word0(&rv) += P*Exp_msk1;
                adj.d = aadj1 * ulp(&rv);
                dval(&rv) += adj.d;
#ifdef IBM
                if ((word0(&rv) & Exp_mask) <  P*Exp_msk1)
#else
                if ((word0(&rv) & Exp_mask) <= P*Exp_msk1)
#endif
                    {
                    if (word0(&rv0) == Tiny0
                     && word1(&rv0) == Tiny1) {
                        if (bc.nd >nd) {
                            bc.uflchk = 1;
                            break;
                            }
                        goto undfl;
                        }
                    word0(&rv) = Tiny0;
                    word1(&rv) = Tiny1;
                    goto cont;
                    }
                else
                    word0(&rv) -= P*Exp_msk1;
                }
            else {
                adj.d = aadj1 * ulp(&rv);
                dval(&rv) += adj.d;
                }
#else /*Sudden_Underflow*/
            /* Compute adj so that the IEEE rounding rules will
             * correctly round rv + adj in some half-way cases.
             * If rv * ulp(rv) is denormalized (i.e.,
             * y <= (P-1)*Exp_msk1), we must adjust aadj to avoid
             * trouble from bits lost to denormalization;
             * example: 1.2e-307 .
             */
            if (y <= (P-1)*Exp_msk1 && aadj > 1.) {
                aadj1 = (double)(int)(aadj + 0.5);
                if (!bc.dsign)
                    aadj1 = -aadj1;
                }
            adj.d = aadj1 * ulp(&rv);
            dval(&rv) += adj.d;
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
            }
        z = word0(&rv) & Exp_mask;
#ifndef SET_INEXACT
        if (bc.nd == nd) {
#ifdef Avoid_Underflow
        if (!bc.scale)
#endif
        if (y == z) {
            /* Can we stop now? */
            L = (Long)aadj;
            aadj -= L;
            /* The tolerances below are conservative. */
            if (bc.dsign || word1(&rv) || word0(&rv) & Bndry_mask) {
                if (aadj < .4999999 || aadj > .5000001)
                    break;
                }
            else if (aadj < .4999999/FLT_RADIX)
                break;
            }
        }
#endif
 cont:
        Bfree(bb);
        Bfree(bd);
        Bfree(bs);
        Bfree(delta);
        }
    Bfree(bb);
    Bfree(bd);
    Bfree(bs);
    Bfree(bd0);
    Bfree(delta);
#ifndef NO_STRTOD_BIGCOMP
    if (bc.nd > nd)
        bigcomp(&rv, s0, &bc);
#endif
#ifdef SET_INEXACT
    if (bc.inexact) {
        if (!oldinexact) {
            word0(&rv0) = Exp_1 + (70 << Exp_shift);
            word1(&rv0) = 0;
            dval(&rv0) += 1.;
            }
        }
    else if (!oldinexact)
        clear_inexact();
#endif
#ifdef Avoid_Underflow
    if (bc.scale) {
        word0(&rv0) = Exp_1 - 2*P*Exp_msk1;
        word1(&rv0) = 0;
        dval(&rv) *= dval(&rv0);
#ifndef NO_ERRNO
        /* try to avoid the bug of testing an 8087 register value */
#ifdef IEEE_Arith
        if (!(word0(&rv) & Exp_mask))
#else
        if (word0(&rv) == 0 && word1(&rv) == 0)
#endif
            errno = ERANGE;
#endif
        }
#endif /* Avoid_Underflow */
#ifdef SET_INEXACT
    if (bc.inexact && !(word0(&rv) & Exp_mask)) {
        /* set underflow bit */
        dval(&rv0) = 1e-300;
        dval(&rv0) *= dval(&rv0);
        }
#endif
 ret:
    if (se)
        *se = (char *)s;
    return sign ? -dval(&rv) : dval(&rv);
    }

#ifndef MULTIPLE_THREADS
 static char *dtoa_result;
#endif

 static char *
#ifdef KR_headers
rv_alloc(i) int i;
#else
rv_alloc(int i)
#endif
{
    int j, k, *r;

    j = sizeof(ULong);
    for(k = 0;
        ((int) (sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j)) <= i;
        j <<= 1)
            k++;
    r = (int*)Balloc(k);
    *r = k;
    return
#ifndef MULTIPLE_THREADS
    dtoa_result =
#endif
        (char *)(r+1);
    }

 static char *
#ifdef KR_headers
nrv_alloc(s, rve, n) char *s, **rve; int n;
#else
nrv_alloc(char *s, char **rve, int n)
#endif
{
    char *rv, *t;

    t = rv = rv_alloc(n);
    while((*t = *s++)) t++;
    if (rve)
        *rve = t;
    return rv;
    }

/* freedtoa(s) must be used to free values s returned by dtoa
 * when MULTIPLE_THREADS is #defined.  It should be used in all cases,
 * but for consistency with earlier versions of dtoa, it is optional
 * when MULTIPLE_THREADS is not defined.
 */

 void
#ifdef KR_headers
freedtoa(s) char *s;
#else
freedtoa(char *s)
#endif
{
    Bigint *b = (Bigint *)((int *)s - 1);
    b->maxwds = 1 << (b->k = *(int*)b);
    Bfree(b);
#ifndef MULTIPLE_THREADS
    if (s == dtoa_result)
        dtoa_result = 0;
#endif
    }

/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
 *
 * Inspired by "How to Print Floating-Point Numbers Accurately" by
 * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 112-126].
 *
 * Modifications:
 *  1. Rather than iterating, we use a simple numeric overestimate
 *     to determine k = floor(log10(d)).  We scale relevant
 *     quantities using O(log2(k)) rather than O(k) multiplications.
 *  2. For some modes > 2 (corresponding to ecvt and fcvt), we don't
 *     try to generate digits strictly left to right.  Instead, we
 *     compute with fewer bits and propagate the carry if necessary
 *     when rounding the final digit up.  This is often faster.
 *  3. Under the assumption that input will be rounded nearest,
 *     mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.
 *     That is, we allow equality in stopping tests when the
 *     round-nearest rule will give the same floating-point value
 *     as would satisfaction of the stopping test with strict
 *     inequality.
 *  4. We remove common factors of powers of 2 from relevant
 *     quantities.
 *  5. When converting floating-point integers less than 1e16,
 *     we use floating-point arithmetic rather than resorting
 *     to multiple-precision integers.
 *  6. When asked to produce fewer than 15 digits, we first try
 *     to get by with floating-point arithmetic; we resort to
 *     multiple-precision integer arithmetic only if we cannot
 *     guarantee that the floating-point calculation has given
 *     the correctly rounded result.  For k requested digits and
 *     "uniformly" distributed input, the probability is
 *     something like 10^(k-15) that we must resort to the Long
 *     calculation.
 */

 char *
dtoa
#ifdef KR_headers
    (dd, mode, ndigits, decpt, sign, rve)
    double dd; int mode, ndigits, *decpt, *sign; char **rve;
#else
    (double dd, int mode, int ndigits, int *decpt, int *sign, char **rve)
#endif
{
 /* Arguments ndigits, decpt, sign are similar to those
    of ecvt and fcvt; trailing zeros are suppressed from
    the returned string.  If not null, *rve is set to point
    to the end of the return value.  If d is +-Infinity or NaN,
    then *decpt is set to 9999.

    mode:
        0 ==> shortest string that yields d when read in
            and rounded to nearest.
        1 ==> like 0, but with Steele & White stopping rule;
            e.g. with IEEE P754 arithmetic , mode 0 gives
            1e23 whereas mode 1 gives 9.999999999999999e22.
        2 ==> max(1,ndigits) significant digits.  This gives a
            return value similar to that of ecvt, except
            that trailing zeros are suppressed.
        3 ==> through ndigits past the decimal point.  This
            gives a return value similar to that from fcvt,
            except that trailing zeros are suppressed, and
            ndigits can be negative.
        4,5 ==> similar to 2 and 3, respectively, but (in
            round-nearest mode) with the tests of mode 0 to
            possibly return a shorter string that rounds to d.
            With IEEE arithmetic and compilation with
            -DHonor_FLT_ROUNDS, modes 4 and 5 behave the same
            as modes 2 and 3 when FLT_ROUNDS != 1.
        6-9 ==> Debugging modes similar to mode - 4:  don't try
            fast floating-point estimate (if applicable).

        Values of mode other than 0-9 are treated as mode 0.

        Sufficient space is allocated to the return value
        to hold the suppressed trailing zeros.
    */

    int bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,
        j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,
        spec_case, try_quick;
    Long L;
#ifndef Sudden_Underflow
    int denorm;
    ULong x;
#endif
    Bigint *b, *b1, *delta, *mlo, *mhi, *S;
    U d2, eps, u;
    double ds;
    char *s, *s0;
#ifdef SET_INEXACT
    int inexact, oldinexact;
#endif
#ifdef Honor_FLT_ROUNDS /*{*/
    int Rounding;
#ifdef Trust_FLT_ROUNDS /*{{ only define this if FLT_ROUNDS really works! */
    Rounding = Flt_Rounds;
#else /*}{*/
    Rounding = 1;
    switch(fegetround()) {
      case FE_TOWARDZERO:   Rounding = 0; break;
      case FE_UPWARD:   Rounding = 2; break;
      case FE_DOWNWARD: Rounding = 3;
      }
#endif /*}}*/
#endif /*}*/

#ifndef MULTIPLE_THREADS
    if (dtoa_result) {
        freedtoa(dtoa_result);
        dtoa_result = 0;
        }
#endif

    mlo = 0;
    u.d = dd;
    if (word0(&u) & Sign_bit) {
        /* set sign for everything, including 0's and NaNs */
        *sign = 1;
        word0(&u) &= ~Sign_bit; /* clear sign bit */
        }
    else
        *sign = 0;

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
    if ((word0(&u) & Exp_mask) == Exp_mask)
#else
    if (word0(&u)  == 0x8000)
#endif
        {
        /* Infinity or NaN */
        *decpt = 9999;
#ifdef IEEE_Arith
        if (!word1(&u) && !(word0(&u) & 0xfffff))
            return nrv_alloc("Infinity", rve, 8);
#endif
        return nrv_alloc("NaN", rve, 3);
        }
#endif
#ifdef IBM
    dval(&u) += 0; /* normalize */
#endif
    if (!dval(&u)) {
        *decpt = 1;
        return nrv_alloc("0", rve, 1);
        }

#ifdef SET_INEXACT
    try_quick = oldinexact = get_inexact();
    inexact = 1;
#endif
#ifdef Honor_FLT_ROUNDS
    if (Rounding >= 2) {
        if (*sign)
            Rounding = Rounding == 2 ? 0 : 2;
        else
            if (Rounding != 2)
                Rounding = 0;
        }
#endif

    b = d2b(&u, &be, &bbits);
#ifdef Sudden_Underflow
    i = (int)(word0(&u) >> Exp_shift1 & (Exp_mask>>Exp_shift1));
#else
    if ((i = (int)(word0(&u) >> Exp_shift1 & (Exp_mask>>Exp_shift1)))) {
#endif
        dval(&d2) = dval(&u);
        word0(&d2) &= Frac_mask1;
        word0(&d2) |= Exp_11;
#ifdef IBM
        if (j = 11 - hi0bits(word0(&d2) & Frac_mask))
            dval(&d2) /= 1 << j;
#endif

        /* log(x)   ~=~ log(1.5) + (x-1.5)/1.5
         * log10(x)  =  log(x) / log(10)
         *      ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
         * log10(d) = (i-BBias)*log(2)/log(10) + log10(d2)
         *
         * This suggests computing an approximation k to log10(d) by
         *
         * k = (i - BBias)*0.301029995663981
         *  + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
         *
         * We want k to be too large rather than too small.
         * The error in the first-order Taylor series approximation
         * is in our favor, so we just round up the constant enough
         * to compensate for any error in the multiplication of
         * (i - BBias) by 0.301029995663981; since |i - BBias| <= 1077,
         * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
         * adding 1e-13 to the constant term more than suffices.
         * Hence we adjust the constant term to 0.1760912590558.
         * (We could get a more accurate k by invoking log10,
         *  but this is probably not worthwhile.)
         */

        i -= BBias;
#ifdef IBM
        i <<= 2;
        i += j;
#endif
#ifndef Sudden_Underflow
        denorm = 0;
        }
    else {
        /* d is denormalized */

        i = bbits + be + (BBias + (P-1) - 1);
        x = i > 32  ? word0(&u) << (64 - i) | word1(&u) >> (i - 32)
                : word1(&u) << (32 - i);
        dval(&d2) = x;
        word0(&d2) -= 31*Exp_msk1; /* adjust exponent */
        i -= (BBias + (P-1) - 1) + 1;
        denorm = 1;
        }
#endif
    ds = (dval(&d2)-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;
    k = (int)ds;
    if (ds < 0. && ds != k)
        k--;    /* want k = floor(ds) */
    k_check = 1;
    if (k >= 0 && k <= Ten_pmax) {
        if (dval(&u) < tens[k])
            k--;
        k_check = 0;
        }
    j = bbits - i - 1;
    if (j >= 0) {
        b2 = 0;
        s2 = j;
        }
    else {
        b2 = -j;
        s2 = 0;
        }
    if (k >= 0) {
        b5 = 0;
        s5 = k;
        s2 += k;
        }
    else {
        b2 -= k;
        b5 = -k;
        s5 = 0;
        }
    if (mode < 0 || mode > 9)
        mode = 0;

#ifndef SET_INEXACT
#ifdef Check_FLT_ROUNDS
    try_quick = Rounding == 1;
#else
    try_quick = 1;
#endif
#endif /*SET_INEXACT*/

    if (mode > 5) {
        mode -= 4;
        try_quick = 0;
        }
    leftright = 1;
    ilim = ilim1 = -1;  /* Values for cases 0 and 1; done here to */
                /* silence erroneous "gcc -Wall" warning. */
    switch(mode) {
        case 0:
        case 1:
            i = 18;
            ndigits = 0;
            break;
        case 2:
            leftright = 0;
            /* no break */
        case 4:
            if (ndigits <= 0)
                ndigits = 1;
            ilim = ilim1 = i = ndigits;
            break;
        case 3:
            leftright = 0;
            /* no break */
        case 5:
            i = ndigits + k + 1;
            ilim = i;
            ilim1 = i - 1;
            if (i <= 0)
                i = 1;
        }
    s = s0 = rv_alloc(i);

#ifdef Honor_FLT_ROUNDS
    if (mode > 1 && Rounding != 1)
        leftright = 0;
#endif

    if (ilim >= 0 && ilim <= Quick_max && try_quick) {

        /* Try to get by with floating-point arithmetic. */

        i = 0;
        dval(&d2) = dval(&u);
        k0 = k;
        ilim0 = ilim;
        ieps = 2; /* conservative */
        if (k > 0) {
            ds = tens[k&0xf];
            j = k >> 4;
            if (j & Bletch) {
                /* prevent overflows */
                j &= Bletch - 1;
                dval(&u) /= bigtens[n_bigtens-1];
                ieps++;
                }
            for(; j; j >>= 1, i++)
                if (j & 1) {
                    ieps++;
                    ds *= bigtens[i];
                    }
            dval(&u) /= ds;
            }
        else if ((j1 = -k)) {
            dval(&u) *= tens[j1 & 0xf];
            for(j = j1 >> 4; j; j >>= 1, i++)
                if (j & 1) {
                    ieps++;
                    dval(&u) *= bigtens[i];
                    }
            }
        if (k_check && dval(&u) < 1. && ilim > 0) {
            if (ilim1 <= 0)
                goto fast_failed;
            ilim = ilim1;
            k--;
            dval(&u) *= 10.;
            ieps++;
            }
        dval(&eps) = ieps*dval(&u) + 7.;
        word0(&eps) -= (P-1)*Exp_msk1;
        if (ilim == 0) {
            S = mhi = 0;
            dval(&u) -= 5.;
            if (dval(&u) > dval(&eps))
                goto one_digit;
            if (dval(&u) < -dval(&eps))
                goto no_digits;
            goto fast_failed;
            }
#ifndef No_leftright
        if (leftright) {
            /* Use Steele & White method of only
             * generating digits needed.
             */
            dval(&eps) = 0.5/tens[ilim-1] - dval(&eps);
            for(i = 0;;) {
                L = (Long) dval(&u);
                dval(&u) -= L;
                *s++ = '0' + (int)L;
                if (dval(&u) < dval(&eps))
                    goto ret1;
                if (1. - dval(&u) < dval(&eps))
                    goto bump_up;
                if (++i >= ilim)
                    break;
                dval(&eps) *= 10.;
                dval(&u) *= 10.;
                }
            }
        else {
#endif
            /* Generate ilim digits, then fix them up. */
            dval(&eps) *= tens[ilim-1];
            for(i = 1;; i++, dval(&u) *= 10.) {
                L = (Long)(dval(&u));
                if (!(dval(&u) -= L))
                    ilim = i;
                *s++ = '0' + (int)L;
                if (i == ilim) {
                    if (dval(&u) > 0.5 + dval(&eps))
                        goto bump_up;
                    else if (dval(&u) < 0.5 - dval(&eps)) {
                        while(*--s == '0');
                        s++;
                        goto ret1;
                        }
                    break;
                    }
                }
#ifndef No_leftright
            }
#endif
 fast_failed:
        s = s0;
        dval(&u) = dval(&d2);
        k = k0;
        ilim = ilim0;
        }

    /* Do we have a "small" integer? */

    if (be >= 0 && k <= Int_max) {
        /* Yes. */
        ds = tens[k];
        if (ndigits < 0 && ilim <= 0) {
            S = mhi = 0;
            if (ilim < 0 || dval(&u) <= 5*ds)
                goto no_digits;
            goto one_digit;
            }
        for(i = 1;; i++, dval(&u) *= 10.) {
            L = (Long)(dval(&u) / ds);
            dval(&u) -= L*ds;
#ifdef Check_FLT_ROUNDS
            /* If FLT_ROUNDS == 2, L will usually be high by 1 */
            if (dval(&u) < 0) {
                L--;
                dval(&u) += ds;
                }
#endif
            *s++ = '0' + (int)L;
            if (!dval(&u)) {
#ifdef SET_INEXACT
                inexact = 0;
#endif
                break;
                }
            if (i == ilim) {
#ifdef Honor_FLT_ROUNDS
                if (mode > 1)
                switch(Rounding) {
                  case 0: goto ret1;
                  case 2: goto bump_up;
                  }
#endif
                dval(&u) += dval(&u);
                if (dval(&u) > ds || (dval(&u) == ds && L & 1)) {
 bump_up:
                    while(*--s == '9')
                        if (s == s0) {
                            k++;
                            *s = '0';
                            break;
                            }
                    ++*s++;
                    }
                break;
                }
            }
        goto ret1;
        }

    m2 = b2;
    m5 = b5;
    mhi = mlo = 0;
    if (leftright) {
        i =
#ifndef Sudden_Underflow
            denorm ? be + (BBias + (P-1) - 1 + 1) :
#endif
#ifdef IBM
            1 + 4*P - 3 - bbits + ((bbits + be - 1) & 3);
#else
            1 + P - bbits;
#endif
        b2 += i;
        s2 += i;
        mhi = i2b(1);
        }
    if (m2 > 0 && s2 > 0) {
        i = m2 < s2 ? m2 : s2;
        b2 -= i;
        m2 -= i;
        s2 -= i;
        }
    if (b5 > 0) {
        if (leftright) {
            if (m5 > 0) {
                mhi = pow5mult(mhi, m5);
                b1 = mult(mhi, b);
                Bfree(b);
                b = b1;
                }
            if ((j = b5 - m5))
                b = pow5mult(b, j);
            }
        else
            b = pow5mult(b, b5);
        }
    S = i2b(1);
    if (s5 > 0)
        S = pow5mult(S, s5);

    /* Check for special case that d is a normalized power of 2. */

    spec_case = 0;
    if ((mode < 2 || leftright)
#ifdef Honor_FLT_ROUNDS
            && Rounding == 1
#endif
                ) {
        if (!word1(&u) && !(word0(&u) & Bndry_mask)
#ifndef Sudden_Underflow
         && word0(&u) & (Exp_mask & ~Exp_msk1)
#endif
                ) {
            /* The special case */
            b2 += Log2P;
            s2 += Log2P;
            spec_case = 1;
            }
        }

    /* Arrange for convenient computation of quotients:
     * shift left if necessary so divisor has 4 leading 0 bits.
     *
     * Perhaps we should just compute leading 28 bits of S once
     * and for all and pass them and a shift to quorem, so it
     * can do shifts and ors to compute the numerator for q.
     */
#ifdef Pack_32
    if ((i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f))
        i = 32 - i;
#define iInc 28
#else
    if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0xf)
        i = 16 - i;
#define iInc 12
#endif
    i = dshift(S, s2);
    b2 += i;
    m2 += i;
    s2 += i;
    if (b2 > 0)
        b = lshift(b, b2);
    if (s2 > 0)
        S = lshift(S, s2);
    if (k_check) {
        if (cmp(b,S) < 0) {
            k--;
            b = multadd(b, 10, 0);  /* we botched the k estimate */
            if (leftright)
                mhi = multadd(mhi, 10, 0);
            ilim = ilim1;
            }
        }
    if (ilim <= 0 && (mode == 3 || mode == 5)) {
        if (ilim < 0 || cmp(b,S = multadd(S,5,0)) <= 0) {
            /* no digits, fcvt style */
 no_digits:
            k = -1 - ndigits;
            goto ret;
            }
 one_digit:
        *s++ = '1';
        k++;
        goto ret;
        }
    if (leftright) {
        if (m2 > 0)
            mhi = lshift(mhi, m2);

        /* Compute mlo -- check for special case
         * that d is a normalized power of 2.
         */

        mlo = mhi;
        if (spec_case) {
            mhi = Balloc(mhi->k);
            Bcopy(mhi, mlo);
            mhi = lshift(mhi, Log2P);
            }

        for(i = 1;;i++) {
            dig = quorem(b,S) + '0';
            /* Do we yet have the shortest decimal string
             * that will round to d?
             */
            j = cmp(b, mlo);
            delta = diff(S, mhi);
            j1 = delta->sign ? 1 : cmp(b, delta);
            Bfree(delta);
#ifndef ROUND_BIASED
            if (j1 == 0 && mode != 1 && !(word1(&u) & 1)
#ifdef Honor_FLT_ROUNDS
                && Rounding >= 1
#endif
                                   ) {
                if (dig == '9')
                    goto round_9_up;
                if (j > 0)
                    dig++;
#ifdef SET_INEXACT
                else if (!b->x[0] && b->wds <= 1)
                    inexact = 0;
#endif
                *s++ = dig;
                goto ret;
                }
#endif
            if (j < 0 || (j == 0 && mode != 1
#ifndef ROUND_BIASED
                            && !(word1(&u) & 1)
#endif
                    )) {
                if (!b->x[0] && b->wds <= 1) {
#ifdef SET_INEXACT
                    inexact = 0;
#endif
                    goto accept_dig;
                    }
#ifdef Honor_FLT_ROUNDS
                if (mode > 1)
                 switch(Rounding) {
                  case 0: goto accept_dig;
                  case 2: goto keep_dig;
                  }
#endif /*Honor_FLT_ROUNDS*/
                if (j1 > 0) {
                    b = lshift(b, 1);
                    j1 = cmp(b, S);
                    if ((j1 > 0 || (j1 == 0 && dig & 1))
                    && dig++ == '9')
                        goto round_9_up;
                    }
 accept_dig:
                *s++ = dig;
                goto ret;
                }
            if (j1 > 0) {
#ifdef Honor_FLT_ROUNDS
                if (!Rounding)
                    goto accept_dig;
#endif
                if (dig == '9') { /* possible if i == 1 */
 round_9_up:
                    *s++ = '9';
                    goto roundoff;
                    }
                *s++ = dig + 1;
                goto ret;
                }
#ifdef Honor_FLT_ROUNDS
 keep_dig:
#endif
            *s++ = dig;
            if (i == ilim)
                break;
            b = multadd(b, 10, 0);
            if (mlo == mhi)
                mlo = mhi = multadd(mhi, 10, 0);
            else {
                mlo = multadd(mlo, 10, 0);
                mhi = multadd(mhi, 10, 0);
                }
            }
        }
    else
        for(i = 1;; i++) {
            *s++ = dig = quorem(b,S) + '0';
            if (!b->x[0] && b->wds <= 1) {
#ifdef SET_INEXACT
                inexact = 0;
#endif
                goto ret;
                }
            if (i >= ilim)
                break;
            b = multadd(b, 10, 0);
            }

    /* Round off last digit */

#ifdef Honor_FLT_ROUNDS
    switch(Rounding) {
      case 0: goto trimzeros;
      case 2: goto roundoff;
      }
#endif
    b = lshift(b, 1);
    j = cmp(b, S);
    if (j > 0 || (j == 0 && dig & 1)) {
 roundoff:
        while(*--s == '9')
            if (s == s0) {
                k++;
                *s++ = '1';
                goto ret;
                }
        ++*s++;
        }
    else {
#ifdef Honor_FLT_ROUNDS
 trimzeros:
#endif
        while(*--s == '0');
        s++;
        }
 ret:
    Bfree(S);
    if (mhi) {
        if (mlo && mlo != mhi)
            Bfree(mlo);
        Bfree(mhi);
        }
 ret1:
#ifdef SET_INEXACT
    if (inexact) {
        if (!oldinexact) {
            word0(&u) = Exp_1 + (70 << Exp_shift);
            word1(&u) = 0;
            dval(&u) += 1.;
            }
        }
    else if (!oldinexact)
        clear_inexact();
#endif
    Bfree(b);
    *s = 0;
    *decpt = k + 1;
    if (rve)
        *rve = s;
    return s0;
    }
#ifdef __cplusplus
}
#endif
/* EMBEDTHIS */
/*
    Cleanup for combo releases
 */
#undef ACQUIRE_DTOA_LOCK
#undef Avoid_Underflow
#undef BBias
#undef ME_FLOAT
#undef Bcopy
#undef Big0
#undef Big1
#undef Bletch
#undef Bndry_mask
#undef Bndry_mask1
#undef Bug
#undef CONST
#undef Check_FLT_ROUNDS
#undef DBL_DIG
#undef DBL_MAX
#undef DBL_MAX_10_EXP
#undef DBL_MAX_EXP
#undef Ebits
#undef Emax
#undef Emin
#undef Exp_1
#undef Exp_11
#undef Exp_mask
#undef Exp_msk1
#undef Exp_msk11
#undef Exp_shift
#undef Exp_shift1
#undef FFFFFFFF
#undef FLT_RADIX
#undef FREE_DTOA_LOCK
#undef Flt_Rounds
#undef Frac_mask
#undef Frac_mask1
#undef IEEE_8087
#undef IEEE_Arith
#undef IEEE_MC68k
#undef INFNAN_CHECK
#undef Int_max
#undef Kmax
#undef LONG_MAX
#undef LSB
#undef Llong
#undef Log2P
#undef Long
#undef MALLOC
#undef MULTIPLE_THREADS
#undef NAN_WORD0
#undef NAN_WORD1
#undef NO_STRTOD_BIGCOMP
#undef Nbits
#undef Need_Hexdig
#undef P
#undef PRIVATE_MEM
#undef PRIVATE_mem
#undef Pack_32
#undef Quick_max
#undef ROUND_BIASED
#undef Rounding
#undef STRTOD_DIGLIM
#undef Scale_Bit
#undef Sign_bit
#undef Storeinc
#undef Sudden_Underflow
#undef Ten_pmax
#undef Tiny0
#undef Tiny1
#undef ULLong
#undef ULbits
#undef ULong
#undef USC
#undef d0
#undef d1
#undef dval
#undef iInc
#undef kmask
#undef kshift
#undef n_bigtens
#undef rounded_product
#undef rounded_quotient
#undef strtod
#undef strtod_diglim
#undef word0
#undef word1
#endif /* ME_FLOAT */

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsApp.c"
 */
/************************************************************************/

/*
    ejsApp.c -- App class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Methods **********************************/
/*  
    Get the application command line arguments
    static function get args(): Array
 */
static EjsArray *app_args(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsArray    *args;
    int         i;

    args = ejsCreateArray(ejs, ejs->argc);
    for (i = 0; i < ejs->argc; i++) {
        ejsSetProperty(ejs, args, i, ejsCreateStringFromAsc(ejs, ejs->argv[i]));
    }
    return args;
}


/*  
    Get the current working directory
    function get dir(): Path
 */
static EjsPath *app_dir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetCurrentPath(ejs));
}


/*  
    Set the current working directory
    function chdir(value: String|Path): void
 */
static EjsObj *app_chdir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar   *path;

    assert(argc == 1);

    if (ejsIs(ejs, argv[0], Path)) {
        path = ((EjsPath*) argv[0])->value;

    } else if (ejsIs(ejs, argv[0], String)) {
        path = ejsToMulti(ejs, argv[0]);

    } else {
        ejsThrowIOError(ejs, "Bad path");
        return NULL;
    }
#if WINDOWS
{
    MprFileSystem   *fs;
    fs = mprLookupFileSystem(path);
    if (!mprPathExists(path, X_OK) && *path == '/') {
        path = sjoin(fs->cygwin, path, NULL);
    }
}
#endif
    if (chdir((char*) path) < 0) {
        ejsThrowIOError(ejs, "Cannot change the current directory");
    }
    return 0;
}

/*  
    Get the directory containing the application's executable file.
    static function get exeDir(): Path
 */
static EjsPath *app_exeDir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetAppDir());
}


/*  
    Get the application's executable filename.
    static function get exePath(): Path
 */
static EjsPath *app_exePath(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetAppPath());
}


/*  
    Exit the application
    static function exit(status: Number, how: String = "immediate"): void
    TODO - status is not implemented
 */
static EjsObj *app_exit(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprTicks    timeout;
    cchar       *how;
    int         status, mode;

    if (ejs->dontExit) {
        ejsThrowStateError(ejs, "App.exit has been disabled");
        return 0;
    }
    status = argc >= 1 ? ejsGetInt(ejs, argv[0]) : 0;
    timeout = argc >= 2 ? ejsGetInt(ejs, argv[1]) : 0;
    how = ejsToMulti(ejs, argc >= 2 ? ejsToString(ejs, argv[1]): ESV(empty));

    if (scmp(how, "normal") == 0) {
        mode = 0;
    } else if (scmp(how, "abort") == 0) {
        mode = MPR_EXIT_ABORT;
    } else if (scmp(how, "safe") == 0) {
        mode = MPR_EXIT_SAFE;
    } else if (scmp(how, "restart") == 0) {
        mode = MPR_EXIT_RESTART;
#if DEPRECATED || 1
    } else if (scmp(how, "immediate") == 0) {
        mode = 0;
    } else if (scmp(how, "graceful") == 0) {
        mode = 0;
        if (argc <= 2) {
            timeout = 30 * 3000;
        }
    } else if (scmp(how, "default") == 0) {
        mode = 0;
#endif
    } else {
        mode = 0;
    }
    mprShutdown(mode, status, timeout);
    ejsAttention(ejs);
    return 0;
}


#if ES_App_env
/*  
    Get all environment vars
    function get env(): Object
 */
static EjsAny *app_env(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
#if VXWORKS
    return ESV(null);
#else
    EjsPot  *result;
    char        **ep, *pair, *key, *value;

    result = ejsCreatePot(ejs, ESV(Object), 0);
    for (ep = environ; ep && *ep; ep++) {
        pair = sclone(*ep);
        key = stok(pair, "=", &value);
        ejsSetPropertyByName(ejs, result, EN(key), ejsCreateStringFromAsc(ejs, value));
    }
    return result;
#endif
}
#endif


/*  
    Get an environment var
    function getenv(key: String): String
 */
static EjsAny *app_getenv(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    cchar   *value;

    value = getenv(ejsToMulti(ejs, argv[0]));
    if (value == 0) {
        return ESV(null);
    }
    return ejsCreateStringFromAsc(ejs, value);
}


/*
    static function get gid(): Number
 */
static EjsNumber *app_gid(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if ME_UNIX_LIKE
    return ejsCreateNumber(ejs, getgid());
#else
    return ESV(null);
#endif
}


/*  
    Put an environment var
    function putenv(key: String, value: String): void
 */
static EjsObj *app_putenv(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    char    *key, *value;

    key = sclone(ejsToMulti(ejs, argv[0]));
    value = sclone(ejsToMulti(ejs, argv[1]));
    mprSetEnv(key, value);
    return 0;
}


/*  
    Get the ejs module search path. Does not actually read the environment.
    function get search(): Array
 */
static EjsArray *app_search(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    return ejs->search;
}


/*  
    Set the ejs module search path. Does not actually update the environment.
    function set search(path: Array): Void
 */
static EjsObj *app_set_search(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    ejsSetSearchPath(ejs, (EjsArray*) argv[0]);
    return 0;
}


/*  
    Get a default search path. NOTE: this does not modify ejs->search.
    function get createSearch(searchPaths: String): Array
 */
static EjsArray *app_createSearch(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    cchar   *searchPath;

    searchPath = (argc == 0) ? NULL : ejsToMulti(ejs, argv[0]);
    return ejsCreateSearchPath(ejs, searchPath);
}


/*
    static function get pid (): Number
 */
static EjsNumber *app_pid(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, getpid());
}


/*  
    static function run(timeout: Number = -1, oneEvent: Boolean = false): Boolean
 */
static EjsObj *app_run(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprTicks    mark, remaining;
    int         rc, oneEvent, timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]) : MAXINT;
    oneEvent = (argc > 1) ? ejsGetInt(ejs, argv[1]) : 0;

    if (ejs->hosted) {
        return ESV(true);
    }
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTicks();
    remaining = timeout;
    do {
        rc = mprWaitForEvent(ejs->dispatcher, remaining); 
        remaining = mprGetRemainingTicks(mark, timeout);
    } while (!ejs->exception && !oneEvent && !ejs->exiting && remaining > 0 && !mprIsStopping());
    return (rc == 0) ? ESV(true) : ESV(false);
}


/*  
    Pause the application. This services events while asleep.
    static function sleep(delay: Number = -1): void
    TODO - sleep currently throws if an exception is generated in an event callback (worker).
    It should not.
 */
static EjsObj *app_sleep(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprTicks    mark, remaining;
    int         timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]) : MAXINT;
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTicks();
    remaining = timeout;
    do {
        mprWaitForEvent(ejs->dispatcher, (int) remaining); 
        remaining = mprGetRemainingTicks(mark, timeout);
    } while (!ejs->exiting && remaining > 0 && !mprIsStopping());
    return 0;
}


/*  
    static function get uid(): Number
 */
static EjsNumber *app_uid(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if ME_UNIX_LIKE
    return ejsCreateNumber(ejs, getuid());
#else
    return ESV(null);
#endif
}


/*  
    static function getpass(prompt: String): String
 */
static EjsString *app_getpass(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprGetPassword((argc > 0) ? ejsToMulti(ejs, argv[0]) : "Password: "));
}


/*********************************** Factory **********************************/

PUBLIC void ejsConfigureAppType(Ejs *ejs)
{
    EjsType     *type;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "App"), 0, 0, 0)) == 0) {
        return;
    }
    ejsSetProperty(ejs, type, ES_App__inputStream, ejsCreateFileFromFd(ejs, 0, "stdin", O_RDONLY));
    ejsSetProperty(ejs, type, ES_App__outputStream, ejsCreateFileFromFd(ejs, 1, "stdout", O_WRONLY));
    ejsSetProperty(ejs, type, ES_App__errorStream, ejsCreateFileFromFd(ejs, 2, "stderr", O_WRONLY));

    ejsBindMethod(ejs, type, ES_App_args, app_args);
    ejsBindMethod(ejs, type, ES_App_createSearch, app_createSearch);
    ejsBindMethod(ejs, type, ES_App_dir, app_dir);
    ejsBindMethod(ejs, type, ES_App_chdir, app_chdir);
    ejsBindMethod(ejs, type, ES_App_exeDir, app_exeDir);
    ejsBindMethod(ejs, type, ES_App_exePath, app_exePath);
    ejsBindMethod(ejs, type, ES_App_env, app_env);
    ejsBindMethod(ejs, type, ES_App_exit, app_exit);
    ejsBindMethod(ejs, type, ES_App_getenv, app_getenv);
    ejsBindMethod(ejs, type, ES_App_gid, app_gid);
    ejsBindMethod(ejs, type, ES_App_putenv, app_putenv);
    ejsBindMethod(ejs, type, ES_App_pid, app_pid);
    ejsBindMethod(ejs, type, ES_App_run, app_run);
    ejsBindAccess(ejs, type, ES_App_search, app_search, app_set_search);
    ejsBindMethod(ejs, type, ES_App_sleep, app_sleep);
    ejsBindMethod(ejs, type, ES_App_uid, app_uid);
    ejsBindMethod(ejs, type, ES_App_getpass, app_getpass);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsArray.c"
 */
/************************************************************************/

/**
    ejsArray.c - Ejscript Array class

    This module implents the standard Array type. It provides the type methods and manages the special "length" property.
    The array elements with numeric indicies are stored in EjsArray.data[]. Non-numeric properties are stored in EjsArray.obj

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/***************************** Forward Declarations ***************************/

static int  checkSlot(Ejs *ejs, EjsArray *ap, int slotNum);
static bool compareArrayElement(Ejs *ejs, EjsObj *v1, EjsObj *v2);
static int growArray(Ejs *ejs, EjsArray *ap, int len);
static int lookupArrayProperty(Ejs *ejs, EjsArray *ap, EjsName qname);
static EjsNumber *pushArray(Ejs *ejs, EjsArray *ap, int argc, EjsAny **argv);
static EjsArray *spliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);
static EjsString *arrayToString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);

static EjsArray *makeIntersection(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsArray *makeUnion(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsArray *removeArrayElements(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsObj *setArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);

/******************************************************************************/
/*
    Create a new array
 */
static EjsArray *createArray(Ejs *ejs, EjsType *type, int numProp)
{
    EjsArray     *ap;

    if ((ap = ejsCreatePot(ejs, ESV(Array), 0)) == 0) {
        return 0;
    }
    ap->length = 0;
#if FUTURE
    /*
        Clear isObject because we must NOT use direct slot access in the VM
     */ 
    ap->obj.isObject = 0;
#endif
    return ap;
}


/*
    Cast the object operand to a primitive type
 */
static EjsAny *castArray(Ejs *ejs, EjsArray *vp, EjsType *type)
{
    switch (type->sid) {
    case ES_Boolean:
        return ESV(true);

    case ES_Number:
        return ESV(zero);

    case ES_String:
        return arrayToString(ejs, vp, 0, 0);

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


PUBLIC EjsArray *ejsCloneArray(Ejs *ejs, EjsArray *ap, bool deep)
{
    EjsArray    *newArray;
    EjsObj      **dest, **src;
    int         i;

    if ((newArray = ejsClonePot(ejs, ap, deep)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    if (ap->length > 0) {
        if (growArray(ejs, newArray, ap->length) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        src = ap->data;
        dest = newArray->data;
        if (deep) {
            for (i = 0; i < ap->length; i++) {
                dest[i] = ejsClone(ejs, src[i], deep);
            }
        } else {
            memcpy(dest, src, ap->length * sizeof(EjsObj*));
        }
    }
    return newArray;
}


/*
    Delete a property and update the length. Return the index where the property was deleted.
 */
static int deleteArrayProperty(Ejs *ejs, EjsArray *ap, int slot)
{
    if (slot >= ap->length) {
        assert(0);
        return EJS_ERR;
    }
    if (ejsSetProperty(ejs, ap, slot, ESV(undefined)) < 0) {
        return EJS_ERR;
    }
    if ((slot + 1) == ap->length) {
        ap->length--;
    }
    return slot;
}


/*
    Delete an element by name
 */
static int deleteArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName qname)
{
    if (isdigit((uchar) qname.name->value[0])) {
        return deleteArrayProperty(ejs, ap, (int) wtoi(qname.name->value));
    }
    return (ejs->service->potHelpers.deletePropertyByName)(ejs, ap, qname);
}


/*
    Return the number of elements in the array
 */
static int getArrayPropertyCount(Ejs *ejs, EjsArray *ap)
{
    return ap->length;
}


/*
    Get an array element. Slot numbers correspond to indicies.
 */
static EjsObj *getArrayProperty(Ejs *ejs, EjsArray *ap, int slotNum)
{
    if (slotNum < 0 || slotNum >= ap->length) {
        return ESV(undefined);
    }
    return ap->data[slotNum];
}


static EjsObj *getArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName qname)
{
    int     slotNum;

    if (isdigit((uchar) qname.name->value[0])) { 
        slotNum = ejsAtoi(ejs, qname.name, 10);
        if (slotNum < 0 || slotNum >= ap->length) {
            return 0;
        }
        return getArrayProperty(ejs, ap, slotNum);
    }

    /* The "length" property is a method getter */
    if (qname.name == ESV(length)) {
        return 0;
    }
    slotNum = (ejs->service->potHelpers.lookupProperty)(ejs, ap, qname);
    if (slotNum < 0) {
        return 0;
    }
    return (ejs->service->potHelpers.getProperty)(ejs, ap, slotNum);
}


/*
    Lookup an array index.
 */
static int lookupArrayProperty(Ejs *ejs, EjsArray *ap, EjsName qname)
{
    int     index;

    if (qname.name == 0 || !isdigit((uchar) qname.name->value[0])) {
        return EJS_ERR;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < ap->length) {
        return index;
    }
    return EJS_ERR;
}


/*
    Cast operands as required for invokeArrayOperator
 */
static EjsObj *coerceArrayOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, arrayToString(ejs, (EjsArray*) lhs, 0, 0), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ESV(zero), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


static EjsAny *invokeArrayOperator(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    EjsAny  *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceArrayOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, !(lhs == rhs));

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ESV(true);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return ESV(one);

    /*
        Binary operators
     */
    case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_REM:
    case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return ESV(zero);

    /*
        Operator overload
     */
    case EJS_OP_ADD:
        result = ejsCreateArray(ejs, 0);
        pushArray(ejs, result, 1, &lhs);
        pushArray(ejs, result, 1, &rhs);
        return result;

    case EJS_OP_AND:
        return makeIntersection(ejs, lhs, rhs);

    case EJS_OP_OR:
        return makeUnion(ejs, lhs, rhs);

    case EJS_OP_SHL:
        return pushArray(ejs, lhs, 1, &rhs);

    case EJS_OP_SUB:
        return removeArrayElements(ejs, lhs, rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    assert(0);
}


/*
    Create or update an array elements. If slotNum is < 0, then create the next free array slot. If slotNum is greater
    than the array length, grow the array.
 */
static int setArrayProperty(Ejs *ejs, EjsArray *ap, int slotNum, EjsAny *value)
{
    if ((slotNum = checkSlot(ejs, ap, slotNum)) < 0) {
        return EJS_ERR;
    }
    ap->data[slotNum] = value;
    return slotNum;
}


static int setArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName qname, EjsObj *value)
{
    int     slotNum;

    if (!isdigit((uchar) qname.name->value[0])) { 
        /* The "length" property is a method getter */
        if (qname.name == ESV(length)) {
            setArrayLength(ejs, ap, 1, &value);
            return ES_Array_length;
        }
        slotNum = (ejs->service->potHelpers.lookupProperty)(ejs, ap, qname);
        if (slotNum < 0) {
            slotNum = (ejs->service->potHelpers.setProperty)(ejs, ap, slotNum, value);
            if (slotNum < 0) {
                return EJS_ERR;
            }
            if ((ejs->service->potHelpers.setPropertyName)(ejs, ap, slotNum, qname) < 0) {
                return EJS_ERR;
            }
            return slotNum;

        } else {
            return (ejs->service->potHelpers.setProperty)(ejs, ap, slotNum, value);
        }
    }
    if ((slotNum = checkSlot(ejs, ap, ejsAtoi(ejs, qname.name, 10))) < 0) {
        return EJS_ERR;
    }
    ap->data[slotNum] = value;
    return slotNum;
}


static EjsArray *makeIntersection(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsArray    *result;
    EjsObj      **l, **r, **resultSlots;
    int         i, j, k;

    result = ejsCreateArray(ejs, 0);
    l = lhs->data;
    r = rhs->data;

    for (i = 0; i < lhs->length; i++) {
        for (j = 0; j < rhs->length; j++) {
            if (compareArrayElement(ejs, l[i], r[j])) {
                resultSlots = result->data;
                for (k = 0; k < result->length; k++) {
                    if (compareArrayElement(ejs, l[i], resultSlots[k])) {
                        break;
                    }
                }
                if (result->length == 0 || k == result->length) {
                    setArrayProperty(ejs, result, -1, l[i]);
                }
            }
        }
    }
    return result;
}


static int addUnique(Ejs *ejs, EjsArray *ap, EjsObj *element)
{
    int     i;

    for (i = 0; i < ap->length; i++) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            break;
        }
    }
    if (i == ap->length) {
        if (setArrayProperty(ejs, ap, -1, element) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


static EjsArray *makeUnion(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsArray    *result;
    EjsObj      **l, **r;
    int         i;

    result = ejsCreateArray(ejs, 0);
    l = lhs->data;
    r = rhs->data;

    for (i = 0; i < lhs->length; i++) {
        addUnique(ejs, result, l[i]);
    }
    for (i = 0; i < rhs->length; i++) {
        addUnique(ejs, result, r[i]);
    }
    return result;
}


static EjsArray *removeArrayElements(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsObj  **l, **r;
    int     i, j, k;

    l = lhs->data;
    r = rhs->data;

    for (j = 0; j < rhs->length; j++) {
        for (i = 0; i < lhs->length; i++) {
            if (compareArrayElement(ejs, l[i], r[j])) {
                for (k = i + 1; k < lhs->length; k++) {
                    l[k - 1] = l[k];
                }
                lhs->length--;
            }
        }
    }
    return lhs;
}


static int checkSlot(Ejs *ejs, EjsArray *ap, int slotNum)
{
    if (slotNum < 0) {
        if (!DYNAMIC(ap)) {
            ejsThrowTypeError(ejs, "Object is not dynamic");
            return EJS_ERR;
        }
        slotNum = ap->length;
        if (growArray(ejs, ap, ap->length + 1) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }

    } else if (slotNum >= ap->length) {
        if (growArray(ejs, ap, slotNum + 1) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
    }
    return slotNum;
}


/********************************** Methods *********************************/
/*
    Array constructor.

    function Array(...args): Array

    Support the forms:

        var arr = Array();
        var arr = Array(size);
        var arr = Array(elt, elt, elt, ...);
 */
static EjsArray *arrayConstructor(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *arg0, **src, **dest;
    int         size, i;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];
    if (args->length == 0) {
        return ap;
    }
    size = 0;
    arg0 = getArrayProperty(ejs, args, 0);

    if (args->length == 1 && ejsIs(ejs, arg0, Number)) {
        /*
            x = new Array(size);
         */
        size = ejsGetInt(ejs, arg0);
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }

    } else {
        /*
            x = new Array(element0, element1, ..., elementN):
         */
        size = args->length;
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        src = args->data;
        dest = ap->data;
        for (i = 0; i < size; i++) {
            dest[i] = src[i];
        }
    }
    ap->length = size;
    return ap;
}


/*
    Append an item to an array

    function append(obj: Object) : Array
 */
static EjsArray *appendArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    if (setArrayProperty(ejs, ap, ap->length, argv[0]) < 0) {
        return 0;
    }
    return ap;
}


/*
    Clear an array. Remove all elements of the array.

    function clear() : void
 */
static EjsObj *clearArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    ap->length = 0;
    return 0;
}


/*
    Clone an array.

    function clone(deep: Boolean = false) : Array
 */
static EjsArray *cloneArrayMethod(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    bool    deep;

    assert(argc == 0 || ejsIs(ejs, argv[0], Boolean));

    deep = (argc == 1) ? ((EjsBoolean*) argv[0])->value : 0;
    return ejsCloneArray(ejs, ap, deep);
}


/*
    Compact an array. Remove all null elements.

    function compact() : Array
 */
static EjsArray *compactArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data, **src, **dest;
    int         i, oldLen;

    data = ap->data;
    src = dest = &data[0];
    for (i = 0; i < ap->length; i++, src++) {
        if (*src == 0 || !ejsIsDefined(ejs, *src)) {
            continue;
        }
        *dest++ = *src;
    }
    oldLen = ap->length;
    ap->length = (int) (dest - &data[0]);
    for (i = ap->length; i < oldLen; i++) {
        *dest++ = ESV(undefined);
    }
    return ap;
}


/*
    Concatenate the supplied elements with the array to create a new array. If any arguments specify an array,
    their elements are catenated. This is a one level deep copy.

    function concat(...args): Array
 */
static EjsArray *concatArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args, *newArray, *vpa;
    EjsObj          *vp, **src, **dest;
    int         i, k, next;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = ((EjsArray*) argv[0]);

    newArray = ejsCreateArray(ejs, ap->length);
    src = ap->data;
    dest = newArray->data;

    /*
        Copy the original array
     */
    for (next = 0; next < ap->length; next++) {
        dest[next] = src[next];
    }

    /*
        Copy the args. If any element is itself an array, then flatten it and copy its elements.
     */
    for (i = 0; i < args->length; i++) {
        vp = args->data[i];
        if (ejsIs(ejs, vp, Array)) {
            vpa = (EjsArray*) vp;
            if (growArray(ejs, newArray, next + vpa->length) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
            dest = newArray->data;
            for (k = 0; k < vpa->length; k++) {
                dest[next++] = vpa->data[k];
            }
        } else {
            if (growArray(ejs, newArray, next + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
            dest[next++] = vp;
        }
    }
    return newArray;
}


/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextArrayKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsArray    *ap;
    EjsObj      *vp, **data;

    ap = (EjsArray*) ip->target;
    if (!ejsIs(ejs, ap, Array)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    data = ap->data;
    if (ap->length < ip->length) {
        ip->length = ap->length;
    }
    for (; ip->index < ip->length; ip->index++) {
        vp = data[ip->index];
        assert(vp);
        if (ejsIs(ejs, vp, Void)) {
            continue;
        }
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsIterator *getArrayIterator(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, ap->length, nextArrayKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextArrayValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsArray    *ap;
    EjsObj      *vp, **data;

    ap = (EjsArray*) ip->target;
    if (!ejsIs(ejs, ap, Array)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    data = ap->data;
    if (ap->length < ip->length) {
        ip->length = ap->length;
    }
    for (; ip->index < ip->length; ip->index++) {
        vp = data[ip->index];
        assert(vp);
        if (ejsIs(ejs, vp, Void)) {
            continue;
        }
        ip->index++;
        return vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsAny *getArrayValues(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, ap->length, nextArrayValue, 0, NULL);
}


#if KEEP
static EjsObj *find(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return 0;
}


/**
    Iterate over all elements in the object and find all elements for which the matching function is true.
    The match is called with the following signature:

        function match(arrayElement: Object, elementIndex: Number, arr: Array): Boolean

    @param match Matching function
    @return Returns a new array containing all matching elements.
 */
static EjsObj *findAll(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *funArgs[3];
    EjsBoolean  *result;
    EjsArray    *elements;
    int         i;

    assert(argc == 1 && ejsIsFunction(ejs, argv[0]));

    elements = ejsCreateArray(ejs, 0);
    if (elements == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    for (i = 0; i < ap->length; i++) {
        funArgs[0] = ap->obj.properties.slots[i];         /* Array element */
        funArgs[1] = ejsCreateNumber(ejs, i);             /* element index */
        funArgs[2] = ap;                                  /* Array */
        result = (EjsBoolean*) ejsRunFunction(ejs, (EjsFunction*) argv[0], 0, 3, funArgs);
        if (result == 0 || !ejsIs(ejs, result, Boolean) || !result->value) {
            setArrayProperty(ejs, elements, elements->length, ap->obj.properties.slots[i]);
        }
    }
    return elements;
}
#endif


static bool compareArrayElement(Ejs *ejs, EjsObj *v1, EjsObj *v2)
{
    if (v1 == v2) {
        return 1;
    }
    if (TYPE(v1) != TYPE(v2)) {
        return 0;
    }
    if (ejsIs(ejs, v1, Number)) {
        return ((EjsNumber*) v1)->value == ((EjsNumber*) v2)->value;
    }
    if (ejsIs(ejs, v1, String)) {
        return (EjsString*) v1 == (EjsString*) v2;
    }
    if (ejsIs(ejs, v1, Path)) {
        return smatch(((EjsPath*) v1)->value, ((EjsPath*) v2)->value);
    }
    //  TODO - should expand for other types 
    return 0;
}


/*
    Search for an item using strict equality "===". This call searches from
    the start of the array for the specified element.
    @return Returns the items index into the array if found, otherwise -1.

    function indexOf(element: Object, startIndex: Number = 0): Number
 */
static EjsNumber *indexOfArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *element;
    int     i, start;

    assert(argc == 1 || argc == 2);

    element = argv[0];
    start = (argc == 2) ? (int) ((EjsNumber*) argv[1])->value : 0;

    if (start < 0) {
        start += ap->length;
    }
    if (start >= ap->length) {
        return ESV(minusOne);
    }
    if (start < 0) {
        start = 0;
    }
    for (i = start; i < ap->length; i++) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            return ejsCreateNumber(ejs, i);
        }
    }
    return ESV(minusOne);
}


/*
    Insert elements. Insert elements at the specified position. Negative indicies are measured from the end of the array.
    @return Returns a the original array.

    function insert(pos: Number, ...args): Array
 */
static EjsArray *insertArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj          **src, **dest;
    int         i, pos, delta, endInsert;

    assert(argc == 2 && ejsIs(ejs, argv[1], Array));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0) {
        pos += ap->length;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (pos >= ap->length) {
        pos = ap->length;
    }
    args = (EjsArray*) argv[1];

    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }
    delta = args->length;
    dest = ap->data;
    src = args->data;

    endInsert = pos + delta;
    for (i = ap->length - 1; i >= endInsert; i--) {
        dest[i] = dest[i - delta];
    }
    for (i = 0; i < delta; i++) {
        dest[pos++] = src[i];
    }
    return ap;
}


/*
    Joins the elements in the array into a single string.
    @param sep Element separator.
    @return Returns a string.

    function join(sep: String = undefined): String
 */
#if OPTIMIZED || 1
static EjsString *joinArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsString       *sep, *sp;
    MprBuf          *buf;
    ssize           len;
    int             i, nonString;

    sep = (argc == 1) ? (EjsString*) argv[0] : NULL;
    if (sep == ESV(empty) && ap->length == 1 && ejsIs(ejs, ap->data[0], String)) {
        /* Optimized path for joining [string]. This happens frequently with fun(...args) */
        return (EjsString*) ap->data[0];
    }
    /*
        Get an estimate of the string length
     */
    len = 0;
    nonString = 0;
    for (i = 0; i < ap->length; i++) {
        sp = (EjsString*) ap->data[i];
        if (!ejsIs(ejs, sp, String)) {
            nonString = 1;
            continue;
        }
        len += sp->length;
    }
    if (sep) {
        len += (ap->length * sep->length);
    }
    if (nonString) {
        len += ME_MAX_BUFFER;
    }
    buf = mprCreateBuf(len + 1, -1);

    for (i = 0; i < ap->length; i++) {
        sp = (EjsString*) ap->data[i];
        if (!ejsIsDefined(ejs, sp)) {
            continue;
        }
        if (i > 0 && sep) {
            mprPutBlockToBuf(buf, sep->value, sep->length);
        }
        sp = ejsToString(ejs, sp);
        mprPutBlockToBuf(buf, sp->value, sp->length);
    }
    mprAddNullToBuf(buf);
    return ejsCreateStringFromBytes(ejs, mprGetBufStart(buf), mprGetBufLength(buf));
}
#else

/* UNUSED */
static EjsString *joinArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsString       *result, *sep;
    EjsObj          *vp;
    int             i;

    sep = (argc == 1) ? (EjsString*) argv[0] : NULL;
    if (sep == ESV(empty) && ap->length == 1 && ejsIs(ejs, ap->data[0], String)) {
        /* Optimized path for joining [string]. This happens frequently with fun(...args) */
        return (EjsString*) ap->data[0];
    }
    result = ESV(empty);
    for (i = 0; i < ap->length; i++) {
        vp = ap->data[i];
        if (!ejsIsDefined(ejs, vp)) {
            continue;
        }
        if (i > 0 && sep) {
            result = ejsJoinString(ejs, result, sep);
        }
        result = ejsJoinString(ejs, result, ejsToString(ejs, vp));
    }
    return result;
}
#endif


/*
    Search for an item using strict equality "===". This call searches from
    the end of the array for the specified element.
    @return Returns the items index into the array if found, otherwise -1.

    function lastIndexOf(element: Object, fromIndex: Number = 0): Number
 */
static EjsNumber *lastArrayIndexOf(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *element;
    int     i, start;

    assert(argc == 1 || argc == 2);

    element = argv[0];
    start = ((argc == 2) ? (int) ((EjsNumber*) argv[1])->value : ap->length - 1);
    if (start < 0) {
        start += ap->length;
    }
    if (start >= ap->length) {
        start = ap->length - 1;
    }
    if (start < 0) {
        return ESV(minusOne);
    }
    for (i = start; i >= 0; i--) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            return ejsCreateNumber(ejs, i);
        }
    }
    return ESV(minusOne);
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    override function get length(): Number
 */
static EjsNumber *getArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ap->length);
}


/*
    Set the length of an array.

    override function set length(value: Number): void
 */
static EjsObj *setArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data, **dest;
    int     length;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));
    assert(ejsIs(ejs, ap, Array));

    length = (int) ((EjsNumber*) argv[0])->value;
    if (length < 0) {
        length = 0;
    }
    if (length > ap->length) {
        if (growArray(ejs, ap, length) < 0) {
            return 0;
        }
        data = ap->data;
        for (dest = &data[ap->length]; dest < &data[length]; dest++) {
            *dest = 0;
        }
    }
    ap->length = length;
    return 0;
}


/*
    Remove and return the last value in the array.
    @return Returns the last element in the array.

    function pop(): Object
 */
static EjsObj *popArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    if (ap->length == 0) {
        return ESV(undefined);
    }
    return ap->data[--ap->length];
}


/*
    Append items to the end of the array.
    @return Returns the new length of the array.

    function push(...items): Number
 */
static EjsNumber *pushArray(Ejs *ejs, EjsArray *ap, int argc, EjsAny **argv)
{
    EjsArray    *args;
    EjsObj      **src, **dest;
    int         i, oldLen;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];
    oldLen = ap->length;
    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }
    dest = ap->data;
    src = args->data;
    for (i = 0; i < args->length; i++) {
        dest[i + oldLen] = src[i];
    }
    return ejsCreateNumber(ejs, ap->length);
}


/*
    Remove array elements

    function removeElements(...elts): Array
 */
static EjsArray *removeElements(Ejs *ejs, EjsArray *ap, int argc, EjsArray **argv)
{
    return removeArrayElements(ejs, ap, argv[0]);
}


/*
    Reverse the order of the objects in the array. The elements are reversed in the original array.
    @return Returns a reference to the array.

    function reverse(): Array
 */
static EjsArray *reverseArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *tmp, **data;
    int         i, j;

    if (ap->length <= 1) {
        return ap;
    }
    data = ap->data;
    i = (ap->length - 2) / 2;
    j = (ap->length + 1) / 2;

    for (; i >= 0; i--, j++) {
        tmp = data[i];
        data[i] = data[j];
        data[j] = tmp;
    }
    return ap;
}


/*
    Remove and return the first value in the array.
    @return Returns the first element in the array.

    function shift(): Object
 */
static EjsObj *shiftArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj         *result, **data;
    int         i;

    if (ap->length == 0) {
        return ESV(undefined);
    }
    data = ap->data;
    result = data[0];
    for (i = 1; i < ap->length; i++) {
        data[i - 1] = data[i];
    }
    ap->length--;
    return result;
}


/*
    Create a new array by taking a slice from an array.

    function slice(start: Number, end: Number, step: Number = 1): Array
 */
static EjsArray *sliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *result;
    EjsObj          **src, **dest;
    int         start, end, step, i, j, len, size;

    assert(1 <= argc && argc <= 3);

    start = ejsGetInt(ejs, argv[0]);
    if (argc >= 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = ap->length;
    }
    if (argc == 3) {
        step = ejsGetInt(ejs, argv[2]);
    } else {
        step = 1;
    }
    if (step == 0) {
        step = 1;
    }
    if (start < 0) {
        start += ap->length;
    }
    if (start < 0) {
        start = 0;
    } else if (start >= ap->length) {
        start = ap->length;
    }
    if (end < 0) {
        end += ap->length;
    }
    if (end < 0) {
        end = 0;
    } else if (end >= ap->length) {
        end = ap->length;
    }
    size = (start < end) ? end - start : start - end;

    /*
        This may allocate too many elements if abs(step) is > 1, but length will still be correct.
     */
    result = ejsCreateArray(ejs, size);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    src = ap->data;
    dest = result->data;

    len = 0;
    if (step > 0) {
        for (i = start, j = 0; i < end; i += step, j++) {
            dest[j] = src[i];
            len++;
        }

    } else {
        for (i = start, j = 0; i > end; i += step, j++) {
            dest[j] = src[i];
            len++;
        }
    }
    result->length = len;
    return result;
}


/*
    Quick sort partition
 */
static int partition(Ejs *ejs, EjsArray *array, EjsFunction *compare, int direction, int p, int r)
{
    EjsString   *sx, *so;
    EjsNumber   *result;
    EjsAny      *argv[3], *tmp;
    EjsObj      *x;
    int         i, j, order;

    x = array->data[r];
    sx = 0;

    if (compare) {
        if ((argv[1] = ejsCreateNumber(ejs, r)) == 0) {
            return 0;
        }
    } else {
        if ((sx = ejsToString(ejs, x)) == 0) {
            return 0;
        }
    }
    j = p - 1;

    for (i = p; i < r; i++) {
        if (compare) {
            argv[0] = array;
            argv[2] = ejsCreateNumber(ejs, i);
            result = ejsRunFunction(ejs, compare, NULL, 3, argv);
            if (!ejsIs(ejs, result, Number)) {
                return 0;
            }
            order = ejsGetInt(ejs, result);

        } else {
            if ((so = ejsToString(ejs, array->data[i])) == 0) {
                return 0;
            }
            order = ejsCompareString(ejs, sx, so);
        }
        order *= direction;
        if (order > 0) {
            j = j + 1;
            tmp = array->data[j];
            array->data[j] = array->data[i];
            array->data[i] = tmp;
        }
    }
    array->data[r] = array->data[j + 1];
    array->data[j + 1] = x;
    return j + 1;
}


PUBLIC void quickSort(Ejs *ejs, EjsArray *ap, EjsFunction *compare, int direction, int p, int r)
{
    int     q;

    if (p < r && !ejs->exception) {
        q = partition(ejs, ap, compare, direction, p, r);
        quickSort(ejs, ap, compare, direction, p, q - 1);
        quickSort(ejs, ap, compare, direction, q + 1, r);
    }
}


/**
    Sort the array using the supplied compare function

    function sort(compare: Function = null, direction: Number = 1): Array

    Where compare is defined as:
        function compare(a,b): Number
 */
PUBLIC EjsArray *ejsSortArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsFunction     *compare;
    int             direction;

    if (ap->length <= 1) {
        return ap;
    }
    compare = (EjsFunction*) ((argc >= 1) ? argv[0]: NULL);
    if (compare == ESV(null)) {
        compare = 0;
    }
    if (compare && !ejsIsFunction(ejs, compare)) {
        ejsThrowArgError(ejs, "Compare argument is not a function");
        return 0;
    }
    direction = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 1;
    quickSort(ejs, ap, compare, direction, 0, ap->length - 1);
    return ap;
}


/*
    Insert, remove or replace array elements. Return the removed elements.

    function splice(start: Number, deleteCount: Number, ...values): Array

 */
static EjsArray *spliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *result, *values;
    EjsObj          **data, **dest, **items;
    int         start, deleteCount, i, delta, endInsert, oldLen;

    assert(1 <= argc && argc <= 3);
    
    start = ejsGetInt(ejs, argv[0]);
    deleteCount = ejsGetInt(ejs, argv[1]);
    values = (EjsArray*) argv[2];

    if (ap->length == 0) {
        if (deleteCount <= 0) {
            return ap;
        }
        ejsThrowArgError(ejs, "Array is empty");
        return 0;
    }
    if (start < 0) {
        start += ap->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (start >= ap->length) {
        start = ap->length - 1;
    }

    if (deleteCount < 0) {
        deleteCount = ap->length - start + 1;
    }
    if (deleteCount > ap->length) {
        deleteCount = ap->length;
    }
    result = ejsCreateArray(ejs, deleteCount);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    data = ap->data;
    dest = result->data;
    items = values->data;

    /*
        Copy removed items to the result
     */
    for (i = 0; i < deleteCount; i++) {
        dest[i] = data[i + start];
    }
    oldLen = ap->length;
    delta = values->length - deleteCount;
    
    if (delta > 0) {
        /*
            Make room for items to insert
         */
        if (growArray(ejs, ap, ap->length + delta) < 0) {
            return 0;
        }
        data = ap->data;
        endInsert = start + delta;
        for (i = ap->length - 1; i >= endInsert; i--) {
            data[i] = data[i - delta];
        }
        
    } else {
        ap->length += delta;
    }

    /*
        Copy in new values
     */
    for (i = 0; i < values->length; i++) {
        data[start + i] = items[i];
    }

    /*
        Remove holes
     */
    if (delta < 0) {
        for (i = start + values->length; i < oldLen; i++) {
            data[i] = data[i - delta];
        }
    }
    return result;
}


#if ES_Object_toLocaleString && FUTURE
/*
    Convert the array to a single localized string each member of the array
    has toString called on it and the resulting strings are concatenated.
    Currently just calls toString.

    function toLocaleString(): String
 */
static EjsString *toLocaleString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return arrayToString(ejs, ap, argc, argv);
}
#endif


/*
    Convert the array to a single string each member of the array has toString called on it and the resulting strings 
    are concatenated.

    override function toString(): String
 */
static EjsString *arrayToString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsString       *result, *comma;
    EjsObj              *vp;
    int             i, rc;

    result = ESV(empty);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    comma = ejsCreateStringFromAsc(ejs, ",");
    for (i = 0; i < ap->length; i++) {
        vp = ap->data[i];
        rc = 0;
        if (i > 0) {
            result = ejsJoinString(ejs, result, comma);
        }
        if (ejsIsDefined(ejs, vp)) {
            result = ejsJoinString(ejs, result, ejsToString(ejs, vp));
        }
        if (rc < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return result;
}


/*
    Return an array with duplicate elements removed where duplicates are detected by using "==" (ie. content equality, 
    not strict equality).

    function unique(): Array
 */
static EjsArray *uniqueArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data;
    int     i, j, k;

    data = ap->data;

    for (i = 0; i < ap->length; i++) {
        for (j = i + 1; j < ap->length; j++) {
            if (compareArrayElement(ejs, data[i], data[j])) {
                for (k = j + 1; k < ap->length; k++) {
                    data[k - 1] = data[k];
                }
                ap->length--;
                j--;
            }
        }
    }
    return ap;
}


/*
    function unshift(...args): Array
 */
static EjsArray *unshiftArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj          **src, **dest;
    int         i, delta, endInsert;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];
    if (args->length <= 0) {
        return ap;
    }
    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }
    delta = args->length;
    dest = ap->data;
    src = args->data;

    endInsert = delta;
    for (i = ap->length - 1; i >= endInsert; i--) {
        dest[i] = dest[i - delta];
    }
    for (i = 0; i < delta; i++) {
        dest[i] = src[i];
    }
    return ap;
}

/*********************************** Support **********************************/

static int growArray(Ejs *ejs, EjsArray *ap, int len)
{
    EjsObj      **dp;
    ssize       size, factor, count;
    int         i;

    assert(ap);

    if (len <= 0) {
        return 0;
    }
    if (len <= ap->length) {
        return 0;
    }
    size = mprGetBlockSize(ap->data);
    size = (int) (mprGetBlockSize(ap->data) / sizeof(EjsObj*));

    /*
        Allocate or grow the data structures.
     */
    if (len > size) {
        if (size > EJS_LOTSA_PROP) {
            /*
                Looks like a big object so grow by a bigger chunk
             */
            factor = max(size / 4, EJS_ROUND_PROP);
            count = (len + factor) / factor * factor;
        } else {
            count = len;
        }
        //  OPT - this is currently 16
        count = EJS_PROP_ROUNDUP(count);
        if (ap->data == 0) {
            assert(ap->length == 0);
            assert(count > 0);
            if ((ap->data = mprAllocZeroed(sizeof(EjsObj*) * count)) == 0) {
                return EJS_ERR;
            }
        } else {
            assert(size > 0);
            if ((ap->data = mprRealloc(ap->data, sizeof(EjsObj*) * count)) == 0) {
                return EJS_ERR;
            }
        }
        dp = &ap->data[ap->length];
        for (i = ap->length; i < count; i++) {
            *dp++ = ESV(undefined);
        }
    } else {
        mprNop(ITOP(size));
    }
    ap->length = len;
    return 0;
}


/*********************************** C Array API  *****************************/

PUBLIC int ejsAddItem(Ejs *ejs, EjsArray *ap, EjsAny *item)
{
    int     index;

    index = ap->length;
    if (setArrayProperty(ejs, ap, index, item) < 0) {
        return MPR_ERR_MEMORY;
    }
    return index;
}


PUBLIC int ejsAppendArray(Ejs *ejs, EjsArray *dest, EjsArray *src)
{
    int     next;

    for (next = 0; next < src->length; next++) {
        if (ejsSetProperty(ejs, dest, dest->length, src->data[next]) < 0) {
            return MPR_ERR_MEMORY;
        }
    }
    return 0;
}


PUBLIC void ejsClearArray(Ejs *ejs, EjsArray *ap)
{
    ap->length = 0;
}


PUBLIC EjsAny *ejsGetItem(Ejs *ejs, EjsArray *ap, int index)
{
    return ejsGetProperty(ejs, ap, index);
}


PUBLIC EjsAny *ejsGetFirstItem(Ejs *ejs, EjsArray *ap)
{
    assert(ap);

    if (ap == 0 || ap->length == 0) {
        return 0;
    }
    return ap->data[0];
}


PUBLIC EjsAny *ejsGetLastItem(Ejs *ejs, EjsArray *ap)
{
    assert(ap);

    if (ap == 0 || ap->length == 0) {
        return 0;
    }
    return ap->data[ap->length - 1];
}


PUBLIC EjsAny *ejsGetNextItem(Ejs *ejs, EjsArray *ap, int *next)
{
    EjsAny  *item;
    int     index;

    assert(next);
    assert(*next >= 0);

    if (ap == 0) {
        return 0;
    }
    index = *next;
    if (index < ap->length) {
        item = ap->data[index];
        *next = ++index;
        return item;
    }
    return 0;
}


PUBLIC EjsAny *ejsGetPrevItem(Ejs *ejs, EjsArray *ap, int *next)
{
    int     index;

    assert(next);

    if (ap == 0) {
        return 0;
    }
    if (*next < 0) {
        *next = ap->length;
    }
    index = *next;

    if (--index < ap->length && index >= 0) {
        *next = index;
        return ap->data[index];
    }
    return 0;
}


/*
    Insert an item to the list at a specified position. We insert before the item at "index".
    ie. The inserted item will go into the "index" location and the other elements will be moved up.
 */
PUBLIC int ejsInsertItem(Ejs *ejs, EjsArray *ap, int index, EjsAny *item)
{
    if (insertArray(ejs, ap, index, item) == 0) {
        /* Should never fail - only for memory errors */
        return -1;
    }
    return index;
}


PUBLIC EjsString *ejsJoinArray(Ejs *ejs, EjsArray *ap, EjsString *join)
{
    return joinArray(ejs, ap, 1, (EjsObj**) (void*) &join);
}


PUBLIC int ejsLookupItem(Ejs *ejs, EjsArray *ap, EjsAny *item)
{
    int     i;

    assert(ap);
    
    for (i = 0; i < ap->length; i++) {
        if (ap->data[i] == item) {
            return i;
        }
    }
    return MPR_ERR_CANT_FIND;
}


PUBLIC int ejsRemoveItem(Ejs *ejs, EjsArray *ap, EjsAny *item, int compact)
{
    int     i;

    for (i = 0; i < ap->length; i++) {
        if (ap->data[i] == item) {
            deleteArrayProperty(ejs, ap, i);
            if (compact) {
                compactArray(ejs, ap, 0, NULL);
            }
            return i;
        }
    }
    return MPR_ERR_CANT_FIND;
}


PUBLIC int ejsRemoveLastItem(Ejs *ejs, EjsArray *ap)
{
    assert(ap);

    if (ap->length <= 0) {
        return MPR_ERR_CANT_FIND;
    }
    return deleteArrayProperty(ejs, ap, ap->length - 1);
}


PUBLIC int ejsRemoveItemAtPos(Ejs *ejs, EjsArray *ap, int index, int compact)
{
    int     rc;

    assert(ap);

    if (ap->length <= 0) {
        return MPR_ERR_CANT_FIND;
    }
    rc = deleteArrayProperty(ejs, ap, index);
    if (compact) {
        compactArray(ejs, ap, 0, NULL);
    }
    return rc;
}


/*********************************** Factory **********************************/

PUBLIC EjsArray *ejsCreateArray(Ejs *ejs, int size)
{
    EjsArray    *ap;

    /*
        No need to invoke constructor
     */
    if ((ap = ejsCreatePot(ejs, ESV(Array), 0)) != 0) {
        ap->length = 0;
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return ap;
}


static void manageArray(EjsArray *ap, int flags)
{
    EjsObj      *vp, **data;
    int         i, length;

    if (flags & MPR_MANAGE_MARK) {
        length = ap->length;
        data = ap->data;
        for (i = length - 1; i >= 0; i--) {
            if ((vp = data[i]) != 0) {
                mprMark(vp);
            }
        }
        mprMark(data);
        ejsManagePot((EjsPot*) ap, flags);
    }
}


PUBLIC void ejsCreateArrayType(Ejs *ejs)
{
    EjsType         *type;
    EjsHelpers      *helpers;

    type = ejsCreateCoreType(ejs, N("ejs", "Array"), sizeof(EjsArray), S_Array, ES_Array_NUM_CLASS_PROP, manageArray, 
        EJS_TYPE_POT | EJS_TYPE_NUMERIC_INDICIES | EJS_TYPE_VIRTUAL_SLOTS | EJS_TYPE_MUTABLE_INSTANCES | 
        EJS_TYPE_DYNAMIC_INSTANCES);

    helpers = &type->helpers;
    helpers->cast = (EjsCastHelper) castArray;
    helpers->clone = (EjsCloneHelper) ejsCloneArray;
    helpers->create = (EjsCreateHelper) createArray;
    helpers->getProperty = (EjsGetPropertyHelper) getArrayProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getArrayPropertyCount;
    helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getArrayPropertyByName;
    helpers->deleteProperty = (EjsDeletePropertyHelper) deleteArrayProperty;
    helpers->deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteArrayPropertyByName;
    helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeArrayOperator;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupArrayProperty;
    helpers->setProperty = (EjsSetPropertyHelper) setArrayProperty;
    helpers->setPropertyByName = (EjsSetPropertyByNameHelper) setArrayPropertyByName;

    ejsAddImmutable(ejs, S_length, EN("length"), ejsCreateStringFromAsc(ejs, "length"));
}


PUBLIC void ejsConfigureArrayType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Array"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, arrayConstructor);
    ejsBindMethod(ejs, prototype, ES_Array_iterator_get, getArrayIterator);
    ejsBindMethod(ejs, prototype, ES_Array_iterator_getValues, getArrayValues);
    ejsBindMethod(ejs, prototype, ES_Array_clone, cloneArrayMethod);
    ejsBindMethod(ejs, prototype, ES_Array_toString, arrayToString);
    ejsBindMethod(ejs, prototype, ES_Array_append, appendArray);
    ejsBindMethod(ejs, prototype, ES_Array_clear, clearArray);
    ejsBindMethod(ejs, prototype, ES_Array_compact, compactArray);
    ejsBindMethod(ejs, prototype, ES_Array_concat, concatArray);
    ejsBindMethod(ejs, prototype, ES_Array_indexOf, indexOfArray);
    ejsBindMethod(ejs, prototype, ES_Array_insert, insertArray);
    ejsBindMethod(ejs, prototype, ES_Array_join, joinArray);
    ejsBindMethod(ejs, prototype, ES_Array_lastIndexOf, lastArrayIndexOf);
    ejsBindAccess(ejs, prototype, ES_Array_length, getArrayLength, setArrayLength);
    ejsBindMethod(ejs, prototype, ES_Array_pop, popArray);
    ejsBindMethod(ejs, prototype, ES_Array_push, pushArray);
    ejsBindMethod(ejs, prototype, ES_Array_removeElements, removeElements);
    ejsBindMethod(ejs, prototype, ES_Array_reverse, reverseArray);
    ejsBindMethod(ejs, prototype, ES_Array_shift, shiftArray);
    ejsBindMethod(ejs, prototype, ES_Array_slice, sliceArray);
    ejsBindMethod(ejs, prototype, ES_Array_sort, ejsSortArray);
    ejsBindMethod(ejs, prototype, ES_Array_splice, spliceArray);
    ejsBindMethod(ejs, prototype, ES_Array_unique, uniqueArray);
    ejsBindMethod(ejs, prototype, ES_Array_unshift, unshiftArray);

#if FUTURE
    ejsBindMethod(ejs, prototype, ES_Array_toLocaleString, toLocaleString);
    ejsBindMethod(ejs, prototype, ES_Array_toJSONString, toJSONString);
    ejsBindMethod(ejs, prototype, ES_Array_LBRACKET, operLBRACKET);
    ejsBindMethod(ejs, prototype, ES_Array_AND, operAND);
    ejsBindMethod(ejs, prototype, ES_Array_EQ, operEQ);
    ejsBindMethod(ejs, prototype, ES_Array_GT, operGT);
    ejsBindMethod(ejs, prototype, ES_Array_LT, operLT);
    ejsBindMethod(ejs, prototype, ES_Array_LSH, operLSH);
    ejsBindMethod(ejs, prototype, ES_Array_MINUS, operMINUS);
    ejsBindMethod(ejs, prototype, ES_Array_OR, operOR);
    ejsBindMethod(ejs, prototype, ES_Array_AND, operAND);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsBlock.c"
 */
/************************************************************************/

/**
    ejsBlock.c - Lexical block

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Helpers **********************************/

PUBLIC EjsBlock *ejsCloneBlock(Ejs *ejs, EjsBlock *src, bool deep)
{
    EjsBlock    *dest;

    dest = (EjsBlock*) ejsClonePot(ejs, src, deep);

    dest->nobind = src->nobind;
    dest->scope = src->scope;
    mprInitList(&dest->namespaces, MPR_LIST_STABLE);
    mprCopyListContents(&dest->namespaces, &src->namespaces);
    return dest;
}


/********************************* Namespaces *******************************/

PUBLIC void ejsResetBlockNamespaces(Ejs *ejs, EjsBlock *block)
{
    mprClearList(&block->namespaces);
}


PUBLIC int ejsGetNamespaceCount(EjsBlock *block)
{
    assert(block);
    return block->namespaces.length;
}


PUBLIC void ejsPopBlockNamespaces(EjsBlock *block, int count)
{
    assert(block);
    assert(block->namespaces.length >= count);

    block->namespaces.length = count;
}


PUBLIC int ejsAddNamespaceToBlock(Ejs *ejs, EjsBlock *block, EjsNamespace *nsp)
{
    assert(block);

    if (nsp == 0) {
        ejsThrowTypeError(ejs, "Not a namespace");
        return EJS_ERR;
    }
    mprAddItem(&block->namespaces, nsp);
    return 0;
}


/*
    Inherit namespaces from base types. Only inherit protected.
 */
PUBLIC void ejsInheritBaseClassNamespaces(Ejs *ejs, EjsType *type, EjsType *baseType)
{
    EjsNamespace    *nsp, *existing;
    EjsBlock        *block;
    MprList         *baseNamespaces;
    int             next, i;

    block = &type->constructor.block;
    baseNamespaces = &baseType->constructor.block.namespaces;

    if (baseNamespaces) {
        for (next = 0; ((nsp = (EjsNamespace*) mprGetNextItem(baseNamespaces, &next)) != 0); ) {
            //  OPT -- must be a better way to do this?
            if (ejsContainsString(ejs, nsp->value, ESV(commaProt)) >= 0) {
                for (i = 0; ((existing = (EjsNamespace*) mprGetNextItem(&block->namespaces, &i)) != 0); ) {
                    if (existing->value == nsp->value) {
                        break;
                    }
                }
                //  OPT -- debug to see if duplicates found 
                assert(existing == NULL);
                if (existing == NULL) {
                    mprInsertItemAtPos(&block->namespaces, next - 1, nsp);
                }
            }
        }
    }
}


/*************************************** Factory ***********************************/

PUBLIC EjsBlock *ejsCreateBlock(Ejs *ejs, int size)
{
    EjsBlock        *block;

    if ((block = ejsCreatePot(ejs, ESV(Block), size)) == 0) {
        return 0;
    }
    block->pot.shortScope = 1;
    block->pot.isBlock = 1;
    mprInitList(&block->namespaces, MPR_LIST_STABLE);
    return block;
}


PUBLIC void ejsManageBlock(EjsBlock *block, int flags)
{
    EjsObj          *item;
    EjsBlock        *b;
    int             next;

    if (block) {
        if (flags & MPR_MANAGE_MARK) {
            ejsManagePot(block, flags);
            mprMark(block->prevException);

            /*
                Must mark each item of the list as the list itself is not allocated
             */
            mprMark(block->namespaces.items);
            for (next = 0; ((item = (EjsObj*) mprGetNextItem(&block->namespaces, &next)) != 0); ) {
                mprMark(item);
            }
            /* This is the lexical block scope */
            for (b = block->scope; b; b = b->scope) {
#if FUTURE
                if (b->pot.shortScope) {
                    break;
                }
#endif
                mprMark(b);
            }
            /* This is the activation (call) chain */
            for (b = block->prev; b; b = b->prev) {
                mprMark(b);
            }
            /*
                Don't mark stack as the VM will mark that
                Don't mark locations as they are always inherited from a frame which will mark them for us
             */
        }
    }
}


PUBLIC void ejsCreateBlockHelpers(Ejs *ejs)
{
    EjsHelpers      *helpers;

    ejs->service->blockHelpers = ejs->service->potHelpers;
    helpers = &ejs->service->blockHelpers;
    helpers->clone = (EjsCloneHelper) ejsCloneBlock;
}


PUBLIC void ejsInitBlockType(Ejs *ejs, EjsType *type)
{
    type->constructor.block.pot.shortScope = 1;
    ejsAddImmutable(ejs, S_commaProt, EN(",protected"), ejsCreateStringFromAsc(ejs, ",protected"));
}


PUBLIC void ejsConfigureBlockType(Ejs *ejs)
{
    EjsType     *type;
    
    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Block"))) == 0) {
        return;
    }
    ejsAddImmutable(ejs, S_commaProt, EN(",protected"), ejsCreateStringFromAsc(ejs, ",protected"));
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsBoolean.c"
 */
/************************************************************************/

/**
    ejsBoolean.c - Boolean native class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/******************************************************************************/
/*
    Cast the operand to a primitive type

    function cast(type: Type) : Object
 */
static EjsAny *castBooleanVar(Ejs *ejs, EjsBoolean *vp, EjsType *type)
{
    assert(ejsIs(ejs, vp, Boolean));

    switch (type->sid) {
    case S_Number:
        return ((vp->value) ? ESV(one): ESV(zero));

    case S_String:
        return ejsCreateStringFromAsc(ejs, (vp->value) ? "true" : "false");

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


/*
    Coerce operands for invokeOperator
 */
static EjsAny *coerceBooleanOperands(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (ejsIs(ejs, rhs, Void)) {
            return ESV(nan);
        } else if (ejsIs(ejs, rhs, Null) || ejsIs(ejs, rhs, Number) || ejsIs(ejs, rhs, Date)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsBoolean*) lhs)->value ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsBoolean*) lhs)->value ? ESV(false) : ESV(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return ESV(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


/*
    Run an operator on the operands
 */
static EjsAny *invokeBooleanOperator(Ejs *ejs, EjsBoolean *lhs, int opcode, EjsBoolean *rhs)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, Boolean) || !ejsIs(ejs, rhs, Boolean)) {
            if ((result = coerceBooleanOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }

    /*
        Types now match
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return ((lhs->value == rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return ((lhs->value != rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_LT:
        return ((lhs->value < rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_LE:
        return ((lhs->value <= rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_GT:
        return ((lhs->value > rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_GE:
        return ((lhs->value >= rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return ESV(false);

    case EJS_OP_COMPARE_FALSE:
        return ((lhs->value) ? ESV(false): ESV(true));

    case EJS_OP_COMPARE_TRUE:
        return ((lhs->value) ? ESV(true): ESV(false));

    /*
        Unary operators
     */
    case EJS_OP_NEG:
        return ejsCreateNumber(ejs, - lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return ejsCreateBoolean(ejs, !lhs->value);

    case EJS_OP_NOT:
        return ejsCreateBoolean(ejs, ~lhs->value);

    /*
        Binary operations
     */
    case EJS_OP_ADD:
        return ejsCreateBoolean(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return ejsCreateBoolean(ejs, lhs->value & rhs->value);

    case EJS_OP_DIV:
        return ejsCreateBoolean(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return ejsCreateBoolean(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return ejsCreateBoolean(ejs, lhs->value | rhs->value);

    case EJS_OP_REM:
        return ejsCreateBoolean(ejs, lhs->value % rhs->value);

    case EJS_OP_SUB:
        return ejsCreateBoolean(ejs, lhs->value - rhs->value);

    case EJS_OP_USHR:
        return ejsCreateBoolean(ejs, lhs->value >> rhs->value);

    case EJS_OP_XOR:
        return ejsCreateBoolean(ejs, lhs->value ^ rhs->value);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
}


/*********************************** Methods **********************************/
/*
    Boolean constructor.

        function Boolean(value: Boolean = null)

    If the value is omitted or 0, -1, NaN, false, null, undefined or the empty string, then set the boolean value to
    to false.
 */
static EjsBoolean *booleanConstructor(Ejs *ejs, EjsBoolean *bp, int argc, EjsObj **argv)
{
    assert(argc == 0 || argc == 1);

    if (argc >= 1) {
        /* Change the bp value */
        bp->value = ejsToBoolean(ejs, argv[0])->value;
    }
    return bp;
}


/*********************************** Factory **********************************/

PUBLIC void ejsCreateBooleanType(Ejs *ejs)
{
    EjsType     *type;
    EjsBoolean  *vp;

    type = ejsCreateCoreType(ejs, N("ejs", "Boolean"), sizeof(EjsBoolean), S_Boolean, ES_Boolean_NUM_CLASS_PROP, 
        0, EJS_TYPE_OBJ | EJS_TYPE_IMMUTABLE_INSTANCES);
    type->helpers.cast = (EjsCastHelper) castBooleanVar;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeBooleanOperator;

    /*
        Pre-create the only two valid instances for boolean
     */
    vp = ejsCreateObj(ejs, type, 0);
    vp->value = 1;
    ejsAddImmutable(ejs, S_true, EN("true"), vp);

    vp = ejsCreateObj(ejs, type, 0);
    vp->value = 0;
    ejsAddImmutable(ejs, S_false, EN("false"), vp);
}


PUBLIC void ejsConfigureBooleanType(Ejs *ejs)
{
    EjsType     *type;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Boolean"))) == 0) {
        return;
    }
    ejsBindConstructor(ejs, type, booleanConstructor);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsByteArray.c"
 */
/************************************************************************/

/*
    ejsByteArray.c - Ejscript ByteArray class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/***************************** Forward Declarations ***************************/

static EjsObj *ba_flush(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv);
static EjsString *ba_toString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv);

static int  flushByteArray(Ejs *ejs, EjsByteArray *ap);
static ssize  getInput(Ejs *ejs, EjsByteArray *ap, ssize required);
static int  lookupByteArrayProperty(Ejs *ejs, EjsByteArray *ap, EjsName qname);

static ME_INLINE int swap16(EjsByteArray *ap, int a);
static ME_INLINE int swap32(EjsByteArray *ap, int a);
static ME_INLINE int64 swap64(EjsByteArray *ap, int64 a);
static ME_INLINE double swapDouble(EjsByteArray *ap, double a);
static int putByte(EjsByteArray *ap, int value);
static int putInteger(EjsByteArray *ap, int value);
static int putLong(EjsByteArray *ap, int64 value);
static int putShort(EjsByteArray *ap, int value);
static int putString(EjsByteArray *ap, EjsString *value, ssize len);
static int putNumber(EjsByteArray *ap, MprNumber value);
static int putDouble(EjsByteArray *ap, double value);

#define availableBytes(ap)  (((EjsByteArray*) ap)->writePosition - ((EjsByteArray*) ap)->readPosition)
#define room(ap) (ap->size - ap->writePosition)
#define adjustReadPosition(ap, amt) \
    if (1) { \
        ap->readPosition += amt; \
        if (ap->readPosition == ap->writePosition) {    \
            ap->readPosition = ap->writePosition = 0; \
        } \
    } else

/******************************************************************************/
/*
    Cast the object operand to a primitive type
 */
static EjsAny *castByteArrayVar(Ejs *ejs, EjsByteArray *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ESV(true);

    case S_Number:
        return ESV(zero);

    case S_String:
        return ba_toString(ejs, vp, 0, 0);

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


static EjsByteArray *cloneByteArrayVar(Ejs *ejs, EjsByteArray *ap, bool deep)
{
    EjsByteArray    *newArray;

    if ((newArray = ejsCreateByteArray(ejs, ap->size)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    memcpy(newArray->value, ap->value, ap->size * sizeof(uchar));
    newArray->readPosition = ap->readPosition;
    newArray->writePosition = ap->writePosition;
    return newArray;
}


static int deleteByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, int slot)
{
    if (slot >= ap->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad subscript");
        return EJS_ERR;
    }
    if ((slot + 1) == ap->size) {
        ap->size--;
        if (ap->readPosition >= ap->size) {
            ap->readPosition = ap->size - 1;
        }
        if (ap->writePosition >= ap->size) {
            ap->writePosition = ap->size - 1;
        }
    }
    if (ejsSetProperty(ejs, ap, slot, ESV(undefined)) < 0) {
        return EJS_ERR;
    }
    return 0;
}


static ssize getByteArrayPropertyCount(Ejs *ejs, EjsByteArray *ap)
{
    return ap->size;
}


static EjsNumber *getByteArrayProperty(Ejs *ejs, EjsByteArray *ap, int slotNum)
{
    if (slotNum < 0 || slotNum >= ap->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad array subscript");
        return 0;
    }
    return ejsCreateNumber(ejs, ap->value[slotNum]);
}


static int lookupByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, EjsName qname)
{
    int     index;

    if (qname.name == 0 || ! isdigit((uchar) qname.name->value[0])) {
        return EJS_ERR;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < ap->size) {
        return index;
    }
    return EJS_ERR;
}


/*
    Cast operands as required for invokeOperator
 */
static EjsAny *coerceByteArrayOperands(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, ba_toString(ejs, (EjsByteArray*) lhs, 0, 0), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ESV(zero), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


static EjsAny *invokeByteArrayOperator(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceByteArrayOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, !(lhs == rhs));

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ESV(true);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return ESV(one);

    /*
        Binary operators
     */
    case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_REM:
    case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return ESV(zero);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    assert(0);
}


/*
    Create or update an array elements. If slotNum is < 0, then create the next free array slot. If slotNum is greater
    than the array length, grow the array.
 */
static int setByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, int slotNum,  EjsObj *value)
{
    if (slotNum >= ap->size && ejsGrowByteArray(ejs, ap, slotNum + 1) < 0) {
        return EJS_ERR;
    }
    if (ejsIs(ejs, value, Number)) {
        ap->value[slotNum] = ejsGetInt(ejs, value);
    } else {
        ap->value[slotNum] = ejsGetInt(ejs, ejsToNumber(ejs, value));
    }
    if (slotNum >= ap->size) {
        ap->size = slotNum + 1;
    }
    return slotNum;
}


/********************************** Methods *********************************/
/*
    function ByteArray(size: Number = -1, resizable: Boolean = true): ByteArray
 */
static EjsByteArray *ba_ByteArray(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    bool    resizable;
    int     size;

    assert(0 <= argc && argc <= 2);

    size = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : ME_MAX_BUFFER;
    if (size <= 0) {
        size = 1;
    }
    resizable = (argc == 2) ? ejsGetBoolean(ejs, argv[1]): 1;
    ap->growInc = (resizable) ? ME_MAX_BUFFER : 0;
    ap->endian = mprGetEndian(ejs);
    ap->resizable = 1;
    if (ejsGrowByteArray(ejs, ap, size) < 0) {
        return 0;
    }
    ap->resizable = resizable;
    assert(ap->value);
    return ap;
}


/**
    Determine if the byte array is in async mode
    function get async(): Boolean
 */
static EjsBoolean *ba_async(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ap->async ? ESV(true) : ESV(false);
}


/**
    Set the async mode 
    function set async(enable: Boolean): Void
 */
static EjsObj *ba_setAsync(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    ap->async = (argv[0] == ESV(true));
    return 0;
}


/*
    function close(): Void
 */
static EjsObj *ba_close(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "close", NULL, ap);
    }
    ap->writePosition = ap->readPosition = 0;
    return 0;
}


/*
    Copy data down and adjust the read/write offset pointers.
    function compact(): Void
 */
static EjsObj *ba_compact(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    assert(argc == 0);

    if (ap->writePosition == ap->readPosition) {
        ap->writePosition = ap->readPosition = 0;

    } else if (ap->readPosition > 0) {
        memmove(ap->value, &ap->value[ap->readPosition], ap->writePosition - ap->readPosition);
        ap->writePosition -= ap->readPosition;
        ap->readPosition = 0;
    }
    return 0;
}


/*
    Copy data into the array. Data is written at the $destOffset.
    function copyIn(destOffset: Number, src: ByteArray, srcOffset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *ba_copyIn(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *src;
    ssize           i, destOffset, srcOffset, count;

    destOffset = ejsGetInt(ejs, argv[0]);
    src = (EjsByteArray*) argv[1];
    srcOffset = (argc > 2) ? ejsGetInt(ejs, argv[2]) : 0;
    count = (argc > 3) ? ejsGetInt(ejs, argv[3]) : MAXINT;

    if (srcOffset >= src->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad source offset");
        return 0;
    }
    if (count < 0) {
        count = MAXINT;
    }
    count = min(src->size - srcOffset, count);

    ejsMakeRoomInByteArray(ejs, ap, destOffset + count);
    if ((destOffset + count) > src->size) {
        ejsThrowOutOfBoundsError(ejs, "Insufficient room for data");
        return 0;
    }
    //  TODO OPT - use memmove/memcpy
    for (i = 0; i < count; i++) {
        ap->value[destOffset++] = src->value[srcOffset++];
    }
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Copy data from the array. Data is copied from the $srcOffset.
    function copyOut(srcOffset: Number, dest: ByteArray, destOffset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *ba_copyOut(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *dest;
    ssize           count;
    int             i, srcOffset, destOffset;

    srcOffset = ejsGetInt(ejs, argv[0]);
    dest = (EjsByteArray*) argv[1];
    destOffset = (argc > 2) ? ejsGetInt(ejs, argv[2]) : 0;
    count = (argc > 3) ? ejsGetInt(ejs, argv[3]) : MAXINT;

    if (srcOffset >= ap->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad source data offset");
        return 0;
    }
    count = min(ap->size - srcOffset, count);
    ejsMakeRoomInByteArray(ejs, dest, destOffset + count);
    if ((destOffset + count) > dest->size) {
        ejsThrowOutOfBoundsError(ejs, "Insufficient room for data");
        return 0;
    }
    //  TODO OPT - use memmove/memcpy
    for (i = 0; i < count; i++) {
        dest->value[destOffset++] = ap->value[srcOffset++];
    }
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Determine if the system is using little endian byte ordering
    function get endian(): Number
 */
static EjsNumber *endian(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ap->endian);
}


/*
    Set the system encoding to little or big endian.
    function set endian(value: Number): Void
 */
static EjsObj *setEndian(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     endian;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));

    endian = ejsGetInt(ejs, argv[0]);
    if (endian != 0 && endian != 1) {
        ejsThrowArgError(ejs, "Bad endian value");
        return 0;
    }
    ap->endian = endian;
    ap->swap = (ap->endian != mprGetEndian(ejs));
    return 0;
}


/*
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextByteArrayKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsByteArray    *ap;

    ap = (EjsByteArray*) ip->target;
    if (!ejsIs(ejs, ap, ByteArray)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < ap->readPosition) {
        ip->index = (int) ap->readPosition;
    }
    if (ip->index < (int) ap->writePosition) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.
    iterator native function get(): Iterator
 */
static EjsIterator *ba_get(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, -1, nextByteArrayKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextByteArrayValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsByteArray    *ap;

    ap = (EjsByteArray*) ip->target;
    if (!ejsIs(ejs, ap, ByteArray)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < (int) ap->readPosition) {
        ip->index = (int) ap->readPosition;
    }
    if (ip->index < ap->writePosition) {
        return ejsCreateNumber(ejs, ap->value[ip->index++]);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return an iterator to return the next array element value.
    iterator native function getValues(): Iterator
 */
static EjsIterator *ba_getValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, ap, -1, nextByteArrayValue, 0, NULL);
}


/*  
    Flush the data in the byte array and reset the read and write position pointers
    function flush(ignored: Number): Void
 */
static EjsObj *ba_flush(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    flushByteArray(ejs, ap);
    ap->writePosition = ap->readPosition = 0;
    memset(ap->value, 0, ap->size);
    return 0;
}


/*
    Get the number of bytes that are currently available on this stream for reading.
    @return Returns the number of items in the array
    override function get length(): Number
 */
static EjsNumber *ba_getLength(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) (ap->writePosition - ap->readPosition));
}


#if KEEP
/*
    Set the length of an array.
    override function set length(value: Number): void
 */
static EjsObj *ba_setLength(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    assert(argc == 1 && ejsIs(ejs, argv[0], Number));
    assert(ejsIs(ejs, ap, ByteArray));

    ap->size = ejsGetInt(ejs, argv[0]);
    if (ap->readPosition >= ap->size) {
        ap->readPosition = ap->size - 1;
    }
    if (ap->writePosition >= ap->size) {
        ap->writePosition = ap->size - 1;
    }

    return 0;
}
#endif


/*
    Get the length of an array.
    @return Returns the number of items in the array
    function resizable(): Boolean
 */
static EjsBoolean *ba_resizable(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ap->resizable ? ESV(true) : ESV(false);
}


/*
    Read data from the array into another byte array. Data is read from the current read $position pointer.
    Data is written to the write position if offset is -1. Othwise at the given offset. If offset is < 0, the 
    write position is updated.
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *ba_read(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    ssize           offset, count;
    int             i;

    assert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc == 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc == 3) ? ejsGetInt(ejs, argv[2]) : (int) buffer->size;

    if (count < 0) {
        count = buffer->size;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset >= buffer->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    } else {
        buffer->readPosition = 0;
        buffer->writePosition = 0;
    }
    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return ESV(null);
    }
    count = min(availableBytes(ap), count);
    for (i = 0; i < count; i++) {
        buffer->value[offset++] = ap->value[ap->readPosition++];
    }
    buffer->writePosition += count;
    if (ap->emitter && availableBytes(ap) && !ejs->exception) {
        ejsSendEvent(ejs, ap->emitter, "writable", NULL, ap);
    }
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Read a boolean from the array.
    function readBoolean(): Boolean
 */
static EjsBoolean *ba_readBoolean(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     result;

    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return ESV(null);
    }
    result = ap->value[ap->readPosition];
    adjustReadPosition(ap, 1);
    return ejsCreateBoolean(ejs, result);
}


/*
    Read a byte from the array.
    function readByte(): Number
 */
static EjsNumber *ba_readByte(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     result;

    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return ESV(null);
    }
    result = ap->value[ap->readPosition];
    adjustReadPosition(ap, 1);
    return ejsCreateNumber(ejs, result);
}


/**
    Read a date from the array.
    function readDate(): Date
 */
static EjsDate *ba_readDate(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    double  value;

    if (getInput(ejs, ap, EJS_SIZE_DOUBLE) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return ESV(null);
    }
    value = * (double*) &ap->value[ap->readPosition];
    value = swapDouble(ap, value);
    adjustReadPosition(ap, sizeof(double));
    return ejsCreateDate(ejs, (MprTime) value);
}


/**
    Read a double from the array. The data will be decoded according to the encoding property.
    function readDouble(): Number
 */
static EjsNumber *ba_readDouble(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    double  value;

    if (getInput(ejs, ap, EJS_SIZE_DOUBLE) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return ESV(null);
    }
    memcpy(&value, (char*) &ap->value[ap->readPosition], sizeof(double));
    value = swapDouble(ap, value);
    adjustReadPosition(ap, sizeof(double));
    return ejsCreateNumber(ejs, (MprNumber) value);
}


/*
    Read a 32-bit integer from the array. The data will be decoded according to the encoding property.
    function readInteger(): Number
 */
static EjsNumber *ba_readInteger(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     value;

    if (getInput(ejs, ap, EJS_SIZE_INT) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return ESV(null);
    }
    value = * (int*) &ap->value[ap->readPosition];
    value = swap32(ap, value);
    adjustReadPosition(ap, sizeof(int));
    return ejsCreateNumber(ejs, value);
}


/*
    Read a 64-bit long from the array.The data will be decoded according to the encoding property.
    function readLong(): Number
 */
static EjsNumber *ba_readLong(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int64   value;

    if (getInput(ejs, ap, EJS_SIZE_LONG) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return ESV(null);
    }
    value = * (int64*) &ap->value[ap->readPosition];
    value = swap64(ap, value);
    adjustReadPosition(ap, sizeof(int64));
    return ejsCreateNumber(ejs, (MprNumber) value);
}


/*
    Get the current read position offset
    function get readPosition(): Number
 */
static EjsNumber *ba_readPosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ap->readPosition);
}


/*
    Set the current read position offset
    function set readPosition(position: Number): Void
 */
static EjsObj *ba_setReadPosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     pos;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0 || pos > ap->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad position value");
        return 0;
    }
    if (pos > ap->writePosition) {
        ejsThrowStateError(ejs, "Read position is greater than write position");
    } else {
        ap->readPosition = pos;
    }
    return 0;
}


/*
    Read a 16-bit short integer from the array. The data will be decoded according to the encoding property.
    function readShort(): Number
 */
static EjsNumber *ba_readShort(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     value;

    if (getInput(ejs, ap, EJS_SIZE_SHORT) <= 0) {
        return ESV(null);
    }
    value = * (short*) &ap->value[ap->readPosition];
    value = swap16(ap, value);
    adjustReadPosition(ap, sizeof(short));
    return ejsCreateNumber(ejs, value);
}


/*
    Read a UTF-8 string from the array. Read data from the read position up to the write position but not more 
    than count characters.

    function readString(count: Number = -1): String
 */
static EjsString *ba_readString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsString   *result;
    ssize       count;

    count = (argc == 1) ? ejsGetInt(ejs, argv[0]) : -1;
    if (count < 0) {
        if (getInput(ejs, ap, 1) < 0) {
            return ESV(null);
        }
        count = availableBytes(ap);

    } else if (getInput(ejs, ap, count) < 0) {
        return ESV(null);
    }
    count = min(count, availableBytes(ap));
    //  TODO - UNICODE ENCODING
    result = ejsCreateStringFromMulti(ejs, (cchar*) &ap->value[ap->readPosition], count);
    adjustReadPosition(ap, count);
    return result;
}


/*
    Reset the read and write position pointers if there is no available data.
    function reset(): Void
 */
static EjsObj *ba_reset(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    ejsResetByteArray(ejs, ap);
    return 0;
}


/**
    function off(name, observer: Function): Number
 */
static EjsObj *ba_off(Ejs *ejs, EjsByteArray *ap, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, ap->emitter, argv[0], argv[1]);
    return 0;
}


/**
    function on(name, observer: Function): ByteArray
 */
static EjsByteArray *ba_on(Ejs *ejs, EjsByteArray *ap, int argc, EjsAny **argv)
{
    ejsAddObserver(ejs, &ap->emitter, argv[0], argv[1]);
    return ap;
}


/**
    Get the number of data bytes that the array can store from the write position till the end of the array.
    function get room(): Number
 */
static EjsNumber *ba_room(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) room(ap));
}


/**
    Get the size of an array.
    function get size(): Number
 */
static EjsNumber *ba_size(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (int) ap->size);
}


/*
    Convert the byte array data between the read and write positions into a string.
    override function toString(): String
 */
static EjsString *ba_toString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    //  TODO - UNICODE ENCODING
    return ejsCreateStringFromMulti(ejs, (cchar*) &ap->value[ap->readPosition], availableBytes(ap));
}


/*
    Write data to the array. Data is written to the current write $position pointer.
    function write(...data): Number
 */
PUBLIC EjsNumber *ejsWriteToByteArray(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *bp;
    EjsString       *sp;
    EjsObj          *vp;
    ssize           len, wrote;
    int             i;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    /*
        Unwrap nested arrays
     */
    args = (EjsArray*) argv[0];
    while (ejsIs(ejs, args, Array) && args->length == 1) {
        vp = ejsGetProperty(ejs, args, 0);
        if (!ejsIs(ejs, vp, Array)) {
            break;
        }
        args = (EjsArray*) vp;
    }
    if (availableBytes(ap) == 0) {
        ap->writePosition = ap->readPosition = 0;
    }
    wrote = 0;

    for (i = 0; i < args->length; i++) {
        if ((vp = ejsGetProperty(ejs, args, i)) == 0) {
            continue;
        }
        switch (TYPE(vp)->sid) {
        case S_Boolean:
            if (!ejsMakeRoomInByteArray(ejs, ap, EJS_SIZE_BOOLEAN)) {
                return 0;
            }
            wrote += putByte(ap, ejsGetBoolean(ejs, vp));
            break;

        case S_Date:
            if (!ejsMakeRoomInByteArray(ejs, ap, EJS_SIZE_DOUBLE)) {
                return 0;
            }
            wrote += putNumber(ap, (MprNumber) ((EjsDate*) vp)->value);
            break;

        case S_Number:
            if (!ejsMakeRoomInByteArray(ejs, ap, EJS_SIZE_DOUBLE)) {
                return 0;
            }
            wrote += putNumber(ap, ejsGetNumber(ejs, vp));
            break;

        case S_String:
            if (!ejsMakeRoomInByteArray(ejs, ap, ((EjsString*) vp)->length)) {
                return 0;
            }
            sp = (EjsString*) vp;
            wrote += putString(ap, sp, sp->length);
            break;

        default:
            sp = ejsToString(ejs, vp);
            wrote += putString(ap, sp, sp->length);
            break;

        case S_ByteArray:
            bp = (EjsByteArray*) vp;
            len = availableBytes(bp);
            if (!ejsMakeRoomInByteArray(ejs, ap, len)) {
                return 0;
            }
            /*
                Note: this only copies between the read/write positions of the source byte array
             */
            //  TODO - should use RC value (== len)
            ejsCopyToByteArray(ejs, ap, ap->writePosition, (char*) &bp->value[bp->readPosition], len);
            ap->writePosition += len;
            wrote += len;
            break;
        }
    }
    if (ap->emitter && wrote > 0 && availableBytes(ap) > 0) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return ejsCreateNumber(ejs, (MprNumber) wrote);
}


/*
    Write a byte to the array
    function writeByte(value: Number): Void
 */
static EjsObj *ba_writeByte(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, 1)) {
        return 0;
    }
    putByte(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write a short to the array
    function writeShort(value: Number): Void
 */
static EjsObj *ba_writeShort(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(short))) {
        return 0;
    }
    putShort(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write a double to the array
    function writeDouble(value: Number): Void
 */
static EjsObj *ba_writeDouble(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(double))) {
        return 0;
    }
    putDouble(ap, ejsGetDouble(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write an integer (32 bits) to the array
    function writeInteger(value: Number): Void
 */

static EjsObj *ba_writeInteger(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(int))) {
        return 0;
    }
    putInteger(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Write a long (64 bit) to the array
    function writeLong(value: Number): Void
 */
static EjsObj *ba_writeLong(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!ejsMakeRoomInByteArray(ejs, ap, sizeof(int))) {
        return 0;
    }
    putLong(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
    }
    return 0;
}


/*
    Get the current write position offset
    function get writePosition(): Number
 */
static EjsNumber *ba_writePosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ap->writePosition);
}


/*
    Set the current write position offset
    function set writePosition(position: Number): Void
 */
static EjsObj *ba_setWritePosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     pos;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0 || pos > ap->size) {
        ejsThrowStateError(ejs, "Write position is outside bounds of array");
        return 0;
    }
    if (pos < ap->readPosition) {
        ejsThrowStateError(ejs, "Write position is less than read position");
    } else {
        ap->writePosition = pos;
    }
    return 0;
}


/*********************************** Support **********************************/
/*
    Flush the array. Issue a "flush" event. Flushing attempts to write pending data before resetting the array.
 */
static int flushByteArray(Ejs *ejs, EjsByteArray *ap)
{
    if (ap->emitter && availableBytes(ap) && !ejs->exception) {
        ejsSendEvent(ejs, ap->emitter, "flush", NULL, ap);
    }
    ap->writePosition = ap->readPosition = 0;
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "writable", NULL, ap);
    }
    return 0;
}


/*
    Grow the byte array up to the given length, but not over the maximum. Return the length or an error code.
    This routine always throws an exception.
 */
PUBLIC ssize ejsGrowByteArray(Ejs *ejs, EjsByteArray *ap, ssize len)
{
    if (len > ap->size) {
        if (!ap->resizable) {
            ejsThrowResourceError(ejs, "Byte array is too small. Need room for %d bytes.", len);
            return EJS_ERR;
        }
        if ((ap->value = mprRealloc(ap->value, len)) == 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
        memset(&ap->value[ap->size], 0, len - ap->size);
        ap->growInc = min(ap->growInc * 2, 32 * 1024);
        ap->size = len;
    }
    return ap->size;
}


/*
    Get more input sufficient to satisfy the rquired number of bytes. The required parameter specifies how many bytes 
    must be read. Short fills are not permitted. Return the count of bytes available or 0 if the required number of 
    bytes can't be read. Return -ve on errors.
 */
static ssize getInput(Ejs *ejs, EjsByteArray *ap, ssize required)
{
    if (availableBytes(ap) == 0) {
        ap->writePosition = ap->readPosition = 0;
    }
    if (availableBytes(ap) < required && !ejs->exception) {
        if (ap->emitter) {
            ejsSendEvent(ejs, ap->emitter, "writable", NULL, ap);
        }
    }
    if (availableBytes(ap) < required) {
        return 0;
    }
    return availableBytes(ap);
}


PUBLIC bool ejsMakeRoomInByteArray(Ejs *ejs, EjsByteArray *ap, ssize require)
{
    ssize   newLen;

    /*
        TODO - should this do ejsResetByteArray if empty
     */
    if (room(ap) < require) {
        if (ap->emitter && availableBytes(ap)) {
            ejsSendEvent(ejs, ap->emitter, "readable", NULL, ap);
        }
        if (room(ap) < require) {
            newLen = max(ap->size + require, ap->size + ap->growInc);
            if (ejsGrowByteArray(ejs, ap, newLen) < 0) {
                return 0;
            }
        }
    }
    return 1;
}


static ME_INLINE int swap16(EjsByteArray *ap, int a)
{
    if (!ap->swap) {
        return a;
    }
    return (a & 0xFF) << 8 | (a & 0xFF00 >> 8);
}


static ME_INLINE int swap32(EjsByteArray *ap, int a)
{
    if (!ap->swap) {
        return a;
    }
    return (a & 0xFF) << 24 | (a & 0xFF00 << 8) | (a & 0xFF0000 >> 8) | (a & 0xFF000000 >> 16);
}


static ME_INLINE int64 swap64(EjsByteArray *ap, int64 a)
{
    int64   low, high;

    if (!ap->swap) {
        return a;
    }
    low = a & 0xFFFFFFFF;
    high = (a >> 32) & 0xFFFFFFFF;
    return  (low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32;
}


static ME_INLINE double swapDouble(EjsByteArray *ap, double a)
{
    int64   low, high;

    if (!ap->swap) {
        return a;
    }
    low = ((int64) a) & 0xFFFFFFFF;
    high = (((int64) a) >> 32) & 0xFFFFFFFF;
    return  (double) ((low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32);
}


static int putByte(EjsByteArray *ap, int value)
{
    ap->value[ap->writePosition++] = (char) value;
    return sizeof(char);
}


static int putShort(EjsByteArray *ap, int value)
{
    value = swap16(ap, value);

    *((short*) &ap->value[ap->writePosition]) = (short) value;
    ap->writePosition += sizeof(short);
    return sizeof(short);
}


static int putInteger(EjsByteArray *ap, int value)
{
    value = swap32(ap, value);

    *((int*) &ap->value[ap->writePosition]) = (int) value;
    ap->writePosition += sizeof(int);
    return sizeof(int);
}


static int putLong(EjsByteArray *ap, int64 value)
{
    value = swap64(ap, value);

    *((int64*) &ap->value[ap->writePosition]) = value;
    ap->writePosition += sizeof(int64);
    return sizeof(int64);
}


static int putDouble(EjsByteArray *ap, double value)
{
    value = swapDouble(ap, value);

    memcpy((char*) &ap->value[ap->writePosition], &value, sizeof(double));
    ap->writePosition += sizeof(double);
    return sizeof(double);
}


/*
    Write a number in the default number encoding
 */
static int putNumber(EjsByteArray *ap, MprNumber value)
{
    return putDouble(ap, value);
}


static int putString(EjsByteArray *ap, EjsString *str, ssize len)
{
    //  TODO -- this must do encoding
    mprMemcpy(&ap->value[ap->writePosition], room(ap), str->value, len);
    ap->writePosition += len;
    return (int) len;
}

/********************************* Public Support API *****************************/

PUBLIC void ejsResetByteArray(Ejs *ejs, EjsByteArray *ba)
{
    if (ba->writePosition == ba->readPosition) {
        ba->writePosition = ba->readPosition = 0;
        memset(ba->value, 0, ba->size);
    }
}


PUBLIC void ejsSetByteArrayPositions(Ejs *ejs, EjsByteArray *ba, ssize readPosition, ssize writePosition)
{
    if (readPosition >= 0) {
        ba->readPosition = readPosition;
    }
    if (writePosition >= 0) {
        ba->writePosition = writePosition;
    }
}


PUBLIC ssize ejsCopyToByteArray(Ejs *ejs, EjsByteArray *ba, ssize offset, cchar *data, ssize length)
{
    int     i;

    assert(ba);
    assert(data);

    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (!ejsMakeRoomInByteArray(ejs, ba, offset + length)) {
        return EJS_ERR;
    }
    if (ba->size < (offset + length)) {
        return EJS_ERR;
    }
    for (i = 0; i < length; i++) {
        //  TODO OPT - memcpy
        ba->value[offset++] = data[i];
    }
    return length;
}


PUBLIC ssize ejsGetByteArrayAvailableData(EjsByteArray *ba)
{
    return availableBytes(ba);
}


PUBLIC ssize ejsGetByteArrayRoom(EjsByteArray *ba)
{
    return room(ba);
}

/*********************************** Factory **********************************/

PUBLIC EjsByteArray *ejsCreateByteArray(Ejs *ejs, ssize size)
{
    EjsByteArray    *ap;

    /*
        No need to invoke constructor
     */
    ap = ejsCreateObj(ejs, ESV(ByteArray), 0);
    if (ap == 0) {
        return 0;
    }
    if (size <= 0) {
        size = ME_MAX_BUFFER;
    }
    ap->async = -1;
    ap->resizable = 1;
    ap->growInc = ME_MAX_BUFFER;
    ap->endian = mprGetEndian(ejs);
    if (ejsGrowByteArray(ejs, ap, size) < 0) {
        return 0;
    }
    return ap;
}


static void manageByteArray(EjsByteArray *ap, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ap->emitter);
        mprMark(ap->value);
        mprMark(TYPE(ap));
    }
}


PUBLIC void ejsConfigureByteArrayType(Ejs *ejs)
{
    EjsType     *type;
    EjsHelpers  *helpers;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "ByteArray"), sizeof(EjsByteArray), manageByteArray, 
            EJS_TYPE_OBJ | EJS_TYPE_NUMERIC_INDICIES | EJS_TYPE_VIRTUAL_SLOTS | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    helpers = &type->helpers;
    helpers->cast = (EjsCastHelper) castByteArrayVar;
    helpers->clone = (EjsCloneHelper) cloneByteArrayVar;
    helpers->deleteProperty = (EjsDeletePropertyHelper) deleteByteArrayProperty;
    helpers->getProperty = (EjsGetPropertyHelper) getByteArrayProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getByteArrayPropertyCount;
    helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeByteArrayOperator;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupByteArrayProperty;
    helpers->setProperty = (EjsSetPropertyHelper) setByteArrayProperty;
    
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, ba_ByteArray);
    ejsBindMethod(ejs, prototype, ES_ByteArray_on, ba_on);
    ejsBindAccess(ejs, prototype, ES_ByteArray_async, ba_async, ba_setAsync);
    ejsBindMethod(ejs, prototype, ES_ByteArray_close, ba_close);
    ejsBindMethod(ejs, prototype, ES_ByteArray_compact, ba_compact);
    ejsBindMethod(ejs, prototype, ES_ByteArray_copyIn, ba_copyIn);
    ejsBindMethod(ejs, prototype, ES_ByteArray_copyOut, ba_copyOut);
    ejsBindAccess(ejs, prototype, ES_ByteArray_endian, endian, setEndian);
    ejsBindMethod(ejs, prototype, ES_ByteArray_flush, ba_flush);
    ejsBindMethod(ejs, prototype, ES_ByteArray_resizable, ba_resizable);
    ejsBindMethod(ejs, prototype, ES_ByteArray_length, ba_getLength);
    ejsBindMethod(ejs, prototype, ES_ByteArray_iterator_get, ba_get);
    ejsBindMethod(ejs, prototype, ES_ByteArray_iterator_getValues, ba_getValues);
    ejsBindMethod(ejs, prototype, ES_ByteArray_off, ba_off);
    ejsBindMethod(ejs, prototype, ES_ByteArray_read, ba_read);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readBoolean, ba_readBoolean);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readByte, ba_readByte);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readDate, ba_readDate);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readDouble, ba_readDouble);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readInteger, ba_readInteger);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readLong, ba_readLong);
    ejsBindAccess(ejs, prototype, ES_ByteArray_readPosition, ba_readPosition,ba_setReadPosition);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readShort, ba_readShort);
    ejsBindMethod(ejs, prototype, ES_ByteArray_readString, ba_readString);
    ejsBindMethod(ejs, prototype, ES_ByteArray_reset, ba_reset);
    ejsBindMethod(ejs, prototype, ES_ByteArray_room, ba_room);
    ejsBindMethod(ejs, prototype, ES_ByteArray_size, ba_size);
    ejsBindMethod(ejs, prototype, ES_ByteArray_toString, ba_toString);
    ejsBindMethod(ejs, prototype, ES_ByteArray_write, ejsWriteToByteArray);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeByte, ba_writeByte);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeShort, ba_writeShort);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeInteger, ba_writeInteger);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeLong, ba_writeLong);
    ejsBindMethod(ejs, prototype, ES_ByteArray_writeDouble, ba_writeDouble);
    ejsBindAccess(ejs, prototype, ES_ByteArray_writePosition, ba_writePosition, ba_setWritePosition);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsCache.c"
 */
/************************************************************************/

/**
    ejsCache.c - API for the Cache class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************* Code ***********************************/

PUBLIC EjsAny *ejsCacheExpire(Ejs *ejs, EjsObj *cache, EjsString *key, EjsDate *when)
{
    EjsAny  *argv[3];
    int     prior;

    prior = ejsBlockGC(ejs);
    argv[0] = key;
    argv[1] = when;
    ejsRunFunctionBySlot(ejs, cache, ES_Cache_expire, 2, argv);
    ejsUnblockGC(ejs, prior);
    return 0;
}


PUBLIC EjsAny *ejsCacheRead(Ejs *ejs, EjsObj *cache, EjsString *key, EjsObj *options)
{
    EjsAny  *argv[3], *result;
    int     prior;

    prior = ejsBlockGC(ejs);
    argv[0] = key;
    argv[1] = (options) ? options : ESV(null);
    result = ejsRunFunctionBySlot(ejs, cache, ES_Cache_read, 2, argv);
    ejsUnblockGC(ejs, prior);
    return result;
}


PUBLIC EjsAny *ejsCacheReadObj(Ejs *ejs, EjsObj *cache, EjsString *key, EjsObj *options)
{
    EjsAny  *value, *argv[3], *result;
    int     prior;

    prior = ejsBlockGC(ejs);
    argv[0] = key;
    argv[1] = (options) ? options : ESV(null);
    if ((value = ejsRunFunctionBySlot(ejs, cache, ES_Cache_read, 2, argv)) == 0 || value == ESV(null)) {
        return 0;
    }
    result = ejsDeserialize(ejs, value);
    ejsUnblockGC(ejs, prior);
    return result;
}


PUBLIC EjsBoolean *ejsCacheRemove(Ejs *ejs, EjsObj *cache, EjsString *key)
{
    EjsAny  *argv[3], *result;
    int     prior;

    prior = ejsBlockGC(ejs);
    argv[0] = key;
    result = ejsRunFunctionBySlot(ejs, cache, ES_Cache_remove, 1, argv);
    ejsUnblockGC(ejs, prior);
    return result;
}


PUBLIC EjsAny *ejsCacheSetLimits(Ejs *ejs, EjsObj *cache, EjsObj *limits)
{
    EjsAny  *argv[2], *result;
    int     prior;

    prior = ejsBlockGC(ejs);
    argv[0] = limits;
    result = ejsRunFunctionBySlot(ejs, cache, ES_Cache_setLimits, 2, argv);
    ejsUnblockGC(ejs, prior);
    return result;
}


PUBLIC EjsNumber *ejsCacheWrite(Ejs *ejs, EjsObj *cache, EjsString *key, EjsString *value, EjsObj *options)
{
    EjsAny  *argv[3], *result;
    int     prior;

    prior = ejsBlockGC(ejs);
    argv[0] = key;
    argv[1] = value;
    argv[2] = (options) ? options : ESV(null);
    result = ejsRunFunctionBySlot(ejs, cache, ES_Cache_write, 3, argv);
    ejsUnblockGC(ejs, prior);
    return result;
}


PUBLIC EjsNumber *ejsCacheWriteObj(Ejs *ejs, EjsObj *cache, EjsString *key, EjsAny *value, EjsObj *options)
{
    EjsAny  *argv[3], *result;
    int     prior;

    prior = ejsBlockGC(ejs);
    argv[0] = key;
    argv[1] = ejsSerialize(ejs, value, 0);
    argv[2] = (options) ? options : ESV(null);
    result = ejsRunFunctionBySlot(ejs, cache, ES_Cache_write, 3, argv);
    ejsUnblockGC(ejs, prior);
    return result;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsCmd.c"
 */
/************************************************************************/

/*
    ejsCmd.c -- Cmd class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Forwards *********************************/

static EjsObj *cmd_start(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv);

/************************************ Methods *********************************/
/*
    function Cmd(cmdline: Object, options: Object)
 */
static EjsCmd *cmd_constructor(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    cmd->stdoutBuf = mprCreateBuf(ME_MAX_BUFFER, -1);
    cmd->stderrBuf = mprCreateBuf(ME_MAX_BUFFER, -1);
    cmd->ejs = ejs;
    cmd->timeout = -1;
    if (argc >= 1) {
        cmd_start(ejs, cmd, argc, argv);
    }
    return cmd;
}


/**
    function close(): Void
 */
static EjsObj *cmd_close(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc) {
        mprDestroyCmd(cmd->mc);
        cmd->mc = 0;
    }
    return 0;
}


/**
    function get errorStream(): Stream
 */
static EjsByteArray *cmd_errorStream(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->error == 0) {
        cmd->error = ejsCreateByteArray(ejs, -1);
    }
    return cmd->error;
}


/**
    function get env(): Object
 */
static EjsObj *cmd_env(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    return cmd->env;
}


/**
    function set env(values: Object): Void
 */
static EjsObj *cmd_set_env(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    cmd->env = argv[0];
    return 0;
}


/**
    function finalize(): Void
 */
static EjsObj *cmd_finalize(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    mprFinalizeCmd(cmd->mc);
    return 0;
}


/**
    function flush(dir: Number = Stream.BOTH): Void
 */
static EjsObj *cmd_flush(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    /* Nothing to do */
    return 0;
}


/**
    static function kill(pid: Number, signal: Number = 2): Boolean
 */
static EjsObj *cmd_kill(Ejs *ejs, EjsAny *unused, int argc, EjsObj **argv)
{
    int     rc, pid, signal;

#if ME_UNIX_LIKE
    signal = SIGINT;
#else
    signal = 2;
#endif
    if (argc >= 2) {
        signal = ejsGetInt(ejs, argv[1]);
    }
    pid = ejsGetInt(ejs, argv[0]);
    if (pid == 0) {
        ejsThrowStateError(ejs, "No process to kill");
        return 0;
    }
#if ME_WIN_LIKE
{
    HANDLE	handle;
	handle = OpenProcess(PROCESS_TERMINATE, 0, pid);
    if (handle == 0) {
        ejsThrowIOError(ejs, "Cannot find process ID %d", pid);
        return 0;
    }
    rc = TerminateProcess(handle, signal) == 0;
}
#elif VXWORKS
    rc = taskDelete(pid);
#else
    rc = kill(pid, signal);
#endif
    if (rc < 0) {
        ejsThrowIOError(ejs, "Cannot kill %d with signal %d, errno %d", pid, signal, errno);
        return ESV(false);
    }
    return ESV(true);
}


/**
    function on(name, observer: Function): Cmd
 */
static EjsCmd *cmd_on(Ejs *ejs, EjsCmd *cmd, int argc, EjsAny **argv)
{
    EjsFunction     *observer;

    observer = (EjsFunction*) argv[1];
    if (observer->boundThis == 0 || observer->boundThis == ejs->global) {
        observer->boundThis = cmd;
    }
    ejsAddObserver(ejs, &cmd->emitter, argv[0], observer);
    if (!cmd->async) {
        cmd->async = 1;
    }
    return cmd;
}


/**
    function get off(name, observer: Function): Void
 */
static EjsObj *cmd_off(Ejs *ejs, EjsCmd *cmd, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, cmd->emitter, argv[0], argv[1]);
    return 0;
}


/**
    function pid(): Number
 */
static EjsNumber *cmd_pid(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc == 0 || cmd->mc->pid == 0) {
        return ESV(zero);
    }
    return ejsCreateNumber(ejs, cmd->mc->pid);
}


/**
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *cmd_read(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    ssize           offset, count, nbytes;

    assert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc == 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc == 3) ? ejsGetInt(ejs, argv[2]) : (int) buffer->size;

    if (count < 0) {
        count = buffer->size;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset >= buffer->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    } else {
        buffer->readPosition = 0;
        buffer->writePosition = 0;
    }
    count = buffer->size - buffer->writePosition;
    if (count <= 0) {
        if (ejsGrowByteArray(ejs, buffer, ME_MAX_BUFFER) < 0) {
            return 0;
        }
        count = buffer->size - buffer->writePosition;
    }
    nbytes = mprGetBufLength(cmd->stdoutBuf);
    if (nbytes == 0 && !cmd->async && cmd->mc) {
        if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
            ejsThrowStateError(ejs, "Command timed out");
            return 0;
        }
        nbytes = mprGetBufLength(cmd->stdoutBuf);
    }
    count = min(count, nbytes);
    //  TODO - should use RC Value (== count)
    ejsCopyToByteArray(ejs, buffer, buffer->writePosition, (char*) mprGetBufStart(cmd->stdoutBuf), count);
    ejsSetByteArrayPositions(ejs, buffer, -1, buffer->writePosition + count);
    mprAdjustBufStart(cmd->stdoutBuf, count);
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*
    Read a UTF-8 string from the array. Read data from the read position up to the write position but not more 
    than count characters.

    function readString(count: Number = -1): String
 */
static EjsString *cmd_readString(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsString   *result;
    ssize       nbytes, count;
    
    assert(0 <= argc && argc <= 1);
    
    count = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : -1;
    if (count < 0) {
        count = MAXSSIZE;
    }
    nbytes = mprGetBufLength(cmd->stdoutBuf);
    if (nbytes == 0 && cmd->mc) {
        if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
            ejsThrowStateError(ejs, "Command timed out");
            return 0;
        }
        nbytes = mprGetBufLength(cmd->stdoutBuf);
    }
    count = min(count, nbytes);
    result = ejsCreateStringFromBytes(ejs, mprGetBufStart(cmd->stdoutBuf), count);
    mprAdjustBufStart(cmd->stdoutBuf, count);
    mprResetBufIfEmpty(cmd->stdoutBuf);
    return result;
}


static void cmdIOCallback(MprCmd *mc, int channel, void *data)
{
    EjsCmd          *cmd;
    EjsByteArray    *ba;
    MprBuf          *buf;
    ssize           len, space;

    /*
        Note: stdin, stdout and stderr are named from the client's perspective
     */
    cmd = data;
    buf = 0;

    switch (channel) {
    case MPR_CMD_STDIN:
        ejsSendEvent(cmd->ejs, cmd->emitter, "writable", NULL, cmd);
        mprEnableCmdEvents(mc, channel);
        return;
    case MPR_CMD_STDOUT:
        buf = cmd->stdoutBuf;
        break;
    case MPR_CMD_STDERR:
        buf = cmd->stderrBuf;
        break;
    default:
        /* Child death */
        return;
    }
    /*
        Read and aggregate the result into a single string
     */
    mprResetBufIfEmpty(buf);
    space = mprGetBufSpace(buf);
    if (space < (ME_MAX_BUFFER / 4)) {
        if (mprGrowBuf(buf, ME_MAX_BUFFER) < 0) {
            mprCloseCmdFd(mc, channel);
            return;
        }
        space = mprGetBufSpace(buf);
    }
    assert(mc->files[channel].fd >= 0);
    len = mprReadCmd(mc, channel, mprGetBufEnd(buf), space);
    if (len <= 0) {
        if (len == 0 || (len < 0 && !(errno == EAGAIN || errno == EWOULDBLOCK))) {
            mprCloseCmdFd(mc, channel);
        }
    } else {
        mprAdjustBufEnd(buf, len);
    }
    if (len > 0) {
        mprEnableCmdEvents(mc, channel);
    } else if (len < 0) {
        len = 0;
    }
    if (channel == MPR_CMD_STDERR) {
        if (cmd->error == 0) {
            cmd->error = ejsCreateByteArray(cmd->ejs, -1);
        }
        ba = cmd->error;
        //  TODO - should use RC Value (== count)
        ejsCopyToByteArray(cmd->ejs, ba, ba->writePosition, mprGetBufStart(buf), len);
        ba->writePosition += len;
        mprAdjustBufStart(buf, len);
        mprResetBufIfEmpty(buf);
    }
    if (cmd->async) {
        if (channel == MPR_CMD_STDOUT) {
            ejsSendEvent(cmd->ejs, cmd->emitter, "readable", NULL, cmd);
        }
        if (channel == MPR_CMD_STDERR) {
            if (len > 0) {
                ejsSendEvent(cmd->ejs, cmd->emitter, "error", NULL, cmd);
            } else {
                ejsSendEvent(cmd->ejs, cmd->emitter, "complete", NULL, cmd);
            }
        }
    }
}


static int parseOptions(Ejs *ejs, EjsCmd *cmd)
{
    EjsObj      *value;
    EjsPath     *path;
    int         flags;

    cmd->throw = 0;    
    flags = MPR_CMD_IN | MPR_CMD_OUT | MPR_CMD_ERR;
    if (cmd->options) {
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("noio"))) != 0) {
            if (value == ESV(true)) {
                flags &= ~(MPR_CMD_OUT | MPR_CMD_ERR);
            }
        }
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("detach"))) != 0) {
            if (value == ESV(true)) {
                flags |= MPR_CMD_DETACH;
            }
        }
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("dir"))) != 0) {
            path = ejsToPath(ejs, value);
            if (path && cmd->mc) {
                mprSetCmdDir(cmd->mc, path->value);
            }
        }
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("exception"))) != 0) {
            if (value == ESV(true)) {
                cmd->throw = 1;
            }
        }
        if ((value = ejsGetPropertyByName(ejs, cmd->options, EN("timeout"))) != 0) {
            cmd->timeout = ejsGetInt(ejs, value);
        }
    }
    return flags;
}


static bool setCmdArgs(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsArray    *ap;
    int         i;

    if (ejsIs(ejs, cmd->command, Array)) {
        ap = (EjsArray*) cmd->command;
        if ((cmd->argv = mprAlloc(sizeof(void*) * (ap->length + 1))) == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        for (i = 0; i < ap->length; i++) {
            cmd->argv[i] = ejsToMulti(ejs, ejsToString(ejs, ejsGetProperty(ejs, cmd->command, i)));
        }
        cmd->argv[i] = 0;
        cmd->argc = ap->length;

    } else {
        cmd->command = ejsToMulti(ejs, cmd->command);
        if ((cmd->argc = mprMakeArgv(cmd->command, &cmd->argv, 0)) < 0 || cmd->argv == 0) {
            ejsThrowArgError(ejs, "Cannot parse command line");
            return 0;
        }
    }
    return 1;
}


/**
    function start(cmdline: Object, options: Object = null): Void
 */
static EjsObj *cmd_start(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsName     qname;
    cchar       **env;
    char        *err;
    int         rc, flags, len, i, status;

    cmd->command = argv[0];
    cmd->options = (argc >=2 ) ? argv[1] : 0;

    if (cmd->command == ESV(null)) {
        ejsThrowStateError(ejs, "Missing command line");
        return 0;
    }
    if ((cmd->mc = mprCreateCmd(ejs->dispatcher)) == 0) {
        return 0;
    }
    mprSetCmdCallback(cmd->mc, cmdIOCallback, cmd);
    mprFlushBuf(cmd->stdoutBuf);
    mprFlushBuf(cmd->stderrBuf);
    if (!setCmdArgs(ejs, cmd, argc, argv)) {
        return 0;
    }
    if (cmd->env) {
        len = ejsGetLength(ejs, cmd->env);
        if ((env = mprAlloc(sizeof(void*) * (len + 1))) == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        for (i = 0; i < len; i++) {
            qname = ejsGetPropertyName(ejs, cmd->env, i);
            env[i] = sfmt("%s=%s", qname.name->value, 
                ejsToMulti(ejs, ejsToString(ejs, ejsGetProperty(ejs, cmd->env, i))));
        }
        env[i] = 0;
    } else {
        env = 0;
    }
    flags = parseOptions(ejs, cmd);

    if ((rc = mprStartCmd(cmd->mc, cmd->argc, cmd->argv, env, flags)) < 0) {
        if (rc == MPR_ERR_BAD_ARGS) {
            err = "Bad command arguments";
        } else if (rc == MPR_ERR_CANT_ACCESS) {
            err = "Cannot access command";
        } else if (rc == MPR_ERR_CANT_OPEN) {
            err = "Cannot open standard I/O for command";
        } else if (rc == MPR_ERR_CANT_CREATE) {
            err = "Cannot create process";
        } else {
            err = "";
        }
        ejsThrowError(ejs, "Command failed: %s\nError Output: %s", cmd->argv[0], err);
        return 0;
    }
    if (!(flags & MPR_CMD_DETACH)) {
        assert(cmd->mc);
        mprFinalizeCmd(cmd->mc);
        if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
            ejsThrowStateError(ejs, "Timeout %d msec waiting for command to complete: %s", cmd->timeout, cmd->argv[0]);
            return 0;
        }
        assert(cmd->mc);
        if (cmd->throw) {
            status = mprGetCmdExitStatus(cmd->mc);
            if (status != 0) {
                ejsThrowIOError(ejs, "Command failed status %d, %@", status, ejsToString(ejs, cmd->error));
            }
        }
    }
    return 0;
}


/**
    function get status(): Number
 */
static EjsNumber *cmd_status(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    if (mprWaitForCmd(cmd->mc, cmd->timeout) < 0) {
        ejsThrowStateError(ejs, "Command still active");
    }
    return ejsCreateNumber(ejs, mprGetCmdExitStatus(cmd->mc));
}


/**
    function stop(signal: Number = 2): Boolean
 */
static EjsObj *cmd_stop(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    int     signal;

    signal = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : SIGINT;

    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    mprFinalizeCmd(cmd->mc);
    if (!mprIsCmdRunning(cmd->mc)) {
        return ESV(true);
    }
    if (mprStopCmd(cmd->mc, signal) < 0) {
        return ESV(false);
    }
    return ESV(true);
}


/**
    function get timeout(): Number
 */
static EjsNumber *cmd_timeout(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) cmd->timeout);
}


/**
    function set timeout(msec: Number): Void
 */
static EjsObj *cmd_set_timeout(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    cmd->timeout = ejsGetInt(ejs, argv[0]);
    return 0;
}


/**
    function wait(timeout: Number = -1): Boolean
 */
static EjsObj *cmd_wait(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    MprTicks    timeout;

    timeout = argc > 0 ? ejsGetInt(ejs, argv[0]) : cmd->timeout;
    if (cmd->mc == 0) {
        ejsThrowStateError(ejs, "No active command");
        return 0;
    }
    /* NOTE: mprWaitForCmd will auto-finalize */
    if (mprWaitForCmd(cmd->mc, timeout) < 0) {
        return ESV(false);
    }
    return ESV(true);
}


/**
    function write(...data): Number
 */
static EjsNumber *cmd_write(Ejs *ejs, EjsCmd *cmd, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *bp;
    EjsString       *sp;
    EjsObj          *vp;
    ssize           len, wrote;
    int             i;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    /*
        Unwrap nested arrays
     */
    args = (EjsArray*) argv[0];
    while (ejsIs(ejs, args, Array) && args->length == 1) {
        vp = ejsGetProperty(ejs, args, 0);
        if (!ejsIs(ejs, vp, Array)) {
            break;
        }
        args = (EjsArray*) vp;
    }
    wrote = 0;
    for (i = 0; i < args->length; i++) {
        if ((vp = ejsGetProperty(ejs, args, i)) == 0) {
            continue;
        }
        if (ejsIs(ejs, vp, ByteArray)) {
            bp = (EjsByteArray*) vp;
            len = bp->writePosition - bp->readPosition;
            wrote += mprWriteCmdBlock(cmd->mc, MPR_CMD_STDIN, (char*) &bp->value[bp->readPosition], len);
        } else {
            sp = (EjsString*) ejsToString(ejs, vp);
            wrote += mprWriteCmdBlock(cmd->mc, MPR_CMD_STDIN, sp->value, sp->length);
        }
    }
    return ejsCreateNumber(ejs, (MprNumber) wrote);
}


/*
    function exec(cmd: Object): Void
 */
static EjsObj *cmd_exec(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if ME_UNIX_LIKE
    cchar   **argVector, *path;

#if FUTURE
    for (i = 3; i < MPR_MAX_FILE; i++) {
        close(i);
    }
#endif
    if (argc == 0) {
        path = MPR->argv[0];
        if (!mprIsPathAbs(path)) {
            path = mprGetAppPath();
        }
        execv(path, (char**) MPR->argv);
    } else {
        mprMakeArgv(ejsToMulti(ejs, argv[0]), &argVector, 0);
        execv(argVector[0], (char**) argVector);
    }
#endif
    ejsThrowStateError(ejs, "Cannot exec %@", ejsToString(ejs, argv[0]));
    return 0;
}

/************************************ Factory *********************************/

static void manageEjsCmd(EjsCmd *cmd, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(cmd, flags);
        mprMark(cmd->emitter);
        mprMark(cmd->mc);
        mprMark(cmd->stdoutBuf);
        mprMark(cmd->stderrBuf);
        mprMark(cmd->command);
        mprMark(cmd->env);
        mprMark(cmd->options);
        mprMark(cmd->error);
        mprMark(cmd->argv);
        mprMark(cmd->ejs);

    } else {
        if (cmd->mc) {
            mprDestroyCmd(cmd->mc);
            cmd->mc = 0;
        }
    }
}


PUBLIC void ejsConfigureCmdType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Cmd"), sizeof(EjsCmd), manageEjsCmd,
            EJS_TYPE_POT | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    ejsBindConstructor(ejs, type, cmd_constructor);
    ejsBindMethod(ejs, type, ES_Cmd_kill, cmd_kill);
    ejsBindMethod(ejs, type, ES_Cmd_exec, cmd_exec);

    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_Cmd_close, cmd_close);
    ejsBindAccess(ejs, prototype, ES_Cmd_errorStream, cmd_errorStream, 0);
    ejsBindAccess(ejs, prototype, ES_Cmd_env, cmd_env, cmd_set_env);
    ejsBindMethod(ejs, prototype, ES_Cmd_finalize, cmd_finalize);
    ejsBindMethod(ejs, prototype, ES_Cmd_flush, cmd_flush);
    ejsBindMethod(ejs, prototype, ES_Cmd_on, cmd_on);
    ejsBindMethod(ejs, prototype, ES_Cmd_off, cmd_off);
    ejsBindAccess(ejs, prototype, ES_Cmd_pid, cmd_pid, 0);
    ejsBindMethod(ejs, prototype, ES_Cmd_read, cmd_read);
    ejsBindMethod(ejs, prototype, ES_Cmd_readString, cmd_readString);
    ejsBindMethod(ejs, prototype, ES_Cmd_start, cmd_start);
    ejsBindAccess(ejs, prototype, ES_Cmd_status, cmd_status, 0);
    ejsBindMethod(ejs, prototype, ES_Cmd_stop, cmd_stop);
    ejsBindAccess(ejs, prototype, ES_Cmd_timeout, cmd_timeout, cmd_set_timeout);

    ejsBindMethod(ejs, prototype, ES_Cmd_wait, cmd_wait);
    ejsBindMethod(ejs, prototype, ES_Cmd_write, cmd_write);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsConfig.c"
 */
/************************************************************************/

/*
    ejsConfig.c -- Config class
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Methods **********************************/

PUBLIC void ejsCreateConfigType(Ejs *ejs)
{
    /*
        The Config object may be used by conditional compilation, so the type must exist without loading ejs.mod
        The compiler will call ejsDefineConfigProperties if required.
     */
    ejsCreateCoreType(ejs, N("ejs", "Config"), sizeof(EjsPot), S_Config, ES_Config_NUM_CLASS_PROP, 
        ejsManagePot, EJS_TYPE_POT);
}


PUBLIC void ejsDefineConfigProperties(Ejs *ejs)
{
    EjsType     *type;
    int         att;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Config"))) == 0) {
        return;
    }
    /* Not mutable once initialized - Should have a Config instance instead */
    type->mutable = 0;

    /*
        Must use -1 for slotNumber as this function is called by the compiler when compiling ejs.mod. 
        There will still be a -Config- property in slot[0]
     */
    att = EJS_PROP_STATIC | EJS_PROP_ENUMERABLE;
    ejsDefineProperty(ejs, type, -1, N("public", "Debug"), 0, att, ME_DEBUG ? ESV(true): ESV(false));

#if WINDOWS
{
    /* 
        Get the real system architecture, not whether this app is 32 or 64 bit.
        On native 64 bit systems, PA is amd64 for 64 bit apps and is PAW6432 is amd64 for 32 bit apps 
     */
    cchar   *cpu;
    if (smatch(getenv("PROCESSOR_ARCHITECTURE"), "AMD64") || getenv("PROCESSOR_ARCHITEW6432")) {
        cpu = "x64";
    } else {
        cpu = "x86";
    }
    ejsDefineProperty(ejs, type, -1, N("public", "CPU"), 0, att, ejsCreateStringFromAsc(ejs, cpu));
}
#else
    ejsDefineProperty(ejs, type, -1, N("public", "CPU"), 0, att, ejsCreateStringFromAsc(ejs, ME_CPU));
#endif
    ejsDefineProperty(ejs, type, -1, N("public", "OS"), 0, att, ejsCreateStringFromAsc(ejs, ME_OS));
    ejsDefineProperty(ejs, type, -1, N("public", "Product"), 0, att, 
        ejsCreateStringFromAsc(ejs, ME_NAME));
    ejsDefineProperty(ejs, type, -1, N("public", "Title"), 0, att, ejsCreateStringFromAsc(ejs, ME_TITLE));
    ejsDefineProperty(ejs, type, -1, N("public", "Version"), 0, att, ejsCreateStringFromAsc(ejs, ME_VERSION));

    ejsDefineProperty(ejs, type, -1, N("public", "Legacy"), 0, att, ejsCreateBoolean(ejs, 0));
    ejsDefineProperty(ejs, type, -1, N("public", "SSL"), 0, att, ejsCreateBoolean(ejs, ME_COM_SSL));
    ejsDefineProperty(ejs, type, -1, N("public", "SQLITE"), 0, att, ejsCreateBoolean(ejs, ME_COM_SQLITE));
#if defined(ME_EJS_DB)
    ejsDefineProperty(ejs, type, -1, N("public", "DB"), 0, att, ejsCreateBoolean(ejs, ME_EJS_DB));
    ejsDefineProperty(ejs, type, -1, N("public", "MAPPER"), 0, att, ejsCreateBoolean(ejs, ME_EJS_MAPPER));
    ejsDefineProperty(ejs, type, -1, N("public", "WEB"), 0, att, ejsCreateBoolean(ejs, ME_EJS_WEB));
    ejsDefineProperty(ejs, type, -1, N("public", "MAIL"), 0, att, ejsCreateBoolean(ejs, ME_EJS_MAIL));
    ejsDefineProperty(ejs, type, -1, N("public", "TEMPLATE"), 0, att, ejsCreateBoolean(ejs, ME_EJS_TEMPLATE));
    ejsDefineProperty(ejs, type, -1, N("public", "TAR"), 0, att, ejsCreateBoolean(ejs, ME_EJS_TAR));
#endif

    if (mprSamePath(mprGetAppDir(), ME_VAPP_PREFIX "/bin")) {
        ejsDefineProperty(ejs, type, -1, N("public", "Bin"), 0, att, ejsCreatePathFromAsc(ejs, ME_VAPP_PREFIX "/bin"));
        ejsDefineProperty(ejs, type, -1, N("public", "Inc"), 0, att, ejsCreatePathFromAsc(ejs, ME_VAPP_PREFIX "/inc"));
    } else {
        ejsDefineProperty(ejs, type, -1, N("public", "Bin"), 0, att, ejsCreatePathFromAsc(ejs, mprGetAppDir()));
        ejsDefineProperty(ejs, type, -1, N("public", "Inc"), 0, att, 
            ejsCreatePathFromAsc(ejs, mprNormalizePath(mprJoinPath(mprGetAppDir(), "../inc"))));
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsDate.c"
 */
/************************************************************************/

/**
    ejsDate.c - Date type class

    Date/time is store internally as milliseconds since 1970/01/01 GMT

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/***************************** Forward Declarations ***************************/
/*
    TODO - move to ejsNumber.h. But would have to rename fixed() to ejsFixed()
 */
#define fixed(n) ((int64) (floor(n)))

#if ME_WIN_LIKE
#pragma warning (disable:4244)
#endif

//  TODO this is a generic need. Make an API

#define getNumber(ejs, a) ejsGetNumber(ejs, ejsToNumber(ejs, a))
#define getInt(ejs, a) ((int) ejsGetNumber(ejs, ejsToNumber(ejs, a)))

/******************************************************************************/
/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */

static EjsAny *castDate(Ejs *ejs, EjsDate *dp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ESV(true);

    case S_Number:
        return ejsCreateNumber(ejs, (MprNumber) dp->value);

    case S_String:
        /*
            Format:  Tue Jul 15 2014 10:53:23 GMT-0700 (PDT)
         */
        return ejsCreateStringFromAsc(ejs, mprFormatLocalTime("%a %b %d %Y %T GMT%z (%Z)", dp->value));

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


static EjsDate *cloneDate(Ejs *ejs, EjsDate *dp, int deep)
{
    return ejsCreateDate(ejs, dp->value);
}


/*
    TODO - this is the same as number. Should share code
 */
static EjsAny *coerceDateOperands(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        if (ejsIs(ejs, rhs, Void)) {
            return ESV(nan);
        } else if (ejsIs(ejs, rhs, Null)) {
            rhs = ESV(zero);
        } else if (ejsIs(ejs, rhs, Boolean) || ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        } else {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsDate*) lhs)->value ? ESV(true) : ESV(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsDate*) lhs)->value ? ESV(false): ESV(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return ESV(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
    return 0;
}


static EjsAny *invokeDateOperator(Ejs *ejs, EjsDate *lhs, int opcode, EjsDate *rhs)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, Date) || !ejsIs(ejs, rhs, Date)) {
            if ((result = coerceDateOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }

    switch (opcode) {
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return ejsCreateBoolean(ejs, lhs->value == rhs->value);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return ejsCreateBoolean(ejs, !(lhs->value == rhs->value));

    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs, lhs->value < rhs->value);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs, lhs->value <= rhs->value);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, lhs->value > rhs->value);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, lhs->value >= rhs->value);

    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_NEG:
        return ejsCreateNumber(ejs, - (MprNumber) lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return ejsCreateBoolean(ejs, (int) !fixed(lhs->value));

    case EJS_OP_NOT:
        return ejsCreateNumber(ejs, (MprNumber) (~fixed(lhs->value)));

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsCreateDate(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) & fixed(rhs->value)));

    case EJS_OP_DIV:
        if (rhs->value == 0) {
            ejsThrowArithmeticError(ejs, "Divisor is zero");
            return 0;
        }
        return ejsCreateDate(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return ejsCreateDate(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) | fixed(rhs->value)));

    case EJS_OP_REM:
        if (rhs->value == 0) {
            ejsThrowArithmeticError(ejs, "Divisor is zero");
            return 0;
        }
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) % fixed(rhs->value)));

    case EJS_OP_SHL:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) << fixed(rhs->value)));

    case EJS_OP_SHR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_SUB:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) - fixed(rhs->value)));

    case EJS_OP_USHR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_XOR:
        return ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) ^ fixed(rhs->value)));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    /* Should never get here */
}


/*********************************** Methods **********************************/
/*
    Date constructor
        Date()
        Date(milliseconds)
        Date(dateString)
        Date(year, month, date, hour, minute, second, msec)
        @param milliseconds Integer representing milliseconds since 1 January 1970 00:00:00 UTC.
        @param dateString String date value in a format recognized by parse().
        @param year Integer value for the year. Should be a Four digit year (e.g. 1998).
        @param month Integer month value (0-11)
        @param date Integer date of the month (1-31)
        @param hour Integer hour value (0-23)
        @param minute Integer minute value (0-59)
        @param second Integer second value (0-59)
        @param msec Integer millisecond value (0-999)
*/
static EjsDate *date_Date(Ejs *ejs, EjsDate *date, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *vp;
    struct tm   tm;
    int         year;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];

    if (args->length == 0) {
        /* Now */
        date->value = mprGetTime();

    } else if (args->length == 1) {
        vp = ejsGetProperty(ejs, args, 0);
        if (ejsIs(ejs, vp, Number)) {
            /* Milliseconds */
            date->value = ejsGetNumber(ejs, vp);

        } else if (ejsIs(ejs, vp, String)) {
            if (mprParseTime(&date->value, ejsToMulti(ejs, vp), MPR_LOCAL_TIMEZONE, NULL) < 0) {
                ejsThrowArgError(ejs, "Cannot parse date string: %@", ejsToString(ejs, vp));
                return 0;
            }
        } else if (ejsIs(ejs, vp, Date)) {
            date->value = ((EjsDate*) vp)->value;

        } else {
            ejsThrowArgError(ejs, "Cannot construct date from this argument");
            return 0;
        }

    } else {
        /* Date(year, month, date, hour, minute, second, msec) or any portion thereof */
        memset(&tm, 0, sizeof(tm));
        tm.tm_isdst = -1;
        vp = ejsGetProperty(ejs, args, 0);
        year = getInt(ejs, vp);
        if (0 <= year && year < 100) {
            year += 1900;
        }
        tm.tm_year = year - 1900;
        if (args->length > 1) {
            vp = ejsGetProperty(ejs, args, 1);
            tm.tm_mon = getInt(ejs, vp);
        }
        if (args->length > 2) {
            vp = ejsGetProperty(ejs, args, 2);
            tm.tm_mday = getInt(ejs, vp);
        } else {
            tm.tm_mday = 1;
        }
        if (args->length > 3) {
            vp = ejsGetProperty(ejs, args, 3);
            tm.tm_hour = getInt(ejs, vp);
        }
        if (args->length > 4) {
            vp = ejsGetProperty(ejs, args, 4);
            tm.tm_min = getInt(ejs, vp);
        }
        if (args->length > 5) {
            vp = ejsGetProperty(ejs, args, 5);
            tm.tm_sec = getInt(ejs, vp);
        }
        date->value = mprMakeTime(&tm);
        if (date->value == -1) {
            ejsThrowArgError(ejs, "Cannot construct date from this argument");
        } else if (args->length > 6) {
            vp = ejsGetProperty(ejs, args, 6);
            date->value += getNumber(ejs, vp);
        }        
    }
    return date;
}


/*
    function get day(): Number
    Range: 0-6, where 0 is Sunday
 */
static EjsNumber *date_day(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_wday);
}


/*
    function set day(day: Number): Void
    Range: 0-6, where 0 is Sunday
*/
static EjsObj *date_set_day(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeLocalTime(&tm, dp->value);
    dayDiff = day - tm.tm_wday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get dayOfYear(): Number
    Return day of year (0 - 365)
 */
static EjsNumber *date_dayOfYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_yday);
}


/*
    function set dayOfYear(day: Number): Void
    Set the day of year (0 - 365)
 */
static EjsObj *date_set_dayOfYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeLocalTime(&tm, dp->value);
    dayDiff = day - tm.tm_yday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get date(): Number
    Return day of month (1-31)
 */
static EjsNumber *date_date(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mday);
}


/*
    function set date(date: Number): Void
    Range day of month (1-31)
 */
static EjsObj *date_set_date(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeLocalTime(&tm, dp->value);
    dayDiff = day - tm.tm_mday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get elapsed(): Number
    Get the elapsed time in milliseconds since the Date object was constructed
 */
static EjsNumber *date_elapsed(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetElapsedTime(dp->value));
}


/*
    function format(layout: String): String
 */
static EjsString *date_format(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprFormatLocalTime(ejsToMulti(ejs, argv[0]), dp->value));
}


/*
    function formatUTC(layout: String): String
 */
static EjsString *date_formatUTC(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprFormatUniversalTime(ejsToMulti(ejs, argv[0]), dp->value));
}


/*
    function future(msec: Number): Date
 */
static EjsDate *date_future(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    MprTime     inc;

    inc = ejsGetNumber(ejs, argv[0]);
    return ejsCreateDate(ejs, dp->value + inc);
}


/**
    Return the number of minutes between the local computer time and Coordinated Universal Time.
    @return Integer containing the number of minutes between UTC and local time. The offset is positive if
    local time is behind UTC and negative if it is ahead. E.g. American PST is UTC-8 so 420/480 will be retured
    depending on if daylight savings is in effect.

    function getTimezoneOffset(): Number
*/
static EjsNumber *date_getTimezoneOffset(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, -mprGetTimeZoneOffset(dp->value) / (MPR_TICKS_PER_SEC * 60));
}


/*
    function getUTCDate(): Number
    Range: 0-31
 */
static EjsNumber *date_getUTCDate(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mday);
}


/*
    function getUTCDay(): Number
    Range: 0-6
 */
static EjsNumber *date_getUTCDay(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_wday);
}


/*
    function getUTCFullYear(): Number
    Range: 4 digits
 */
static EjsNumber *date_getUTCFullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function getUTCHours(): Number
    Range: 0-23
 */
static EjsNumber *date_getUTCHours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_hour);
}


/*
    function getUTCMilliseconds(): Number
    Range: 0-999
 */
static EjsNumber *date_getUTCMilliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ((int64) dp->value) % MPR_TICKS_PER_SEC);
}


/*
    function getUTCMinutes(): Number
    Range: 0-31
 */
static EjsNumber *date_getUTCMinutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_min);
}


/*
    function getUTCMonth(): Number
    Range: 1-12
 */
static EjsNumber *date_getUTCMonth(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mon);
}


/*
    function getUTCSeconds(): Number
    Range: 0-59
 */
static EjsNumber *date_getUTCSeconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_sec);
}


/*
    function get hours(): Number
    Return hour of day (0-23)
 */
static EjsNumber *date_hours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_hour);
}


/*
    function set hours(hour: Number): void
    Update the hour of the day using a 0-23 hour
 */
static EjsObj *date_set_hours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_hour = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function get milliseconds(): Number
 */
static EjsNumber *date_milliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, ((int64) dp->value) % MPR_TICKS_PER_SEC);
}


/*
    function set milliseconds(ms: Number): void
 */
static EjsObj *date_set_milliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function get minutes(): Number
 */
static EjsNumber *date_minutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_min);
}


/*
    function set minutes(min: Number): void
 */
static EjsObj *date_set_minutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_min = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function get month(): Number
    Get the month (0-11)
 */
static EjsNumber *date_month(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_mon);
}


/*
    function set month(month: Number): void
 */
static EjsObj *date_set_month(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_mon = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function nextDay(inc: Number = 1): Date
 */
static EjsDate *date_nextDay(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    MprTime     inc;

    if (argc == 1) {
        inc = ejsGetNumber(ejs, argv[0]);
    } else {
        inc = 1;
    }
    return ejsCreateDate(ejs, dp->value + (inc * 86400 * 1000));
}


/*
    static function now(): Number
 */
static EjsNumber *date_now(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetTime());
}


/*
    static function parse(arg: String): Number
 */
static EjsNumber *date_parse(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    MprTime     when;

    if (mprParseTime(&when, ejsToMulti(ejs, argv[0]), MPR_LOCAL_TIMEZONE, NULL) < 0) {
        ejsThrowArgError(ejs, "Cannot parse date string: %@", ejsToString(ejs, argv[0]));
        return 0;
    }
    return ejsCreateNumber(ejs, (MprNumber) when);
}


/*
    static function parseDate(arg: String, defaultDate: Date = null): Date
 */
static EjsDate *date_parseDate(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    struct tm   tm, *defaults;
    MprTime     when;

    if (argc >= 2) {
        mprDecodeLocalTime(&tm, ((EjsDate*) argv[1])->value);
        defaults = &tm;
    } else {
        defaults = 0;
    }
    if (mprParseTime(&when, ejsToMulti(ejs, argv[0]), MPR_LOCAL_TIMEZONE, defaults) < 0) {
        ejsThrowArgError(ejs, "Cannot parse date string: %@", ejsToString(ejs, argv[0]));
        return 0;
    }
    return ejsCreateDate(ejs, when);
}


/*
    static function parseUTCDate(arg: String, defaultDate: Date = null): Date
 */
static EjsDate *date_parseUTCDate(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    struct tm   tm, *defaults;
    MprTime     when;

    if (argc >= 2) {
        mprDecodeUniversalTime(&tm, ((EjsDate*) argv[1])->value);
        defaults = &tm;
    } else {
        defaults = 0;
    }
    if (mprParseTime(&when, ejsToMulti(ejs, argv[0]), MPR_UTC_TIMEZONE, defaults) < 0) {
        ejsThrowArgError(ejs, "Cannot parse date string: %@", ejsToString(ejs, argv[0]));
        return 0;
    }
    return ejsCreateDate(ejs, when);
}


/*
    function get seconds(): Number
    Get seconds (0-59)
 */
static EjsNumber *date_seconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_sec);
}


/*
    function set seconds(sec: Number): void
 */
static EjsObj *date_set_seconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_sec = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeTime(&tm);
    return 0;
}


/*
    function setUTCDate(date: Number): Void
    Range month (1-31)
 */
static EjsObj *date_setUTCDate(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprTime     dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    mprDecodeUniversalTime(&tm, dp->value);
    dayDiff = day - tm.tm_mday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
   function setUTCFullYear(y: Number): void
 */
static EjsObj *date_setUTCFullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_year = (int) ejsGetNumber(ejs, argv[0]) - 1900;
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCHours(h: Number): void
 */
static EjsObj *date_setUTCHours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_hour = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCMilliseconds(ms: Number): void
 */
static EjsObj *date_setUTCMilliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    /* Same as set_milliseconds */
    dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function setUTCMinutes(min: Number): void
 */
static EjsObj *date_setUTCMinutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_min = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCMonth(mon: Number): void
 */
static EjsObj *date_setUTCMonth(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_mon = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    return 0;
}


/*
    function setUTCSeconds(sec: Number, msec: Number = null): void
 */
static EjsObj *date_setUTCSeconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(&tm, dp->value);
    tm.tm_sec = (int) ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(&tm);
    if (argc >= 2) {
        dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[1]);
    }
    return 0;
}


/*
    static function ticks(): Number
 */
static EjsNumber *date_ticks(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetHiResTicks());
}


/*
    Get the number of millseconds since Jan 1, 1970 UTC.
    function get time(): Number
 */
static EjsNumber *date_time(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, dp->value);
}


/*
    function set time(value: Number): Number
 */
static EjsNumber *date_set_time(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    dp->value = ejsGetNumber(ejs, argv[0]);
    return 0;
}


/**
    Return an ISO formatted date string.
    Sample format: "2006-12-15T23:45:09.33-08:00"
    function toISOString(): String
*/
static EjsString *date_toISOString(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    char    *base, *str;

    base = mprFormatUniversalTime("%Y-%m-%dT%H:%M:%S", dp->value);
    str = sfmt("%s.%03dZ", base, dp->value % MPR_TICKS_PER_SEC);
    return ejsCreateStringFromAsc(ejs, str);
}


/*
    Serialize using JSON encoding. This uses the ISO date format

    function toJSON(): String
 */
static EjsString *date_toJSON(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    char    *base, *str;

    base = mprFormatUniversalTime("%Y-%m-%dT%H:%M:%S", dp->value);
    str = sfmt("\"%sZ\"", base);
    return ejsCreateStringFromAsc(ejs, str);
}


/*
    override native function toString(): String
 */
static EjsString *date_toString(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return castDate(ejs, dp, ESV(String));
}


/*
    Construct a date from UTC values
    function UTC(year, month, date, hour = 0, minute = 0, second = 0, msec = 0): Number
 */
static EjsNumber *date_UTC(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    EjsDate     *dp;
    struct tm   tm;
    int         year;

    memset(&tm, 0, sizeof(tm));
    year = getInt(ejs, argv[0]);
    if (year < 100) {
        year += 1900;
    }
    tm.tm_year = year - 1900;
    if (argc > 1) {
        tm.tm_mon = getInt(ejs, argv[1]);
    }
    if (argc > 2) {
        tm.tm_mday = getInt(ejs, argv[2]);
    }
    if (argc > 3) {
        tm.tm_hour = getInt(ejs, argv[3]);
    }
    if (argc > 4) {
        tm.tm_min = getInt(ejs, argv[4]);
    }
    if (argc > 5) {
        tm.tm_sec = getInt(ejs, argv[5]);
    }
    dp = ejsCreateDate(ejs, mprMakeUniversalTime(&tm));
    if (argc > 6) {
        dp->value += getNumber(ejs, argv[6]);
    }
    return ejsCreateNumber(ejs, dp->value);
}


/*
    function get year(): Number
 */
static EjsNumber *date_year(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    return ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function set year(year: Number): void
 */
static EjsObj *date_set_year(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(&tm, dp->value);
    tm.tm_year = (int) ejsGetNumber(ejs, argv[0]) - 1900;
    dp->value = mprMakeTime(&tm);
    return 0;
}

/*********************************** Factory **********************************/
/*
    Create an initialized date object. Set to the current time if value is zero.
 */

PUBLIC EjsDate *ejsCreateDate(Ejs *ejs, MprTime value)
{
    EjsDate *vp;

    vp = ejsCreateObj(ejs, ESV(Date), 0);
    if (vp != 0) {
        vp->value = value;
    }
    return vp;
}


PUBLIC void ejsConfigureDateType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Date"), sizeof(EjsDate), 0, 
            EJS_TYPE_OBJ | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    type->helpers.cast = (EjsCastHelper) castDate;
    type->helpers.clone = (EjsCloneHelper) cloneDate;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeDateOperator;

    ejsBindMethod(ejs, type, ES_Date_now, date_now);
    ejsBindAccess(ejs, type, ES_Date_ticks, date_ticks, NULL);
    ejsBindMethod(ejs, type, ES_Date_parseDate, date_parseDate);
    ejsBindMethod(ejs, type, ES_Date_parseUTCDate, date_parseUTCDate);
    ejsBindMethod(ejs, type, ES_Date_parse, date_parse);
    ejsBindMethod(ejs, type, ES_Date_UTC, date_UTC);

    prototype = type->prototype;
    ejsBindConstructor(ejs, type, date_Date);
    ejsBindAccess(ejs, prototype, ES_Date_day, date_day, date_set_day);
    ejsBindAccess(ejs, prototype, ES_Date_dayOfYear, date_dayOfYear, date_set_dayOfYear);
    ejsBindAccess(ejs, prototype, ES_Date_date, date_date, date_set_date);
    ejsBindMethod(ejs, prototype, ES_Date_elapsed, date_elapsed);
    ejsBindMethod(ejs, prototype, ES_Date_format, date_format);
    ejsBindMethod(ejs, prototype, ES_Date_formatUTC, date_formatUTC);
    ejsBindMethod(ejs, prototype, ES_Date_future, date_future);
    ejsBindMethod(ejs, prototype, ES_Date_getTimezoneOffset, date_getTimezoneOffset); 
    ejsBindMethod(ejs, prototype, ES_Date_getUTCDate, date_getUTCDate);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCDay, date_getUTCDay);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCFullYear, date_getUTCFullYear);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCHours, date_getUTCHours);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCMilliseconds, date_getUTCMilliseconds);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCMinutes, date_getUTCMinutes);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCMonth, date_getUTCMonth);
    ejsBindMethod(ejs, prototype, ES_Date_getUTCSeconds, date_getUTCSeconds);
    ejsBindAccess(ejs, prototype, ES_Date_hours, date_hours, date_set_hours);
    ejsBindAccess(ejs, prototype, ES_Date_milliseconds, date_milliseconds, date_set_milliseconds);
    ejsBindAccess(ejs, prototype, ES_Date_minutes, date_minutes, date_set_minutes);
    ejsBindAccess(ejs, prototype, ES_Date_month, date_month, date_set_month);
    ejsBindMethod(ejs, prototype, ES_Date_nextDay, date_nextDay);
    ejsBindAccess(ejs, prototype, ES_Date_seconds, date_seconds, date_set_seconds);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCDate, date_setUTCDate);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCFullYear, date_setUTCFullYear);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCHours, date_setUTCHours);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCMilliseconds, date_setUTCMilliseconds);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCMinutes, date_setUTCMinutes);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCMonth, date_setUTCMonth);
    ejsBindMethod(ejs, prototype, ES_Date_setUTCSeconds, date_setUTCSeconds);
    ejsBindAccess(ejs, prototype, ES_Date_time, date_time, date_set_time);
    ejsBindMethod(ejs, prototype, ES_Date_toJSON, date_toJSON);
    ejsBindMethod(ejs, prototype, ES_Date_toISOString, date_toISOString);
    ejsBindMethod(ejs, prototype, ES_Date_toString, date_toString);
    ejsBindAccess(ejs, prototype, ES_Date_year, date_year, date_set_year);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsDebug.c"
 */
/************************************************************************/

/*
    ejsDebug.c - Debug.Debug class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */
/********************************** Includes **********************************/



/************************************ Methods *********************************/
/*
    Trap to the debugger

    static function breakpoint(): Void
 */
static EjsObj *debug_breakpoint(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if ME_DEBUG && DEBUG_IDE
    #if ME_WIN_LIKE && !ME_64
        __asm { int 3 };
    #elif (MACOSX || LINUX) && (ME_CPU_ARCH == MPR_CPU_IX86 || ME_CPU_ARCH == MPR_CPU_IX64)
        asm("int $03");
        /*  __asm__ __volatile__ ("int $03"); */
    #endif
#else
    mprBreakpoint();
#endif
    return 0;
}


/*
    function get mode(): Boolean
 */
static EjsObj *debug_mode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return mprGetDebugMode() ? ESV(true) : ESV(false);
}


/*
    function set mode(on: Boolean): Void
 */
static EjsObj *debug_set_mode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    mprSetDebugMode(argv[0] == ESV(true));
    return 0;
}

/************************************ Factory *********************************/

PUBLIC void ejsConfigureDebugType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Debug"), sizeof(EjsPot), ejsManagePot, EJS_TYPE_POT)) != 0) {
        ejsBindMethod(ejs, type, ES_Debug_breakpoint, debug_breakpoint);
        ejsBindAccess(ejs, type, ES_Debug_mode, debug_mode, debug_set_mode);
    }
    ejsBindFunction(ejs, ejs->global, ES_breakpoint, debug_breakpoint);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsError.c"
 */
/************************************************************************/

/**
    ejsError.c - Error Exception class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************* Code ***********************************/
/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */
static EjsAny *castError(Ejs *ejs, EjsError *error, EjsType *type)
{
    EjsString   *stack, *msg;
    EjsString   *us;
    char        *buf;

    switch (type->sid) {
    case S_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case S_String:
        stack = (EjsString*) ejsRunFunctionBySlot(ejs, error, ES_Error_formatStack, 0, NULL);
        us = ejsIs(ejs, stack, String) ? stack : ESV(empty);
        msg = ejsGetProperty(ejs, error, ES_Error_message);
        if ((buf = sfmt("%@ Exception: %@\nStack:\n%@\n", TYPE(error)->qname.name, msg, us)) == NULL) {
            ejsThrowMemoryError(ejs);
        }
        return ejsCreateStringFromAsc(ejs, buf);

    default:
        ejsThrowTypeError(ejs, "Unknown type");
    }
    return 0;
}


/*********************************** Methods **********************************/
/*
    Error Constructor and constructor for all the core error classes.

    public function Error(message: String = null)
 */
static EjsError *errorConstructor(Ejs *ejs, EjsError *error, int argc, EjsObj **argv)
{
    if (argc > 0) {
        ejsSetProperty(ejs, error, ES_Error_message, ejsToString(ejs, argv[0]));
    }
    if (ESV(Date)) {
        ejsSetProperty(ejs, error, ES_Error_timestamp, ejsCreateDate(ejs, mprGetTime()));
        ejsSetProperty(ejs, error, ES_Error_stack, ejsCaptureStack(ejs, 0));
    }
    return error;
}


/*
    static function capture(uplevels: Number): Array
 */
static EjsArray *error_capture(Ejs *ejs, EjsError *error, int argc,  EjsObj **argv)
{
    int     uplevels;
    
    uplevels = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    return ejsCaptureStack(ejs, uplevels);
}

/************************************ Factory *********************************/

PUBLIC EjsError *ejsCreateError(Ejs *ejs, EjsType *type, EjsObj *msg) 
{
    EjsError    *error;

    error = ejsCreatePot(ejs, type, 0);
    if (error) {
        ejsSetProperty(ejs, error, ES_Error_message, msg);
        ejsSetProperty(ejs, error, ES_Error_timestamp, ejsCreateDate(ejs, mprGetTime()));
        ejsSetProperty(ejs, error, ES_Error_stack, ejsCaptureStack(ejs, 0));
    }
    return error;
}


static EjsType *defineType(Ejs *ejs, cchar *name, int id)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", name), sizeof(EjsError), id, ES_Error_NUM_CLASS_PROP, ejsManagePot, 
        EJS_TYPE_POT | EJS_TYPE_DYNAMIC_INSTANCES | EJS_TYPE_HAS_INSTANCE_VARS | EJS_TYPE_MUTABLE_INSTANCES);
    type->constructor.block.nobind = 1;
    type->helpers.cast = (EjsCastHelper) castError;
    return type;
}


PUBLIC void ejsCreateErrorType(Ejs *ejs)
{
    defineType(ejs, "Error", S_Error);
    defineType(ejs, "ArgError", ES_ArgError);
    defineType(ejs, "ArithmeticError", ES_ArithmeticError);
    defineType(ejs, "AssertError", ES_AssertError);
    defineType(ejs, "InstructionError", ES_InstructionError);
    defineType(ejs, "IOError", ES_IOError);
    defineType(ejs, "InternalError", ES_InternalError);
    defineType(ejs, "MemoryError", ES_MemoryError);
    defineType(ejs, "OutOfBoundsError", ES_OutOfBoundsError);
    defineType(ejs, "ReferenceError", ES_ReferenceError);
    defineType(ejs, "ResourceError", ES_ResourceError);
    defineType(ejs, "SecurityError", ES_SecurityError);
    defineType(ejs, "StateError", ES_StateError);
    defineType(ejs, "SyntaxError", ES_SyntaxError);
    defineType(ejs, "TypeError", ES_TypeError);
    defineType(ejs, "URIError", ES_URIError);
}


static void configureType(Ejs *ejs, cchar *name)
{
    EjsType     *type;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", name))) == 0) {
        return;
    }
    ejsBindConstructor(ejs, type, errorConstructor);
}


PUBLIC void ejsConfigureErrorType(Ejs *ejs)
{
    //  OPT simplify
    configureType(ejs, "Error");
    configureType(ejs, "ArgError");
    configureType(ejs, "ArithmeticError");
    configureType(ejs, "AssertError");
    configureType(ejs, "InstructionError");
    configureType(ejs, "IOError");
    configureType(ejs, "InternalError");
    configureType(ejs, "MemoryError");
    configureType(ejs, "OutOfBoundsError");
    configureType(ejs, "ReferenceError");
    configureType(ejs, "ResourceError");
    configureType(ejs, "SecurityError");
    configureType(ejs, "StateError");
    configureType(ejs, "SyntaxError");
    configureType(ejs, "TypeError");
    configureType(ejs, "URIError");

    ejsBindMethod(ejs, ESV(Error), ES_Error_capture, error_capture);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsFile.c"
 */
/************************************************************************/

/**
    ejsFile.c - File class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************** Defines ***********************************/

#if ME_WIN_LIKE
#define isDelim(fp, c)  (c == '/' || c == fp->delimiter)
#else
#define isDelim(fp, c)  (c == fp->delimiter)
#endif

#define EJS_FILE_OPEN           0x1     /* File is opened */
#define EJS_FILE_READ           0x2     /* File is opened for reading */
#define EJS_FILE_WRITE          0x4     /* File is opened for writing */

/**************************** Forward Declarations ****************************/

static EjsObj *closeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv);
static int mapMode(cchar *mode);
static EjsObj *openFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv);
static ssize readData(Ejs *ejs, EjsFile *fp, EjsByteArray *ap, ssize offset, ssize count);

#if ME_CC_MMU && FUTURE
static void *mapFile(EjsFile *fp, uint size, int mode);
static void unmapFile(EjsFile *fp);
#endif

/************************************ Helpers *********************************/
/*  
    Index into a file and extract a byte. This is random access reading.
 */
static EjsNumber *getFileProperty(Ejs *ejs, EjsFile *fp, int slotNum)
{
    MprOff  offset;
    int     c;

    if (!(fp->mode & EJS_FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
#if KEEP
    if (fp->mode & EJS_FILE_READ) {
        if (slotNum >= fp->info.size) {
            ejsThrowOutOfBoundsError(ejs, "Bad file index");
            return 0;
        }
    }
    if (slotNum < 0) {
        ejsThrowOutOfBoundsError(ejs, "Bad file index");
        return 0;
    }
#endif

#if ME_CC_MMU && FUTURE
    //  must check against mapped size here.
    c = fp->mapped[slotNum];
#else
    offset = mprSeekFile(fp->file, SEEK_CUR, 0);
    if (offset != slotNum) {
        if (mprSeekFile(fp->file, SEEK_SET, slotNum) != slotNum) {
            ejsThrowIOError(ejs, "Cannot seek to file offset");
            return 0;
        }
    }
    c = mprPeekFileChar(fp->file);
    if (c < 0) {
        ejsThrowIOError(ejs, "Cannot read file");
        return 0;
    }
#endif
    return ejsCreateNumber(ejs, c);
}



static int lookupFileProperty(Ejs *ejs, EjsFile *fp, EjsName qname)
{
    int     index;

    if (qname.name == 0 || !isdigit((uchar) qname.name->value[0])) {
        return EJS_ERR;
    }
    if (!(fp->mode & EJS_FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < mprGetFileSize(fp->file)) {
        return index;
    }
    return EJS_ERR;
}


/*  
    Set a byte in the file at the offset designated by slotNum.
 */
static int setFileProperty(Ejs *ejs, EjsFile *fp, int slotNum, EjsObj *value)
{
    MprOff  offset;
    int     c;

    if (!(fp->mode & EJS_FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
    if (!(fp->mode & EJS_FILE_WRITE)) {
        ejsThrowIOError(ejs, "File is not opened for writing");
        return 0;
    }
    c = ejsIs(ejs, value, Number) ? ejsGetInt(ejs, value) : ejsGetInt(ejs, ejsToNumber(ejs, value));

    offset = mprSeekFile(fp->file, SEEK_CUR, 0);
    if (slotNum < 0) {
        //  could have an mprGetPosition(file) API
        slotNum = (int) offset;
    }

#if ME_CC_MMU && FUTURE
    fp->mapped[slotNum] = c;
#else
    if (offset != slotNum && mprSeekFile(fp->file, SEEK_SET, slotNum) != slotNum) {
        ejsThrowIOError(ejs, "Cannot seek to file offset");
        return 0;
    }
    if (mprPutFileChar(fp->file, c) < 0) {
        ejsThrowIOError(ejs, "Cannot write file");
        return 0;
    }
#endif
    return slotNum;
}


/************************************ Methods *********************************/

//  TODO - rename
static int ejsGetNumOption(Ejs *ejs, EjsObj *options, cchar *field, int defaultValue, bool optional)
{
    EjsObj      *vp;
    EjsNumber   *num;

    vp = ejsGetPropertyByName(ejs, options, EN(field));
    if (vp == 0) {
        if (optional) {
            return defaultValue;
        }
        ejsThrowArgError(ejs, "Required option \"%s\" is missing", field);
        return 0;
    }
    num = ejsToNumber(ejs, vp);
    if (!ejsIs(ejs, num, Number)) {
        ejsThrowArgError(ejs, "Bad option type for field \"%s\"", field);
        return 0;
    }
    return (int) num->value;
}


static cchar *getStrOption(Ejs *ejs, EjsObj *options, cchar *field, cchar *defaultValue, bool optional)
{
    EjsObj      *vp;
    EjsString   *str;

    vp = ejsGetPropertyByName(ejs, options, EN(field));
    if (vp == 0) {
        if (optional) {
            return sclone(defaultValue);
        }
        ejsThrowArgError(ejs, "Required option %s is missing", field);
        return 0;
    }
    str = ejsToString(ejs, vp);
    if (!ejsIs(ejs, str, String)) {
        ejsThrowArgError(ejs, "Bad option type for field \"%s\"", field);
        return 0;
    }
    return ejsToMulti(ejs, str);
}


/*  
    Constructor
    function File(path: Object, options: Object = null)
 */
static EjsFile *fileConstructor(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj      *pp, *options;
    cchar       *path;

    if (argc < 1 || argc > 2) {
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    }
    pp = argv[0];
    if (ejsIs(ejs, pp, Path)) {
        path = ((EjsPath*) pp)->value;
    } else if (ejsIs(ejs, pp, String)) {
        path = ejsToMulti(ejs, pp);
    } else {
        ejsThrowIOError(ejs, "Bad path");
        return 0;
    }
    fp->path = mprNormalizePath(path);
    if (argc == 2) {
        options = (argc >= 2) ? argv[1] : 0;
        openFile(ejs, fp, 1, &options);
    }
    return fp;
}


/*  
    function get canRead(): Boolean
 */
static EjsBoolean *canReadFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, fp->mode & EJS_FILE_OPEN && (fp->mode & EJS_FILE_READ));
}


/*  
    function get canRead(): Boolean
 */
static EjsBoolean *canWriteFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, fp->mode & EJS_FILE_OPEN && (fp->mode & EJS_FILE_WRITE));
}

/*  
    Close the file and free up all associated resources.
    function close(): void
 */
static EjsObj *closeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    if (fp->mode & EJS_FILE_OPEN && fp->mode & EJS_FILE_WRITE) {
        if (mprFlushFile(fp->file) < 0) {
            if (ejs) {
                ejsThrowIOError(ejs, "Cannot flush file data");
            } else {
                mprError("Cannot flush file data");
            }
            return 0;
        }
    }
    if (fp->file) {
        mprCloseFile(fp->file);
        fp->file = 0;
    }
#if ME_CC_MMU && FUTURE
    if (fp->mapped) {
        unmapFile(fp);
        fp->mapped = 0;
    }
#endif
    fp->mode = 0;
    fp->modeString = 0;
    return 0;
}


/*  
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsFile     *fp;

    fp = (EjsFile*) ip->target;
    if (!ejsIs(ejs, fp, File)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < fp->info.size) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return the default iterator for use with "for ... in". This returns byte offsets in the file.
    iterator native function get(): Iterator
 */
static EjsIterator *getFileIterator(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    mprGetPathInfo(fp->path, &fp->info);
    return ejsCreateIterator(ejs, fp, -1, nextKey, 0, NULL);
}


/*  
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsFile     *fp;

    fp = (EjsFile*) ip->target;
    if (!ejsIs(ejs, fp, File)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < fp->info.size) {
#if !ME_CC_MMU || 1
        if (mprSeekFile(fp->file, SEEK_CUR, 0) != ip->index) {
            if (mprSeekFile(fp->file, SEEK_SET, ip->index) != ip->index) {
                ejsThrowIOError(ejs, "Cannot seek to %d", ip->index);
                return 0;
            }
        }
        ip->index++;
        return (EjsObj*) ejsCreateNumber(ejs, mprGetFileChar(fp->file));
#else
        return (EjsObj*) ejsCreateNumber(ejs, fp->mapped[ip->index++]);
#endif
    }

#if ME_CC_MMU && FUTURE
    unmapFile(fp);
    fp->mapped = 0;
#endif

    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return an iterator to enumerate the bytes in the file. For use with "for each ..."
    iterator native function getValues(): Iterator
 */
static EjsObj *getFileValues(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    mprGetPathInfo(fp->path, &fp->info);

    return (EjsObj*) ejsCreateIterator(ejs, fp, -1, nextValue, 0, NULL);
}


/*  
    Get a path object for the file
    function get path(): Path
 */
static EjsObj *getFilePath(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathFromAsc(ejs, fp->path);
}


/*  
    Get the current I/O position in the file.
    function get position(): Number
 */
static EjsObj *getFilePosition(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not opened");
        return 0;
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) mprGetFilePosition(fp->file));
}


/*  
    Seek to a new location in the file and set the File marker to a new read/write position.
    function set position(value: Number): void
 */
static EjsObj *setFilePosition(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    MprOff      pos;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));
    pos = ejsGetInt(ejs, argv[0]);

    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not opened");
        return 0;
    }
    pos = ejsGetInt(ejs, argv[0]);
    if (mprSeekFile(fp->file, SEEK_SET, pos) != pos) {
        ejsThrowIOError(ejs, "Cannot seek to %Ld", pos);
    }
    return 0;
}


/*  
    function get isOpen(): Boolean
 */
static EjsObj *isFileOpen(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, fp->mode & EJS_FILE_OPEN);
}


/*  
    Constructor
    function open(options: Object = null): File
    NOTE: options can be an options hash or as mode string
 */
static EjsObj *openFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj  *options;
    cchar   *mode;
    int     perms, omode;

    if (argc < 0 || argc > 1) {
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    }
    options = argv[0];
    if (argc == 0 || !ejsIsDefined(ejs, options)) {
        omode = O_RDONLY | O_BINARY;
        perms = EJS_FILE_PERMS;
        fp->mode = EJS_FILE_READ;
        mode = "r";
    } else {
        if (ejsIs(ejs, options, String)) {
            mode = ejsToMulti(ejs, options);
            perms = EJS_FILE_PERMS;
        } else {
            perms = ejsGetNumOption(ejs, options, "permissions", EJS_FILE_PERMS, 1);
            mode = getStrOption(ejs, options, "mode", "r", 1);
            if (ejs->exception) {
                return 0;
            }
        }
        omode = mapMode(mode);
        if (!(omode & O_WRONLY)) {
            fp->mode |= EJS_FILE_READ;
        }
        if (omode & (O_WRONLY | O_RDWR)) {
            fp->mode |= EJS_FILE_WRITE;
        }
    }
    fp->modeString = sclone(mode);
    fp->perms = perms;

    if (fp->file) {
        mprCloseFile(fp->file);
    }
    fp->file = mprOpenFile(fp->path, omode, perms);
    if (fp->file == 0) {
        ejsThrowIOError(ejs, "Cannot open %s", fp->path);
        return 0;
    }
    if (options) {
        ejsSetPathAttributes(ejs, fp->path, options);
    }
#if ME_CC_MMU && FUTURE
    mprGetPathInfo(&fp->info);
    fp->mapped = mapFile(fp, fp->info.size, MPR_MAP_READ | MPR_MAP_WRITE);
#endif
    fp->mode |= EJS_FILE_OPEN;
    return (EjsObj*) fp;
}


static EjsObj *getFileOptions(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj      *options;

    options = (EjsObj*) ejsCreateEmptyPot(ejs);
    ejsSetPropertyByName(ejs, options, EN("mode"), ejsCreateStringFromAsc(ejs, fp->modeString));
    ejsSetPropertyByName(ejs, options, EN("permissions"), ejsCreateNumber(ejs, fp->perms));
    return options;
}

/*  
    Read data bytes from a file
    function readBytes(count: Number = -1): ByteArray
 */
static EjsObj *readFileBytes(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsByteArray    *result;
    MprPath         info;
    ssize           count, totalRead;

    if (argc == 0) {
        count = -1;
    } else if (argc != 1) {
        count = 0;
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    } else {
        assert(argc == 1 && ejsIs(ejs, argv[0], Number));
        count = ejsGetInt(ejs, argv[0]);
    }
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & EJS_FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = ME_MAX_BUFFER;
        }
        assert(count >= 0);
    }
    result = ejsCreateByteArray(ejs, count);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    totalRead = readData(ejs, fp, result, 0, count);
    if (totalRead < 0) {
        ejsThrowIOError(ejs, "Cannot read from file: %s", fp->path);
        return 0;
    } else if (totalRead == 0) {
        return ESV(null);
    }
    ejsSetByteArrayPositions(ejs, result, 0, totalRead);
    return (EjsObj*) result;
}


/*  
    Read data as a string
    function readString(count: Number = -1): String
 */
static EjsString *readFileString(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsString       *result;
    MprPath         info;
    ssize           totalRead;
    int             count;

    if (argc == 0) {
        count = -1;
    } else if (argc != 1) {
        count = 0;
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    } else {
        assert(argc == 1 && ejsIs(ejs, argv[0], Number));
        count = ejsGetInt(ejs, argv[0]);
    }
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & EJS_FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = ME_MAX_BUFFER;
        }
        assert(count >= 0);
    }
    if ((result = ejsCreateBareString(ejs, count)) == NULL) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    totalRead = mprReadFile(fp->file, result->value, count);
    if (totalRead != count) {
        ejsThrowIOError(ejs, "Cannot read from file: %s", fp->path);
        return 0;
    }
    return ejsInternString(result);
}


/*  
    Read data bytes from a file. If offset is < 0, then append to the write position.
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *readFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    MprPath         info;
    ssize           offset, count, totalRead;

    assert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]): 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]): -1;

    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & EJS_FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (offset >= buffer->size) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset == 0) {
        ejsSetByteArrayPositions(ejs, buffer, 0, 0);
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = ME_MAX_BUFFER;
        }
        assert(count >= 0);
    }
    totalRead = readData(ejs, fp, buffer, offset, count);
    if (totalRead < 0) {
        return 0;
    } else if (totalRead == 0) {
        return ESV(zero);
    }
    ejsSetByteArrayPositions(ejs, buffer, -1, offset + totalRead);
    return ejsCreateNumber(ejs, (MprNumber) totalRead);
}


/*  
    Get the size of the file associated with this File object.
    override function get size(): Number
 */
static EjsObj *getFileSize(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    if (mprGetPathInfo(fp->path, &info) < 0) {
        return (EjsObj*) ESV(minusOne);
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) info.size);
}


/*  
    function truncate(size: Number): Void
 */
PUBLIC EjsObj *truncateFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    int     size;

    size = ejsGetInt(ejs, argv[0]);
    if (mprTruncateFile(fp->path, size) < 0) {
        ejsThrowIOError(ejs, "Cant truncate %s", fp->path);
    }
    return 0;
}


/*  
    Write data to the file
    function write(data: Object): Number
 */
PUBLIC EjsObj *writeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *ap;
    EjsObj          *vp;
    EjsString       *str;
    cchar           *buf;
    ssize           len, written;
    int             i;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];

    if (!(fp->mode & EJS_FILE_WRITE)) {
        ejsThrowStateError(ejs, "File not opened for writing");
        return 0;
    }
    written = 0;

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, (EjsObj*) args, i);
        assert(vp);
        switch (TYPE(vp)->sid) {
        case S_ByteArray:
            ap = (EjsByteArray*) vp;
            //  TODO UNICODE ENCODING
            buf = (cchar*) &ap->value[ap->readPosition];
            len = ap->writePosition - ap->readPosition;
            break;

        case S_String: // UNICODE
#if UNICODE && FUTURE
            buf = awtom(((EjsString*) vp)->value, &len);
#else
            buf = ((EjsString*) vp)->value;
            len = ((EjsString*) vp)->length;
#endif
            break;

        default:
            str = ejsToString(ejs, vp);
            buf = awtom(((EjsString*) str)->value, &len);
            break;
        }
        if (mprWriteFile(fp->file, buf, len) != len) {
            mprLog(0, "Write IO error %d\n", mprGetOsError());
            ejsThrowIOError(ejs, "Cannot write to %s", fp->path);
            return 0;
        }
        written += len;
        /* Use GC to free buf as it may not be allocated */
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) written);
}


/*********************************** Support **********************************/

/*  
    Read the specified count of bytes into the byte array. Grow the array if required and growable
 */
static ssize readData(Ejs *ejs, EjsFile *fp, EjsByteArray *ap, ssize offset, ssize count)
{
    ssize   room, bytes;

    if (count <= 0) {
        return 0;
    }
    room = ap->size - offset;
    if (room < count) {
        if (ap->resizable) {
            ejsGrowByteArray(ejs, ap, ap->size + (count - room));
        } else {
            count = min(room, count);
        }
    }
    bytes = mprReadFile(fp->file, &ap->value[offset], count);
    if (bytes < 0) {
        ejsThrowIOError(ejs, "Error reading from %s", fp->path);
    }
    return bytes;
}


#if ME_CC_MMU && FUTURE
static void *mapFile(EjsFile *fp, uint size, int mode)
{
    Mpr         *mpr;
    void        *ptr;

    mpr = mprGetMpr();
    x = ~(mpr->alloc.pageSize - 1);
    size = (size + mpr->alloc.pageSize - 1) & ~(mpr->alloc.pageSize - 1);
#if MACOSX || LINUX || FREEBSD
    //  USE MAP_SHARED instead of MAP_PRIVATE if opened for write
    ptr = mmap(0, size, mode, MAP_FILE | MAP_PRIVATE, fp->file->fd, 0);
#else
    ptr = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, mapProt(mode));
#endif

    if (ptr == 0) {
        mprSetMemError(mpr);
        return 0;
    }
    return ptr;
}


static void unmapFile(EjsFile *fp)
{
#if MACOSX || LINUX || FREEBSD
    munmap(fp->mapped, fp->info.size);
#else
    VirtualFree(file->mapped, 0, MEM_RELEASE);
#endif
}
#endif

static int mapMode(cchar *mode)
{
    int     omode;

    omode = O_BINARY;
    if (strchr(mode, 'r')) {
        omode |= O_RDONLY;
    }
    if (strchr(mode, 'w')) {
        omode |= O_CREAT | O_WRONLY | O_TRUNC;
    }
    if (strchr(mode, 'a')) {
        omode |= O_WRONLY | O_APPEND;
        omode &= ~O_TRUNC;
    }
    if (strchr(mode, '+')) {
        /* Append to existing content */
        omode &= ~O_TRUNC;
    }
    if (strchr(mode, 't')) {
        /* Text mode */
        omode &= ~O_BINARY;
    }
#if O_EXLOCK
    if (strchr(mode, 'l')) {
        /* Exclusive lock */
        omode |= O_EXLOCK;
    }
#endif
#if O_SHLOCK
    if (strchr(mode, 's')) {
        /* Shared lock */
        omode |= O_SHLOCK;
    }
#endif
    if (strchr(mode, 'c')) {
        /* Create - must not exist prior */
        omode |= O_CREAT | O_EXCL;
    }
    return omode;
}


/*********************************** Factory **********************************/

PUBLIC EjsFile *ejsCreateFile(Ejs *ejs, cchar *path)
{
    EjsFile     *fp;
    EjsObj      *arg;

    assert(path && *path);

    fp = ejsCreateObj(ejs, ESV(File), 0);
    if (fp == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateStringFromAsc(ejs, path);
    fileConstructor(ejs, fp, 1, (EjsObj**) &arg);
    return fp;
}


PUBLIC EjsFile *ejsCreateFileFromFd(Ejs *ejs, int fd, cchar *name, int mode)
{
    EjsFile     *fp;

    assert(fd >= 0);
    assert(name);

    if ((fp = ejsCreateObj(ejs, ESV(File), 0)) == NULL) {
        return NULL;
    }
    fp->perms = EJS_FILE_PERMS;
    fp->mode = EJS_FILE_OPEN;
    if (!(mode & O_WRONLY)) {
        fp->mode |= EJS_FILE_READ;
    }
    if (mode & (O_WRONLY | O_RDWR)) {
        fp->mode |= EJS_FILE_WRITE;
    }
    if ((fp->file = mprAttachFileFd(fd, name, mode)) == 0) {
        return 0;
    }
    fp->attached = 1;
    fp->path = MPR->emptyString;
    return fp;
}


static void manageFile(void *ptr, int flags)
{
    EjsFile     *fp;

    fp = (EjsFile*) ptr;

    if (flags & MPR_MANAGE_MARK) {
        mprMark(fp->file);
        mprMark(fp->path);
        mprMark(fp->modeString);
        mprMark(TYPE(fp));

    } else if (flags & MPR_MANAGE_FREE) {
        if (fp->file && !fp->attached) {
            closeFile(0, fp, 0, NULL);
        }
    }
}


PUBLIC void ejsConfigureFileType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "File"), sizeof(EjsFile), manageFile,
            EJS_TYPE_OBJ | EJS_TYPE_NUMERIC_INDICIES | EJS_TYPE_VIRTUAL_SLOTS | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    type->helpers.getProperty    = (EjsGetPropertyHelper) getFileProperty;
    type->helpers.lookupProperty = (EjsLookupPropertyHelper) lookupFileProperty;
    type->helpers.setProperty    = (EjsSetPropertyHelper) setFileProperty;

    prototype = type->prototype;
    ejsBindConstructor(ejs, type, fileConstructor);
    ejsBindMethod(ejs, prototype, ES_File_canRead, canReadFile);
    ejsBindMethod(ejs, prototype, ES_File_canWrite, canWriteFile);
    ejsBindMethod(ejs, prototype, ES_File_close, closeFile);
    ejsBindMethod(ejs, prototype, ES_File_iterator_get, getFileIterator);
    ejsBindMethod(ejs, prototype, ES_File_iterator_getValues, getFileValues);
    ejsBindMethod(ejs, prototype, ES_File_isOpen, isFileOpen);
    ejsBindMethod(ejs, prototype, ES_File_open, openFile);
    ejsBindMethod(ejs, prototype, ES_File_options, getFileOptions);
    ejsBindMethod(ejs, prototype, ES_File_path, getFilePath);
    ejsBindAccess(ejs, prototype, ES_File_position, getFilePosition, setFilePosition);
    ejsBindMethod(ejs, prototype, ES_File_readBytes, readFileBytes);
    ejsBindMethod(ejs, prototype, ES_File_readString, readFileString);
    ejsBindMethod(ejs, prototype, ES_File_read, readFile);
    ejsBindMethod(ejs, prototype, ES_File_size, getFileSize);
    ejsBindMethod(ejs, prototype, ES_File_truncate, truncateFile);
    ejsBindMethod(ejs, prototype, ES_File_write, writeFile);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsFileSystem.c"
 */
/************************************************************************/

/**
    ejsFileSystem.c - FileSystem class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Methods *********************************/
/*
    static function drives(): Array
 */
static EjsArray *fs_drives(Ejs *ejs, EjsFileSystem *unused, int argc, EjsObj **argv)
{
    EjsArray    *ap;

    if ((ap = ejsCreateArray(ejs, 0)) == 0) {
        return 0;
    }
#if ME_WIN_LIKE
{
    char        dbuf[2];
    int         i, mask;

    mask = GetLogicalDrives();
    for (i = 0; i < 26; i++) {
        if (mask & (1 << i)) {
            dbuf[0] = 'A' + i;
            dbuf[1] = '\0';
            ejsAddItem(ejs, ap, ejsCreateStringFromAsc(ejs, dbuf));
        }
    }
}
#endif
    return ap;
}


/*
    Constructor

    function FileSystem(path: String)
 */
static EjsFileSystem *fileSystemConstructor(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    cchar   *path;

#if UNUSED
    assert(argc == 1 && ejsIs(ejs, argv[0], String));
    path = ejsToMulti(ejs, argv[0]);
#else
    assert(argc == 1 && ejsIs(ejs, argv[0], Path));
    path = ((EjsPath*) argv[0])->value;
#endif
    fp->path = mprNormalizePath(path);
    fp->fs = mprLookupFileSystem(path);
    return fp;
}


#if ES_space
/*
    Return the amount of free space in the file system that would contain the given path.

    function freeSpace(path: String = null): Number
 */
static EjsObj *fileSystemSpace(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
#if BREW
    Mpr     *mpr;
    uint    space;

    mpr = mprGetMpr();
    space = IFILEMGR_GetFreeSpace(mpr->fileMgr, 0);
    ejsSetReturnValueToInteger(ejs, space);
#endif
    return 0;
}
#endif


/*
    Determine if the file system has a drive specs (C:) in paths

    static function hasDrives(): Boolean
 */
static EjsBoolean *hasDrives(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, fp->fs->hasDriveSpecs);
}


#if ES_isReady
/*
    Determine if the file system is ready for I/O

    function get isReady(): Boolean
 */
static EjsBoolean *isReady(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}
#endif


#if ES_isWritable
static EjsBoolean *isWritable(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}
#endif


/*
    Get the newline characters

    function get newline(): String
 */
static EjsString *getNewline(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprGetPathNewline(fp->path));
}


/*
    set the newline characters

    function set newline(terminator: String): Void
 */
static EjsObj *setNewline(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    cchar   *nl;

    assert(ejsIs(ejs, argv[0], String));
    nl = ejsToMulti(ejs, (EjsString*) argv[0]);
    mprSetPathNewline(fp->path, nl);
    return 0;
}


static EjsPath *root(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    cchar   *separators;
    char    *path, *cp;

    separators = mprGetPathSeparators(fp->path);
    path = mprGetAbsPath(fp->path);
    if ((cp = strchr(path, separators[0])) != 0) {
        *++cp = '\0';
    }
    return ejsCreatePathFromAsc(ejs, path);
}


/*
    Return the path directory separators

    static function get separators(): String
 */
static EjsString *getSeparators(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, fp->fs->separators);
}


/*
    Set the path directory separators

    static function set separators(value: String): void
 */
static EjsObj *setSeparators(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    assert(argc == 1 && ejsIs(ejs, argv[0], String));
    mprSetPathSeparators(fp->path, ejsToMulti(ejs, argv[0]));
    return 0;
}


#if ES_size
static EjsObj *size(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return 0;
}
#endif

/*********************************** Factory **********************************/

static void manageFileSystem(EjsFileSystem *fs, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(TYPE(fs));
        mprMark(fs->path);
    }
}


PUBLIC EjsFileSystem *ejsCreateFileSystem(Ejs *ejs, cchar *path)
{
    EjsFileSystem   *fs;
    EjsObj          *arg;

    fs = ejsCreateObj(ejs, ESV(FileSystem), 0);
    if (fs == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateStringFromAsc(ejs, path);
    fileSystemConstructor(ejs, fs, 1, (EjsObj**) &arg);
    return fs;
}


PUBLIC void ejsConfigureFileSystemType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "FileSystem"), sizeof(EjsFileSystem), manageFileSystem,
            EJS_TYPE_OBJ)) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, fileSystemConstructor);
    ejsBindMethod(ejs, type, ES_FileSystem_drives, fs_drives);
#if ES_space
    ejsBindMethod(ejs, prototype, ES_FileSystem_space, fileSystemSpace);
#endif
    ejsBindMethod(ejs, prototype, ES_FileSystem_hasDrives, hasDrives);
#if ES_isReady
    ejsBindMethod(ejs, prototype, ES_FileSystem_isReady, isReady);
#endif
#if ES_isWritable
    ejsBindMethod(ejs, prototype, ES_FileSystem_isWritable, isWritable);
#endif
    ejsBindAccess(ejs, prototype, ES_FileSystem_newline, getNewline, setNewline);
    ejsBindMethod(ejs, prototype, ES_FileSystem_root, root);
    ejsBindAccess(ejs, prototype, ES_FileSystem_separators, getSeparators, setSeparators);
#if ES_size
    ejsBindMethod(ejs, prototype, ES_FileSystem_size, size);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsFrame.c"
 */
/************************************************************************/

/**
    ejsFrame.c - Activation frame class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/******************************************************************************/

static void manageFrame(EjsFrame *frame, int flags)
{
    assert(frame);
    if (frame) {
        if (flags & MPR_MANAGE_MARK) {
            ejsManageFunction((EjsFunction*) frame, flags);
            mprMark(frame->orig);
            mprMark(frame->caller);
            mprMark(TYPE(frame));
        }
    }
}


static EjsFrame *allocFrame(Ejs *ejs, int numProp)
{
    EjsObj      *obj;
    ssize       size;

    assert(ejs);

    size = sizeof(EjsFrame) + sizeof(EjsProperties) + numProp * sizeof(EjsSlot);
    if ((obj = mprAllocBlock(size, MPR_ALLOC_MANAGER | MPR_ALLOC_ZERO)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    mprSetManager(obj, (MprManager) manageFrame);
    SET_TYPE(obj, ESV(Frame));
    ejsSetMemRef(obj);
    return (EjsFrame*) obj;
}


/*
    Create a frame object just for the compiler
 */
PUBLIC EjsFrame *ejsCreateCompilerFrame(Ejs *ejs, EjsFunction *fun)
{
    EjsFrame    *fp;

    if ((fp = ejsCreatePot(ejs, ESV(Frame), 0)) == 0) {
        return 0;
    }
    fp->orig = fun;
    fp->function.name = fun->name;
    fp->function.block.pot.isBlock = 1;
    fp->function.block.pot.isFrame = 1;
    fp->function.isConstructor = fun->isConstructor;
    fp->function.isInitializer = fun->isInitializer;
    fp->function.staticMethod = fun->staticMethod;
    mprSetName(fp, "frame");
    return fp;
}


PUBLIC EjsFrame *ejsCreateFrame(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, EjsObj **argv)
{
    EjsFrame    *frame;
    EjsPot      *obj, *activation;
    int         numProp, size, i;

    activation = fun->activation;
    numProp = (activation) ? activation->numProp : 0;
    size = max(numProp, EJS_MIN_FRAME_SLOTS);

    frame = allocFrame(ejs, size);
    obj = (EjsPot*) frame;
    obj->properties = (EjsProperties*) &(((char*) obj)[sizeof(EjsFrame)]);
    obj->properties->size = size;
    obj->numProp = numProp;
    if (activation) {
        //  OPT -- could the function be setup as the prototype and thus avoid doing this?
        //  OPT -- assumes that the function is sealed
        memcpy(obj->properties->slots, activation->properties->slots, numProp * sizeof(EjsSlot));
        ejsIndexProperties(ejs, obj);
    }
    ejsZeroSlots(ejs, &obj->properties->slots[numProp], size - numProp);
    //  OPT - should not need to do this
    SET_DYNAMIC(obj, 1);

    frame->orig = fun;
    frame->function.name = fun->name;
    frame->function.block.pot.isBlock = 1;
    frame->function.block.pot.isFrame = 1;
    frame->function.block.namespaces = fun->block.namespaces;
    frame->function.block.scope = fun->block.scope;
    frame->function.block.prev = fun->block.prev;
    frame->function.block.nobind = fun->block.nobind;

    //  OPT
    frame->function.numArgs = fun->numArgs;
    frame->function.numDefault = fun->numDefault;
    frame->function.castNulls = fun->castNulls;
    frame->function.fullScope = fun->fullScope;
    frame->function.hasReturn = fun->hasReturn;
    frame->function.isConstructor = fun->isConstructor;
    frame->function.isInitializer = fun->isInitializer;
    frame->function.isNativeProc = fun->isNativeProc;
    frame->function.rest = fun->rest;
    frame->function.staticMethod = fun->staticMethod;
    frame->function.strict = fun->strict;
    frame->function.throwNulls = fun->throwNulls;

    frame->function.boundArgs = fun->boundArgs;

    /* NOTE: this can be set to ejs->global in frames */
    frame->function.boundThis = thisObj;
    
    frame->function.resultType = fun->resultType;
    frame->function.body = fun->body;
    frame->pc = fun->body.code->byteCode;
    assert(frame->pc);

    if (argc > 0) {
        frame->argc = argc;
        if ((uint) argc < (fun->numArgs - fun->numDefault - fun->rest) || (uint) argc > fun->numArgs) {
            ejsThrowArgError(ejs, "Incorrect number of arguments");
            return 0;
        }
        for (i = 0; i < argc; i++) {
            frame->function.block.pot.properties->slots[i].value.ref = argv[i];
        }
    }
    //  UNICODE
    mprSetName(frame, fun->name->value);
    return frame;
}


PUBLIC void ejsCreateFrameType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", "Frame"), sizeof(EjsFrame), S_Frame, ES_Frame_NUM_CLASS_PROP,
        manageFrame, EJS_TYPE_POT | EJS_TYPE_DYNAMIC_INSTANCES | EJS_TYPE_MUTABLE_INSTANCES);
    type->constructor.block.pot.shortScope = 1;
    type->configured = 1;
    type->helpers.clone = (EjsCloneHelper) ejsCloneBlock;
}


PUBLIC void ejsConfigureFrameType(Ejs *ejs)
{
    EjsType     *type;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Frame"))) == 0) {
        return;
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsFunction.c"
 */
/************************************************************************/

/**
    ejsFunction.c - Function class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Forwards *********************************/

static void setFunctionAttributes(EjsFunction *fun, int attributes);

/************************************* Code ***********************************/
/*
    Create a function object.
 */
static EjsFunction *createFunction(Ejs *ejs, EjsType *type, int numProp)
{
    EjsFunction     *fun;

    if ((fun = ejsCreatePot(ejs, ESV(Function), 0)) == 0) {
        return 0;
    }
    fun->block.pot.isFunction = 1;
    SET_DYNAMIC(fun, 1);
    return fun;
}


/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */
static EjsAny *castFunction(Ejs *ejs, EjsFunction *vp, EjsType *type)
{
    switch (type->sid) {
    case S_String:
        return ejsCreateStringFromAsc(ejs, "[function Function]");

    case S_Number:
        return ESV(nan);

    case S_Boolean:
        return ESV(true);
            
    default:
        ejsThrowTypeError(ejs, "Cannot cast type \"%@\"", type->qname.name);
        return 0;
    }
}


PUBLIC EjsFunction *ejsCloneFunction(Ejs *ejs, EjsFunction *src, int deep)
{
    EjsFunction     *dest;

    if ((dest = (EjsFunction*) ejsCloneBlock(ejs, &src->block, deep)) == 0) {
        return 0;
    }
    dest->body.code = src->body.code;
    dest->resultType = src->resultType;
    dest->boundArgs = src->boundArgs;
    dest->boundThis = src->boundThis;
    dest->numArgs = src->numArgs;
    dest->numDefault = src->numDefault;

    /*
        OPT
     */
    dest->staticMethod = src->staticMethod;
    dest->hasReturn = src->hasReturn;
    dest->isConstructor = src->isConstructor;
    dest->isInitializer = src->isInitializer;
    dest->isNativeProc = src->isNativeProc;
    dest->moduleInitializer = src->moduleInitializer;
    dest->rest = src->rest;
    dest->fullScope = src->fullScope;
    dest->strict = src->strict;
    dest->name = src->name;

    if (src->activation) {
        dest->activation = ejsClonePot(ejs, src->activation, 0);
    }
    mprCopyName(dest, src);
    return dest;
}


/*************************************************************************************************************/
/*
    function Function(...[args], body)
 */
static EjsFunction *fun_Function(Ejs *ejs, EjsFunction *fun, int argc, void *argv)
{
#if FUTURE
    EjsArray        *args;
    EjsString       *str;
    MprBuf          *buf;
    cchar           *body, *param, *script;
    int             i, count;
    
    assert(argc > 1);
    args = (EjsArray*) argv[1];
    assert(ejsIs(ejs, args, Array));

    if (args->length <= 0) {
        ejsThrowArgError(ejs, "Missing function body");
        return 0;
    }
    str = ejsToString(ejs, args->data[args->length - 1]);
    body = ejsToMulti(ejs, str);

    buf = mprCreateBuf(ejs, -1, -1);
    mprPutStringToBuf(buf, "function(");
    count = args->length - 1;
    for (i = 0; i < count; i++) {
        str = ejsToString(ejs, args->data[i]);
        param = ejsToMulti(ejs, str);
        mprPutStringToBuf(buf, param);
        if (i < (count - 1)) {
            mprPutCharToBuf(buf, ',');
        }
        mprPutStringToBuf(buf, "\n{");
    }
    mprPutStringToBuf(buf, body);
    mprPutStringToBuf(buf, "\n}");

    script = mprGetBufStart(buf);
    if (ejsLoadScriptLiteral(ejs, script, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW | EC_FLAGS_VISIBLE) < 0) {
        //  TODO -- what happens to compiler errors
        return 0;
    }
    fun->body.code = ;
    fun->body.codeLen
#endif
    return fun;
}

/*
    function apply(thisObj: Object, args: Array)
 */
static EjsObj *fun_applyFunction(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *save, *result, *thisObj;
    
    assert(argc > 1);
    args = (EjsArray*) argv[1];
    assert(ejsIs(ejs, args, Array));

    save = fun->boundThis;
    thisObj = argv[0];
    if (thisObj == ESV(null)) {
        thisObj = fun->boundThis ? fun->boundThis : ejs->global;
    }
    result =  ejsRunFunction(ejs, fun, thisObj, args->length, args->data);
    fun->boundThis = save;
    return result;
}


/*
    function bind(thisObj: Object, ...args): Void
 */
static EjsObj *fun_bindFunction(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsAny      *thisObj;

    assert(argc >= 1);

    thisObj = argv[0];
    fun->boundThis = ejsIsDefined(ejs, thisObj) ? thisObj : 0;
    if (argc == 2) {
        fun->boundArgs = (EjsArray*) argv[1];
        assert(ejsIs(ejs, fun->boundArgs, Array));
    }
    return 0;
}


/*
    function get bound(): Object
 */
static EjsAny *fun_bound(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    return fun->boundThis ? fun->boundThis : ESV(undefined);
}


/*
    function call(thisObj, ...args)
 */
static EjsObj *fun_call(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    assert(argc > 1);
    return fun_applyFunction(ejs, fun, argc, argv);
}


/*
    Return the number of required args.

    function get length(): Number
 */
static EjsNumber *fun_length(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, fun->numArgs);
}


/*
    function get name(): String
 */
static EjsString *fun_name(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    if (fun->name && fun->name->value[0] == '-') {
        return ESV(empty);
    }
    return fun->name;
}


/*
    function setScope(obj): Void
 */
static EjsObj *fun_setScope(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsBlock    *scope;

    scope = (EjsBlock*) argv[0];
    if (!ejsIsBlock(ejs, scope)) {
        scope = (EjsBlock*) TYPE(scope);
        if (!ejsIsBlock(ejs, scope)) {
            ejsThrowArgError(ejs, "Scope object must be a class or function");
            return 0;
        }
    }
    fun->block.scope = scope;
    return 0;
}


/*************************************************************************************************************/

PUBLIC void ejsRemoveConstructor(Ejs *ejs, EjsType *type)
{
    EjsFunction     *fun;

    fun = (EjsFunction*) type;
    fun->block.pot.isFunction = 0;
    fun->isConstructor = 0;
    fun->isInitializer = 0;
    fun->activation = 0;
}


static void setFunctionAttributes(EjsFunction *fun, int attributes)
{
    if (attributes & EJS_FUN_CONSTRUCTOR) {
        fun->isConstructor = 1;
    }
    if (attributes & EJS_FUN_INITIALIZER) {
        fun->isInitializer = 1;
    }
    if (attributes & EJS_PROP_NATIVE) {
        fun->isNativeProc = 1;
    }
    if (attributes & EJS_FUN_MODULE_INITIALIZER) {
        fun->moduleInitializer = 1;
    }
    if (attributes & EJS_FUN_REST_ARGS) {
        fun->rest = 1;
    }
    if (attributes & EJS_PROP_STATIC) {
        fun->staticMethod = 1;
    }
    if (attributes & EJS_FUN_FULL_SCOPE) {
        fun->fullScope = 1;
    }
    if (attributes & EJS_FUN_HAS_RETURN) {
        fun->hasReturn = 1;
    }
    if (attributes & EJS_TRAIT_CAST_NULLS) {
        fun->castNulls = 1;
    }
    if (attributes & EJS_TRAIT_THROW_NULLS) {
        fun->throwNulls = 1;
    }
}


PUBLIC void ejsSetFunctionName(Ejs *ejs, EjsFunction *fun, EjsString *name)
{
    fun->name = name;
}


PUBLIC EjsEx *ejsAddException(Ejs *ejs, EjsFunction *fun, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart,
        uint handlerEnd, int numBlocks, int numStack, int flags, int preferredIndex)
{
    EjsEx           *exception;
    EjsCode         *code;
    int             size;

    assert(fun);

    /* Managed by manageCode */
    if ((exception = mprAllocZeroed(sizeof(EjsEx))) == 0) {
        assert(0);
        return 0;
    }
    exception->flags = flags;
    exception->tryStart = tryStart;
    exception->tryEnd = tryEnd;
    exception->catchType = catchType;
    exception->handlerStart = handlerStart;
    exception->handlerEnd = handlerEnd;
    exception->numBlocks = numBlocks;
    exception->numStack = numStack;

    code = fun->body.code;
    if (preferredIndex < 0) {
        preferredIndex = code->numHandlers++;
    }
    if (preferredIndex >= code->sizeHandlers) {
        size = code->sizeHandlers + EJS_EX_INC;
        code->handlers = mprRealloc(code->handlers, size * sizeof(EjsEx));
        if (code->handlers == 0) {
            assert(0);
            return 0;
        }
        memset(&code->handlers[code->sizeHandlers], 0, EJS_EX_INC * sizeof(EjsEx)); 
        code->sizeHandlers = size;
    }
    code->handlers[preferredIndex] = exception;
    return exception;
}


#if UNUSED
PUBLIC void ejsOffsetExceptions(EjsFunction *fun, int offset)
{
    EjsEx           *ex;
    int             i;

    assert(fun);

    for (i = 0; i < fun->body.code->numHandlers; i++) {
        ex = fun->body.code->handlers[i];
        ex->tryStart += offset;
        ex->tryEnd += offset;
        ex->handlerStart += offset;
        ex->handlerEnd += offset;
    }
}
#endif


static void manageCode(EjsCode *code, int flags)
{
    int     i;

    assert(code->magic == EJS_CODE_MAGIC);
    if (flags & MPR_MANAGE_MARK) {
        assert(code->debug == 0 || code->debug->magic == EJS_DEBUG_MAGIC);        
        mprMark(code->module);
        mprMark(code->debug);
        if (code->handlers) {
            mprMark(code->handlers);
            for (i = 0; i < code->numHandlers; i++) {
                /* Manage EjsEx */
                mprMark(code->handlers[i]);
            }
        }
    }
}


PUBLIC EjsCode *ejsCreateCode(Ejs *ejs, EjsFunction *fun, EjsModule *module, cuchar *byteCode, ssize len, 
    EjsDebug *debug)
{
    EjsCode     *code;

    assert(fun);
    assert(module);
    assert(byteCode);
    assert(len >= 0);
    assert(debug == 0 || debug->magic == EJS_DEBUG_MAGIC);

    if ((code = mprAllocBlock(sizeof(EjsCode) + len, MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        return NULL;
    }
    mprSetManager(code, (MprManager) manageCode);
    code->codeLen = (int) len;
    code->module = module;
    code->debug = debug;
    code->magic = EJS_CODE_MAGIC;
    memcpy(code->byteCode, byteCode, len);
    return code;
}


/*
    Set the byte code for a script function
 */
PUBLIC int ejsSetFunctionCode(Ejs *ejs, EjsFunction *fun, EjsModule *module, cuchar *byteCode, ssize len, EjsDebug *debug)
{
    assert(fun);
    assert(byteCode);
    assert(len >= 0);
    assert(debug == 0 || debug->magic == EJS_DEBUG_MAGIC);

    fun->body.code = ejsCreateCode(ejs, fun, module, byteCode, len, debug);
    return 0;
}


static EjsObj *nopFunction(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return ESV(undefined);
}


#if UNUSED
PUBLIC void ejsUseActivation(Ejs *ejs, EjsFunction *fun)
{
    EjsPot  *activation;
    int     numProp;

    if ((activation = fun->activation) == 0) {
        return;
    }
    numProp = activation->numProp;
    if (numProp > 0) {
        ejsGrowPot(ejs, (EjsPot*) fun, numProp);
        ejsCopySlots(ejs, (EjsPot*) fun, 0, fun->activation, 0, numProp);
        fun->block.pot.numProp = numProp;
    }
}
#endif


PUBLIC EjsPot *ejsCreateActivation(Ejs *ejs, EjsFunction *fun, int numProp)
{
    EjsPot  *activation;

    activation = ejsCreatePot(ejs, ESV(Object), numProp);
    mprCopyName(activation, fun);
    return activation;
}

/********************************** Factory **********************************/

PUBLIC EjsFunction *ejsCreateBareFunction(Ejs *ejs, EjsString *name, int attributes)
{
    EjsFunction     *fun;

    if ((fun = ejsCreateObj(ejs, ESV(Function), 0)) == NULL) {
        return 0;
    }
    fun->name = name;
    fun->block.pot.isBlock = 1;
    fun->block.pot.isFunction = 1;
    mprCopyName(fun, fun->name);
    setFunctionAttributes(fun, attributes);
    return fun;
}


/*
    Create a script function. This defines the method traits. It does not create a  method slot. ResultType may
    be null to indicate untyped. NOTE: untyped functions may return a result at their descretion.
 */
PUBLIC EjsFunction *ejsCreateFunction(Ejs *ejs, EjsString *name, cuchar *byteCode, int codeLen, int numArgs, int numDefault, 
    int numExceptions, EjsType *resultType, int attributes, EjsModule *module, EjsBlock *scope, int strict)
{
    EjsFunction     *fun;

    if ((fun = ejsCreateBareFunction(ejs, name, attributes)) == 0) {
        return 0;
    }
    ejsInitFunction(ejs, fun, name, byteCode, codeLen, numArgs, numDefault, numExceptions, resultType, attributes, 
        module, scope, strict);
    return fun;
}


/*
    Init function to initialize constructors inside types
 */
PUBLIC int ejsInitFunction(Ejs *ejs, EjsFunction *fun, EjsString *name, cuchar *byteCode, int codeLen, int numArgs, 
    int numDefault, int numExceptions, EjsType *resultType, int attributes, EjsModule *module, EjsBlock *scope, int strict)
{
    if (scope) {
        fun->block.scope = scope;
    }
    fun->block.pot.isBlock = 1;
    fun->block.pot.isFunction = 1;
    fun->numArgs = numArgs;
    fun->numDefault = numDefault;
    fun->resultType = resultType;
    fun->strict = strict;

    if (codeLen > 0) {
        fun->body.code = ejsCreateCode(ejs, fun, module, byteCode, codeLen, NULL);
        fun->body.code->numHandlers = numExceptions;
    }
    fun->name = name;
    setFunctionAttributes(fun, attributes);
    return 0;
}


PUBLIC void ejsManageFunction(EjsFunction *fun, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManageBlock((EjsBlock*) fun, flags);
        mprMark(fun->activation);
        mprMark(fun->name);
        mprMark(fun->setter);
        mprMark(fun->archetype);
        if (!fun->isNativeProc) {
            mprMark(fun->body.code);
        }
        mprMark(fun->boundArgs);
        mprMark(fun->boundThis);
        mprMark(fun->resultType);
    }
}


PUBLIC void ejsCreateFunctionType(Ejs *ejs)
{
    EjsType         *type;
    EjsHelpers      *helpers;
    EjsFunction     *nop;

    type = ejsCreateCoreType(ejs, N("ejs", "Function"), sizeof(EjsFunction), S_Function, ES_Function_NUM_CLASS_PROP,
        ejsManageFunction, EJS_TYPE_POT | EJS_TYPE_IMMUTABLE_INSTANCES | EJS_TYPE_DYNAMIC_INSTANCES);
    helpers = &type->helpers;
    helpers->create = (EjsCreateHelper) createFunction;
    helpers->cast   = (EjsCastHelper) castFunction;
    helpers->clone  = (EjsCloneHelper) ejsCloneFunction;

    nop = ejsCreateFunction(ejs, ejsCreateStringFromAsc(ejs, "nop"), NULL, 0, -1, 0, 0, NULL, EJS_PROP_NATIVE, NULL, NULL,0);
    ejsAddImmutable(ejs, S_nop, EN("nop"), nop);
    nop->body.proc = (EjsProc) nopFunction;
    nop->isNativeProc = 1;
}


PUBLIC void ejsConfigureFunctionType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Function"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, fun_Function);
    ejsBindMethod(ejs, prototype, ES_Function_apply, fun_applyFunction);
    ejsBindMethod(ejs, prototype, ES_Function_bind, fun_bindFunction);
    ejsBindMethod(ejs, prototype, ES_Function_bound, fun_bound);
    ejsBindMethod(ejs, prototype, ES_Function_call, fun_call);
    ejsBindMethod(ejs, prototype, ES_Function_length, fun_length);
    ejsBindMethod(ejs, prototype, ES_Function_name, fun_name);
    ejsBindMethod(ejs, prototype, ES_Function_setScope, fun_setScope);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsGC.c"
 */
/************************************************************************/

/**
    ejsGC.c - Garbage collector class for the EJS Object Model

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Methods *********************************/
/*
    native static function get enabled(): Boolean
 */
static EjsBoolean *gc_enabled(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    return ((mprGetMpr()->heap->gcEnabled) ? ESV(true): ESV(false));
}


/*
    native static function set enabled(on: Boolean): Void
 */
static EjsObj *gc_set_enabled(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    assert(argc == 1 && ejsIs(ejs, argv[0], Boolean));
    mprGetMpr()->heap->gcEnabled = ejsGetBoolean(ejs, argv[0]);
    return 0;
}


/*
    run()
 */
static EjsObj *gc_run(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    assert(!ejs->state->paused);
    
    if (!ejs->state->paused) {
        mprGC(MPR_GC_FORCE);
    }
    return 0;
}


/*
    native static function get newQuota(): Number
 */
static EjsNumber *gc_newQuota(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetMpr()->heap->workQuota);
}


/*
    native static function set newQuota(quota: Number): Void
 */
static EjsObj *gc_set_newQuota(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     quota;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));
    quota = ejsGetInt(ejs, argv[0]);

    if (quota < 1024 && quota != 0) {
        ejsThrowArgError(ejs, "Bad work quota. Must be > 1024");
        return 0;
    }
    mprGetMpr()->heap->workQuota = quota;
    return 0;
}


/*
    verify(): Void
 */
static EjsObj *gc_verify(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    //  UNUSED - not supported
    return 0;
}


PUBLIC void ejsConfigureGCType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "GC"), sizeof(EjsPot), ejsManagePot, EJS_TYPE_POT)) == 0) {
        return;
    }
    ejsBindAccess(ejs, type, ES_GC_enabled, gc_enabled, gc_set_enabled);
    ejsBindAccess(ejs, type, ES_GC_newQuota, gc_newQuota, gc_set_newQuota);
    ejsBindMethod(ejs, type, ES_GC_run, gc_run);
    ejsBindMethod(ejs, type, ES_GC_verify, gc_verify);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsGlobal.c"
 */
/************************************************************************/

/**
    ejsGlobal.c - Global functions and variables

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Locals ***********************************/
/*  
    Assert a condition is true.
    static function assert(condition: Boolean): Boolean
 */
static EjsBoolean *g_assert(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsFrame        *fp;
    wchar           *source;
    EjsBoolean      *b;

    if (argc == 0) {
        b = ESV(false);
    } else {
        if (!ejsIs(ejs, argv[0], Boolean)) {
            b = (EjsBoolean*) ejsCast(ejs, argv[0], Boolean);
        } else {
            b = (EjsBoolean*) argv[0];
        }
    }
    assert(b);

    if (b == 0 || !b->value) {
        fp = ejs->state->fp;
        if (ejsGetDebugInfo(ejs, (EjsFunction*) fp, fp->pc, NULL, NULL, &source) >= 0) {
            ejsThrowAssertError(ejs, "%w", source);
        } else {
            ejsThrowAssertError(ejs, "Assertion error");
        }
        return 0;
    }
    return ESV(true);
}


/*  
    function blend(dest: Object, src: Object, options = null): Object
 */
static EjsObj *g_blend(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *src, *dest, *options;
    int         flags;

    options = (argc >= 3) ? argv[2] : 0;
    if (options) {
        flags = 0;
        /* Default to true */
        flags |= ejsGetPropertyByName(ejs, options, EN("combine")) == ESV(true) ? EJS_BLEND_COMBINE : 0;
        flags |= ejsGetPropertyByName(ejs, options, EN("functions")) == ESV(true) ? EJS_BLEND_FUNCTIONS : 0;
        flags |= ejsGetPropertyByName(ejs, options, EN("trace")) == ESV(true) ? EJS_BLEND_TRACE : 0;

        /* Default to false */
        flags |= ejsGetPropertyByName(ejs, options, EN("overwrite")) == ESV(false) ? 0 : EJS_BLEND_OVERWRITE;
        flags |= ejsGetPropertyByName(ejs, options, EN("subclass")) == ESV(false) ? 0 : EJS_BLEND_SUBCLASSES;
        flags |= ejsGetPropertyByName(ejs, options, EN("deep")) == ESV(false) ? 0 : EJS_BLEND_DEEP;
    } else {
        flags = EJS_BLEND_DEEP | EJS_BLEND_OVERWRITE | EJS_BLEND_SUBCLASSES;
    }
    dest = argv[0];
    src = argv[1];
    ejsBlendObject(ejs, dest, src, flags);
    return dest;
}


/*  
    Clone the base class. Used by Record.es
    static function cloneBase(klass: Type): Void
 */
static EjsObj *g_cloneBase(Ejs *ejs, EjsObj *ignored, int argc, EjsObj **argv)
{
    EjsType     *type;
    
    assert(argc == 1);
    
    type = (EjsType*) argv[0];
    type->baseType = ejsClone(ejs, type->baseType, 0);
    return 0;
}


/*  
    function eval(script: String, cache: String = null): String
 */
static EjsObj *g_eval(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *script;
    cchar       *cache;

    script = (EjsString*) argv[0];
    if (argc < 2 || ejsIs(ejs, argv[1], Null)) {
        cache = NULL;
    } else {
        cache = ejsToMulti(ejs, argv[1]);
    }
    if (ejsLoadScriptLiteral(ejs, script, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_THROW | EC_FLAGS_VISIBLE) < 0) {
        return 0;
    }
    return ejs->result;
}


/*  
    Get the hash code for the object.
    function hashcode(o: Object): Number
 */
static EjsNumber *g_hashcode(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    assert(argc == 1);
    return ejsCreateNumber(ejs, (MprNumber) PTOL(argv[0]));
}


/*  
    Load a script or module. Name should have an extension. Name will be located according to the EJSPATH search strategy.

    static function load(filename: String, options: Object): void

    options = { cache: String|Path, reload: true }
 */
static EjsObj *g_load(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *options, *vp;
    cchar       *path, *cache, *cp;
    int         reload;

    cache = 0;
    reload = 1;
    path = ejsToMulti(ejs, argv[0]);
    options = (argc >= 2) ? argv[1] : 0;

    if (options) {
        if ((vp = ejsGetPropertyByName(ejs, options, EN("cache"))) != 0) {
            cache = ejsToMulti(ejs, ejsToString(ejs, vp));
        }
        reload = ejsGetPropertyByName(ejs, options, EN("reload")) == ESV(true);
    }
    if ((cp = strrchr(path, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) != 0) {
        if (ejs->service->loadScriptFile == 0) {
            ejsThrowIOError(ejs, "load: Compiling is not enabled for %s", path);
        } else {
            return (ejs->service->loadScriptFile)(ejs, path, cache);
        }
    } else {
        ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, path), -1, -1, (reload) ? EJS_LOADER_RELOAD : 0);
        return (ejs->exception) ? 0 : ejs->result;
    }
    return 0;
}


/*  
    Compute an MD5 checksum
    static function md5(name: String): String
 */
static EjsString *g_md5(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *str;
    char        *hash;

    str = (EjsString*) argv[0];
    hash = mprGetMD5WithPrefix(ejsToMulti(ejs, str), str->length, NULL);
    return ejsCreateStringFromAsc(ejs, hash);
}


/*  
    Merge one object into another. This is useful for inheriting and optionally overwriting option hashes (among other
    things). The blending is done at the primitive property level. If overwrite is true, the property is replaced. If
    overwrite is false, the property will be added if it does not already exist
 */
PUBLIC int ejsBlendObject(Ejs *ejs, EjsObj *dest, EjsObj *src, int flags)
{
    EjsTrait    *trait;
    EjsObj      *vp, *dp, *item;
    EjsName     qname, trimmedName;
    EjsArray    *ap;
    char        *str;
    int         i, j, count, start, deep, functions, overwrite, privateProps, trace, kind, combine, cflags;

    if (!ejsIsPot(ejs, dest)) {
        ejsThrowArgError(ejs, "destination is not an object");
        return -1;
    }
    if (!ejsIsDefined(ejs, src)) {
        /* Allow this - blend nothing */
        return 0;
    }
#if FUTURE
    if (!ejsIsPot(ejs, src)) {
        ejsThrowArgError(ejs, "source is not an object");
        return -1;
    }
#endif
    count = ejsGetLength(ejs, src);
    start = (flags & EJS_BLEND_SUBCLASSES) ? 0 : TYPE(src)->numInherited;
    deep = (flags & EJS_BLEND_DEEP) ? 1 : 0;
    overwrite = (flags & EJS_BLEND_OVERWRITE) ? 1 : 0;
    combine = (flags & EJS_BLEND_COMBINE) ? 1 : 0;
    functions = (flags & EJS_BLEND_FUNCTIONS) ? 1 : 0;
    privateProps = (flags & EJS_BLEND_PRIVATE) ? 1 : 0;
    trace = (flags & EJS_BLEND_TRACE) ? 1 : 0;

    for (i = start; i < count; i++) {
        if ((trait = ejsGetPropertyTraits(ejs, src, i)) != 0) {
            if (trait->attributes & (EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
                continue;
            }
        }
        if ((vp = ejsGetProperty(ejs, src, i)) == 0) {
            continue;
        }
        if (!functions && ejsIsFunction(ejs, ejsGetProperty(ejs, src, i))) {
            continue;
        }
        qname = ejsGetPropertyName(ejs, src, i);
        if (!qname.name || !qname.space) {
            continue;
        }
        if (!privateProps && ejsContainsAsc(ejs, qname.space, ",private") >= 0) {
            continue;
        }
        if (trace) {
            mprLog(0, "Blend name %N", qname);
        }
        if (combine && qname.name) {
            cflags = flags;
            kind = qname.name->value[0];
            if (kind == '+') {
                cflags |= EJS_BLEND_ADD;
                trimmedName = N(qname.space->value, &qname.name->value[1]);
            } else if (kind == '-') {
                cflags |= EJS_BLEND_SUB;
                trimmedName = N(qname.space->value, &qname.name->value[1]);
            } else if (kind == '=') {
                cflags |= EJS_BLEND_ASSIGN;
                trimmedName = N(qname.space->value, &qname.name->value[1]);
            } else if (kind == '?') {
                cflags |= EJS_BLEND_COND_ASSIGN;
                trimmedName = N(qname.space->value, &qname.name->value[1]);
            } else {
                /* cflags |= EJS_BLEND_ASSIGN; */
                trimmedName = qname;
            }
            if ((dp = ejsGetPropertyByName(ejs, dest, trimmedName)) == 0) {
                /* Destination property missing */
                if (cflags & EJS_BLEND_SUB) {
                    continue;
                }
                if (!ejsIsPot(ejs, vp) || ejsIsFunction(ejs, vp)) {
                    ejsSetPropertyByName(ejs, dest, trimmedName, ejsClone(ejs, vp, 1));
                    continue;
                }
                dp = ejsCreateObj(ejs, TYPE(vp), 0);
                ejsSetPropertyByName(ejs, dest, trimmedName, dp);
            }
            /* Destination present */
            if (ejsIs(ejs, dp, Array)) {
                if (cflags & EJS_BLEND_ADD) {
                    if (ejsIs(ejs, vp, Array)) {
                        ap = (EjsArray*) vp;
                        for (j = 0; j < ap->length; j++) {
                            item = ejsGetProperty(ejs, ap, j);
                            if (ejsLookupItem(ejs, (EjsArray*) dp, item) < 0) {
                                ejsAddItem(ejs, (EjsArray*) dp, ejsGetProperty(ejs, ap, j));
                            }
                        }
                    } else {
                        ejsAddItem(ejs, (EjsArray*) dp, vp);
                    }
                } else if (cflags & EJS_BLEND_SUB) {
                    if (ejsIs(ejs, vp, Array)) {
                        ap = (EjsArray*) vp;
                        for (j = 0; j < ap->length; j++) {
                            ejsRemoveItem(ejs, (EjsArray*) dp, ejsGetProperty(ejs, ap, j), 1);
                        }
                    } else {
                        ejsRemoveItem(ejs, (EjsArray*) dp, ejsToString(ejs, vp), 1);
                    }
                } else if (cflags & EJS_BLEND_COND_ASSIGN) {
                    if (ejsLookupProperty(ejs, dest, trimmedName) < 0) {
                        ejsSetPropertyByName(ejs, dest, trimmedName, ejsClone(ejs, vp, deep));
                    }
                } else {
                    /* Default is a assign */
                    ejsSetPropertyByName(ejs, dest, trimmedName, ejsClone(ejs, vp, deep));
                }

            } else if (ejsIsPot(ejs, dp)) {
                if (cflags & EJS_BLEND_ASSIGN) {
                    ejsSetPropertyByName(ejs, dest, trimmedName, ejsClone(ejs, vp, deep));

                } else if (cflags & EJS_BLEND_COND_ASSIGN) {
                    if (ejsLookupProperty(ejs, dest, trimmedName) < 0) {
                        ejsSetPropertyByName(ejs, dest, trimmedName, ejsClone(ejs, vp, deep));
                    }
                } else {
                    /* Recurse and blend the elements */
                    ejsBlendObject(ejs, dp, vp, flags);
                }

            } else if (ejsIs(ejs, dp, String)) {
                if (cflags & EJS_BLEND_ADD) {
                    str = sjoin(((EjsString*) dp)->value, " ", ejsToMulti(ejs, vp), NULL);
                    ejsSetPropertyByName(ejs, dest, trimmedName, ejsCreateString(ejs, str, -1));
                    
                } else if (cflags & EJS_BLEND_SUB) {
                    str = sreplace(sclone(((EjsString*) dp)->value), ejsToMulti(ejs, vp), "");
                    ejsSetPropertyByName(ejs, dest, trimmedName, ejsCreateString(ejs, str, -1));
                    
                } else if (cflags & EJS_BLEND_COND_ASSIGN) {
                    /* Do nothing */;

                } else {
                    /* Default is assign */
                    ejsSetPropertyByName(ejs, dest, trimmedName, ejsClone(ejs, vp, deep));
                }
            } else {
                /* Assign */
                ejsSetPropertyByName(ejs, dest, trimmedName, vp);
            }

        } else {
            /* 
                NOTE: non-combine blend treats arrays as primitive types 
             */
            if (deep && !ejsIs(ejs, vp, Array) && !ejsIsXML(ejs, vp) && ejsGetLength(ejs, vp) > 0) {
                if ((dp = ejsGetPropertyByName(ejs, dest, qname)) == 0 || ejsGetLength(ejs, dp) == 0) {
                    ejsSetPropertyByName(ejs, dest, qname, ejsClonePot(ejs, vp, deep));
                } else {
                    ejsBlendObject(ejs, dp, vp, flags);
                }
            } else {
                /*  Primitive type (including arrays) */
                if (overwrite) {
                    ejsSetPropertyByName(ejs, dest, qname, vp);
                } else if (ejsLookupProperty(ejs, dest, qname) < 0) {
                    ejsSetPropertyByName(ejs, dest, qname, vp);
                }
            }
        }
    }
    return 0;
}


/*     
    Parse the input and convert to a primitive type
    static function parse(input: String, preferredType: Type = null): void
 */
static EjsObj *g_parse(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *input;
    int         preferred;

    input = (EjsString*) argv[0];
    if (argc == 2 && !ejsIsType(ejs, argv[1])) {
        ejsThrowArgError(ejs, "PreferredType argument is not a type");
        return 0;
    }
    preferred = (argc == 2) ? ((EjsType*) argv[1])->sid : -1;
    return ejsParse(ejs, input->value, preferred);
}


/*
    Parse the input as an integer
    static function parseInt(input: String, radix: Number = 10): Number
    Formats:
        [(+|-)][0][OCTAL_DIGITS]
        [(+|-)][0][(x|X)][HEX_DIGITS]
        [(+|-)][DIGITS]
 */
static EjsNumber *g_parseInt(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   n;
    cchar       *str;
    int         radix, err;

    str = ejsToMulti(ejs, argv[0]);
    radix = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    while (isspace((uchar) *str)) {
        str++;
    }
    if (*str == '-' || *str == '+' || isdigit((uchar) *str)) {
        n = (MprNumber) stoiradix(str, radix, &err);
        if (err) {
            return ESV(nan);
        }
        return ejsCreateNumber(ejs, n);
    }
    return ESV(nan);
}


/*  
    Print the arguments to the standard output with a new line.
    static function print(...args): void
    DEPRECATED static function output(...args): void
 */
static EjsObj *g_printLine(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *s;
    EjsObj      *args, *vp;
    cchar       *data;
    int         i, count;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = argv[0];
    count = ejsGetLength(ejs, args);

    for (i = 0; i < count; i++) {
        if ((vp = ejsGetProperty(ejs, args, i)) != 0) {
            s  = (ejsIs(ejs, vp, String)) ? (EjsString*) vp : (EjsString*) ejsToString(ejs, vp);
            if (ejs->exception) {
                return 0;
            }
            data = ejsToMulti(ejs, s);
            if (write(1, (char*) data, (int) strlen(data)) < 0) {}
            if ((i+1) < count) {
                if (write(1, " ", 1) < 0) {}
            }
        }
    }
    if (write(1, "\n", 1) < 0) {}
    return 0;
}


static EjsString *g_base64(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *bstring;
    char        *str;

    bstring = ejsToString(ejs, argv[0]);
    str = ejsToMulti(ejs, bstring);
    return ejsCreateStringFromAsc(ejs, mprEncode64Block(str, bstring->length));
}


PUBLIC void ejsFreezeGlobal(Ejs *ejs)
{
    EjsTrait    *trait;
    int         i;

    for (i = 0; i < ES_global_NUM_CLASS_PROP; i++) {
        if ((trait = ejsGetPropertyTraits(ejs, ejs->global, i)) != 0) {
            ejsSetPropertyTraits(ejs, ejs->global, i, NULL, trait->attributes | EJS_TRAIT_READONLY | EJS_TRAIT_FIXED);
        }
    }
}


PUBLIC void ejsCreateGlobalNamespaces(Ejs *ejs)
{
    ejsAddImmutable(ejs, S_iteratorSpace, EN("iterator"), 
        ejsCreateNamespace(ejs, ejsCreateStringFromAsc(ejs, EJS_ITERATOR_NAMESPACE)));
    ejsAddImmutable(ejs, S_publicSpace, EN("public"), 
        ejsCreateNamespace(ejs, ejsCreateStringFromAsc(ejs, EJS_PUBLIC_NAMESPACE)));
    ejsAddImmutable(ejs, S_ejsSpace, EN("ejs"), 
        ejsCreateNamespace(ejs, ejsCreateStringFromAsc(ejs, EJS_EJS_NAMESPACE)));
    ejsAddImmutable(ejs, S_emptySpace, EN("empty"), 
        ejsCreateNamespace(ejs, ejsCreateStringFromAsc(ejs, EJS_EMPTY_NAMESPACE)));
}


PUBLIC void ejsDefineGlobalNamespaces(Ejs *ejs)
{
    /*  
        Order matters here. This is the (reverse) order of lookup.
        Empty is first to maximize speed of searching dynamic properties. Ejs second to maximize builtin lookups.
     */
    ejsAddNamespaceToBlock(ejs, ejs->global, ESV(iteratorSpace));
    ejsAddNamespaceToBlock(ejs, ejs->global, ESV(publicSpace));
    ejsAddNamespaceToBlock(ejs, ejs->global, ESV(ejsSpace));
    ejsAddNamespaceToBlock(ejs, ejs->global, ESV(emptySpace));
}


PUBLIC void ejsConfigureGlobalBlock(Ejs *ejs)
{
    EjsBlock    *block;

    block = (EjsBlock*) ejs->global;
    assert(block);
    
    ejsSetProperty(ejs, ejs->global, ES_global, ejs->global);
    ejsSetProperty(ejs, ejs->global, ES_void, ESV(Void));
    ejsSetProperty(ejs, ejs->global, ES_undefined, ESV(undefined));
    ejsSetProperty(ejs, ejs->global, ES_null, ESV(null));
    ejsSetProperty(ejs, ejs->global, ES_global, ejs->global);
    ejsSetProperty(ejs, ejs->global, ES_NegativeInfinity, ESV(negativeInfinity));
    ejsSetProperty(ejs, ejs->global, ES_Infinity, ESV(infinity));
    ejsSetProperty(ejs, ejs->global, ES_NaN, ESV(nan));
    ejsSetProperty(ejs, ejs->global, ES_double, ESV(Number));
    ejsSetProperty(ejs, ejs->global, ES_num, ESV(Number));
    ejsSetProperty(ejs, ejs->global, ES_boolean, ESV(Boolean));
    ejsSetProperty(ejs, ejs->global, ES_string, ESV(String));
    ejsSetProperty(ejs, ejs->global, ES_true, ESV(true));
    ejsSetProperty(ejs, ejs->global, ES_false, ESV(false));

    ejsBindFunction(ejs, block, ES_assert, g_assert);
    ejsBindFunction(ejs, block, ES_cloneBase, g_cloneBase);
    ejsBindFunction(ejs, block, ES_eval, g_eval);
    ejsBindFunction(ejs, block, ES_hashcode, g_hashcode);
    ejsBindFunction(ejs, block, ES_load, g_load);
    ejsBindFunction(ejs, block, ES_md5, g_md5);
    ejsBindFunction(ejs, block, ES_blend, g_blend);
    ejsBindFunction(ejs, block, ES_parse, g_parse);
    ejsBindFunction(ejs, block, ES_parseInt, g_parseInt);
    ejsBindFunction(ejs, block, ES_print, g_printLine);
    ejsBindFunction(ejs, block, ES_base64, g_base64);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsHttp.c"
 */
/************************************************************************/

/**
    ejsHttp.c - Http client class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/**************************** Forward Declarations ****************************/

static EjsDate  *getDateHeader(Ejs *ejs, EjsHttp *hp, cchar *key);
static EjsString *getStringHeader(Ejs *ejs, EjsHttp *hp, cchar *key);
static void     httpEvent(HttpConn *conn, MprEvent *event);
static void     httpEventChange(HttpConn *conn, int event, int arg);
static void     prepForm(Ejs *ejs, EjsHttp *hp, cchar *prefix, EjsObj *data);
static ssize    readHttpData(Ejs *ejs, EjsHttp *hp, ssize count);
static void     sendHttpCloseEvent(Ejs *ejs, EjsHttp *hp);
static void     sendHttpErrorEvent(Ejs *ejs, EjsHttp *hp);
static EjsHttp  *startHttpRequest(Ejs *ejs, EjsHttp *hp, char *method, int argc, EjsObj **argv);
static bool     waitForResponseHeaders(EjsHttp *hp);
static bool     waitForState(EjsHttp *hp, int state, MprTicks timeout, int throw);
static ssize    writeHttpData(Ejs *ejs, EjsHttp *hp);

/************************************ Methods *********************************/
/*  
    function Http(uri: Uri = null)
 */
static EjsHttp *httpConstructor(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ejsLoadHttpService(ejs);
    hp->ejs = ejs;

    if ((hp->conn = httpCreateConn(ejs->http, NULL, ejs->dispatcher)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    httpSetConnData(hp->conn, ejs);
    httpPrepClientConn(hp->conn, 0);
    httpSetConnNotifier(hp->conn, httpEventChange);
    httpSetConnContext(hp->conn, hp);
    if (argc == 1 && ejsIs(ejs, argv[0], Null)) {
        hp->uri = httpUriToString(((EjsUri*) argv[0])->uri, HTTP_COMPLETE_URI);
    }
    hp->method = sclone("GET");
    hp->requestContent = mprCreateBuf(ME_MAX_BUFFER, -1);
    hp->responseContent = mprCreateBuf(ME_MAX_BUFFER, -1);
    return hp;
}


/*  
    function get async(): Boolean
 */
static EjsBoolean *http_async(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return httpGetAsync(hp->conn) ? ESV(true) : ESV(false);
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *http_set_async(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;
    int         async;

    conn = hp->conn;
    async = (argv[0] == ESV(true));
    httpSetAsync(conn, async);
    httpSetIOCallback(conn, httpEvent);
    return 0;
}


#if ES_Http_available
/*  
    function get available(): Number
    DEPRECATED 1.0.0B3 (11/09)
 */
static EjsNumber *http_available(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprOff      len;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    len = httpGetContentLength(hp->conn);
    if (len > 0) {
        return ejsCreateNumber(ejs, (MprNumber) len);
    }
    /* Probably should be returning null here */
    return (EjsNumber*) ESV(minusOne);
}
#endif


/*
    function get ca(): String
 */
static EjsString *http_ca(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->caFile) {
        return ejsCreateStringFromAsc(ejs, hp->caFile);
    }
    return ESV(null);
}


/*  
    function set setCertificate(value: String): Void
 */
static EjsObj *http_set_ca(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->caFile = argv[0] == ESV(null) ? 0 : ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function close(): Void
 */
static EjsObj *http_close(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn) {
        if (hp->conn->state > HTTP_STATE_BEGIN) {
            httpFinalize(hp->conn);
        }
        sendHttpCloseEvent(ejs, hp);
        httpDestroyConn(hp->conn);
        hp->conn = httpCreateConn(ejs->http, NULL, ejs->dispatcher);
        httpPrepClientConn(hp->conn, 0);
        httpSetConnNotifier(hp->conn, httpEventChange);
        httpSetConnContext(hp->conn, hp);
    }
    return 0;
}


/*  
    function connect(method: String, url = null, data ...): Http
 */
static EjsHttp *http_connect(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->method = ejsToMulti(ejs, argv[0]);
    return startHttpRequest(ejs, hp, NULL, argc - 1, &argv[1]);
}


/*
    function get certificate(): String
 */
static EjsString *http_certificate(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->certFile) {
        return ejsCreateStringFromAsc(ejs, hp->certFile);
    }
    return ESV(null);
}


/*  
    function set setCertificate(value: String): Void
 */
static EjsObj *http_set_certificate(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->certFile = argv[0] == ESV(null) ? 0 : ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function get contentLength(): Number
 */
static EjsNumber *http_contentLength(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprOff      length;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    length = httpGetContentLength(hp->conn);
    return ejsCreateNumber(ejs, (MprNumber) length);
}


/*  
    function get contentType(): String
 */
static EjsString *http_contentType(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getStringHeader(ejs, hp, "CONTENT-TYPE");
}


/*  
    function get date(): Date
 */
static EjsDate *http_date(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getDateHeader(ejs, hp, "DATE");
}


/*  
    function finalize(): Void
 */
static EjsObj *http_finalize(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn) {
        httpFinalizeOutput(hp->conn);
        httpFlush(hp->conn);
    }
    return 0;
}


/*  
    function get finalized(): Boolean
 */
static EjsBoolean *http_finalized(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn) {
        return ejsCreateBoolean(ejs, hp->conn->tx->finalizedOutput);
    }
    return ESV(false);
}


/*  
    function flush(dir: Number = Stream.WRITE): Void
 */
static EjsObj *http_flush(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     dir;

    dir = (argc == 1) ? ejsGetInt(ejs, argv[0]) : EJS_STREAM_WRITE;
    if (dir & EJS_STREAM_WRITE) {
        httpFlush(hp->conn);
    }
    return 0;
}


/*  
    function form(uri: String = null, formData: Object = null): Http
    Issue a POST method with form data
 */
static EjsHttp *http_form(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsObj  *data;

    if (argc == 2 && !ejsIs(ejs, argv[1], Null)) {
        /*
            Prep here to reset the state. The ensures the current headers will be preserved.
            Users may have called setHeader to define custom headers. Users must call reset if they want to clear 
            prior headers.
         */
        httpPrepClientConn(hp->conn, 1);
        mprFlushBuf(hp->requestContent);
        data = argv[1];
        if (ejsGetLength(ejs, data) > 0) {
            prepForm(ejs, hp, NULL, data);
        } else {
            mprPutStringToBuf(hp->requestContent, ejsToMulti(ejs, data));
        }
        mprAddNullToBuf(hp->requestContent);
        httpSetHeader(hp->conn, "Content-Type", "application/x-www-form-urlencoded");
        /* Ensure this gets recomputed */
        httpRemoveHeader(hp->conn, "Content-Length");
    }
    return startHttpRequest(ejs, hp, "POST", argc, argv);
}


/*  
    function get followRedirects(): Boolean
 */
static EjsBoolean *http_followRedirects(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, hp->conn->followRedirects);
}


/*  
    function set followRedirects(flag: Boolean): Void
 */
static EjsObj *http_set_followRedirects(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpFollowRedirects(hp->conn, ejsGetBoolean(ejs, argv[0]));
    return 0;
}


/*  
    function get(uri: String = null, ...data): Http
    The spec allows GET methods to have body data, but is rarely, if ever, used.
 */
static EjsHttp *http_get(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    startHttpRequest(ejs, hp, "GET", argc, argv);
    if (!ejs->exception && hp->conn) {
        httpFinalizeOutput(hp->conn);
        httpFlush(hp->conn);
    }
    return hp;
}


/*  
    Return the (proposed) request headers
    function getRequestHeaders(): Object
 */
static EjsPot *http_getRequestHeaders(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprKey          *kp;
    HttpConn        *conn;
    EjsPot          *headers;

    conn = hp->conn;
    headers = ejsCreateEmptyPot(ejs);
    for (kp = 0; conn->tx && (kp = mprGetNextKey(conn->tx->headers, kp)) != 0; ) {
        ejsSetPropertyByName(ejs, headers, EN(kp->key), ejsCreateStringFromAsc(ejs, kp->data));
    }
    return headers;
}


/*  
    function head(uri: String = null): Http
 */
static EjsHttp *http_head(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "HEAD", argc, argv);
}


/*  
    function header(key: String): String
 */
static EjsString *http_header(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsString   *result;
    cchar       *value;
    char        *str;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    str = slower(ejsToMulti(ejs, argv[0]));
    value = httpGetHeader(hp->conn, str);
    if (value) {
        result = ejsCreateStringFromAsc(ejs, value);
    } else {
        result = ESV(null);
    }
    return result;
}


/*  
    function get headers(): Object
 */
static EjsPot *http_headers(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprHash         *hash;
    MprKey          *kp;
    EjsPot          *results;
    int             i;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    results = ejsCreateEmptyPot(ejs);
    hash = httpGetHeaderHash(hp->conn);
    if (hash == 0) {
        return results;
    }
    for (i = 0, kp = mprGetFirstKey(hash); kp; kp = mprGetNextKey(hash, kp), i++) {
        ejsSetPropertyByName(ejs, results, EN(kp->key), ejsCreateStringFromAsc(ejs, kp->data));
    }
    return results;
}


/*
    function get info(): Object
 */
static EjsObj *http_info(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsObj  *obj;
    char    *key, *next, *value;

    if (hp->conn && hp->conn->sock) {
        obj = ejsCreateEmptyPot(ejs);
        for (key = stok(mprGetSocketState(hp->conn->sock), ",", &next); key; key = stok(NULL, ",", &next)) {
            stok(key, "=", &value);
            ejsSetPropertyByName(ejs, obj, EN(key), ejsCreateStringFromAsc(ejs, value));
        }
        return obj;
    }
    return ESV(null);
}


/*  
    function get isSecure(): Boolean
 */
static EjsBoolean *http_isSecure(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, hp->conn->secure);
}


/*  
    function get key(): String
 */
static EjsAny *http_key(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->keyFile) {
        return ejsCreateStringFromAsc(ejs, hp->keyFile);
    }
    return ESV(null);
}


/*  
    function set key(keyFile: String): Void
 */
static EjsObj *http_set_key(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->keyFile = argv[0] == ESV(null) ? 0 : ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function get lastModified(): Date
 */
static EjsDate *http_lastModified(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getDateHeader(ejs, hp, "LAST-MODIFIED");
}


/*
    function get limits(): Object
 */
static EjsObj *http_limits(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->limits == 0) {
        hp->limits = (EjsObj*) ejsCreateEmptyPot(ejs);
        ejsGetHttpLimits(ejs, hp->limits, hp->conn->limits, 0);
    }
    return hp->limits;
}


/*  
    function get method(): String
 */
static EjsString *http_method(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, hp->method);
}


/*  
    function set method(value: String): Void
 */
static EjsObj *http_set_method(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    cchar    *method;

    method = ejsToMulti(ejs, argv[0]);
    if (strcmp(method, "DELETE") != 0 && strcmp(method, "GET") != 0 &&  strcmp(method, "HEAD") != 0 &&
            strcmp(method, "OPTIONS") != 0 && strcmp(method, "POST") != 0 && strcmp(method, "PUT") != 0 &&
            strcmp(method, "TRACE") != 0) {
        ejsThrowArgError(ejs, "Unknown HTTP method");
        return 0;
    }
    hp->method = ejsToMulti(ejs, argv[0]);
    return 0;
}


/*
    function off(name, observer: function): Void
 */
static EjsObj *http_off(Ejs *ejs, EjsHttp *hp, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, hp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function on(name, observer: function): Http
 */
static EjsHttp *http_on(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsFunction     *observer;
    HttpConn        *conn;

    observer = (EjsFunction*) argv[1];
    if (observer->boundThis == 0 || observer->boundThis == ejs->global) {
        observer->boundThis = hp;
    }
    ejsAddObserver(ejs, &hp->emitter, argv[0], observer);

    conn = hp->conn;
    if (conn->readq && conn->readq->count > 0) {
        ejsSendEvent(ejs, hp->emitter, "readable", NULL, hp);
    }
    //  TODO - don't need to test finalizedConnector
    if (!conn->tx->finalizedConnector && !conn->error && HTTP_STATE_CONNECTED <= conn->state && 
            conn->state < HTTP_STATE_FINALIZED && conn->writeq->ioCount == 0) {
        httpNotify(conn, HTTP_EVENT_WRITABLE, 0);
    }
    return hp;
}


/*
    function post(uri: String = null, ...requestContent): Http
 */
static EjsHttp *http_post(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "POST", argc, argv);
}


/*
    function get provider(): String
 */
static EjsString *http_provider(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    cchar   *name;

    if (hp->ssl && hp->ssl->provider) {
        name = hp->ssl->provider->name;
    } else {
        name = MPR->socketService->sslProvider;
    }
    return ejsCreateStringFromAsc(ejs, name);
}


/*
    function set provider(name: String): Void
 */
static EjsObj *http_set_provider(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (!hp->ssl) {
        hp->ssl = mprCreateSsl(0);
    }
    mprSetSslProvider(hp->ssl, ejsToMulti(ejs, argv[0]));
    return 0;
}


/*
    function get providers(): Array
 */
static EjsArray *http_providers(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsArray    *result;
    int         i;

    result = ejsCreateArray(ejs, 0);
    i = 0;
#if ME_COM_EST
    ejsSetProperty(ejs, result, i++, ejsCreateStringFromAsc(ejs, "est"));
#endif
#if ME_COM_OPENSSL
    ejsSetProperty(ejs, result, i++, ejsCreateStringFromAsc(ejs, "openssl"));
#endif
#if ME_COM_MATRIXSSL
    ejsSetProperty(ejs, result, i++, ejsCreateStringFromAsc(ejs, "matrixssl"));
#endif
#if ME_COM_MOCANA
    ejsSetProperty(ejs, result, i++, ejsCreateStringFromAsc(ejs, "mocana"));
#endif
    return result;
}


/*  
    function put(uri: String = null, form object): Http
 */
static EjsHttp *http_put(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "PUT", argc, argv);
}


/*  
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
    Returns a count of bytes read. Non-blocking if a callback is defined. Otherwise, blocks.

    Offset: -1 then read to the buffer write position, >= 0 then read to that offset
    count: -1 then read as much as the buffer will hold. If buffer is growable, read all content. If not growable, 
        read the buffer size. If count >= 0, then read that number of bytes.
 */
static EjsNumber *http_read(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    HttpConn        *conn;
    MprOff          contentLength;
    ssize           offset, count;

    conn = hp->conn;
    buffer = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]): -1;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    contentLength = httpGetContentLength(conn);
    if (conn->state >= HTTP_STATE_PARSED && contentLength == hp->readCount) {
        /* End of input */
        return ESV(null);
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset < buffer->size) {
        ejsSetByteArrayPositions(ejs, buffer, offset, offset);
    } else {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    }
    if (count < 0 && !buffer->resizable) {
        count = buffer->size - offset;
    }
    if ((count = readHttpData(ejs, hp, count)) < 0) {
        assert(ejs->exception);
        return 0;
    } else if (count == 0 && conn->state > HTTP_STATE_CONTENT) {
        return ESV(null);
    }
    hp->readCount += count;
    if (ejsCopyToByteArray(ejs, buffer, offset, (char*) mprGetBufStart(hp->responseContent), count) != count) {
        ejsThrowMemoryError(ejs);
    }
    ejsSetByteArrayPositions(ejs, buffer, -1, buffer->writePosition + count);
    mprAdjustBufStart(hp->responseContent, count);
    mprResetBufIfEmpty(hp->responseContent);
    return ejsCreateNumber(ejs, (MprNumber) count);
}


/*  
    function readString(count: Number = -1): String
    Read count bytes (default all) of content as a string. This always starts at the first character of content.
 */
static EjsString *http_readString(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsString   *result;
    ssize       count;
    
    count = (argc == 1) ? ejsGetInt(ejs, argv[0]) : -1;
    if (!waitForState(hp, HTTP_STATE_CONTENT, -1, 1)) {
        return 0;
    }
    if ((count = readHttpData(ejs, hp, count)) < 0) {
        assert(ejs->exception);
        return 0;
    } else if (count == 0 && hp->conn->state > HTTP_STATE_CONTENT) {
        return ESV(null);
    }
    //  UNICODE ENCODING
    result = ejsCreateStringFromMulti(ejs, mprGetBufStart(hp->responseContent), count);
    mprAdjustBufStart(hp->responseContent, count);
    mprResetBufIfEmpty(hp->responseContent);
    return result;
}


/*  
    function reset(): Void
 */
static EjsObj *http_reset(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpResetCredentials(hp->conn);
    httpPrepClientConn(hp->conn, 0);
    return 0;
}


/*  
    function get response(): String
 */
static EjsString *http_response(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsAny  *response;

    if (hp->responseCache) {
        return hp->responseCache;
    }
    if ((response = http_readString(ejs, hp, argc, argv)) == ESV(null)) {
        return ESV(empty);
    }
    hp->responseCache = (EjsString*) response;
    return hp->responseCache;
}


/*  
    function set response(data: String): Void
 */
static EjsObj *http_set_response(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->responseCache = (EjsString*) argv[0];
    return 0;
}


/*  
    function get retries(): Number
 */
static EjsNumber *http_retries(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, hp->conn->retries);
}


/*  
    function set retries(count: Number): Void
 */
static EjsObj *http_set_retries(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpSetRetries(hp->conn, ejsGetInt(ejs, argv[0]));
    return 0;
}


/*  
    function setCredentials(username: String?, password: String?, authType: String?): Void
 */
static EjsObj *http_setCredentials(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    cchar   *authType, *password, *user;

    user = (argc <= 0) ? 0 : ejsToMulti(ejs, argv[0]);
    password = (argc <= 1) ? 0 : ejsToMulti(ejs, argv[1]);
    authType = (argc <= 2) ? 0 : ejsToMulti(ejs, argv[2]);
    if (ejsIs(ejs, argv[0], Null)) {
        httpResetCredentials(hp->conn);
    } else {
        httpSetCredentials(hp->conn, user, password, authType);
    }
    return 0;
}


/*  
    function setHeader(key: String, value: String, overwrite: Boolean = true): Void
 */
static EjsObj *http_setHeader(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;
    cchar       *key, *value;
    bool        overwrite;

    assert(argc >= 2);

    conn = hp->conn;
    if (conn->state >= HTTP_STATE_CONNECTED) {
        ejsThrowArgError(ejs, "Cannot update request headers once the request has started");
        return 0;
    }
    key = ejsToMulti(ejs, argv[0]);
    value = ejsToMulti(ejs, argv[1]);
    overwrite = (argc == 3) ? ejsGetBoolean(ejs, argv[2]) : 1;
    if (overwrite) {
        httpSetHeaderString(hp->conn, key, value);
    } else {
        httpAppendHeaderString(hp->conn, key, value);
    }
    return 0;
}


/*  
    function set limits(limits: Object): Void
 */
static EjsObj *http_setLimits(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->conn->limits == ejs->http->clientLimits) {
        httpSetUniqueConnLimits(hp->conn);
    }
    if (hp->limits == 0) {
        hp->limits = (EjsObj*) ejsCreateEmptyPot(ejs);
        ejsGetHttpLimits(ejs, hp->limits, hp->conn->limits, 0);
    }
    ejsBlendObject(ejs, hp->limits, argv[0], EJS_BLEND_OVERWRITE);
    ejsSetHttpLimits(ejs, hp->conn->limits, hp->limits, 0);
    return 0;
}


static int getNumOption(Ejs *ejs, EjsObj *options, cchar *field)
{
    EjsObj      *obj;

    if ((obj = ejsGetPropertyByName(ejs, options, EN(field))) != 0) {
        return ejsGetInt(ejs, obj);
    }
    return -1;
}


static void setupTrace(Ejs *ejs, HttpTrace *trace, int dir, EjsObj *options)
{
    EjsArray    *extensions;
    EjsObj      *ext;
    HttpTrace   *tp;
    int         i, level, *levels;

    tp = &trace[dir];
    levels = tp->levels;
    if ((level = getNumOption(ejs, options, "all")) >= 0) {
        for (i = 0; i < HTTP_TRACE_MAX_ITEM; i++) {
            levels[i] = level;
        }
    } else {
        levels[HTTP_TRACE_CONN] = getNumOption(ejs, options, "conn");
        levels[HTTP_TRACE_FIRST] = getNumOption(ejs, options, "first");
        levels[HTTP_TRACE_HEADER] = getNumOption(ejs, options, "headers");
        levels[HTTP_TRACE_BODY] = getNumOption(ejs, options, "body");
    }
    tp->size = getNumOption(ejs, options, "size");
    if ((extensions = (EjsArray*) ejsGetPropertyByName(ejs, options, EN("include"))) != 0) {
        if (!ejsIs(ejs, extensions, Array)) {
            ejsThrowArgError(ejs, "include is not an array");
            return;
        }
        tp->include = mprCreateHash(0, 0);
        for (i = 0; i < extensions->length; i++) {
            if ((ext = ejsGetProperty(ejs, extensions, i)) != 0) {
                mprAddKey(tp->include, ejsToMulti(ejs, ejsToString(ejs, ext)), "");
            }
        }
    }
    if ((extensions = (EjsArray*) ejsGetPropertyByName(ejs, options, EN("exclude"))) != 0) {
        if (!ejsIs(ejs, extensions, Array)) {
            ejsThrowArgError(ejs, "exclude is not an array");
            return;
        }
        tp->exclude = mprCreateHash(0, 0);
        for (i = 0; i < extensions->length; i++) {
            if ((ext = ejsGetProperty(ejs, extensions, i)) != 0) {
                mprAddKey(tp->exclude, ejsToMulti(ejs, ejsToString(ejs, ext)), MPR->emptyString);
            }
        }
    }
}


PUBLIC int ejsSetupHttpTrace(Ejs *ejs, HttpTrace *trace, EjsObj *options)
{
    EjsObj      *rx, *tx;

    if ((rx = ejsGetPropertyByName(ejs, options, EN("rx"))) != 0) {
        setupTrace(ejs, trace, HTTP_TRACE_RX, rx);
    }
    if ((tx = ejsGetPropertyByName(ejs, options, EN("tx"))) != 0) {
        setupTrace(ejs, trace, HTTP_TRACE_TX, tx);
    }
    return 0;
}


/*  
    function trace(options): Void
 */
static EjsObj *http_trace(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ejsSetupHttpTrace(ejs, hp->conn->trace, argv[0]);
    return 0;
}


/*  
    function get status(): Number
 */
static EjsNumber *http_status(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     code;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    code = httpGetStatus(hp->conn);
    if (code <= 0) {
        return ESV(null);
    }
    return ejsCreateNumber(ejs, code);
}


/*  
    function get statusMessage(): String
 */
static EjsString *http_statusMessage(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    conn = hp->conn;
    if (conn->errorMsg) {
        return ejsCreateStringFromAsc(ejs, conn->errorMsg);
    }
    return ejsCreateStringFromAsc(ejs, httpGetStatusMessage(hp->conn));
}


/*  
    function get uri(): Uri
 */
static EjsUri *http_uri(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return ejsCreateUriFromAsc(ejs, hp->uri);
}


/*  
    function set uri(newUri: Uri): Void
 */
static EjsObj *http_set_uri(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->uri = httpUriToString(((EjsUri*) argv[0])->uri, HTTP_COMPLETE_URI);
    return 0;
}


/*
    function get verify(): Boolean
 */
static EjsBoolean *http_verify(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (!hp->ssl) {
        hp->ssl = mprCreateSsl(0);
    }
    return hp->ssl->verifyPeer ?  ESV(true) : ESV(false);
}


/*  
    function set verify(on: Boolean): Void
 */
static EjsObj *http_set_verify(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     verify;

    verify = (argv[0] == ESV(true));
    if (!hp->ssl) {
        hp->ssl = mprCreateSsl(0);
    }
    mprVerifySslIssuer(hp->ssl, verify);
    mprVerifySslPeer(hp->ssl, verify);
    return 0;
}


/*
    function get verifyIssuer(): Boolean
 */
static EjsBoolean *http_verifyIssuer(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (!hp->ssl) {
        hp->ssl = mprCreateSsl(0);
    }
    return hp->ssl->verifyIssuer ?  ESV(true) : ESV(false);
}


/*  
    function set verifyIssuer(on: Boolean): Void
 */
static EjsObj *http_set_verifyIssuer(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     verifyIssuer;

    verifyIssuer = (argv[0] == ESV(true));
    if (!hp->ssl) {
        hp->ssl = mprCreateSsl(0);
    }
    mprVerifySslIssuer(hp->ssl, verifyIssuer);
    return 0;
}


/*  
    Wait for a request to complete. Timeout is in msec. Timeout < 0 means use default inactivity and request timeouts.
    Timeout of zero means no timeout.

    function wait(timeout: Number = -1): Boolean
 */
static EjsBoolean *http_wait(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprTicks    timeout;

    timeout = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : -1;
    if (timeout == 0) {
        timeout = MPR_MAX_TIMEOUT;
    }
    if (!waitForState(hp, HTTP_STATE_FINALIZED, timeout, 0)) {
        return ESV(false);
    }
    return ESV(true);
}


/*
    function write(...data): Void
 */
static EjsNumber *http_write(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ssize     nbytes;

    hp->data = ejsCreateByteArray(ejs, -1);
    if (ejsWriteToByteArray(ejs, hp->data, 1, &argv[0]) < 0) {
        return 0;
    }
    if ((nbytes = writeHttpData(ejs, hp)) < 0) {
        return 0;
    }
    hp->writeCount += nbytes;
    if (hp->conn->async) {
        if (ejsGetByteArrayAvailableData(hp->data) > 0) {
            httpEnableConnEvents(hp->conn);
        }
    }
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}


/*********************************** Support **********************************/
/*
    function [get|put|delete|post...](uri = null, ...data): Http
 */
static EjsHttp *startHttpRequest(Ejs *ejs, EjsHttp *hp, char *method, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *data;
    EjsNumber       *written;
    EjsUri          *uriObj;
    HttpConn        *conn;
    ssize           nbytes;

    conn = hp->conn;
    hp->responseCache = 0;
    hp->requestContentCount = 0;
    mprFlushBuf(hp->responseContent);

    if (argc >= 1 && !ejsIs(ejs, argv[0], Null)) {
        uriObj = (EjsUri*) argv[0];
        hp->uri = httpUriToString(uriObj->uri, HTTP_COMPLETE_URI);
    }
    if (argc == 2 && ejsIs(ejs, argv[1], Array)) {
        args = (EjsArray*) argv[1];
        if (args->length > 0) {
            data = ejsCreateByteArray(ejs, -1);
            written = ejsWriteToByteArray(ejs, data, 1, &argv[1]);
            mprPutBlockToBuf(hp->requestContent, (char*) data->value, (int) written->value);
            mprAddNullToBuf(hp->requestContent);
            assert(written > 0);
        }
    }
    if (hp->uri == 0) {
        ejsThrowArgError(ejs, "URL is not defined");
        return 0;
    }
    if (method && strcmp(hp->method, method) != 0) {
        hp->method = sclone(method);
    }
    if (hp->method == 0) {
        ejsThrowArgError(ejs, "HTTP Method is not defined");
        return 0;
    }
    if (hp->certFile) {
        if (!hp->ssl) {
            hp->ssl = mprCreateSsl(0);
        }
        mprSetSslCertFile(hp->ssl, hp->certFile);
        if (!hp->keyFile) {
            ejsThrowStateError(ejs, "Must define a Http.key to use with a certificate");
        }
        mprSetSslKeyFile(hp->ssl, hp->keyFile);
    }
    if (hp->caFile) {
        if (!hp->ssl) {
            hp->ssl = mprCreateSsl(0);
        }
        mprSetSslCaFile(hp->ssl, hp->caFile);
    }
    if (httpConnect(conn, hp->method, hp->uri, hp->ssl) < 0) {
        ejsThrowIOError(ejs, "Cannot issue request for \"%s\"", hp->uri);
        return 0;
    }
    if (mprGetBufLength(hp->requestContent) > 0) {
        nbytes = httpWriteBlock(conn->writeq, mprGetBufStart(hp->requestContent), mprGetBufLength(hp->requestContent), HTTP_BLOCK);
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Cannot write request data for \"%s\"", hp->uri);
            return 0;
        } else if (nbytes > 0) {
            assert(nbytes == mprGetBufLength(hp->requestContent));
            mprAdjustBufStart(hp->requestContent, nbytes);
            hp->requestContentCount += nbytes;
        }
        httpFinalizeOutput(conn);
        httpFlush(conn);
    }
    httpNotify(conn, HTTP_EVENT_WRITABLE, 0);
    if (conn->async) {
        httpEnableConnEvents(hp->conn);
    }
    return hp;
}


static void httpEventChange(HttpConn *conn, int event, int arg)
{
    Ejs         *ejs;
    EjsHttp     *hp;
    HttpTx      *tx;
    MprOff      lastWritten;

    hp = httpGetConnContext(conn);
    ejs = hp->ejs;
    tx = conn->tx;

    switch (event) {
    case HTTP_EVENT_STATE:
        switch (arg) {
        case HTTP_STATE_PARSED:
            if (hp->emitter) {
                ejsSendEvent(ejs, hp->emitter, "headers", NULL, hp);
            }
            break;

        case HTTP_STATE_FINALIZED:
            if (hp->emitter) {
                if (conn->error) {
                    sendHttpErrorEvent(ejs, hp);
                }
                sendHttpCloseEvent(ejs, hp);
            }
            break;
        }
        break;

    case HTTP_EVENT_READABLE:
        if (hp && hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "readable", NULL, hp);
        }
        break;

    case HTTP_EVENT_WRITABLE:
        if (hp && hp->emitter) {
            do {
                lastWritten = tx->bytesWritten;
                ejsSendEvent(ejs, hp->emitter, "writable", NULL, hp);
            } while (tx->bytesWritten > lastWritten && !tx->writeBlocked);
        }
        break;
    }
}


/*  
    Read the required number of bytes into the response content buffer. Count < 0 means transfer the entire content.
    Returns the number of bytes read. Returns null on EOF.
 */ 
static ssize readHttpData(Ejs *ejs, EjsHttp *hp, ssize count)
{
    MprBuf      *buf;
    HttpConn    *conn;
    ssize       len, space, nbytes;

    conn = hp->conn;
    buf = hp->responseContent;
    mprResetBufIfEmpty(buf);
    while (count < 0 || mprGetBufLength(buf) < count) {
        len = (count < 0) ? ME_MAX_BUFFER : (count - mprGetBufLength(buf));
        space = mprGetBufSpace(buf);
        if (space < len) {
            mprGrowBuf(buf, len - space);
        }
        if ((nbytes = httpRead(conn, mprGetBufEnd(buf), len)) < 0) {
            ejsThrowIOError(ejs, "Cannot read required data");
            return MPR_ERR_CANT_READ;
        }
        mprAdjustBufEnd(buf, nbytes);
        if (hp->conn->async || (nbytes == 0 && conn->state > HTTP_STATE_CONTENT)) {
            break;
        }
    }
    if (count < 0) {
        return mprGetBufLength(buf);
    }
    return min(count, mprGetBufLength(buf));
}


/* 
    Write another block of data
 */
static ssize writeHttpData(Ejs *ejs, EjsHttp *hp)
{
    EjsByteArray    *ba;
    HttpConn        *conn;
    ssize           count, nbytes;

    conn = hp->conn;
    ba = hp->data;
    nbytes = 0;
    if (ba && (count = ejsGetByteArrayAvailableData(ba)) > 0) {
        if (conn->tx->finalizedOutput) {
            ejsThrowIOError(ejs, "Cannot write to socket");
            return 0;
        }
        //  TODO - or should this be non-blocking
        nbytes = httpWriteBlock(conn->writeq, (cchar*) &ba->value[ba->readPosition], count, HTTP_BLOCK);
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Cannot write to socket");
            return 0;
        }
        ba->readPosition += nbytes;
    }
    httpServiceQueues(conn, HTTP_BLOCK);
    return nbytes;
}


/*  
    Respond to an IO event. This wraps the standard httpIOEvent() call.
 */
static void httpEvent(HttpConn *conn, MprEvent *event)
{
    EjsHttp     *hp;
    Ejs         *ejs;

    assert(conn->async);

    hp = conn->context;
    ejs = hp->ejs;

    httpIOEvent(conn, event);
    if (event->mask & MPR_WRITABLE) {
        if (hp->data) {
            writeHttpData(ejs, hp);
        }
    }
}


static EjsDate *getDateHeader(Ejs *ejs, EjsHttp *hp, cchar *key)
{
    MprTime     when;
    cchar       *value;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    value = httpGetHeader(hp->conn, key);
    if (value == 0) {
        return ESV(null);
    }
    if (mprParseTime(&when, value, MPR_UTC_TIMEZONE, NULL) < 0) {
        value = 0;
    }
    return ejsCreateDate(ejs, when);
}


static EjsString *getStringHeader(Ejs *ejs, EjsHttp *hp, cchar *key)
{
    cchar       *value;

    if (!waitForResponseHeaders(hp)) {
        return 0;
    }
    value = httpGetHeader(hp->conn, key);
    if (value == 0) {
        return ESV(null);
    }
    return ejsCreateStringFromAsc(ejs, value);
}


/*  
    Prepare form data as a series of key-value pairs. Data is formatted according to www-url-encoded specs by 
    mprSetHttpFormData. Objects are flattened into a one level key/value pairs. Keys can have embedded "." separators.
    E.g.  name=value&address=77%20Park%20Lane
 */
static void prepForm(Ejs *ejs, EjsHttp *hp, cchar *prefix, EjsObj *data)
{
    EjsName     qname;
    EjsObj      *vp;
    EjsString   *value;
    cchar       *key, *sep, *vstr;
    char        *encodedKey, *encodedValue, *newPrefix, *newKey;
    int         i, count;

    count = ejsGetLength(ejs, data);
    for (i = 0; i < count; i++) {
        if (ejsIs(ejs, data, Array)) {
            key = itos(i);
        } else {
            qname = ejsGetPropertyName(ejs, data, i);
            key = ejsToMulti(ejs, qname.name);
        }
        vp = ejsGetProperty(ejs, data, i);
        if (vp == 0) {
            continue;
        }
        if (ejsGetLength(ejs, vp) > 0) {
            if (prefix) {
                newPrefix = sfmt("%s.%s", prefix, key);
                prepForm(ejs, hp, newPrefix, vp);
            } else {
                prepForm(ejs, hp, key, vp);
            }
        } else {
            value = ejsToString(ejs, vp);
            sep = (mprGetBufLength(hp->requestContent) > 0) ? "&" : "";
            if (prefix) {
                newKey = sjoin(prefix, ".", key, NULL);
                encodedKey = mprUriEncode(newKey, MPR_ENCODE_URI_COMPONENT); 
            } else {
                encodedKey = mprUriEncode(key, MPR_ENCODE_URI_COMPONENT);
            }
            vstr = ejsToMulti(ejs, value);
            encodedValue = mprUriEncode(vstr, MPR_ENCODE_URI_COMPONENT);
            mprPutToBuf(hp->requestContent, "%s%s=%s", sep, encodedKey, encodedValue);
        }
    }
}

#if FUTURE && KEEP
/*  
    Prepare form data using json encoding. The objects are json encoded then URI encoded to be safe. 
 */
static void prepForm(Ejs *ejs, EjsHttp *hp, char *prefix, EjsObj *data)
{
    EjsName     qname;
    EjsObj      *vp;
    EjsString   *value;
    cchar       *key, *sep;
    char        *encodedKey, *encodedValue, *newPrefix, *newKey;
    int         i, count;

    jdata = ejsToJSON(ejs, data, NULL);
    if (prefix) {
        newKey = sjoin(prefix, ".", key, NULL);
        encodedKey = mprUriEncode(newKey, MPR_ENCODE_URI_COMPONENT); 
    } else {
        encodedKey = mprUriEncode(key, MPR_ENCODE_URI_COMPONENT);
    }
    encodedValue = mprUriEncode(value->value, MPR_ENCODE_URI_COMPONENT);
    mprPutToBuf(hp->requestContent, "%s%s=%s", sep, encodedKey, encodedValue);
}
#endif


#if FUTURE
static bool expired(EjsHttp *hp)
{
    int     requestTimeout, inactivityTimeout, diff, inactivity;

    requestTimeout = conn->limits->requestTimeout ? conn->limits->requestTimeout : MAXINT;
    inactivityTimeout = conn->limits->inactivityTimeout ? conn->limits->inactivityTimeout : MAXINT;

    /* 
        Workaround for a GCC bug when comparing two 64bit numerics directly. Need a temporary.
     */
    diff = (conn->lastActivity + inactivityTimeout) - http->now;
    inactivity = 1;
    if (diff > 0 && conn->rx) {
        diff = (conn->started + requestTimeout) - http->now;
        inactivity = 0;
    }
    if (diff < 0) {
        if (conn->rx) {
            if (inactivity) {
                mprTrace(4, "Inactive request timed out %s, exceeded inactivity timeout %d", 
                    conn->rx->uri, inactivityTimeout);
            } else {
                mprTrace(4, "Request timed out %s, exceeded timeout %d", conn->rx->uri, requestTimeout);
            }
        } else {
            mprTrace(4, "Idle connection timed out");
        }
    }
}
#endif


/*  
    Wait for the connection to acheive a requested state
    Timeout is in msec. Timeout of zero means don't wait. Timeout of < 0 means use standard inactivity and 
    duration timeouts.
 */
static bool waitForState(EjsHttp *hp, int state, MprTicks timeout, int throw)
{
    Ejs             *ejs;
    MprTicks        mark, remaining;
    HttpConn        *conn;
    HttpUri         *location, *uri;
    HttpRx          *rx;
    char            *url;
    int             count, redirectCount, success, rc;

    ejs = hp->ejs;
    conn = hp->conn;
    if (conn->state >= state) {
        return 1;
    }
    if (conn->state < HTTP_STATE_CONNECTED) {
        if (throw && ejs->exception == 0) {
            ejsThrowIOError(ejs, "Http request failed: not connected");
        }
        return 0;
    }
    if (!conn->async) {
        httpFinalizeOutput(conn);
    }
    httpFlush(conn);
    redirectCount = 0;
    success = count = 0;
    mark = mprGetTicks();
    remaining = timeout;
    while (conn->state < state && count <= conn->retries && redirectCount < 16 && !conn->error && 
            !ejs->exiting && !mprIsStopping(conn)) {
        count++;
        if ((rc = httpWait(conn, HTTP_STATE_PARSED, remaining)) == 0) {
            if (httpNeedRetry(conn, &url)) {
                if (url) {
                    httpRemoveHeader(conn, "Host");
                    location = httpCreateUri(url, 0);
                    uri = httpJoinUri(conn->tx->parsedUri, 1, &location);
                    hp->uri = httpUriToString(uri, HTTP_COMPLETE_URI);
                }
                count--; 
                redirectCount++;
            } else if (httpWait(conn, state, remaining) == 0) {
                success = 1;
                break;
            }
        } else {
            if (rc == MPR_ERR_CANT_CONNECT) {
                httpError(conn, HTTP_CODE_COMMS_ERROR, "Connection error");
            } else if (rc == MPR_ERR_TIMEOUT) {
                if (timeout > 0) {
                    httpError(conn, HTTP_CODE_REQUEST_TIMEOUT, "Request timed out");
                }
            } else {
                httpError(conn, HTTP_CODE_NO_RESPONSE, "Client request error");
            }
            /* Retry */
        }
        rx = conn->rx;
        if (rx) {
            if (rx->status == HTTP_CODE_REQUEST_TOO_LARGE || rx->status == HTTP_CODE_REQUEST_URL_TOO_LARGE ||
                (rx->status == HTTP_CODE_UNAUTHORIZED && conn->username == 0)) {
                /* No point retrying */
                break;
            }
        }
        if (hp->writeCount > 0) {
            /* Cannot auto-retry with manual writes */
            break;
        }
        if (timeout > 0) {
            remaining = mprGetRemainingTicks(mark, timeout);
            if (count > 0 && remaining <= 0) {
                break;
            }
        }
        if (hp->requestContentCount > 0) {
            mprAdjustBufStart(hp->requestContent, -hp->requestContentCount);
        }
        /* Force a new connection */
        if (rx == 0 || rx->status != HTTP_CODE_UNAUTHORIZED) {
            httpSetKeepAliveCount(conn, -1);
        }
        httpPrepClientConn(conn, 1);
        startHttpRequest(ejs, hp, NULL, 0, NULL);
        if (ejs->exception) {
            return 0;
        }
        if (!conn->async) {
            httpFinalizeOutput(conn);
            httpFlush(conn);
        }
    }
    if (!success) {
        if (throw && ejs->exception == 0) {
            ejsThrowIOError(ejs, "Http request failed: %s", (conn->errorMsg) ? conn->errorMsg : "");
        }
        return 0;
    }
    return 1;
}


/*  
    Wait till the response headers have been received. Safe in sync and async mode. Async mode never blocks.
    Timeout < 0 means use default inactivity timeout. Timeout of zero means wait forever.
 */
static bool waitForResponseHeaders(EjsHttp *hp)
{
    if (hp->conn->state < HTTP_STATE_CONNECTED) {
        return 0;
    }
    if (hp->conn->state < HTTP_STATE_PARSED && !waitForState(hp, HTTP_STATE_PARSED, -1, 1)) {
        return 0;
    }
    return 1;
}


/*
    Get limits:  obj[*] = limits
 */
PUBLIC void ejsGetHttpLimits(Ejs *ejs, EjsObj *obj, HttpLimits *limits, bool server) 
{
    ejsSetPropertyByName(ejs, obj, EN("chunk"), ejsCreateNumber(ejs, (MprNumber) limits->chunkSize));
    ejsSetPropertyByName(ejs, obj, EN("connReuse"), ejsCreateNumber(ejs, limits->keepAliveMax));
    ejsSetPropertyByName(ejs, obj, EN("receive"), ejsCreateNumber(ejs, (MprNumber) limits->receiveBodySize));
    ejsSetPropertyByName(ejs, obj, EN("transmission"), ejsCreateNumber(ejs, (MprNumber) limits->transmissionBodySize));
    ejsSetPropertyByName(ejs, obj, EN("upload"), ejsCreateNumber(ejs, (MprNumber) limits->uploadSize));
    ejsSetPropertyByName(ejs, obj, EN("inactivityTimeout"), 
        ejsCreateNumber(ejs, (MprNumber) (limits->inactivityTimeout / MPR_TICKS_PER_SEC)));
    ejsSetPropertyByName(ejs, obj, EN("requestTimeout"), 
        ejsCreateNumber(ejs, (MprNumber) (limits->requestTimeout / MPR_TICKS_PER_SEC)));
    ejsSetPropertyByName(ejs, obj, EN("sessionTimeout"), 
        ejsCreateNumber(ejs, (MprNumber) (limits->sessionTimeout / MPR_TICKS_PER_SEC)));

    if (server) {
        ejsSetPropertyByName(ejs, obj, EN("clients"), ejsCreateNumber(ejs, (MprNumber) limits->clientMax));
        ejsSetPropertyByName(ejs, obj, EN("connections"), ejsCreateNumber(ejs, (MprNumber) limits->connectionsMax));
        ejsSetPropertyByName(ejs, obj, EN("header"), ejsCreateNumber(ejs, (MprNumber) limits->headerSize));
        ejsSetPropertyByName(ejs, obj, EN("headers"), ejsCreateNumber(ejs, (MprNumber) limits->headerMax));
        ejsSetPropertyByName(ejs, obj, EN("requests"), ejsCreateNumber(ejs, (MprNumber) limits->requestsPerClientMax));
        ejsSetPropertyByName(ejs, obj, EN("stageBuffer"), ejsCreateNumber(ejs, (MprNumber) limits->bufferSize));
        ejsSetPropertyByName(ejs, obj, EN("uri"), ejsCreateNumber(ejs, (MprNumber) limits->uriSize));
    }
}


/*
    Set the limit field: 
        *limit = obj[field]
 */
static int64 setLimit(Ejs *ejs, EjsObj *obj, cchar *field, int factor)
{
    EjsObj      *vp;

    if ((vp = ejsGetPropertyByName(ejs, obj, EN(field))) != 0) {
        return ejsGetInt64(ejs, ejsToNumber(ejs, vp)) * factor;
    }
    return 0;
}


PUBLIC void ejsSetHttpLimits(Ejs *ejs, HttpLimits *limits, EjsObj *obj, bool server) 
{
    limits->chunkSize = (ssize) setLimit(ejs, obj, "chunk", 1);
    limits->inactivityTimeout = (int) setLimit(ejs, obj, "inactivityTimeout", MPR_TICKS_PER_SEC);
    limits->receiveBodySize = (MprOff) setLimit(ejs, obj, "receive", 1);
    //  TODO - need dedicated "form" limit
    limits->receiveFormSize = (MprOff) setLimit(ejs, obj, "receive", 1);
    limits->keepAliveMax = (int) setLimit(ejs, obj, "connReuse", 1);
    limits->requestTimeout = (int) setLimit(ejs, obj, "requestTimeout", MPR_TICKS_PER_SEC);
    limits->sessionTimeout = (int) setLimit(ejs, obj, "sessionTimeout", MPR_TICKS_PER_SEC);
    limits->transmissionBodySize = (MprOff) setLimit(ejs, obj, "transmission", 1);
    limits->uploadSize = (MprOff) setLimit(ejs, obj, "upload", 1);
    if (limits->requestTimeout <= 0) {
        limits->requestTimeout = MPR_MAX_TIMEOUT;
    }
    if (limits->inactivityTimeout <= 0) {
        limits->inactivityTimeout = MPR_MAX_TIMEOUT;
    }
    if (limits->sessionTimeout <= 0) {
        limits->sessionTimeout = MPR_MAX_TIMEOUT;
    }
    if (server) {
        limits->bufferSize = (ssize) setLimit(ejs, obj, "stageBuffer", 1);
        limits->clientMax = (int) setLimit(ejs, obj, "clients", 1);
        limits->connectionsMax = (int) setLimit(ejs, obj, "connections", 1);
        limits->requestsPerClientMax = (int) setLimit(ejs, obj, "requests", 1);
        limits->uriSize = (ssize) setLimit(ejs, obj, "uri", 1);
        limits->headerMax = (int) setLimit(ejs, obj, "headers", 1);
        limits->headerSize = (ssize) setLimit(ejs, obj, "header", 1);
    }
}


static void sendHttpCloseEvent(Ejs *ejs, EjsHttp *hp)
{
    if (!hp->closed && ejs->service) {
        hp->closed = 1;
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "close", NULL, hp);
        }
    }
}


static void sendHttpErrorEvent(Ejs *ejs, EjsHttp *hp)
{
    if (!hp->error) {
        hp->error = 1;
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "error", NULL, hp);
        }
    }
}


/*********************************** Factory **********************************/

/*  
    Manage the object properties for the garbage collector
 */
static void manageHttp(EjsHttp *hp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(hp->emitter);
        mprMark(hp->data);
        mprMark(hp->limits);
        mprMark(hp->responseCache);
        mprMark(hp->conn);
        mprMark(hp->ssl);
        mprMark(hp->requestContent);
        mprMark(hp->responseContent);
        mprMark(hp->uri);
        mprMark(hp->method);
        mprMark(hp->caFile);
        mprMark(hp->certFile);
        mprMark(TYPE(hp));

    } else if (flags & MPR_MANAGE_FREE) {
        if (hp->conn && !hp->conn->destroyed) {
            sendHttpCloseEvent(hp->ejs, hp);
            httpDestroyConn(hp->conn);
            hp->conn = 0;
        }
    }
}


PUBLIC void ejsConfigureHttpType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Http"), sizeof(EjsHttp), manageHttp, EJS_TYPE_OBJ)) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, httpConstructor);
#if ES_Http_providers
    ejsBindMethod(ejs, type, ES_Http_providers, http_providers);
#endif

    ejsBindAccess(ejs, prototype, ES_Http_async, http_async, http_set_async);
#if ES_Http_available
    /* DEPRECATED */
    ejsBindMethod(ejs, prototype, ES_Http_available, http_available);
#endif
    ejsBindAccess(ejs, prototype, ES_Http_ca, http_ca, http_set_ca);
    ejsBindMethod(ejs, prototype, ES_Http_close, http_close);
    ejsBindMethod(ejs, prototype, ES_Http_connect, http_connect);
    ejsBindAccess(ejs, prototype, ES_Http_certificate, http_certificate, http_set_certificate);
    ejsBindMethod(ejs, prototype, ES_Http_contentLength, http_contentLength);
    ejsBindMethod(ejs, prototype, ES_Http_contentType, http_contentType);
    ejsBindMethod(ejs, prototype, ES_Http_date, http_date);
    ejsBindMethod(ejs, prototype, ES_Http_finalize, http_finalize);
    ejsBindMethod(ejs, prototype, ES_Http_finalized, http_finalized);
    ejsBindMethod(ejs, prototype, ES_Http_flush, http_flush);
    ejsBindAccess(ejs, prototype, ES_Http_followRedirects, http_followRedirects, http_set_followRedirects);
    ejsBindMethod(ejs, prototype, ES_Http_form, http_form);
    ejsBindMethod(ejs, prototype, ES_Http_get, http_get);
    ejsBindMethod(ejs, prototype, ES_Http_getRequestHeaders, http_getRequestHeaders);
    ejsBindMethod(ejs, prototype, ES_Http_head, http_head);
    ejsBindMethod(ejs, prototype, ES_Http_header, http_header);
    ejsBindMethod(ejs, prototype, ES_Http_headers, http_headers);
    ejsBindMethod(ejs, prototype, ES_Http_isSecure, http_isSecure);
    ejsBindAccess(ejs, prototype, ES_Http_key, http_key, http_set_key);
    ejsBindMethod(ejs, prototype, ES_Http_lastModified, http_lastModified);
    ejsBindMethod(ejs, prototype, ES_Http_limits, http_limits);
    ejsBindAccess(ejs, prototype, ES_Http_method, http_method, http_set_method);
    ejsBindMethod(ejs, prototype, ES_Http_off, http_off);
    ejsBindMethod(ejs, prototype, ES_Http_on, http_on);
    ejsBindMethod(ejs, prototype, ES_Http_post, http_post);
    ejsBindAccess(ejs, prototype, ES_Http_provider, http_provider, http_set_provider);
    ejsBindMethod(ejs, prototype, ES_Http_put, http_put);
    ejsBindMethod(ejs, prototype, ES_Http_read, http_read);
    ejsBindMethod(ejs, prototype, ES_Http_readString, http_readString);
    ejsBindMethod(ejs, prototype, ES_Http_reset, http_reset);
    ejsBindAccess(ejs, prototype, ES_Http_response, http_response, http_set_response);
    ejsBindAccess(ejs, prototype, ES_Http_retries, http_retries, http_set_retries);
    ejsBindMethod(ejs, prototype, ES_Http_setCredentials, http_setCredentials);
    ejsBindMethod(ejs, prototype, ES_Http_setHeader, http_setHeader);
    ejsBindMethod(ejs, prototype, ES_Http_setLimits, http_setLimits);
    ejsBindAccess(ejs, prototype, ES_Http_info, http_info, NULL);
    ejsBindMethod(ejs, prototype, ES_Http_status, http_status);
    ejsBindMethod(ejs, prototype, ES_Http_statusMessage, http_statusMessage);
    ejsBindMethod(ejs, prototype, ES_Http_trace, http_trace);
    ejsBindAccess(ejs, prototype, ES_Http_uri, http_uri, http_set_uri);
    ejsBindAccess(ejs, prototype, ES_Http_verify, http_verify, http_set_verify);
    ejsBindAccess(ejs, prototype, ES_Http_verifyIssuer, http_verifyIssuer, http_set_verifyIssuer);
    ejsBindMethod(ejs, prototype, ES_Http_write, http_write);
    ejsBindMethod(ejs, prototype, ES_Http_wait, http_wait);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsIterator.c"
 */
/************************************************************************/

/**
    ejsIterator.c - Iterator class

    This provides a high performance iterator construction for native classes.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Code ************************************/
/*
    Call the supplied next() function to return the next enumerable item
 */
static EjsObj *nextIterator(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    if (ip->nativeNext) {
        return (ip->nativeNext)(ejs, ip, argc, argv);
    } else {
        ejsThrowStopIteration(ejs);
        return 0;
    }
}


PUBLIC EjsObj *ejsThrowStopIteration(Ejs *ejs)
{
#if FUTURE
    ejs->exception = ejs->iterator;
#else
    ejs->exception = ESV(StopIteration);
#endif
    ejsAttention(ejs);
    return ejs->exception;
}


/*********************************** Methods **********************************/
#if KEEP
/*
    Constructor to create an iterator using a scripted next().

    public function Iterator(obj, f, deep, ...namespaces)
 */
static EjsObj *iteratorConstructor(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    if (argc != 2 || !ejsIsFunction(ejs, argv[1])) {
        ejsThrowArgError(ejs, "usage: Iterator(obj, function)");
        return 0;
    }
    ip->target = argv[0];
    ip->next = (EjsFunction*) argv[1];
    assert(ip->nativeNext == 0);

    return ip;
}
#endif


/*********************************** Factory **********************************/
/*
    Create an iterator.
 */
PUBLIC EjsIterator *ejsCreateIterator(Ejs *ejs, EjsAny *obj, int length, void *nativeNext, bool deep, EjsArray *namespaces)
{
    EjsIterator     *ip;

    if ((ip = ejsCreateObj(ejs, ESV(Iterator), 0)) != 0) {
        ip->index = 0;
        ip->indexVar = 0;
        ip->nativeNext = nativeNext;
        ip->target = obj;
        ip->length = length;
        ip->deep = deep;
        ip->namespaces = namespaces;
    }
    return ip;
}


static void manageIterator(EjsIterator *ip, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ip->target);
        mprMark(ip->namespaces);
        mprMark(ip->indexVar);
    }
}


/*
    Create the Iterator and StopIteration types
 */
PUBLIC void ejsCreateIteratorType(Ejs *ejs)
{
    ejsCreateCoreType(ejs, N(EJS_ITERATOR_NAMESPACE, "Iterator"), sizeof(EjsIterator), S_Iterator,  
        ES_iterator_Iterator_NUM_CLASS_PROP, manageIterator, EJS_TYPE_OBJ);
    ejsCreateCoreType(ejs, N(EJS_ITERATOR_NAMESPACE, "StopIteration"), sizeof(EjsError), S_StopIteration, 
        ES_iterator_StopIteration_NUM_CLASS_PROP, manageIterator, EJS_TYPE_OBJ);
}


PUBLIC void ejsConfigureIteratorType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N(EJS_ITERATOR_NAMESPACE, "Iterator"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_iterator_Iterator_next, nextIterator);

    if ((type = ejsFinalizeCoreType(ejs, N(EJS_ITERATOR_NAMESPACE, "StopIteration"))) == 0) {
        return;
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsJSON.c"
 */
/************************************************************************/

/**
    ejsJSON.c - JSON encoding and decoding

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Locals ***********************************/

typedef struct JsonState {
    wchar      *data;
    wchar      *end;
    wchar      *next;
    wchar      *error;
} JsonState;

typedef struct Json {
    MprBuf      *buf;
    EjsObj      *current;
    EjsObj      *options;           /* Options object */
    EjsFunction *replacer;
    char        *indent;
    int         baseClasses;
    int         commas;
    int         depth;
    int         hidden;
    int         namespaces;
    int         regexp;             /* Emit native regular expression types */
    int         quotes;
    int         pretty;
    int         nest;               /* Json serialize nest level */
} Json;

/***************************** Forward Declarations ***************************/

static EjsObj *parseLiteral(Ejs *ejs, JsonState *js);
static EjsObj *parseLiteralInner(Ejs *ejs, MprBuf *buf, JsonState *js);
static EjsString *serialize(Ejs *ejs, EjsAny *vp, Json *json);

/*********************************** Locals ***********************************/
/*
    function deserialize(obj: String, options: Object): Object
 */
PUBLIC EjsObj *g_deserialize(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    assert(argc >=1);
    return ejsDeserialize(ejs, (EjsString*) argv[0]);
}

/*
    function serialize(obj: Object, options: Object = null): String
        Options: baseClasses, commas, depth, indent, hidden, pretty, replacer
 */
static EjsString *g_serialize(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsToJSON(ejs, argv[0], (argc == 2) ? argv[1] : NULL);
}


//  TODO - convert to use MPR json parser

PUBLIC EjsAny *ejsDeserialize(Ejs *ejs, EjsString *str)
{
    EjsObj      *obj;
    JsonState   js;

    if (!ejsIs(ejs, str, String)) {
        ejsThrowSyntaxError(ejs, "Object is not a string");
        return 0;
    }
    if (str->length == 0) {
        return ESV(empty);
    }
    js.next = js.data = str->value;
    js.end = &js.data[str->length];
    js.error = 0;
    if ((obj = parseLiteral(ejs, &js)) == 0) {
        if (js.error) {
            ejsThrowSyntaxError(ejs, 
                "Cannot parse object literal. Error at position %d.\n"
                "===========================\n"
                "Offending text: %w\n"
                "===========================\n"
                "In literal %w"
                "\n===========================\n",
                (int) (js.error - js.data), js.error, js.data);
        } else {
            ejsThrowSyntaxError(ejs, "Cannot parse object literal. Undefined error");
        }
        return 0;
    }
    return obj;
}


static EjsObj *parseLiteral(Ejs *ejs, JsonState *js)
{
    assert(js);

    return parseLiteralInner(ejs, mprCreateBuf(0, 0), js);
}


typedef enum Token {
    TOK_ERR,            /* Error */
    TOK_EOF,            /* End of input */
    TOK_LBRACE,         /* { */
    TOK_LBRACKET,       /* [ */
    TOK_RBRACE,         /* } */
    TOK_RBRACKET,       /* ] */
    TOK_COLON,          /* : */
    TOK_COMMA,          /* , */
    TOK_ID,             /* Unquoted ID */
    TOK_QID,            /* Quoted ID */
} Token;


static wchar *skipComments(wchar *cp, wchar *end)
{
    int     inComment;

    for (; cp < end && isspace((uchar) *cp); cp++) {}

    while (cp < &end[-1]) {
        if (cp < &end[-1] && *cp == '/' && cp[1] == '*') {
            inComment = 1;
            for (cp += 2; cp < &end[-1]; cp++) {
                if (*cp == '*' && cp[1] == '/') {
                    inComment = 0;
                    cp += 2;
                    break;
                }
            }
            if (inComment) {
                return 0;
            }
            while (cp < end && isspace((uchar) *cp)) cp++;

        } else  if (cp < &end[-1] && *cp == '/' && cp[1] == '/') {
            inComment = 1;
            for (cp += 2; cp < end; cp++) {
                if (*cp == '\n') {
                    inComment = 0;
                    cp++;
                    break;
                }
            }
            if (inComment) {
                return 0;
            }
            while (cp < end && isspace((uchar) *cp)) cp++;

        } else {
            break;
        }
    }
    return cp;
}


Token getNextJsonToken(MprBuf *buf, wchar **token, JsonState *js)
{
    wchar       *start, *cp, *end, *next;
    wchar       *src, *dest;
    int         quote, tid, c, isReg;

    if (buf) {
        mprFlushBuf(buf);
    }
    cp = js->next;
    end = js->end;
    cp = skipComments(cp, end);
    next = cp + 1;
    quote = -1;
    isReg = 0;

    if (*cp == '\0') {
        tid = TOK_EOF;

    } else  if (*cp == '{') {
        tid = TOK_LBRACE;

    } else if (*cp == '[') {
        tid = TOK_LBRACKET;

    } else if (*cp == '}' || *cp == ']') {
        tid = *cp == '}' ? TOK_RBRACE: TOK_RBRACKET;
        while (*++cp && isspace((uchar) *cp)) ;
        if (*cp == ',' || *cp == ':') {
            cp++;
        }
        next = cp;

    } else {
        if (*cp == '"' || *cp == '\'') {
            tid = TOK_QID;
            quote = *cp++;
            for (start = cp; cp < end; cp++) {
                if (*cp == '\\') {
                    if (cp[1] == quote) {
                        cp++;
                    }
                    continue;
                }
                if (*cp == quote) {
                    break;
                }
            }
            if (*cp != quote) {
                js->error = cp;
                return TOK_ERR;
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, (cp - start));
            }
            cp++;

        } else if (*cp == '/') {
            tid = TOK_ID;
            isReg = 1;
            for (start = cp++; cp < end; cp++) {
                if (*cp == '\\') {
                    if (cp[1] == '/') {
                        cp++;
                    }
                    continue;
                }
                if (*cp == '/') {
                    break;
                }
            }
            if (*cp != '/') {
                js->error = cp;
                return TOK_ERR;
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, (cp - start + 1));
            }
            cp++;

        } else {
            /*
                Note: this is for keys and values
             */
            tid = TOK_ID;
            for (start = cp; cp < end; cp++) {
                if (*cp == '\\') {
                    continue;
                }
                /* 
                    Not an allowable character outside quotes (TODO - removed space 
                    Should really keep state for parsing keys or values and not allow -,+,. in keys
                 */
                if (!(isalnum((uchar) *cp) || *cp == '_' || *cp == '-' || *cp == '+' || *cp == '.')) {
                    break;
                }
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, (int) (cp - start));
            }
        }
        if (buf) {
            mprAddNullToBuf(buf);
        }
        while (*cp && isspace((int) *cp)) cp++;
        if (*cp == ',' || *cp == ':') {
            cp++;
        } else if (*cp != '}' && *cp != ']' && *cp != '\0' && *cp != '\n' && *cp != '\r' && *cp != ' ') {
            js->error = cp;
            return TOK_ERR;
        }
        next = cp;

        if (buf) {
            for (dest = src = (wchar*) buf->start; src < (wchar*) buf->end; ) {
                c = *src++;
                if (c == '\\' && !isReg) {
                    c = *src++;
                    if (c == 'r') {
                        c = '\r';
                    } else if (c == 'n') {
                        c = '\n';
                    } else if (c == 'b') {
                        c = '\b';
                    }
                }
                *dest++ = c;
            }
            *dest = '\0';
            *token = (wchar*) mprGetBufStart(buf);
        }
    }
    js->next = next;
    return tid;
}


Token peekNextJsonToken(JsonState *js)
{
    JsonState   discard = *js;
    return getNextJsonToken(NULL, NULL, &discard);
}


/*
    Parse an object literal string pointed to by js->next into the given buffer. Update js->next to point
    to the next input token in the object literal. Supports nested object literals.
 */
static EjsObj *parseLiteralInner(Ejs *ejs, MprBuf *buf, JsonState *js)
{
    EjsAny      *obj, *vp;
    MprBuf      *valueBuf;
    wchar       *token, *key, *value;
    int         tid, isArray;

    isArray = 0;

    tid = getNextJsonToken(buf, &token, js);
    if (tid == TOK_ERR || tid == TOK_EOF) {
        return 0;
    }
    if (tid == TOK_LBRACKET) {
        isArray = 1;
        obj = (EjsObj*) ejsCreateArray(ejs, 0);
    } else if (tid == TOK_LBRACE) {
        obj = ejsCreateEmptyPot(ejs);
    } else {
        return ejsParse(ejs, token, S_String);
    }
    if (obj == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    while (1) {
        vp = 0;
        tid = peekNextJsonToken(js);
        if (tid == TOK_ERR) {
            return 0;
        } else if (tid == TOK_EOF) {
            break;
        } else if (tid == TOK_RBRACE || tid == TOK_RBRACKET) {
            getNextJsonToken(buf, &key, js);
            break;
        }
        if (tid == TOK_LBRACKET) {
            /* For array values */
            vp = parseLiteral(ejs, js);
            assert(vp);
            
        } else if (tid == TOK_LBRACE) {
            /* For object values */
            vp = parseLiteral(ejs, js);
            assert(vp);
            
        } else if (isArray) {
            tid = getNextJsonToken(buf, &value, js);
            vp = ejsParse(ejs, value, (tid == TOK_QID) ? S_String: -1);
            assert(vp);
            
        } else {
            getNextJsonToken(buf, &key, js);
            tid = peekNextJsonToken(js);
            if (tid == TOK_ERR) {
                return 0;
            } else if (tid == TOK_EOF) {
                break;
            } else if (tid == TOK_LBRACE || tid == TOK_LBRACKET) {
                vp = parseLiteral(ejs, js);

            } else if (tid == TOK_ID || tid == TOK_QID) {
                valueBuf = mprCreateBuf(0, 0);
                getNextJsonToken(valueBuf, &value, js);
                if (tid == TOK_QID) {
                    vp = ejsCreateString(ejs, value, strlen(value));
                } else {
                    if (mcmp(value, "null") == 0) {
                        vp = ESV(null);
                    } else if (mcmp(value, "undefined") == 0) {
                        vp = ESV(undefined);
                    } else {
                        vp = ejsParse(ejs, value, -1);
                    }
                }
                assert(vp);
            } else {
                getNextJsonToken(buf, &value, js);
                js->error = js->next;
                return 0;
            }
        }
        if (vp == 0) {
            js->error = js->next;
            return 0;
        }
        if (isArray) {
            if (ejsSetProperty(ejs, obj, -1, vp) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
        } else {
            if (ejsSetPropertyByName(ejs, obj, WEN(key), vp) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
        }
    }
    return obj;
}


/**
    Get a serialized string representation of a variable using JSON encoding.
    This will look for a "toJSON" function on the specified object. Use ejsSerialize for low level JSON.
    @return Returns a string variable or null if an exception is thrown.
 */
PUBLIC EjsString *ejsToJSON(Ejs *ejs, EjsAny *vp, EjsObj *options)
{
    EjsFunction     *fn;
    EjsString       *result;
    EjsObj          *argv[1];
    int             argc;

    fn = (EjsFunction*) ejsGetPropertyByName(ejs, TYPE(vp)->prototype, N(NULL, "toJSON"));
    if (!ejsIsFunction(ejs, fn) || (fn->isNativeProc && fn->body.proc == (EjsProc) ejsObjToJSON)) {
        result = ejsSerializeWithOptions(ejs, vp, options);
    } else {
        argv[0] = options;
        argc = options ? 1 : 0;
        result = (EjsString*) ejsRunFunction(ejs, fn, vp, argc, argv);
    }
    return result;
}


//  TODO - should merge this with MPR routines

PUBLIC EjsString *ejsSerializeWithOptions(Ejs *ejs, EjsAny *vp, EjsObj *options)
{
    Json        json;
    EjsObj      *arg;
    EjsString   *result;
    int         i;

    memset(&json, 0, sizeof(Json));
    json.depth = 99;
    json.quotes = 1;
    json.indent = sclone("    ");

    if (options) {
        json.options = options;
        if ((arg = ejsGetPropertyByName(ejs, options, EN("baseClasses"))) != 0) {
            json.baseClasses = (arg == ESV(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("depth"))) != 0) {
            json.depth = ejsGetInt(ejs, arg);
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("indent"))) != 0) {
            if (ejsIs(ejs, arg, String)) {
               json.indent = (char*) ejsToMulti(ejs, arg);
                //  TODO - get another solution to hold
            } else if (ejsIs(ejs, arg, Number)) {
                i = ejsGetInt(ejs, arg);
                if (0 <= i && i < ME_MAX_BUFFER) {
                    json.indent = mprAlloc(i + 1);
                    //  TODO - get another solution to hold
                    memset(json.indent, ' ', i);
                    json.indent[i] = '\0';
                }
            }
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("commas"))) != 0) {
            json.commas = (arg == ESV(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("hidden"))) != 0) {
            json.hidden = (arg == ESV(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("namespaces"))) != 0) {
            json.namespaces = (arg == ESV(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("regexp"))) != 0) {
            json.regexp = (arg == ESV(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("quotes"))) != 0) {
            json.quotes = (arg != ESV(false));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("pretty"))) != 0) {
            json.pretty = (arg == ESV(true));
        }
        json.replacer = ejsGetPropertyByName(ejs, options, EN("replacer"));
        if (!ejsIsFunction(ejs, json.replacer)) {
            json.replacer = NULL;
        }
    }
    mprRelease(json.indent);
    mprHold(json.indent);
    result = serialize(ejs, vp, &json);
    //  TODO - get another solution to hold
    return result;
}


PUBLIC EjsString *ejsSerialize(Ejs *ejs, EjsAny *vp, int flags)
{
    Json    json;

    memset(&json, 0, sizeof(Json));
    json.depth = 99;
    json.baseClasses = (flags & EJS_JSON_SHOW_SUBCLASSES) ? 1 : 0;
    json.commas = (flags & EJS_JSON_SHOW_COMMAS) ? 1 : 0;
    json.hidden = (flags & EJS_JSON_SHOW_HIDDEN) ? 1 : 0;
    json.namespaces = (flags & EJS_JSON_SHOW_NAMESPACES) ? 1 : 0;
    json.regexp = (flags & EJS_JSON_SHOW_REGEXP) ? 1 : 0;
    json.pretty = (flags & EJS_JSON_SHOW_PRETTY) ? 1 : 0;
    json.quotes = (flags & EJS_JSON_SHOW_NOQUOTES) ? 0 : 1;
    return serialize(ejs, vp, &json);
}


static EjsString *serialize(Ejs *ejs, EjsAny *vp, Json *json)
{
    EjsName     qname;
    EjsFunction *fn;
    EjsString   *result, *sv;
    EjsTrait    *trait;
    EjsObj      *pp, *obj, *replacerArgs[2];
    wchar       *cp;
    cchar       *key;
    int         c, isArray, i, count, slotNum, quotes;

    /*
        The main code below can handle Arrays, Objects, objects derrived from Object and also native classes with properties.
        All others just use toString.
     */
    count = ejsIsPot(ejs, vp) ? ejsGetLength(ejs, vp) : 0;
    if (count == 0 && TYPE(vp) != ESV(Object) && TYPE(vp) != ESV(Array)) {
        //  OPT - need some flag for this test.
        if (!ejsIsDefined(ejs, vp) || ejsIs(ejs, vp, Boolean) || ejsIs(ejs, vp, Number)) {
            return ejsToString(ejs, vp);
        } else if (json->regexp) {
            return ejsToString(ejs, vp);
        } else {
            return ejsToLiteralString(ejs, vp);
        }
    }
    obj = vp;
    json->nest++;
    if (json->buf == 0) {
        json->buf = mprCreateBuf(0, 0);
        mprAddRoot(json->buf);
    }
    isArray = ejsIs(ejs, vp, Array);
    mprPutCharToWideBuf(json->buf, isArray ? '[' : '{');
    if (json->pretty) {
        mprPutCharToWideBuf(json->buf, '\n');
    }
    if (++ejs->serializeDepth <= json->depth && !VISITED(obj)) {
        SET_VISITED(obj, 1);
        for (slotNum = 0; slotNum < count && !ejs->exception; slotNum++) {
            trait = ejsGetPropertyTraits(ejs, obj, slotNum);
            if (trait && (trait->attributes & (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | 
                    EJS_FUN_MODULE_INITIALIZER)) && !json->hidden) {
                continue;
            }
            pp = ejsGetProperty(ejs, obj, slotNum);
            if (ejs->exception) {
                SET_VISITED(obj, 0);
                json->nest--;
                return 0;
            }
            if (pp == 0) {
                continue;
            }
            if (isArray) {
                key = itos(slotNum);
                qname.name = ejsCreateStringFromAsc(ejs, key);
                qname.space = ESV(empty);
            } else {
                qname = ejsGetPropertyName(ejs, vp, slotNum);
            }

            quotes = json->quotes;
            if (!quotes) {
                //  UNICODE
                for (cp = qname.name->value; cp < &qname.name->value[qname.name->length]; cp++) {
                    if (!isalnum((uchar) *cp) && *cp != '_') {
                        quotes = 1;
                        break;
                    }
                }
            }
            if (json->pretty) {
                for (i = 0; i < ejs->serializeDepth; i++) {
                    mprPutStringToWideBuf(json->buf, json->indent);
                }
            }
            if (!isArray) {
                if (json->namespaces) {
                    if (qname.space != ESV(empty)) {
                        mprPutToBuf(json->buf, "\"%@\"::", qname.space);
                    }
                }
                if (quotes) {
                    mprPutCharToWideBuf(json->buf, '"');
                }
                for (cp = qname.name->value; cp && *cp; cp++) {
                    c = *cp;
                    if (c == '"' || c == '\\') {
                        mprPutCharToWideBuf(json->buf, '\\');
                        mprPutCharToWideBuf(json->buf, c);
                    } else {
                        mprPutCharToWideBuf(json->buf, c);
                    }
                }
                if (quotes) {
                    mprPutCharToWideBuf(json->buf, '"');
                }
                mprPutCharToWideBuf(json->buf, ':');
                if (json->pretty) {
                    mprPutCharToWideBuf(json->buf, ' ');
                }
            }
            fn = (EjsFunction*) ejsGetPropertyByName(ejs, TYPE(pp)->prototype, N(NULL, "toJSON"));
            // OPT - check that this is going directly to serialize most of the time
            if (!ejsIsFunction(ejs, fn) || (fn->isNativeProc && fn->body.proc == (EjsProc) ejsObjToJSON)) {
                sv = serialize(ejs, pp, json);
            } else {
                sv = (EjsString*) ejsRunFunction(ejs, fn, pp, 1, &json->options);
            }
            if (sv == 0 || !ejsIs(ejs, sv, String)) {
                if (ejs->exception) {
                    ejsThrowTypeError(ejs, "Cannot serialize property %@", qname.name);
                    SET_VISITED(obj, 0);
                    return 0;
                }
            } else {
                if (json->replacer) {
                    replacerArgs[0] = (EjsObj*) qname.name; 
                    replacerArgs[1] = (EjsObj*) sv; 

                    /* function replacer(key: String, value: String): String */
                    sv = ejsRunFunction(ejs, json->replacer, obj, 2, (EjsObj**) replacerArgs);
                }
                mprPutBlockToBuf(json->buf, sv->value, sv->length * sizeof(wchar));
            }
            if ((slotNum + 1) < count || json->commas) {
                mprPutCharToWideBuf(json->buf, ',');
            }
            if (json->pretty) {
                mprPutCharToWideBuf(json->buf, '\n');
            }
        }
        SET_VISITED(obj, 0);
    }
    --ejs->serializeDepth; 
    if (json->pretty) {
        for (i = ejs->serializeDepth; i > 0; i--) {
            mprPutStringToWideBuf(json->buf, json->indent);
        }
    }
    mprPutCharToWideBuf(json->buf, isArray ? ']' : '}');
    mprAddNullToWideBuf(json->buf);

    if (--json->nest == 0) {
        result = ejsCreateString(ejs, mprGetBufStart(json->buf), mprGetBufLength(json->buf) / sizeof(wchar));
        mprRemoveRoot(json->buf);
    } else {
        result = 0;
    }
    return result;
}


PUBLIC void ejsConfigureJSONType(Ejs *ejs)
{
    ejsFinalizeScriptType(ejs, N("ejs", "JSON"), sizeof(EjsPot), ejsManagePot, EJS_TYPE_POT);
    ejsBindFunction(ejs, ejs->global, ES_deserialize, g_deserialize);
    ejsBindFunction(ejs, ejs->global, ES_serialize, g_serialize);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsLocalCache.c"
 */
/************************************************************************/

/**
    ejsEjsLocalCache.c - Native code for the Local cache class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Locals **********************************/

//  TODO - should this be refactored to use MprCache?

#define CACHE_TIMER_PERIOD  (60 * MPR_TICKS_PER_SEC)
#define CACHE_HASH_SIZE     257
#define CACHE_LIFESPAN      (86400 * MPR_TICKS_PER_SEC)

typedef struct EjsLocalCache
{
    EjsObj          obj;                /* Object base */
    MprHash         *store;             /* Key/value store */
    MprMutex        *mutex;             /* Cache lock */
    MprEvent        *timer;             /* Pruning timer */
    MprTicks        lifespan;           /* Default lifespan (msec) */
    int             resolution;         /* Frequence for pruner */
    ssize           usedMem;            /* Memory in use for keys and data */
    ssize           maxKeys;            /* Max number of keys */
    ssize           maxMem;             /* Max memory for session data */
    struct EjsLocalCache *shared;       /* Shared common cache */
} EjsLocalCache;

static EjsLocalCache *shared;           /* Singleton shared cache */

typedef struct CacheItem
{
    EjsString   *key;                   /* Original key */
    EjsString   *data;                  /* Cache data */
    MprTime     expires;                /* Fixed expiry date. If zero, key is imortal. */
    MprTicks    lifespan;               /* Lifespan after each access to key (msec) */
    int64       version;
} CacheItem;

/*********************************** Forwards *********************************/

static void localPruner(EjsLocalCache *cache, MprEvent *event);
static void manageLocalCache(EjsLocalCache *cache, int flags);
static void manageCacheItem(CacheItem *item, int flags);
static void removeItem(EjsLocalCache *cache, CacheItem *item);
static void setLocalLimits(Ejs *ejs, EjsLocalCache *cache, EjsPot *options);

/************************************* Code ***********************************/
/*
   function Local(options)
 */
static EjsLocalCache *localConstructor(Ejs *ejs, EjsLocalCache *cache, int argc, EjsAny **argv)
{
    EjsPot      *options;
    int         wantShared;

    options = (argc >= 1 && ejsIsDefined(ejs, argv[0])) ? argv[0] : 0;
    wantShared = (options && ejsGetPropertyByName(ejs, options, EN("shared")) == ESV(true));

    if (wantShared && shared) {
        cache->shared = shared;
    } else {
        cache->mutex = mprCreateLock();
        cache->store = mprCreateHash(CACHE_HASH_SIZE, 0);
        cache->maxMem = MAXSSIZE;
        cache->maxKeys = MAXSSIZE;
        cache->resolution = CACHE_TIMER_PERIOD;
        cache->lifespan = CACHE_LIFESPAN;
        setLocalLimits(ejs, cache, options);
        if (wantShared) {
            shared = cache;
        }
    }
    return cache;
}


static EjsVoid *sl_destroy(Ejs *ejs, EjsLocalCache *cache, int argc, EjsObj **argv)
{
    if (cache->timer && cache != shared) {
        mprRemoveEvent(cache->timer);
        cache->timer = 0;
    }
    if (cache == shared) {
        shared = 0;
    }
    return 0;
}


/*
    function expire(key: String, expires: Date): Boolean
 */
static EjsAny *sl_expire(Ejs *ejs, EjsLocalCache *cache, int argc, EjsAny **argv)
{
    EjsString   *key;
    EjsDate     *expires;
    CacheItem   *item;

    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    key = argv[0];
    expires = argv[1];

    lock(cache);
    //  UNICODE
    if ((item = mprLookupKey(cache->store, key->value)) == 0) {
        unlock(cache);
        return ESV(false);
    }
    item->lifespan = 0;
    if (expires == ESV(null)) {
        removeItem(cache, item);
    } else {
        item->expires = ejsGetDate(ejs, expires);
    }
    unlock(cache);
    return ESV(true);
}


/*
    function inc(key: String, amount: Number): Number
 */
static EjsAny *sl_inc(Ejs *ejs, EjsLocalCache *cache, int argc, EjsAny **argv)
{
    EjsString   *key;
    CacheItem   *item;
    int64       amount;

    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    key = argv[0];
    amount = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 1;

    lock(cache);
    //  UNICODE
    if ((item = mprLookupKey(cache->store, key->value)) == 0) {
        if ((item = mprAllocObj(CacheItem, manageCacheItem)) == 0) {
            unlock(cache);
            ejsThrowMemoryError(ejs);
            return 0;
        }
    } else {
        amount += stoi(item->data->value);
    }
    if (item->data) {
        cache->usedMem -= item->data->length;
    }
    item->data = ejsCreateStringFromAsc(ejs, itos(amount));
    cache->usedMem += item->data->length;
    item->expires = mprGetTime() + item->lifespan;
    item->version++;
    unlock(cache);
    return item->data;
}


/*
    function get limits(): Object
 */
static EjsPot *sl_limits(Ejs *ejs, EjsLocalCache *cache, int argc, EjsObj **argv)
{
    EjsPot      *result;

    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    result = ejsCreateEmptyPot(ejs);
    ejsSetPropertyByName(ejs, result, EN("keys"), 
        ejsCreateNumber(ejs, (MprNumber) (cache->maxKeys == MAXSSIZE ? 0 : cache->maxKeys)));
    ejsSetPropertyByName(ejs, result, EN("lifespan"), 
        ejsCreateNumber(ejs, (MprNumber) (cache->lifespan / MPR_TICKS_PER_SEC)));
    ejsSetPropertyByName(ejs, result, EN("memory"), 
        ejsCreateNumber(ejs, (MprNumber) (cache->maxMem == MAXSSIZE ? 0 : cache->maxMem)));
    return result;
}


/*
    function read(key: String, options: Object = null): Object
 */
static EjsAny *sl_read(Ejs *ejs, EjsLocalCache *cache, int argc, EjsAny **argv)
{
    EjsString   *key;
    EjsAny      *result;
    EjsPot      *options;
    CacheItem   *item;
    int         getVersion;

    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    key = argv[0];
    getVersion = 0;

    if (argc >= 2 && ejsIsDefined(ejs, argv[1])) {
        options = argv[1];
        getVersion = ejsGetPropertyByName(ejs, options, EN("version")) == ESV(true);
    }
    lock(cache);
    //  UNICODE
    if ((item = mprLookupKey(cache->store, key->value)) == 0) {
        unlock(cache);
        return ESV(null);
    }
    if (item->expires && item->expires <= mprGetTime()) {
        unlock(cache);
        return ESV(null);
    }
#if UNUSED && FUTURE
    //  TODO - should reading refresh cache
    //  Perhaps option "read-refresh"
    if (item->lifespan) {
        item->expires = mprGetTime() + item->lifespan;
    }
#endif
    if (getVersion) {
        result = ejsCreatePot(ejs, ESV(Object), 2);
        ejsSetPropertyByName(ejs, result, EN("version"), ejsCreateNumber(ejs, (MprNumber) item->version));
        ejsSetPropertyByName(ejs, result, EN("data"), item->data);
    } else {
        result = item->data;
    }
    unlock(cache);
    return result;
}


/*
    native function remove(key: String): Boolean
 */
static EjsBoolean *sl_remove(Ejs *ejs, EjsLocalCache *cache, int argc, EjsAny **argv)
{
    EjsString   *key;
    EjsAny      *result;
    CacheItem   *item;

    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    key = argv[0];
    lock(cache);
    if (ejsIsDefined(ejs, key)) {
        //  UNICODE
        if ((item = mprLookupKey(cache->store, key->value)) != 0) {
            cache->usedMem -= (key->length + item->data->length);
            mprRemoveKey(cache->store, key->value);
            result = ESV(true);
        } else {
            result = ESV(false);
        }

    } else {
        /* Remove all keys */
        result = mprGetHashLength(cache->store) ? ESV(true) : ESV(false);
        cache->store = mprCreateHash(CACHE_HASH_SIZE, 0);
        cache->usedMem = 0;
    }
    unlock(cache);
    return result;
}


static void setLocalLimits(Ejs *ejs, EjsLocalCache *cache, EjsPot *options)
{
    EjsAny      *vp;

    if (!options) {
        return;
    }
    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    if ((vp = ejsGetPropertyByName(ejs, options, EN("keys"))) != 0) {
        cache->maxKeys = (ssize) ejsGetInt64(ejs, vp);
        if (cache->maxKeys <= 0) {
            cache->maxKeys = MAXSSIZE;
        }
    }
    if ((vp = ejsGetPropertyByName(ejs, options, EN("lifespan"))) != 0) {
        cache->lifespan = (ssize) ejsGetInt64(ejs, vp) * MPR_TICKS_PER_SEC;
    }
    if ((vp = ejsGetPropertyByName(ejs, options, EN("memory"))) != 0) {
        cache->maxMem = (ssize) ejsGetInt64(ejs, vp);
        if (cache->maxMem <= 0) {
            cache->maxMem = MAXSSIZE;
        }
    }
    if ((vp = ejsGetPropertyByName(ejs, options, EN("resolution"))) != 0) {
        cache->resolution = ejsGetInt(ejs, vp);
        if (cache->resolution <= 0) {
            cache->resolution = CACHE_TIMER_PERIOD;
        }
    }
}


/*
    function setLimits(limits: Object): Void
 */
static EjsVoid *sl_setLimits(Ejs *ejs, EjsLocalCache *cache, int argc, EjsAny **argv)
{
    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    setLocalLimits(ejs, cache, argv[0]);
    return 0;
}


/*
    function write(key: String~, value: String~, options: Object = null): Number
 */
static EjsNumber *sl_write(Ejs *ejs, EjsLocalCache *cache, int argc, EjsAny **argv)
{
    CacheItem   *item;
    EjsString   *key, *value, *sp;
    EjsPot      *options;
    EjsAny      *vp;
    MprKey      *kp;
    MprTime     expires;
    ssize       len, oldLen;
    int64       lifespan, version;
    int         checkVersion, exists, add, set, prepend, append, throw;

    if (cache->shared) {
        cache = cache->shared;
        assert(cache == shared);
    }
    checkVersion = exists = add = prepend = append = throw = 0;
    set = 1;
    expires = 0;
    lifespan = cache->lifespan;
    version = 0;
    key = argv[0];
    value = argv[1];

    if (argc >= 3 && argv[2] != ESV(null)) {
        options = argv[2];
        if ((vp = ejsGetPropertyByName(ejs, options, EN("lifespan"))) != 0) {
            lifespan = ejsGetInt64(ejs, vp) * MPR_TICKS_PER_SEC;
        }
        if ((vp = ejsGetPropertyByName(ejs, options, EN("expires"))) != 0 && ejsIs(ejs, vp, Date)) {
            expires = ejsGetDate(ejs, vp);
        }
        if ((sp = ejsGetPropertyByName(ejs, options, EN("mode"))) != 0) {
            set = 0;
            //  UNICODE
            if (scmp(sp->value, "add") == 0) {
                add = 1;
            } else if (scmp(sp->value, "append") == 0) {
                append = 1;
            } else if (scmp(sp->value, "prepend") == 0) {
                prepend = 1;
            } else if (scmp(sp->value, "set") == 0) {
                set = 1;
            }
        }
        throw = (vp = ejsGetPropertyByName(ejs, options, EN("throw"))) == ESV(true);
        if ((vp = ejsGetPropertyByName(ejs, options, EN("version"))) != 0) {
            version = ejsGetInt64(ejs, vp);
            checkVersion = 1;
        }
    }
    lock(cache);
    if ((kp = mprLookupKeyEntry(cache->store, key->value)) != 0) {
        exists++;
        item = (CacheItem*) kp->data;
        if (checkVersion) {
            if (item->version != version) {
                unlock(cache);
                if (throw) {
                    ejsThrowStateError(ejs, "Key version does not match");
                }
                return ESV(null);
            }
        }
    } else {
        if ((item = mprAllocObj(CacheItem, manageCacheItem)) == 0) {
            unlock(cache);
            ejsThrowMemoryError(ejs);
            return 0;
        }
        //  UNICODE
        mprAddKey(cache->store, key->value, item);
        set = 1;
        item->key = key;
    }
    oldLen = (item->data) ? (item->key->length + item->data->length) : 0;
    if (set) {
        item->data = value;
    } else if (add) {
        if (exists) {
            return ESV(null);
        }
        item->data = value;
    } else if (append) {
        item->data = ejsJoinString(ejs, item->data, value);
    } else if (prepend) {
        item->data = ejsJoinString(ejs, value, item->data);
    }
    if (expires) {
        /* Expires takes precedence over lifespan */
        item->expires = expires;
        item->lifespan = 0;
    } else if (lifespan == 0) {
        /* Never expires */
        item->expires = 0;
    } else {
        item->lifespan = lifespan;
        item->expires = mprGetTime() + item->lifespan;
    }
    item->version++;
    len = item->key->length + item->data->length;

    cache->usedMem += (len - oldLen);

    if (cache->timer == 0) {
        mprTrace(5, "Start LocalCache pruner with resolution %d", cache->resolution);
        /* 
            Use the MPR dispatcher incase this VM is destroyed 
         */
        cache->timer = mprCreateTimerEvent(MPR->dispatcher, "localCacheTimer", cache->resolution, localPruner, cache, 
            MPR_EVENT_STATIC_DATA); 
    }
    unlock(cache);
    //  UNICODE
    return ejsCreateNumber(ejs, (MprNumber) len);
}


static void removeItem(EjsLocalCache *cache, CacheItem *item)
{
    lock(cache);
    //UNICODE
    mprRemoveKey(cache->store, item->key->value);
    cache->usedMem -= (item->key->length + item->data->length);
    unlock(cache);
}


/*
    Check for expired keys
 */
static void localPruner(EjsLocalCache *cache, MprEvent *event)
{
    MprTime         when, factor;
    MprKey          *kp;
    CacheItem       *item;
    ssize           excessKeys;

    if (mprTryLock(cache->mutex)) {
        when = mprGetTime();
        /*
            Prune keys expiring first.
         */
        for (kp = 0; (kp = mprGetNextKey(cache->store, kp)) != 0; ) {
            item = (CacheItem*) kp->data;
#if KEEP
            mprTrace(6, "LocalCache: \"%@\" lifespan %d, expires in %d secs", item->key, 
                    item->lifespan / 1000, (item->expires - when) / 1000);
#endif
            if (item->expires && item->expires <= when) {
                mprTrace(5, "LocalCache prune expired key %s", kp->key);
                removeItem(cache, item);
            }
        }
        assert(cache->usedMem >= 0);

        /*
            If too many keys or too much memory used. Prune oldest first.
         */
        if (cache->maxKeys < MAXSSIZE || cache->maxMem < MAXSSIZE) {
            excessKeys = mprGetHashLength(cache->store) - cache->maxKeys;
            for (factor = 3600; factor < (86400 * 1000); factor *= 4) {
                if (excessKeys > 0 || cache->usedMem > cache->maxMem) {
                    for (kp = 0; (kp = mprGetNextKey(cache->store, kp)) != 0; ) {
                        item = (CacheItem*) kp->data;
                        if (item->expires && item->expires <= when) {
                            mprTrace(5, "LocalCache too big execess keys %Ld, mem %Ld, prune key %s", 
                                    excessKeys, (cache->maxMem - cache->usedMem), kp->key);
                            removeItem(cache, item);
                            excessKeys--;
                        }
                    }
                    when += factor;
                } else {
                    break;
                }
            }
        }
        assert(cache->usedMem >= 0);

        if (mprGetHashLength(cache->store) == 0) {
            mprRemoveEvent(event);
            cache->timer = 0;
        }
        unlock(cache);
    }
}


static void manageLocalCache(EjsLocalCache *cache, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(cache->store);
        mprMark(cache->mutex);
        mprMark(cache->timer);
        mprMark(cache->shared);

    } else if (flags & MPR_MANAGE_FREE) {
        if (cache == shared) {
            shared = 0;
        }
    }
}


static void manageCacheItem(CacheItem *item, int flags) 
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(item->key);
        mprMark(item->data);
    }
}


static EjsLocalCache *cloneLocalCache(Ejs *ejs, EjsLocalCache *src, bool deep)
{
    EjsLocalCache   *dest;

    if ((dest = ejsCreateObj(ejs, TYPE(src), 0)) == 0) {
        return 0;
    }
    if (src->shared) {
        dest->shared = src->shared;
    } else if (src == shared) {
        dest->shared = src;
    } else {
        dest->store = mprCreateHash(CACHE_HASH_SIZE, 0);
        dest->mutex = mprCreateLock();
        dest->timer = 0;
        dest->lifespan = src->lifespan;
        dest->resolution = src->resolution;
        dest->usedMem = src->usedMem;
        dest->maxMem = src->maxMem;
        dest->maxKeys = src->maxKeys;
        dest->shared = src->shared;
    }
    return dest;
}


PUBLIC void ejsConfigureLocalCacheType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "LocalCache"), sizeof(EjsLocalCache), 
            manageLocalCache, EJS_TYPE_OBJ | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    ejsAddImmutable(ejs, S_LocalCache, type->qname, type);
    type->helpers.clone = (EjsCloneHelper) cloneLocalCache;
    ejsBindConstructor(ejs, type, localConstructor);

    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_LocalCache_destroy, sl_destroy);
    ejsBindMethod(ejs, prototype, ES_LocalCache_expire, sl_expire);
    ejsBindMethod(ejs, prototype, ES_LocalCache_inc, sl_inc);
    ejsBindAccess(ejs, prototype, ES_LocalCache_limits, sl_limits, 0);
    ejsBindMethod(ejs, prototype, ES_LocalCache_read, sl_read);
    ejsBindMethod(ejs, prototype, ES_LocalCache_remove, sl_remove);
    ejsBindMethod(ejs, prototype, ES_LocalCache_setLimits, sl_setLimits);
    ejsBindMethod(ejs, prototype, ES_LocalCache_write, sl_write);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsMath.c"
 */
/************************************************************************/

/**
    ejsMath.c - Math type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/


#include     <math.h>

/**************************** Forward Declarations ****************************/

#define fixed(n) ((int64) (floor(n)))

/******************************************************************************/
/*
    function abs(value: Number): Number
 */
static EjsNumber *math_abs(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    //  TODO - can a null slip through?
    return ejsCreateNumber(ejs, (MprNumber) fabs(ejsGetNumber(ejs, argv[0])));
}


/*
    function acos(value: Number): Number
 */
static EjsNumber *math_acos(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) acos(ejsGetNumber(ejs, argv[0])));
}


/*
    function asin(value: Number): Number
 */
static EjsNumber *math_asin(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) asin(ejsGetNumber(ejs, argv[0])));
}


/*
    function atan(value: Number): Number
 */
static EjsNumber *math_atan(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) atan(ejsGetNumber(ejs, argv[0])));
}


/*
    function atan2(x: Number, y: Number): Number
 */
static EjsNumber *math_atan2(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) atan2(ejsGetNumber(ejs, argv[0]), ejsGetNumber(ejs, argv[1])));
}


/*
    function ceil(value: Number): Number
 */
static EjsNumber *math_ceil(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ceil(ejsGetNumber(ejs, argv[0])));
}


/*
    function cos(value: Number): Number
 */
static EjsNumber *math_cos(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) cos(ejsGetNumber(ejs, argv[0])));
}


/*
    function exp(value: Number): Number
 */
static EjsNumber *math_exp(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) exp(ejsGetNumber(ejs, argv[0])));
}


/*
    function floor(value: Number): Number
 */
static EjsNumber *math_floor(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) floor(ejsGetNumber(ejs, argv[0])));
}


/*
    function log10(value: Number): Number
 */
static EjsNumber *math_log10(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) log10(ejsGetNumber(ejs, argv[0])));
}


/*
    function log(value: Number): Number
 */
static EjsNumber *math_log(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) log(ejsGetNumber(ejs, argv[0])));
}


/*
    function max(x: Number, y: Number): Number
 */
static EjsNumber *math_max(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    if (x > y) {
        return (EjsNumber*) argv[0];
    }
    return (EjsNumber*) argv[1];
}


/*
    function min(value: Number): Number
 */
static EjsObj *math_min(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    if (x < y) {
        return argv[0];
    }
    return argv[1];
}


/*
    function pow(x: Number, y: Number): Number
 */
static EjsNumber *math_pow(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y, result;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    result = pow(x, y);
#if CYGWIN
    /* Cygwin computes (0.0 / -1) == -Infinity */
    if (result < 0 && x == 0.0) {
        result = -result;
    }
#endif
    return ejsCreateNumber(ejs, (MprNumber) result);
}


/*
    function random(value: Number): Number
 */
static EjsNumber *math_random(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   value;
    uint        uvalue;
    static int  initialized = 0;
    
    if (!initialized) {
#if WINDOWS
        uint seed = (uint) time(0);
        srand(seed);
#elif !MACOSX && !VXWORKS
        srandom(time(0));
#endif
        initialized = 1;
    }
    
#if WINDOWS
{
    errno_t rand_s(uint *value);
    rand_s(&uvalue);
}
#elif LINUX
    uvalue = random();
#elif MACOSX
    uvalue = arc4random();
#else
{
    int64   data[16];
    int     i;
    mprGetRandomBytes((char*) data, sizeof(data), 0);
    uvalue = 0;
    for (i = 0; i < sizeof(data) / sizeof(int64); i++) {
        uvalue += data[i];
    }
}
#endif
    value = ((MprNumber) (uvalue & 0x7FFFFFFF)) / MAXINT;
    return ejsCreateNumber(ejs, value);
}


/*
    function round(value: Number): Number
 */
static EjsNumber *math_round(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   n;

    n = ejsGetNumber(ejs, argv[0]);
    if (-0.5 <= n && n < 0) {
        n = -0.0;
    } else {
        n += 0.5;
    }
    return ejsCreateNumber(ejs, floor(n));
}


/*
    function sin(value: Number): Number
 */
static EjsNumber *math_sin(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) sin(ejsGetNumber(ejs, argv[0])));
}


/*
    function sqrt(value: Number): Number
 */
static EjsNumber *math_sqrt(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) sqrt(ejsGetNumber(ejs, argv[0])));
}


/*
    function tan(value: Number): Number
 */
static EjsNumber *math_tan(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) tan(ejsGetNumber(ejs, argv[0])));
}


/*********************************** Factory **********************************/

PUBLIC void ejsConfigureMathType(Ejs *ejs)
{
    EjsType     *type;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Math"), sizeof(EjsPot), ejsManagePot, EJS_TYPE_POT)) == 0) {
        return;
    }
    ejsBindMethod(ejs, type, ES_Math_abs, math_abs);
    ejsBindMethod(ejs, type, ES_Math_acos, math_acos);
    ejsBindMethod(ejs, type, ES_Math_asin, math_asin);
    ejsBindMethod(ejs, type, ES_Math_atan, math_atan);
    ejsBindMethod(ejs, type, ES_Math_atan2, math_atan2);
    ejsBindMethod(ejs, type, ES_Math_ceil, math_ceil);
    ejsBindMethod(ejs, type, ES_Math_cos, math_cos);
    ejsBindMethod(ejs, type, ES_Math_exp, math_exp);
    ejsBindMethod(ejs, type, ES_Math_floor, math_floor);
    ejsBindMethod(ejs, type, ES_Math_log, math_log);
    ejsBindMethod(ejs, type, ES_Math_log10, math_log10);
    ejsBindMethod(ejs, type, ES_Math_max, math_max);
    ejsBindMethod(ejs, type, ES_Math_min, math_min);
    ejsBindMethod(ejs, type, ES_Math_pow, math_pow);
    ejsBindMethod(ejs, type, ES_Math_random, math_random);
    ejsBindMethod(ejs, type, ES_Math_round, math_round);
    ejsBindMethod(ejs, type, ES_Math_sin, math_sin);
    ejsBindMethod(ejs, type, ES_Math_sqrt, math_sqrt);
    ejsBindMethod(ejs, type, ES_Math_tan, math_tan);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsMemory.c"
 */
/************************************************************************/

/*
    ejsMemory.c - Memory class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */
/********************************** Includes **********************************/



/*********************************** Methods *********************************/
/*
    native static function get allocated(): Number
 */
static EjsNumber *getAllocatedMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->bytesAllocated);
}


#if FUTURE
/*
    native static function callback(fn: Function): Void
 */
static EjsNumber *setRedlineCallback(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    assert(argc == 1 && ejsIsFunction(ejs, argv[0]));

    if (!ejsIsFunction(ejs, argv[0])) {
        ejsThrowArgError(ejs, "Callaback is not a function");
        return 0;
    }
    ejs->memoryCallback = (EjsFunction*) argv[0];
    return 0;
}
#endif


/*
    native static function get maximum(): Number
 */
static EjsNumber *getMaxMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->maxHeap);
}


/*
    native static function set maximum(limit: Number): Void
 */
static EjsObj *setMaxMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     maxHeap;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));

    maxHeap = ejsGetInt(ejs, argv[0]);
    mprSetMemLimits(-1, maxHeap, -1);
    return 0;
}


/*
    native static function get redline(): Number
 */
static EjsNumber *getRedline(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->warnHeap);
}


/*
    native static function set redline(limit: Number): Void
 */
static EjsObj *setRedline(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     redline;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));

    redline = ejsGetInt(ejs, argv[0]);
    if (redline <= 0) {
        //  TODO - 64 bit
        redline = MAXINT;
    }
    mprSetMemLimits(redline, -1, -1);
    return 0;
}


/*
    native static function get resident(): Number
 */
static EjsNumber *getResident(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (MprNumber) mem->rss);
}


/*
    native static function get system(): Number
 */
static EjsNumber *getSystemRam(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprMemStats    *mem;

    mem = mprGetMemStats(ejs);
    return ejsCreateNumber(ejs, (double) mem->ram);
}


/*
    native static function stats(): Void
 */
static EjsObj *printStats(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    //  TODO - should go to log file and not to stdout
    mprPrintMem("Memory Report", 1);
    return 0;
}


/******************************** Initialization ******************************/

PUBLIC void ejsConfigureMemoryType(Ejs *ejs)
{
    EjsType     *type;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Memory"), sizeof(EjsPot), ejsManagePot, EJS_TYPE_POT)) == 0) {
        return;
    }
    ejsBindMethod(ejs, type, ES_Memory_allocated, getAllocatedMemory);
    ejsBindAccess(ejs, type, ES_Memory_maximum, getMaxMemory, setMaxMemory);
    ejsBindAccess(ejs, type, ES_Memory_redline, getRedline, setRedline);
    ejsBindMethod(ejs, type, ES_Memory_resident, getResident);
    ejsBindMethod(ejs, type, ES_Memory_system, getSystemRam);
    ejsBindMethod(ejs, type, ES_Memory_stats, printStats);

#if FUTURE
    EjsPot      *prototype;
    prototype = type->prototype;
    ejsBindAccess(ejs, type, ES_Memory_callback, NULL, setRedlineCallback);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsMprLog.c"
 */
/************************************************************************/

/*
    ejsMprLog.c -- MprLog class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Methods **********************************/
/*
    function emit(level: Number, ...data): Number
 */
static EjsNumber *lf_emit(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *ap;
    EjsObj          *vp;
    EjsString       *str;
    char            *msg, *arg;
    ssize           len, written;
    int             i, level, paused;

    assert(argc >= 2 && ejsIs(ejs, argv[1], Array));

    level = ejsGetInt(ejs, argv[0]);
    args = (EjsArray*) argv[1];
    written = 0;
    msg = 0;
    paused = ejsBlockGC(ejs);

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, args, i);
        assert(vp);
        switch (TYPE(vp)->sid) {
        case S_ByteArray:
            ap = (EjsByteArray*) vp;
            //  TODO ENCODING
            arg = (char*) &ap->value[ap->readPosition];
            len = ap->writePosition - ap->readPosition;
            break;

        case S_String:
            //  TODO - use NULL instead of &len
            arg = awtom(((EjsString*) vp)->value, &len);
            break;

        default:
            str = ejsToString(ejs, vp);
            //  TODO - use NULL instead of &len
            arg = awtom(((EjsString*) str)->value, &len);
            break;
        }
        msg = srejoin(msg, arg, NULL);
    }
    if (msg) {
        mprRawLog(level, "%s", msg);
        written += slen(msg);
    }
    ejsUnblockGC(ejs, paused);
    return ejsCreateNumber(ejs, (MprNumber) slen(msg));
}


/*
    function get fixed(): Boolean
 */
static EjsBoolean *lf_fixed(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, ejs->hosted || mprGetCmdlineLogging());
}


/*  
    function set fixed(yes: Boolean)
 */
static EjsVoid *lf_set_fixed(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    int     yes;

    yes = (argc >= 1 && argv[0] == ESV(true));
    mprSetCmdlineLogging(yes);
    return 0;
}


/*  
    function get level(): Number
 */
static EjsNumber *lf_level(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, mprGetLogLevel(ejs));
}


/*  
    function set level(value: Number): Void
 */
static EjsObj *lf_set_level(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    mprSetLogLevel(ejsGetInt(ejs, argv[0]));
    return 0;
}


/*  
    function redirect(location: String, level: Number = null): Void
 */
static EjsFile *lf_redirect(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar   *logSpec;
    int     level;

    logSpec = ejsToMulti(ejs, argv[0]);
    level = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : -1;
    mprStartLogging(logSpec, 0);
    if (level >= 0) {
        mprSetLogLevel(level);
    }
    return 0;
}


/*********************************** Factory **********************************/

PUBLIC void ejsConfigureMprLogType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "MprLog"), sizeof(EjsPot), ejsManagePot, EJS_TYPE_POT)) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_MprLog_emit, lf_emit);
    ejsBindAccess(ejs, prototype, ES_MprLog_fixed, lf_fixed, lf_set_fixed);
    ejsBindAccess(ejs, prototype, ES_MprLog_level, lf_level, lf_set_level);
    ejsBindMethod(ejs, prototype, ES_MprLog_redirect, lf_redirect);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsNamespace.c"
 */
/************************************************************************/

/**
    ejsNamespace.c - Ejscript Namespace class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************* Code ***********************************/
/*
    Cast the operand to the specified type
 */

static EjsAny *castNamespace(Ejs *ejs, EjsNamespace *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case S_String:
        return vp->value;

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


static EjsAny *invokeNamespaceOperator(Ejs *ejs, EjsNamespace *lhs, int opCode, EjsNamespace *rhs)
{
    bool        boolResult;

    switch (opCode) {
    case EJS_OP_COMPARE_EQ:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opCode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        }
        boolResult = ejsCompareString(ejs, lhs->value, rhs->value) == 0;
        break;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        boolResult = lhs == rhs;
        break;

    case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opCode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        }
        boolResult = !(ejsCompareString(ejs, lhs->value, rhs->value) == 0);
        break;

    case EJS_OP_COMPARE_STRICTLY_NE:
        boolResult = !(lhs == rhs);
        break;

    default:
        ejsThrowTypeError(ejs, "Operation is not valid on this type");
        return 0;
    }
    return ejsCreateBoolean(ejs, boolResult);
}


/*
    Define a reserved namespace in a block.
 */
PUBLIC EjsNamespace *ejsDefineReservedNamespace(Ejs *ejs, EjsBlock *block, EjsName *typeName, cchar *spaceName)
{
    EjsNamespace    *namespace;

    namespace = ejsCreateReservedNamespace(ejs, typeName, ejsCreateStringFromAsc(ejs, spaceName));
    if (namespace && block && ejsAddNamespaceToBlock(ejs, block, namespace) < 0) {
        return 0;
    }
    return namespace;
}


/*
    Format a reserved namespace to create a unique namespace. "internal, public, private, protected"

    Namespaces are formatted as strings using the following format, where type is optional. Types may be qualified.
        [type,space]

    Example:
        [debug::Shape,public] where Shape was declared as "debug class Shape"
 */
PUBLIC EjsString *ejsFormatReservedNamespace(Ejs *ejs, EjsName *typeName, EjsString *spaceName)
{
    EjsString   *namespace;

    if (typeName) {
        if (typeName->space && typeName->space == ESV(public)) {
            namespace = ejsSprintf(ejs, "[%N,%@]", *typeName, spaceName);
        } else {
            namespace = ejsSprintf(ejs, "[%@,%@]", typeName->name, spaceName);
        }
    } else {
        namespace = ejsSprintf(ejs, "[%@]", spaceName);
    }
    return namespace;
}


/*********************************** Factory **********************************/
/*
    Create a namespace with the given name as its definition value.
 */
PUBLIC EjsNamespace *ejsCreateNamespace(Ejs *ejs, EjsString *name)
{
    EjsNamespace    *np;

    if ((np = ejsCreateObj(ejs, ESV(Namespace), 0)) == 0) {
        return 0;
    }
    np->value = name;
    mprSetName(np, "namespace");
    return np;
}


/*
    Create a reserved namespace. Format the package, type and space names to create a unique namespace.
 */
PUBLIC EjsNamespace *ejsCreateReservedNamespace(Ejs *ejs, EjsName *typeName, EjsString *spaceName)
{
    EjsString       *formattedName;

    assert(spaceName);

    if (typeName) {
        formattedName = ejsFormatReservedNamespace(ejs, typeName, spaceName);
    } else {
        formattedName = spaceName;
    }
    return ejsCreateNamespace(ejs, formattedName);
}


static void manageNamespace(EjsNamespace *ns, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ns->value);
    }
}


PUBLIC void ejsCreateNamespaceType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", "Namespace"), sizeof(EjsNamespace), S_Namespace, ES_Namespace_NUM_CLASS_PROP,
        manageNamespace, EJS_TYPE_OBJ | EJS_TYPE_IMMUTABLE_INSTANCES);
    type->helpers.cast = (EjsCastHelper) castNamespace;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeNamespaceOperator;
}


PUBLIC void ejsConfigureNamespaceType(Ejs *ejs)
{
    EjsType     *type;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Namespace"))) == 0) {
        return;
    }
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsNull.c"
 */
/************************************************************************/

/**
    ejsNull.c - Ejscript Null class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/******************************************************************************/
/*
    Cast the null operand to a primitive type
 */

static EjsAny *castNull(Ejs *ejs, EjsObj *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ESV(false);

    case S_Number:
        return ESV(zero);

    case S_Object:
    default:
        /*
            Cast null to anything else results in a null
         */
        return vp;

    case S_String:
        return ejsCreateStringFromAsc(ejs, "null");
    }
}


static EjsAny *coerceNullOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (!ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        /* Fall through */

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ESV(zero), opcode, rhs);

    /*
        Comparision
     */
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ESV(zero), opcode, rhs);
        } else if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_COMPARE_NE:
        if (ejsIs(ejs, rhs, Void)) {
            return ESV(false);
        }
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_EQ:
        if (ejsIs(ejs, rhs, Void)) {
            return ESV(true);
        }
        return ESV(false);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return ESV(true);

    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
    return 0;
}


static EjsAny *invokeNullOperator(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceNullOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*
        Types now match. Both left and right types are both "null"
     */
    switch (opcode) {

    /*
        NOTE: strict eq is the same as eq
     */
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return ESV(true);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return ESV(one);

    /*
        Binary operators. Reinvoke with left = zero
     */
    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ESV(zero), opcode, rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
}


/*
    iterator native function get(): Iterator
 */
static EjsIterator *getNullIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, np, -1, NULL, 0, NULL);
}


static EjsObj *getNullProperty(Ejs *ejs, EjsNull *unused, int slotNum)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
    return 0;
}


/*********************************** Factory **********************************/
/*
    We dont actually allocate any nulls. We just reuse the singleton instance.
    OPT - macro
 */
PUBLIC EjsNull *ejsCreateNull(Ejs *ejs)
{
    return ESV(null);
}


PUBLIC void ejsInitNullType(Ejs *ejs, EjsType *type)
{
    type->helpers.cast             = (EjsCastHelper) castNull;
    type->helpers.getProperty      = (EjsGetPropertyHelper) getNullProperty;
    type->helpers.invokeOperator   = (EjsInvokeOperatorHelper) invokeNullOperator;
}


PUBLIC void ejsConfigureNullType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Null"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_Null_iterator_get, getNullIterator);
    ejsBindMethod(ejs, prototype, ES_Null_iterator_getValues, getNullIterator);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsNumber.c"
 */
/************************************************************************/

/**
    ejsNumber.c - Number type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************** Defines ***********************************/
/*
   Mode values for nota
 */
#define DTOA_ALL_DIGITS         0       /**< Return all digits */
#define DTOA_N_DIGITS           2       /**< Return total N digits */
#define DTOA_N_FRACTION_DIGITS  3       /**< Return total fraction digits */

/*
    Flags for mprDtoa
 */
#define DTOA_EXPONENT_FORM      0x10    /**< Result in exponent form (N.NNNNe+NN) */
#define DTOA_FIXED_FORM         0x20    /**< Emit in fixed form (NNNN.MMMM)*/

#if UNUSED
/**
    Convert a double to ascii
    @param value Value to convert
    @param ndigits Number of digits to render
    @param mode Modes are:
         0   Shortest string,
         1   Like 0, but with Steele & White stopping rule,
         2   Return ndigits of result,
         3   Number of digits applies after the decimal point.
    @param flags Format flags
 */
extern char *mprDtoa(double value, int ndigits, int mode, int flags);
#endif

extern char *dtoa(double d, int mode, int ndigits, int* decpt, int* sign, char** rve);
extern void freedtoa(char* ptr);

/**************************** Forward Declarations ****************************/

#define fixed(n) ((int64) (floor(n)))
static char *ntoa(double value, int ndigits, int mode, int flags);

/******************************************************************************/
/*
    Cast the operand to the specified type
 */
static EjsAny *castNumber(Ejs *ejs, EjsNumber *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ((vp->value && !ejsIsNan(vp->value)) ? ESV(true) : ESV(false));

    case S_String:
        //  OPT. ntoa does a clone
        return ejsCreateStringFromAsc(ejs, ntoa(vp->value, 0, 0, 0));

    case S_Number:
        return vp;
            
    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


static EjsNumber *cloneNumber(Ejs *ejs, EjsNumber *np, int deep)
{
    return ejsCreateNumber(ejs, np->value);
}


static EjsAny *coerceNumberOperands(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        if (ejsIs(ejs, rhs, Void)) {
            return ESV(nan);
        } else if (ejsIs(ejs, rhs, Null)) {
            return lhs;
        } else if (ejsIs(ejs, rhs, Boolean) || ejsIs(ejs, rhs, Date)) {
            return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        } else if (ejsIs(ejs, rhs, String)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsNumber*) lhs)->value ? ESV(true) : ESV(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsNumber*) lhs)->value ? ESV(false): ESV(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return ESV(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


static EjsAny *invokeNumberOperator(Ejs *ejs, EjsNumber *lhs, int opcode, EjsNumber *rhs)
{
    EjsObj      *result;

    assert(lhs);
    
    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, Number) || !ejsIs(ejs, rhs, Number)) {
            if ((result = coerceNumberOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }

    /*
        Types now match, both numbers
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return ((lhs->value == rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return ((lhs->value != rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_LT:
        return ((lhs->value < rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_LE:
        return ((lhs->value <= rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_GT:
        return ((lhs->value > rhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_GE:
        return ((lhs->value >= rhs->value) ? ESV(true): ESV(false));

    /*
     *  Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return ESV(false);

    case EJS_OP_NEG:
        return ejsCreateNumber(ejs, -lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return ejsCreateBoolean(ejs, !fixed(lhs->value));

    case EJS_OP_NOT:
        return ejsCreateNumber(ejs, (MprNumber) (~fixed(lhs->value)));


    /*
        Binary operations
     */
    case EJS_OP_ADD:
        return ejsCreateNumber(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) & fixed(rhs->value)));

    case EJS_OP_DIV:
        return ejsCreateNumber(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return ejsCreateNumber(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) | fixed(rhs->value)));

    case EJS_OP_REM:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) % fixed(rhs->value)));

    case EJS_OP_SHL:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) << fixed(rhs->value)));

    case EJS_OP_SHR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_SUB:
        return ejsCreateNumber(ejs, lhs->value - rhs->value);

    case EJS_OP_USHR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_XOR:
        return ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) ^ fixed(rhs->value)));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
}


/*********************************** Methods **********************************/
/*
    Number constructor.
    function Number(value: Object = null)
 */
static EjsNumber *numberConstructor(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    EjsNumber   *num;

    assert(argc == 0 || argc == 1);

    if (argc == 1) {
        num = ejsToNumber(ejs, argv[0]);
        if (num) {
            np->value = num->value;
        }
    }
    return np;
}


/*
    Function to iterate and return each number in sequence.
    NOTE: this is not a method of Number. Rather, it is a callback function for Iterator.
 */
static EjsNumber *nextNumber(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsNumber   *np;

    np = (EjsNumber*) ip->target;
    if (!ejsIs(ejs, np, Number)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < np->value) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    function integral(size: Number: 32): Number
 */
static EjsNumber *integral(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    int64   mask, result;
    int     size;

    size = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 32;

    result = ((int64) np->value);
    if (size < 64) {
        mask = 1;
        mask = (mask << size) - 1;
        result &= mask;
    }
    return ejsCreateNumber(ejs, (MprNumber) result);
}


/*
    function get isFinite(): Boolean
 */
static EjsBoolean *isFinite(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    if (np->value == ((EjsNumber*) ESV(nan))->value || np->value == ((EjsNumber*) ESV(infinity))->value || 
            np->value == ((EjsNumber*) ESV(negativeInfinity))->value) {
        return ESV(false);
    }
    return ESV(true);
}


/*
    function get isNaN(): Boolean
 */
static EjsBoolean *isNaN(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    return (mprIsNan(np->value) ? ESV(true) : ESV(false));
}


/*
    function toExponential(fractionDigits: Number = 0): String

    Display with only one digit before the decimal point.
 */
static EjsString *toExponential(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]): 0;
    result = ntoa(np->value, ndigits, DTOA_N_DIGITS, DTOA_EXPONENT_FORM);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    function toFixed(fractionDigits: Number = 0): String

    Display the specified number of fractional digits
 */
static EjsString *toFixed(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    result = ntoa(np->value, ndigits, DTOA_N_FRACTION_DIGITS, DTOA_FIXED_FORM);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    function toPrecision(numDigits: Number = MAX_VALUE): String

    Display the specified number of total digits
 */
static EjsString *toPrecision(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    result = ntoa(np->value, ndigits, DTOA_N_DIGITS, 0);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    Return the default iterator. This returns the index names.

    iterator native function get(): Iterator
 */
static EjsIterator *getNumberIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, np, -1, nextNumber, 0, NULL);
}


/*
    Convert the number to a string.
    function toString(): String
 */
static EjsObj *numberToString(Ejs *ejs, EjsNumber *vp, int argc, EjsObj **argv)
{
    return castNumber(ejs, vp, ESV(String));
}


/*********************************** Support **********************************/

#ifndef ejsIsNan
PUBLIC int ejsIsNan(double f)
{
#if ME_WIN_LIKE
    return _isnan(f);
#elif VXWORKS
    return isnan(f);
#else
    return (f == FP_NAN);
#endif
}
#endif


PUBLIC bool ejsIsInfinite(MprNumber f)
{
#if ME_WIN_LIKE
    return !_finite(f);
#elif VXWORKS
    return isinf(f);
#else
    return (f == FP_INFINITE);
#endif
}


PUBLIC void ejsLockDtoa(int n)
{
    EjsService  *es;
    
    es = MPR->ejsService;
    mprSpinLock(es->dtoaSpin[n]);
}


PUBLIC void ejsUnlockDtoa(int n)
{
    EjsService  *es;
    
    es = MPR->ejsService;
    mprSpinUnlock(es->dtoaSpin[n]);
}


/*
    Convert a double to ascii. Caller must free the result. This uses the JavaScript ECMA-262 spec for formatting rules.
 */
static char *ntoa(double value, int ndigits, int mode, int flags)
{
    MprBuf  *buf;
    char    *intermediate, *ip;
    int     period, sign, len, exponentForm, fixedForm, exponent, count, totalDigits, npad;

    buf = mprCreateBuf(64, -1);
    intermediate = 0;
    exponentForm = 0;
    fixedForm = 0;

    if (mprIsNan(value)) {
        mprPutStringToBuf(buf, "NaN");

    } else if (mprIsInfinite(value)) {
        if (value < 0) {
            mprPutStringToBuf(buf, "-Infinity");
        } else {
            mprPutStringToBuf(buf, "Infinity");
        }
    } else if (value == 0) {
        mprPutCharToBuf(buf, '0');

    } else {
        if (ndigits <= 0) {
            if (!(flags & DTOA_FIXED_FORM)) {
                mode = DTOA_ALL_DIGITS;
            }
            ndigits = 0;

        } else if (mode == DTOA_ALL_DIGITS) {
            mode = DTOA_N_DIGITS;
        }
        if (flags & DTOA_EXPONENT_FORM) {
            exponentForm = 1;
            if (ndigits > 0) {
                ndigits++;
            } else {
                ndigits = 0;
                mode = DTOA_ALL_DIGITS;
            }
        } else if (flags & DTOA_FIXED_FORM) {
            fixedForm = 1;
        }

        /*
            Convert to an intermediate string representation. Period is the offset of the decimal point. NOTE: the
            intermediate representation may have less digits than period.
            Note: ndigits < 0 seems to trim N digits from the end with rounding.
         */
        ip = intermediate = dtoa(value, mode, ndigits, &period, &sign, NULL);
        len = (int) slen(intermediate);
        exponent = period - 1;

        if (mode == DTOA_ALL_DIGITS && ndigits == 0) {
            ndigits = len;
        }
        if (!fixedForm) {
            if (period <= -6 || period > 21) {
                exponentForm = 1;
            }
        }
        if (sign) {
            mprPutCharToBuf(buf, '-');
        }
        if (exponentForm) {
            mprPutCharToBuf(buf, ip[0] ? ip[0] : '0');
            if (len > 1) {
                mprPutCharToBuf(buf, '.');
                mprPutSubStringToBuf(buf, &ip[1], (ndigits == 0) ? len - 1: ndigits);
            }
            mprPutCharToBuf(buf, 'e');
            mprPutCharToBuf(buf, (period < 0) ? '-' : '+');
            mprPutToBuf(buf, "%d", (exponent < 0) ? -exponent: exponent);

        } else {
            if (mode == DTOA_N_FRACTION_DIGITS) {
                /* Count of digits */
                if (period <= 0) {
                    /* Leading fractional zeros required */
                    mprPutStringToBuf(buf, "0.");
                    mprPutPadToBuf(buf, '0', -period);
                    mprPutStringToBuf(buf, ip);
                    npad = ndigits - len + period;
                    if (npad > 0) {
                        mprPutPadToBuf(buf, '0', npad);
                    }

                } else {
                    count = min(len, period);
                    /* Leading integral digits */
                    mprPutSubStringToBuf(buf, ip, count);
                    /* Trailing zero pad */
                    if (period > len) {
                        mprPutPadToBuf(buf, '0', period - len);
                    }
                    totalDigits = count + ndigits;
                    if (period < totalDigits) {
                        count = totalDigits + sign - (int) mprGetBufLength(buf);
                        mprPutCharToBuf(buf, '.');
                        mprPutSubStringToBuf(buf, &ip[period], count);
                        mprPutPadToBuf(buf, '0', count - slen(&ip[period]));
                    }
                }

            } else if (len <= period && period <= 21) {
                /* data shorter than period */
                mprPutStringToBuf(buf, ip);
                mprPutPadToBuf(buf, '0', period - len);

            } else if (0 < period && period <= 21) {
                /* Period shorter than data */
                mprPutSubStringToBuf(buf, ip, period);
                mprPutCharToBuf(buf, '.');
                mprPutStringToBuf(buf, &ip[period]);

            } else if (-6 < period && period <= 0) {
                /* Small negative exponent */
                mprPutStringToBuf(buf, "0.");
                mprPutPadToBuf(buf, '0', -period);
                mprPutStringToBuf(buf, ip);

            } else {
                assert(0);
            }
        }
    }
    mprAddNullToBuf(buf);
    if (intermediate) {
        freedtoa(intermediate);
    }
    return sclone(mprGetBufStart(buf));
}


/*********************************** Factory **********************************/
/*
    Create an initialized number
 */

PUBLIC EjsNumber *ejsCreateNumber(Ejs *ejs, MprNumber value)
{
    EjsNumber   *vp;

    if (value == 0) {
        return ESV(zero);
    } else if (value == 1) {
        return ESV(one);
    } else if (value == -1) {
        return ESV(minusOne);
    }
    if ((vp = ejsCreateObj(ejs, ESV(Number), 0)) != 0) {
        vp->value = value;
    }
    return vp;
}


PUBLIC void ejsCreateNumberType(Ejs *ejs)
{
    EjsNumber   *np;
    EjsType     *type;
    static int  zero = 0;

    type = ejsCreateCoreType(ejs, N("ejs", "Number"), sizeof(EjsNumber), S_Number, ES_Number_NUM_CLASS_PROP, 
        NULL, EJS_TYPE_OBJ | EJS_TYPE_IMMUTABLE_INSTANCES);

    type->helpers.cast = (EjsCastHelper) castNumber;
    type->helpers.clone = (EjsCloneHelper) cloneNumber;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeNumberOperator;

    np = ejsCreateObj(ejs, type, 0);
    np->value = 0;
    ejsAddImmutable(ejs, S_zero, EN("zero"), np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 1;
    ejsAddImmutable(ejs, S_one, EN("one"), np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = -1;
    ejsAddImmutable(ejs, S_minusOne, EN("minusOne"), np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 1.0 / zero;
    ejsAddImmutable(ejs, S_infinity, EN("Infinity"), np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = -1.0 / zero;
    ejsAddImmutable(ejs, S_negativeInfinity, EN("NegativeInfinity"), np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 0.0 / zero;
    ejsAddImmutable(ejs, S_nan, EN("NaN"), np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 1.7976931348623157e+308;
    ejsAddImmutable(ejs, S_max, EN("max"), np);

    np = ejsCreateObj(ejs, type, 0);
    np->value = 5e-324;
    ejsAddImmutable(ejs, S_min, EN("min"), np);
}


PUBLIC void ejsConfigureNumberType(Ejs *ejs)
{
    EjsType    *type;
    EjsPot     *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Number"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, numberConstructor);
    ejsBindMethod(ejs, prototype, ES_Number_iterator_get, getNumberIterator);
    ejsBindMethod(ejs, prototype, ES_Number_iterator_getValues, getNumberIterator);
    ejsBindMethod(ejs, prototype, ES_Number_integral, integral);
    ejsBindMethod(ejs, prototype, ES_Number_isFinite, isFinite);
    ejsBindMethod(ejs, prototype, ES_Number_isNaN, isNaN);
    ejsBindMethod(ejs, prototype, ES_Number_toExponential, toExponential);
    ejsBindMethod(ejs, prototype, ES_Number_toFixed, toFixed);
    ejsBindMethod(ejs, prototype, ES_Number_toPrecision, toPrecision);
    ejsBindMethod(ejs, prototype, ES_Number_toString, numberToString);

    ejsSetProperty(ejs, type, ES_Number_MaxValue, ESV(max));
    ejsSetProperty(ejs, type, ES_Number_MinValue, ESV(min));
    ejsSetProperty(ejs, type, ES_Number_NEGATIVE_INFINITY, ESV(negativeInfinity));
    ejsSetProperty(ejs, type, ES_Number_POSITIVE_INFINITY, ESV(infinity));
    ejsSetProperty(ejs, type, ES_Number_NaN, ESV(nan));
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsObject.c"
 */
/************************************************************************/

/**
    ejsObject.c - Object class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/****************************** Forward Declarations **************************/

static EjsObj   *obj_defineProperty(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv);

/************************************* Code ***********************************/
/*
    function get constructor(): Object
 */
static EjsType *obj_constructor(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsType     *constructor;

    if ((constructor = ejsGetPropertyByName(ejs, obj, EN("constructor"))) != 0) {
        return constructor;
    }
    return TYPE(obj);
}


/*
    function get prototype(): Object

    The prototype method is special. It is declared as static so it is generated in the type slots, but it is
    patched to be an instance method so the value of "this" will be preserved when it is invoked.
 */
static EjsAny *obj_prototype(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsFunction     *fun;
    EjsType         *type;
    EjsPot          *prototype;

    if (ejs->compiling) {
        assert(0);
        prototype = ESV(undefined);
        
    } else if (ejsIsType(ejs, obj)) {
        prototype = ((EjsType*) obj)->prototype;
        
    } else if (ejsIsFunction(ejs, obj)) {
        fun = (EjsFunction*) obj;
        if (fun->archetype) {
            prototype = fun->archetype->prototype;
        
        } else {
            type = ejsCreateArchetype(ejs, fun, NULL);
            prototype = type->prototype;
        }
    } else {
        prototype = ESV(undefined);
    }
    return prototype;
}


/*
    function set prototype(p: Object): Void
 */
static EjsObj *obj_set_prototype(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsPot          *prototype;
    EjsFunction     *fun;

    if (ejs->compiling) {
        assert(0);
        return ESV(undefined);
    }
    prototype = (EjsPot*) argv[0];
    if (ejsIsType(ejs, obj)) {
        ((EjsType*) obj)->prototype = prototype;
    } else {
        if (ejsIsFunction(ejs, obj)) {
            fun = (EjsFunction*) obj;
            if (ejsIsType(ejs, fun->archetype)) {
                fun->archetype->prototype = prototype;
            } else {
                ejsCreateArchetype(ejs, fun, prototype);
            }
        } else {
            /*
                Normal property creation. This "prototype" property is not used internally.
             */
            ejsSetPropertyByName(ejs, obj, EN("prototype"), prototype);
        }
    }
    return 0;
}


/*
    function clone(deep: Boolean = true) : Object
 */
static EjsObj *obj_clone(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    bool    deep;

    deep = (argc == 1 && argv[0] == ESV(true));
    return ejsClone(ejs, obj, deep);
}


/*
    static function create(proto: Object, props: Object = undefined): Objectd 
 */
static EjsObj *obj_create(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *constructor;
    EjsObj          *obj, *properties, *options;
    EjsPot          *prototype;
    EjsType         *type;
    EjsName         qname;
    int             count, slotNum;

    prototype = (EjsPot*) argv[0];
    properties = (argc >= 1) ? argv[1] : 0;

    if (ejsIsType(ejs, prototype)) {
        type = (EjsType*) prototype;
    } else {
        constructor = ejsGetPropertyByName(ejs, prototype, EN("constructor"));
        if (constructor) {
            if (ejsIsType(ejs, constructor)) {
                type = (EjsType*) constructor;
            } else if (ejsIsFunction(ejs, constructor)) {
                if (constructor->archetype == 0) {
                    if ((type = ejsCreateArchetype(ejs, constructor, prototype)) == 0) {
                        return 0;
                    }
                }
                type = constructor->archetype;
            } else {
                ejsThrowTypeError(ejs, "Bad type for the constructor property. Must be a function or type");
                return 0;
            }

        } else {
            if ((type = ejsCreateArchetype(ejs, NULL, prototype)) == 0) {
                return 0;
            }
            ejsSetPropertyByName(ejs, prototype, EN("constructor"), type);
        }
    }
    obj = ejsCreateObj(ejs, type, 0);
    if (properties) {
        count = ejsGetLength(ejs, properties);
        for (slotNum = 0; slotNum < count; slotNum++) {
            qname = ejsGetPropertyName(ejs, properties, slotNum);
            options = ejsGetProperty(ejs, properties, slotNum);
            argv[0] = obj;
            argv[1] = (EjsObj*) qname.name;
            argv[2] = options;
            obj_defineProperty(ejs, (EjsObj*) type, 3, argv);
        }
    }
    return obj;
}


/*
    static function defineProperty(obj: Object, prop: String, options: Object): Void
*/
static EjsObj *obj_defineProperty(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *fun, *get, *set;
    EjsType         *type;
    EjsObj          *obj, *options, *configurable, *enumerable, *namespace, *value, *writable;
    EjsName         qname;
    int             attributes, slotNum;

    assert(argc == 3);

    obj = argv[0];
    if (!ejsIsPot(ejs, obj)) {
        ejsThrowTypeError(ejs, "Object is not configurable");
        return NULL;
    }
    qname.name = (EjsString*) argv[1];
    qname.space = ESV(empty);
    options = argv[2];
    value = 0;
    set = get = 0;
    attributes = 0;

    if ((namespace = ejsGetPropertyByName(ejs, options, EN("namespace"))) != 0) {
        qname.space = (EjsString*) namespace;
    }
    if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
        if (ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_FIXED)) {
            ejsThrowTypeError(ejs, "Property \"%N\" is not configurable", qname);
            return 0;
        }
    }
    type = ejsGetPropertyByName(ejs, options, EN("type"));

    if ((configurable = ejsGetPropertyByName(ejs, options, EN("configurable"))) != 0) {
        if (configurable == ESV(false)) {
            attributes |= EJS_TRAIT_FIXED;
        }
    }
    if ((enumerable = ejsGetPropertyByName(ejs, options, EN("enumerable"))) != 0) {
        if (enumerable == ESV(false)) {
            attributes |= EJS_TRAIT_HIDDEN;
        }
    }
    value = ejsGetPropertyByName(ejs, options, EN("value"));
    if (value && type && !ejsIsA(ejs, value, type)) {
        ejsThrowArgError(ejs, "Value is not of the required type");
        return 0;
    }
    if ((get = ejsGetPropertyByName(ejs, options, EN("get"))) != 0) {
        if (ejsIsFunction(ejs, get)) {
            EjsName qset = { qname.space, ejsCreateStringFromAsc(ejs, "set") };
            get->setter = ejsGetPropertyByName(ejs, obj, qset);
            attributes |= EJS_TRAIT_GETTER;
        } else {
            ejsThrowArgError(ejs, "The \"get\" property is not a function");
            return 0;
        }
    }
    if ((set = ejsGetPropertyByName(ejs, options, EN("set"))) != 0) {
        if (ejsIsFunction(ejs, set)) {
            if (get == 0 && (fun = ejsGetPropertyByName(ejs, obj, qname)) != 0) {
                get = fun;
            }
            if (get) {
                get->setter = set;
            }
        } else {
            ejsThrowArgError(ejs, "The \"set\" property is not a function");
            return 0;
        }
        attributes |= EJS_TRAIT_SETTER;
    }
    if (value && (get || set)) {
        ejsThrowArgError(ejs, "Cannot provide a value and getters or setters");
        return 0;
    }
    if (get) {
        value = (EjsObj*) get;
    }
    if ((writable = ejsGetPropertyByName(ejs, options, EN("writable"))) != 0) {
        if (writable == ESV(false)) {
            attributes |= EJS_TRAIT_READONLY;
        }
    }
    assert((attributes & EJS_TRAIT_MASK) == attributes);
    if (ejsDefineProperty(ejs, obj, -1, qname, type, attributes, value) < 0) {
        ejsThrowTypeError(ejs, "Cannot define property %@", qname.name);
    }
    return 0;
}


/*
    static function freeze(obj: Object): Void
 */
static EjsObj *obj_freeze(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsTrait    *trait;
    int         slotNum, numProp;

    obj = (EjsObj*) argv[0];
    SET_DYNAMIC(obj, 0);
    numProp = ejsGetLength(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            ejsSetPropertyTraits(ejs, obj, slotNum, NULL, trait->attributes | EJS_TRAIT_READONLY | EJS_TRAIT_FIXED);
        }
    }
    if (ejsIsType(ejs, obj)) {
        obj = (EjsObj*) ((EjsType*) obj)->prototype;
        numProp = ejsGetLength(ejs, obj);
        for (slotNum = 0; slotNum < numProp; slotNum++) {
            if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
                ejsSetPropertyTraits(ejs, obj, slotNum, NULL, trait->attributes | EJS_TRAIT_READONLY | EJS_TRAIT_FIXED);
            }
        }
    }
    return 0;
}


/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Object. Rather, it is a callback function for Iterator.
 */
static EjsObj *nextObjectKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsName     qname;
    EjsTrait    *trait;
    int         count;

    obj = ip->target;
    if ((count = ejsGetLength(ejs, obj)) < ip->length) {
        ip->length = count;
    }
    for (; ip->index < ip->length; ip->index++) {
        qname = ejsGetPropertyName(ejs, obj, ip->index);
        if (qname.name == NULL) {
            continue;
        }
        trait = ejsGetPropertyTraits(ejs, obj, ip->index);
        if (trait && trait->attributes & 
                (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
            continue;
        }
        ip->index++;
        return (EjsObj*) qname.name;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator.

    iterator function get(options: Object = null): Iterator
 */
static EjsIterator *obj_get(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, obj, ejsGetLength(ejs, obj), nextObjectKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Object. Rather, it is a callback function for Iterator
 */
static EjsObj *nextObjectValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsTrait    *trait;
    int         count;

    obj = ip->target;
    if ((count = ejsGetLength(ejs, obj)) < ip->length) {
        ip->length = count;
    }
    for (; ip->index < ip->length; ip->index++) {
        trait = ejsGetPropertyTraits(ejs, obj, ip->index);
        if (trait && trait->attributes & 
                (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
            continue;
        }
        return ejsGetProperty(ejs, obj, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator function getValues(options: Object = null): Iterator
 */
static EjsIterator *obj_getValues(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, obj, ejsGetLength(ejs, obj), nextObjectValue, 0, NULL);
}


/*
    Get the number of properties in the object.

    function get getOwnPropertyCount(obj): Number
 */
static EjsNumber *obj_getOwnPropertyCount(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return ejsCreateNumber(ejs, ejsGetLength(ejs, obj) - TYPE(obj)->numInherited);
}


/*
    static function getOwnPropertyDescriptor(obj: Object, prop: String): Object
 */
static EjsObj *obj_getOwnPropertyDescriptor(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *fun;
    EjsTrait        *trait;
    EjsObj          *obj, *result, *value;
    EjsName         qname, qn;
    EjsType         *type;
    EjsLookup       lookup;
    int             slotNum;

    obj = argv[0];
    //  TODO - ugly
    qname.space = ESV(empty);
    qname.name = (EjsString*) argv[1];
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, qname, &lookup)) < 0) {
        return ESV(false);
    }
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    result = ejsCreateEmptyPot(ejs);
    value = ejsGetVarByName(ejs, obj, qname, &lookup);
    if (value == 0) {
        value = ESV(null);
    }
    type = (trait) ? trait->type: 0;
    if (trait && trait->attributes & EJS_TRAIT_GETTER) {
        ejsSetPropertyByName(ejs, result, EN("get"), value);
    } else if (trait && trait->attributes & EJS_TRAIT_SETTER) {
        fun = (EjsFunction*) value;
        if (ejsIsFunction(ejs, fun)) {
            ejsSetPropertyByName(ejs, result, EN("set"), fun->setter);
        }
    } else if (value) {
        ejsSetPropertyByName(ejs, result, EN("value"), value);
    }
    ejsSetPropertyByName(ejs, result, EN("configurable"), 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_FIXED)));
    ejsSetPropertyByName(ejs, result, EN("enumerable"), 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_HIDDEN)));
    qn = ejsGetPropertyName(ejs, obj, slotNum);
    ejsSetPropertyByName(ejs, result, EN("namespace"), qn.space);
    ejsSetPropertyByName(ejs, result, EN("type"), type ? (EjsObj*) type : ESV(null));
    ejsSetPropertyByName(ejs, result, EN("writable"), 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_READONLY)));
    return result;
}


/*
    Get all properties names including non-enumerable properties

    static function getOwnPropertyNames(obj: Object, options: Object): Array
 */
static EjsArray *obj_getOwnPropertyNames(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj, *options, *arg;
    EjsArray    *result;
    EjsTrait    *trait;
    EjsName     qname;
    int         slotNum, numProp, index, includeBases, excludeFunctions;

    obj = (EjsObj*) argv[0];
    includeBases = 0;
    excludeFunctions = 0;
    if (argc > 1) {
        options = argv[1];
        if ((arg = ejsGetPropertyByName(ejs, options, EN("includeBases"))) != 0) {
            includeBases = (arg == ESV(true));
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN("excludeFunctions"))) != 0) {
            excludeFunctions = (arg == ESV(true));
        }
    }
    if ((result = ejsCreateArray(ejs, 0)) == 0) {
        return 0;
    }
    index = 0;
    slotNum = (includeBases) ? 0 : TYPE(obj)->numInherited;
    numProp = ejsGetLength(ejs, obj);
    for (; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (trait->attributes & (EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
                continue;
            }
        }
        qname = ejsGetPropertyName(ejs, obj, slotNum);
        if (excludeFunctions && ejsIsFunction(ejs, ejsGetProperty(ejs, obj, slotNum))) {
            continue;
        }
        ejsSetProperty(ejs, result, index++, qname.name);
    }
    if (ejsIsType(ejs, obj) || ejsIsFunction(ejs, obj)) {
        if (ejsLookupProperty(ejs, obj, EN("prototype")) < 0) {
            ejsSetProperty(ejs, result, index++, ejsCreateStringFromAsc(ejs, "prototype"));
        }
        if (ejsLookupProperty(ejs, obj, EN("length")) < 0) {
            ejsSetProperty(ejs, result, index++, ejsCreateStringFromAsc(ejs, "length"));
        }
    } else if (ejsIsPrototype(ejs, obj)) {
        if (ejsLookupProperty(ejs, obj, EN("constructor")) < 0) {
            ejsSetProperty(ejs, result, index++, ejsCreateStringFromAsc(ejs, "constructor"));
        }
    }
    return result;
}


/*
    static function getOwnPrototypeOf(obj: Object): Object
 */
static EjsPot *obj_getOwnPrototypeOf(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return TYPE(argv[0])->prototype;
}


/*
    function hasOwnProperty(name: String): Boolean
 */
static EjsBoolean *obj_hasOwnProperty(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsName     qname;
    EjsLookup   lookup;
    int         slotNum;

    qname.space = ESV(empty);
    qname.name = (EjsString*) argv[0];
    slotNum = ejsLookupVarWithNamespaces(ejs, obj, qname, &lookup);
    return ejsCreateBoolean(ejs, slotNum >= 0);
}


/*
    static function isExtensible(obj: Object): Boolean
 */
static EjsBoolean *obj_isExtensible(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return ejsCreateBoolean(ejs, DYNAMIC(obj));
}


/*
    static function isFrozen(obj: Object): Boolean
 */
static EjsBoolean *obj_isFrozen(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsPot      *obj;
    int         numProp, frozen, slotNum;

    obj = (EjsPot*) argv[0];
    frozen = 1;
    numProp = ejsGetLength(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (!(trait->attributes & EJS_TRAIT_READONLY)) {
                frozen = 0;
                break;
            }
            if (!(trait->attributes & EJS_TRAIT_FIXED)) {
                frozen = 0;
                break;
            }
        }
    }
    if (DYNAMIC(obj)) {
        frozen = 0;
    }
    return ejsCreateBoolean(ejs, frozen);
}


/*
    static function isPrototypeOf(obj: Object): Boolean
 */
static EjsBoolean *obj_isPrototypeOf(Ejs *ejs, EjsObj *prototype, int argc, EjsObj **argv)
{
    EjsObj  *obj;
    
    obj = argv[0];
    return (prototype == ((EjsObj*) TYPE(obj)->prototype)) ? ESV(true) : ESV(false);
}


/*
    static function isSealed(obj: Object): Boolean
 */
static EjsBoolean *obj_isSealed(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsPot      *obj;
    int         numProp, sealed, slotNum;

    obj = (EjsPot*) argv[0];
    sealed = 1;
    numProp = ejsGetLength(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (!(trait->attributes & EJS_TRAIT_FIXED)) {
                sealed = 0;
                break;
            }
        }
    }
    if (DYNAMIC(obj)) {
        sealed = 0;
    }
    return ejsCreateBoolean(ejs, sealed);
}


#if FUTURE
/*
    Get enumerable properties names

    static function keys(obj: Object): Array
 */
static EjsArray *obj_keys(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj, *vp;
    EjsArray    *result;
    EjsTrait    *trait;
    EjsName     qname;
    int         numProp, slotNum;

    obj = argv[0];
    numProp = ejsGetLength(ejs, obj);
    if ((result = ejsCreateArray(ejs, numProp)) == 0) {
        return 0;
    }
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            if (trait->attributes & EJS_TRAIT_DELETED) {
                continue;
            }
        }
        vp = ejsGetProperty(ejs, obj, slotNum);
        qname = ejsGetPropertyName(ejs, obj, slotNum);
        ejsSetProperty(ejs, result, slotNum, ejsCreateStringFromAsc(ejs, qname.name));
    }
    return result;
}
#endif


/*
    static function preventExtensions(obj: Object): Object
 */
static EjsObj *obj_preventExtensions(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    SET_DYNAMIC(obj, 0);
    return obj;
}


/*
    static function seal(obj: Object): Void
 */
static EjsObj *obj_seal(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsTrait    *trait;
    int         slotNum, numProp;

    obj = argv[0];
    numProp = ejsGetLength(ejs, obj);
    for (slotNum = 0; slotNum < numProp; slotNum++) {
        if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
            trait->attributes |= EJS_TRAIT_FIXED;
        }
    }
    SET_DYNAMIC(obj, 0);
    return 0;
}


static int sortSlots(cvoid *a1, cvoid *a2)
{
    EjsSlot *s1, *s2;

    s1 = (EjsSlot*) a1;
    s2 = (EjsSlot*) a2;
    if (s1->qname.name->value == s2->qname.name->value) {
        return 0;
    } else if (scmp(s1->qname.name->value, s2->qname.name->value) < 0) {
        return -1;
    } 
    return 1;
}


/*
    static function sortProperties(obj: Object): Void
 */
static EjsObj *obj_sortProperties(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsPot      *obj;

    obj = (EjsPot*) argv[0];
    if (!ejsIsPot(ejs, obj)) {
        ejsThrowTypeError(ejs, "Object does not have properties");
        return 0;
    }
#if FUTURE && KEEP
    asc = (argc >= 2 && argv[1] == ESV(true));
#endif
    qsort(obj->properties->slots, obj->numProp, sizeof(EjsSlot), sortSlots);
    ejsIndexProperties(ejs, obj);
    return 0;
}


/*
    function propertyIsEnumerable(property: String, flag: Object = undefined): Boolean
 */
static EjsBoolean *obj_propertyIsEnumerable(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsName     qname;
    EjsLookup   lookup;
    int         slotNum;

    assert(argc == 1 || argc == 2);

    qname.space = ESV(empty);
    qname.name = (EjsString*) argv[0];
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, qname, &lookup)) < 0) {
        return ESV(false);
    }
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    return ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_HIDDEN));
}


/*
    Convert the object to a JSON string. This also handles Json for Arrays.

    function toJSON(options: Object = null): String
 */
PUBLIC EjsString *ejsObjToJSON(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return ejsSerializeWithOptions(ejs, vp, (argc == 1) ? argv[0] : NULL);
}


#if ES_Object_toLocaleString
/*
    Convert the object to a localized string

    function toLocaleString(): String
 */
static EjsString *toLocaleString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return ejsObjToString(ejs, vp, argc, argv);
}
#endif


PUBLIC EjsString *ejsObjToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    if (ejsIs(ejs, vp, String)) {
        return (EjsString*) vp;
    }
    return (ejs->service->objHelpers.cast)(ejs, vp, ESV(String));
}


/************************************************** Reflection **********************************************/
/*
    Get the base class of a type object.

    function getBaseType(obj: Type): Type
 */
static EjsType *obj_getBaseType(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *vp;

    vp = argv[0];
    if (ejsIsType(ejs, vp)) {
        return (((EjsType*) vp)->baseType);
    }
    return ESV(null);
}


/*
    function isPrototype(obj: Object): Boolean
 */
static EjsBoolean *obj_isPrototype(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, ejsIsPrototype(ejs, argv[0]));
}


/*
    function isType(obj: Object): Boolean
 */
static EjsBoolean *obj_isType(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, ejsIsType(ejs, argv[0]));
}


/*
    Get the type of the object.

    function getType(obj: Object): Type
 */
static EjsType *obj_getType(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return TYPE(obj);
}


/*
    Return the name of the type of an object. If the obj is a type, get the base type.
 */
PUBLIC EjsString *ejsGetTypeName(Ejs *ejs, EjsAny *obj)
{
    EjsType     *type;

    if (obj == 0) {
        return ESV(undefined);
    }
    type = (EjsType*) TYPE(obj);
    if (type == 0) {
        return ESV(null);
    }
    return type->qname.name;
}


/*
    function getTypeName(obj): String
 */
static EjsString *obj_getTypeName(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    assert(argc >= 1);
    return ejsGetTypeName(ejs, argv[0]);
}


/*
    Get the name of a function or type object

    function getName(obj: Object): String
 */
static EjsString *obj_getName(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];

    if (ejsIsType(ejs, obj)) {
        return ((EjsType*) obj)->qname.name;
    } else if (ejsIsFunction(ejs, obj)) {
        return ((EjsFunction*) obj)->name;
    }
    return ESV(empty);
}

/*********************************** Globals **********************************/
/*
    function typeOf(obj): String
 */
static EjsString *obj_typeOf(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    assert(argc >= 1);
    return ejsGetTypeName(ejs, argv[0]);
}


/*
    Get the ecma "typeof" value for an object. Unfortunately, typeof is pretty lame.
 */
PUBLIC EjsString *ejsGetTypeOf(Ejs *ejs, EjsAny *vp)
{
    cchar   *word;

    if (vp == ESV(undefined)) {
        word = "undefined";

    } else if (ejsIs(ejs, vp, Null)) {
        /* Yea - I know, ECMAScript is broken */
        word = "object";

    } else if (ejsIs(ejs, vp, Boolean)) {
        word = "boolean";

    } else if (ejsIs(ejs, vp, Number)) {
        word = "number";

    } else if (ejsIs(ejs, vp, String)) {
        word = "string";

    } else if (ejsIs(ejs, vp, Function)) {
        word = "function";
               
    } else {
        word = "object";
    }
    return ejsCreateStringFromAsc(ejs, word);
}


PUBLIC void ejsConfigureObjectType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;
    EjsFunction *fun;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Object"))) != 0) {
        prototype = type->prototype;
        ejsBindMethod(ejs, type, ES_Object_create, obj_create);
        ejsBindMethod(ejs, type, ES_Object_defineProperty, obj_defineProperty);
        ejsBindMethod(ejs, type, ES_Object_freeze, obj_freeze);
        ejsBindMethod(ejs, type, ES_Object_getOwnPropertyCount, obj_getOwnPropertyCount);
        ejsBindMethod(ejs, type, ES_Object_getOwnPropertyDescriptor, obj_getOwnPropertyDescriptor);
        ejsBindMethod(ejs, type, ES_Object_getOwnPropertyNames, obj_getOwnPropertyNames);
        ejsBindMethod(ejs, type, ES_Object_getOwnPrototypeOf, obj_getOwnPrototypeOf);
        ejsBindMethod(ejs, type, ES_Object_isExtensible, obj_isExtensible);
        ejsBindMethod(ejs, type, ES_Object_isFrozen, obj_isFrozen);
        ejsBindMethod(ejs, type, ES_Object_isSealed, obj_isSealed);
        ejsBindMethod(ejs, type, ES_Object_preventExtensions, obj_preventExtensions);
        ejsBindAccess(ejs, type, ES_Object_prototype, obj_prototype, obj_set_prototype);
        ejsBindMethod(ejs, type, ES_Object_seal, obj_seal);
        ejsBindMethod(ejs, type, ES_Object_sortProperties, obj_sortProperties);

        /* Reflection */
        ejsBindMethod(ejs, type, ES_Object_getBaseType, obj_getBaseType);
        ejsBindMethod(ejs, type, ES_Object_getType, obj_getType);
        ejsBindMethod(ejs, type, ES_Object_getTypeName, obj_getTypeName);
        ejsBindMethod(ejs, type, ES_Object_getName, obj_getName);
        ejsBindMethod(ejs, type, ES_Object_isPrototype, obj_isPrototype);
        ejsBindMethod(ejs, type, ES_Object_isType, obj_isType);

        ejsBindMethod(ejs, prototype, ES_Object_constructor, obj_constructor);
        ejsBindMethod(ejs, prototype, ES_Object_clone, obj_clone);
        ejsBindMethod(ejs, prototype, ES_Object_iterator_get, obj_get);
        ejsBindMethod(ejs, prototype, ES_Object_iterator_getValues, obj_getValues);
        ejsBindMethod(ejs, prototype, ES_Object_hasOwnProperty, obj_hasOwnProperty);
        ejsBindMethod(ejs, prototype, ES_Object_isPrototypeOf, obj_isPrototypeOf);
        ejsBindMethod(ejs, prototype, ES_Object_propertyIsEnumerable, obj_propertyIsEnumerable);
        ejsBindMethod(ejs, prototype, ES_Object_toLocaleString, toLocaleString);
        ejsBindMethod(ejs, prototype, ES_Object_toString, ejsObjToString);
        ejsBindMethod(ejs, prototype, ES_Object_toJSON, ejsObjToJSON);
        /*
            The prototype method is special. It is declared as static so it is generated in the type slots, but it is
            patched to be an instance method so the value of "this" will be preserved when it is invoked.
         */
        fun = ejsGetProperty(ejs, type, ES_Object_prototype);
        fun->staticMethod = 0;
        fun->setter->staticMethod = 0;
        type->constructor.block.pot.properties->slots[ES_Object_prototype].trait.attributes &= ~EJS_PROP_STATIC;
    }
    ejsBindFunction(ejs, ejs->global, ES_typeOf, obj_typeOf);

}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsPath.c"
 */
/************************************************************************/

/*
    ejsPath.c - Path class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/


#include    "pcre.h"

/************************************ Forwards ********************************/

static cchar *getPathString(Ejs *ejs, EjsObj *vp);
static void getUserGroup(Ejs *ejs, EjsObj *attributes, int *uid, int *gid);
static EjsArray *globPath(Ejs *ejs, EjsArray *results, cchar *path, cchar *base, cchar *pattern, int flags, 
        EjsRegExp *exclude, EjsRegExp *include);
static int globMatch(Ejs *ejs, cchar *s, cchar *pat, int isDir, int flags, cchar *seps, int count, cchar **nextPartPattern);

/************************************ Helpers *********************************/

static EjsAny *castPath(Ejs *ejs, EjsPath *fp, EjsType *type)
{
    if (type->sid == S_String) {
        return ejsCreateStringFromAsc(ejs, fp->value);
    }
    return (ejs->service->potHelpers.cast)(ejs, fp, type);
}


static EjsPath *clonePath(Ejs *ejs, EjsPath *src, bool deep)
{
    return ejsCreatePathFromAsc(ejs, src->value);
}


static EjsAny *coercePathOperands(Ejs *ejs, EjsPath *lhs, int opcode,  EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, lhs->value), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        }
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, lhs->value), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return ESV(true);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return ESV(false);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return ESV(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


static EjsAny *invokePathOperator(Ejs *ejs, EjsPath *lhs, int opcode,  EjsPath *rhs, void *data)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coercePathOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*  
        Types now match, both paths
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        if (lhs == rhs || (lhs->value == rhs->value)) {
            return ESV(true);
        }
        return ejsCreateBoolean(ejs,  mprSamePath(lhs->value, rhs->value));

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        return ejsCreateBoolean(ejs,  !mprSamePath(lhs->value, rhs->value));

    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) < 0);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) <= 0);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) > 0);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs,  scmp(lhs->value, rhs->value) >= 0);

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->value) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->value == 0) ? ESV(true): ESV(false));


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return ESV(false);

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsCreatePathFromAsc(ejs, mprJoinPath(lhs->value, rhs->value));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    assert(0);
}


/************************************ Methods *********************************/
/*
    Constructor
    function Path(path: String = ".")
 */
static EjsPath *pathConstructor(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *path;

    if (argc >= 1) {
        if ((path = getPathString(ejs, argv[0])) == 0) {
            return fp;
        }
        fp->value = path;
    } else {
        fp->value = sclone(".");
    }
    return fp;
}


/*
    Return an absolute path name for the file
    function get absolute(): Path
 */
static EjsPath *absolutePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetAbsPath(fp->value));
}


/*
    Get when the file was last accessed.
    function get accessed(): Date
 */
static EjsDate *getAccessedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        return ESV(null);
    }
    return ejsCreateDate(ejs, ((MprTime) info.atime) * 1000);
}


/*
    Get file attributes
    function get attributes(): Object
 */
static EjsObj *getAttributes(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    EjsObj      *attributes;

    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        return ESV(null);
    }
    attributes = ejsCreateEmptyPot(ejs);
    ejsSetPropertyByName(ejs, attributes, EN("permissions"), ejsCreateStringFromAsc(ejs, sfmt("0%0o", info.perms)));
    ejsSetPropertyByName(ejs, attributes, EN("uid"), ejsCreateNumber(ejs, info.owner));
    ejsSetPropertyByName(ejs, attributes, EN("gid"), ejsCreateNumber(ejs, info.group));

#if ME_UNIX_LIKE
    struct passwd   *pw;
    struct group    *gp;
    if ((pw = getpwuid(info.owner)) != 0) {
        ejsSetPropertyByName(ejs, attributes, EN("user"), ejsCreateStringFromAsc(ejs, pw->pw_name));
    }
    if ((gp = getgrgid(info.group)) != 0) {
        ejsSetPropertyByName(ejs, attributes, EN("group"), ejsCreateStringFromAsc(ejs, gp->gr_name));
    }
#endif
    return attributes;
}


/*
    Set file attributes
    function attributes(options: Object)
 */
static EjsObj *path_setAttributes(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    EjsObj      *attributes;

    attributes = argv[0];
    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        ejsThrowIOError(ejs, "Cannot access %s", fp->value);
        return 0;
    }
    ejsSetPathAttributes(ejs, fp->value, attributes);
    return 0;
}


/*
    Get the base name of a file
    function basename(): Path
 */
static EjsPath *getPathBasename(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetPathBase(fp->value));
}


/*
    Get the path components
    function components(): Array
 */
static EjsArray *getPathComponents(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    EjsArray        *ap;
    char            *cp, *last;
    int             index;

    fs = mprLookupFileSystem(fp->value);
    if ((ap = ejsCreateArray(ejs, 0)) == 0) {
        return 0;
    }
    index = 0;
    for (last = cp = mprNormalizePath(fp->value); *cp; cp++) {
        if (*cp == fs->separators[0] || *cp == fs->separators[1]) {
            *cp++ = '\0';
            ejsSetProperty(ejs, ap, index++, ejsCreateStringFromAsc(ejs, last));
            last = cp;
        }
    }
    if (cp > last) {
        ejsSetProperty(ejs, ap, index++, ejsCreateStringFromAsc(ejs, last));
    }
    return ap;
}


PUBLIC int ejsSetPathAttributes(Ejs *ejs, cchar *path, EjsObj *attributes)
{
    EjsObj  *permissions;
    int     perms;

    if (attributes == 0) {
        return 0;
    }
#if ME_UNIX_LIKE
{
    int     uid, gid;
    getUserGroup(ejs, attributes, &uid, &gid);
    if (uid >= 0 || gid >= 0) {
        if (chown(path, uid, gid) < 0) {
            ejsThrowStateError(ejs, "Cannot change group. Error %d", mprGetError());
        }
    }
}
#endif
    if ((permissions = ejsGetPropertyByName(ejs, attributes, EN("permissions"))) != 0) {
        perms = ejsGetInt(ejs, permissions);
        if (chmod(path, perms) < 0) {
            ejsThrowIOError(ejs, "Cannot change permissions. Error %d", mprGetError());
        }
    }
    return 0;
}


/*
    Copy a file
    function copy(to: Object, options: Object = null): Void
 */
static EjsObj *copyPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *from, *to;
    MprPath     info;
    EjsObj      *options;
    cchar       *toPath;
    ssize       bytes;
    char        *buf;

    assert(argc >= 1);
    options = (argc >= 2) ? argv[1] : 0;

    from = to = 0;
    if ((toPath = getPathString(ejs, argv[0])) == 0) {
        return 0;
    }
    if ((from = mprOpenFile(fp->value, O_RDONLY | O_BINARY, 0)) == 0) {
        ejsThrowIOError(ejs, "Cannot open %s", fp->value);
        return 0;
    }
    if ((to = mprOpenFile(toPath, O_CREAT | O_WRONLY | O_TRUNC | O_BINARY, EJS_FILE_PERMS)) == 0) {
        ejsThrowIOError(ejs, "Cannot create %s, errno %d", toPath, errno);
        mprCloseFile(from);
        return 0;
    }
    /* Keep perms of original file, don't inherit user/group (may not have permissions to create) */
    if (mprGetPathInfo(fp->value, &info) >= 0 && info.valid) {
        chmod(toPath, info.perms);
    }
    if (options) {
        ejsSetPathAttributes(ejs, toPath, options);
    }
    if ((buf = mprAlloc(ME_MAX_BUFFER)) == NULL) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(to);
        mprCloseFile(from);
        return 0;
    }
    while ((bytes = mprReadFile(from, buf, ME_MAX_BUFFER)) > 0) {
        if (mprWriteFile(to, buf, bytes) != bytes) {
            ejsThrowIOError(ejs, "Write error to %s", toPath);
            break;
        }
    }
    mprCloseFile(from);
    mprCloseFile(to);
    return 0;
}


/*
    Return when the file was created.
    function get created(): Date
 */
static EjsDate *getCreatedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        return ESV(null);
    }
    return ejsCreateDate(ejs, ((MprTime) info.ctime) * 1000);
}


/**
    Get the directory name portion of a file.
    function get dirname(): Path
 */
static EjsPath *getPathDirname(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsPath*) ejsCreatePathFromAsc(ejs, mprGetPathDir(fp->value));
}


/*
    Test to see if this file exists.
    function get exists(): Boolean
 */
static EjsBoolean *getPathExists(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    return ejsCreateBoolean(ejs, mprGetPathInfo(fp->value, &info) == 0);
}


/*
    Get the file extension portion of the file name.
    function get extension(): String
 */
static EjsString *getPathExtension(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *ext;

    if ((ext = mprGetPathExt(fp->value)) == 0) {
        return ESV(empty);
    }
    return ejsCreateStringFromAsc(ejs, ext);
}


/*
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsAny *nextPathKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsPath     *fp;

    fp = (EjsPath*) ip->target;
    if (!ejsIs(ejs, fp, Path)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < mprGetListLength(fp->files)) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator for use with "for ... in". This will iterate over the files in a directory.
    iterator function get(): Iterator
 */
static EjsAny *getPathIterator(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    fp->files = mprGetPathFiles(fp->value, 0);
    return ejsCreateIterator(ejs, fp, -1, nextPathKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsAny *nextPathValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsPath     *fp;
    MprDirEntry *dp;

    fp = (EjsPath*) ip->target;
    if (!ejsIs(ejs, fp, Path)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < mprGetListLength(fp->files)) {
        dp = (MprDirEntry*) mprGetItem(fp->files, ip->index++);
        return ejsCreatePathFromAsc(ejs, dp->name);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to enumerate the bytes in the file. For use with "for each ..."
    iterator function getValues(): Iterator
 */
static EjsAny *getPathValues(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    fp->files = mprGetPathFiles(fp->value, 0);
    return ejsCreateIterator(ejs, fp, -1, nextPathValue, 0, NULL);
}


/*
    Flags for path_files
 */
#define FILES_DESCEND           MPR_PATH_DESCEND
#define FILES_DEPTH_FIRST       MPR_PATH_DEPTH_FIRST
#define FILES_HIDDEN            MPR_PATH_INC_HIDDEN
#define FILES_NODIRS            MPR_PATH_NODIRS
#define FILES_RELATIVE          MPR_PATH_RELATIVE
#define FILES_NOMATCH_EXC       0x10000                 /* Throw an exception if no matching files */
#define FILES_CASELESS          0x20000

/*
    Get the files in a directory and subdirectories
    function files(patterns: Array|String|Path, options: Object = null): Array
 */
PUBLIC EjsArray *ejsGetPathFiles(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    EjsAny          *vp, *fill;
    EjsObj          *options;
    EjsArray        *result, *patterns;
    EjsRegExp       *exclude, *include;
    char            *pattern, *start, *special;
    cchar           *path, *base;
    int             flags, i;

    options = (argc >= 2) ? argv[1]: 0;
    include = exclude = 0;
    result = ejsCreateArray(ejs, 0);
    fs = mprLookupFileSystem(fp->value);
    flags = 0;
    fill = 0;

    if (argc == 0) {
        patterns = ejsCreateArray(ejs, 0);
        ejsAddItem(ejs, patterns, ejsCreateString(ejs, "*", -1));
    } else if (!ejsIs(ejs, argv[0], Array)) {
        patterns = ejsCreateArray(ejs, 0);
        ejsAddItem(ejs, patterns, ejsToString(ejs, argv[0]));
    } else {
        patterns = (EjsArray*) argv[0];
    }

    if (options) {
        if (ejsGetPropertyByName(ejs, options, EN("depthFirst")) == ESV(true)) {
            flags |= FILES_DEPTH_FIRST;
        }
        if (ejsGetPropertyByName(ejs, options, EN("hidden")) == ESV(true)) {
            flags |= FILES_HIDDEN;
        }
        exclude = ejsGetPropertyByName(ejs, options, EN("exclude"));
        if (exclude && !ejsIs(ejs, exclude, RegExp)) {
            if (ejsIsDefined(ejs, exclude)) {
                ejsThrowArgError(ejs, "Exclude option must be a regular expression");
                return 0;
            }
            exclude = 0;
        }
        include = ejsGetPropertyByName(ejs, options, EN("include"));
        if (include && !ejsIs(ejs, include, RegExp)) {
            if (ejsIsDefined(ejs, include)) {
                ejsThrowArgError(ejs, "Include option must be a regular expression");
                return 0;
            }
            include = 0;
        }
        if ((vp = ejsGetPropertyByName(ejs, options, EN("missing"))) != 0) {
            if (vp == ESV(undefined)) {
                flags |= FILES_NOMATCH_EXC;
            } else if (vp == ESV(empty)) {
                fill = ejsToPath(ejs, ejsToString(ejs, patterns));
            } else if (vp != ESV(null)) {
                fill = vp;
            }
        }
        if (ejsGetPropertyByName(ejs, options, EN("relative")) == ESV(true)) {
            flags |= FILES_RELATIVE;
        } 
    }
    for (i = 0; i < patterns->length; i++) {
        /* 
            Optimize by converting absolute pattern path prefixes into the base directory.
            This allows path.files('/path/ *')
         */
        pattern = ejsToMulti(ejs, ejsGetItem(ejs, patterns, i));
        path = fp->value;
        base = "";
        if (mprIsPathAbs(pattern)) {
            start = pattern;
            if ((special = strpbrk(start, "*?")) != 0) {
                if (special > start) {
                    for (pattern = special; pattern > start && !strchr(fs->separators, *pattern); pattern--) { }
                    if (pattern > start) {
                        *pattern++ = '\0';
                        path = mprJoinPath(path, start);
                        base = start;
                    }
                }
            } else {
                pattern = (char*) mprGetPathBaseRef(start);
                if (pattern > start) {
                    pattern[-1] = '\0';
                    path = mprJoinPath(path, start);
                    base = start;
                }
            }
        }
        if (!globPath(ejs, result, path, base, pattern, flags, exclude, include)) {
            return 0;
        }
    }
    if (ejsGetLength(ejs, result) == 0) {
        if (flags & FILES_NOMATCH_EXC) {
            ejsThrowIOError(ejs, "Cannot find any matching files for patterns: %@", ejsToString(ejs, patterns));
        } else if (fill) {
            ejsSetProperty(ejs, result, -1, fill);
        }
    }
    return result;
}


/*
    Match a string against a pattern using glob style matching.
    Pat may contain a fully path of patterns. Only the first portion up to a file separator is used. The remaining portion
        is returned in nextPartPattern.
    seps contains the file system separator characters

    Wildcard Patterns:
    ?           Matches any single character
    *           Matches zero or more characters of the file or directory
    ** /        Matches zero or more directories (spaces introduced to avoid closing comment)
    **          Matches zero or more files or directories. Equivlane to ** / *
    trailing/   Trailing slash matches only directory
 */
static int globMatch(Ejs *ejs, cchar *s, cchar *pat, int isDir, int flags, cchar *seps, int count, cchar **nextPartPattern)
{
    int     match;
//  TODO - need recursion limits
    *nextPartPattern = 0;

    while (*s && *pat && *pat != seps[0] && *pat != seps[1]) {
        match = (flags & FILES_CASELESS) ? (*pat == *s) : (tolower((uchar) *pat) == tolower((uchar) *s));
        if (match || *pat == '?') {
            ++pat; ++s;
        } else if (*pat == '*') {
            if (*++pat == '\0') {
                /* Terminal star matches files and directories */
                return 1;
            }
            if (*pat == '*') {
                /* Double star - matches zero or more directories */
                if (isDir) {
                    *nextPartPattern = pat - 1;
                    return 1;
                }
                if (pat[1] && (pat[1] == seps[0] || pat[1] == seps[1])) {
                    /* Double star/ */
                    if (pat[2] == '\0') {
                        /* Trailing slash and not a directory */
                        return 0;
                    }
                    pat += 2;
                } else {
                    /* Plain double star matches all (alias for ** / *) */
                    if (pat[1] == '\0') {
                        *nextPartPattern = pat - 1;
                        return 1;
                    }
                }
            } else {
                /* Single star */
                if (count > 2000) {
                    ejsThrowArgError(ejs, "Glob match is too recursive");
                    return 0;
                }
                if (*pat == seps[0] || *pat == seps[1]) {
                    s = "";
                    break;
                }
                while (*s) {
                    if (globMatch(ejs, s++, pat, isDir, flags, seps, count + 1, nextPartPattern)) {
                        return 1;
                    }
                }
                return 0;
            }
        } else {
            return 0;
        }
    }
    if (*pat == '*') {
        ++pat;
    }
    if (*s) {
        return 0;
    }
    if (*pat == '\0') {
        return 1;
    }
    if (*pat && (*pat == seps[0] || *pat == seps[1])) {
        if (*++pat == '\0') {
            /* Terminal / matches only directories */
            return isDir;
        }
        *nextPartPattern = pat;
        return 1;
    }
    return 0;
}


static EjsArray *globPath(Ejs *ejs, EjsArray *results, cchar *path, cchar *base, cchar *pattern, int flags, 
        EjsRegExp *exclude, EjsRegExp *include)
{
    MprFileSystem   *fs;
    MprDirEntry     *dp;
    MprList         *list;
    cchar           *filename, *nextPartPattern, *nextPath, *matchFile;
    int             next, add;

    if ((list = mprGetPathFiles(path, flags | MPR_PATH_RELATIVE)) == 0) {
        if (flags & FILES_NOMATCH_EXC) {
            ejsThrowIOError(ejs, "Cannot read directory");
            return 0;
        }
        return results;
    }
    fs = mprLookupFileSystem(path);

    for (next = 0; (dp = mprGetNextItem(list, &next)) != 0; ) {
        if (!globMatch(ejs, dp->name, pattern, dp->isDir, flags, fs->separators, 0, &nextPartPattern)) {
            continue;
        }
        add = 1;
        //  TODO - OPT
        if (nextPartPattern && strcmp(nextPartPattern, "**") != 0 && strcmp(nextPartPattern, "**/") != 0
                   && strcmp(nextPartPattern, "**/*") != 0) {
            /* Double star matches zero or more */
            add = 0;
        }
        filename = (flags & MPR_PATH_RELATIVE) ? mprJoinPath(base, dp->name) : mprJoinPath(path, dp->name);
        if (add && (include || exclude)) {
            matchFile = (dp->isDir && !dp->isLink) ? sjoin(filename, "/", NULL) : filename;
            if (include && pcre_exec(include->compiled, NULL, matchFile, (int) slen(matchFile), 0, 0, NULL, 0) < 0) {
                add = 0;
            }
            if (exclude && pcre_exec(exclude->compiled, NULL, matchFile, (int) slen(matchFile), 0, 0, NULL, 0) >= 0) {
                add = 0;
            }
        }
        if (!(flags & FILES_DEPTH_FIRST) && add) {
            /* Exclude mid-pattern directories and terminal directories if only "files" */
            ejsSetProperty(ejs, results, -1, ejsCreatePathFromAsc(ejs, filename));
        }
        if (dp->isDir && nextPartPattern) {
            nextPath = (flags & MPR_PATH_RELATIVE) ? mprJoinPath(path, dp->name) : filename;
            globPath(ejs, results, nextPath, filename, nextPartPattern, flags, exclude, include);
        }
        if ((flags & FILES_DEPTH_FIRST) && add) {
            ejsSetProperty(ejs, results, -1, ejsCreatePathFromAsc(ejs, filename));
        }
    }
    return results;
}


/*
    Determine if the file path has a drive spec (C:) in the file name
    static function hasDrive(): Boolean
 */
static EjsBoolean *pathHasDrive(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, 
        (isalpha((uchar) fp->value[0]) && fp->value[1] == ':' && (fp->value[2] == '/' || fp->value[2] == '\\')));
}


/*
    function get isAbsolute(): Boolean
 */
static EjsBoolean *isPathAbsolute(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (mprIsPathAbs(fp->value) ? ESV(true): ESV(false));
}


/*
    Determine if the file name is a directory
    function get isDir(): Boolean
 */
static EjsBoolean *isPathDir(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(fp->value, &info);
    return ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}


/*
    function get isLink(): Boolean
 */
static EjsBoolean *isPathLink(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    //  TODO -work around. GetPathInfo will return err if the target of the symlink does not exist.
    info.isLink = 0;
    mprGetPathInfo(fp->value, &info);
    return ejsCreateBoolean(ejs, info.isLink);
}


/*
    Determine if the file name is a regular file
    function get isRegular(): Boolean
 */
static EjsBoolean *isPathRegular(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    return ejsCreateBoolean(ejs, info.isReg);
}


/*
    function get isRelative(): Boolean
 */
static EjsBoolean *isPathRelative(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (mprIsPathRel(fp->value) ? ESV(true): ESV(false));
}


/*
    Join path segments. Returns a normalized path.
    function join(...others): Path
 */
static EjsPath *joinPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    cchar       *other, *result;
    int         i;

    args = (EjsArray*) argv[0];
    result = fp->value;
    for (i = 0; i < args->length; i++) {
        if ((other = getPathString(ejs, ejsGetProperty(ejs, args, i))) == NULL) {
            return 0;
        }
        result = mprJoinPath(result, other);
    }
    return ejsCreatePathFromAsc(ejs, result);
}


/*
    Join extension. This will add an extension if one does not already exist. 
    If force is true, the extension will be added. This is for path names that have embedded periods.
  
    function joinExt(ext: String, force: Boolean = false): Path
 */
static EjsPath *joinPathExt(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *ext;
    int     force;

    force = (argc >= 2 && argv[1] == ESV(true)) ? 1 : 0;
    if (mprGetPathExt(fp->value) && !force) {
        return fp;
    }
    ext = ejsToMulti(ejs, argv[0]);
    while (ext && *ext == '.') {
        ext++;
    }
    if (ext && *ext) {
        return ejsCreatePathFromAsc(ejs, sjoin(fp->value, ".", ext, NULL));
    }
    //  TODO - should this clone?
    return fp;
}


/*
    Get the length of the path name.
  
    override function get length(): Number
 */
static EjsNumber *pathLength(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) strlen(fp->value));
}


/**
    function link(target: Path, hard: Boolean = false): Void

    Create the target as a link to refer to the path.
    This will remove any pre-existing link.
    NOTE: this will copy the target on systems that don't support links
    NOTE: this will re-create the link if it already exists
  */
static EjsVoid *path_link(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *target;
    int     hard;

    hard = (argc >= 2) ? (argv[1] == ESV(true)) : 0;
    if ((target = ejsToMulti(ejs, argv[0])) == 0) {
        return 0;
    }
    unlink(target);
#if ME_UNIX_LIKE
    if (mprMakeLink(fp->value, target, hard) < 0) {
        ejsThrowIOError(ejs, "Cannot create link %s to refer to %s, error %d", target, fp->value, errno);
    }
#else
    //  TODO - does not work for directories
    if (mprCopyPath(fp->value, target, 0644) < 0) {
        ejsThrowIOError(ejs, "Cannot copy %s to %s, error %d", fp->value, target, errno);
        return 0;
    }
#endif
    return 0;
}


/*
    function get linkTarget(): Path
 */
static EjsPath *pathLinkTarget(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;

    if ((path = mprGetPathLink(fp->value)) == 0) {
        return ESV(null);
    }
    return ejsCreatePathFromAsc(ejs, mprGetPathLink(fp->value));
}


/*
    Get user/group from an attributes hash. Looks at group, user, gid and uid. If both user and uid are specified,
    user takes precedence. If both group and gid are specified, then group takes precedence.
 */
static void getUserGroup(Ejs *ejs, EjsObj *attributes, int *uid, int *gid)
{
#if ME_UNIX_LIKE
    EjsAny          *vp;
    struct passwd   *pp;
    struct group    *gp;

    *uid = *gid = -1;
    if ((vp = ejsGetPropertyByName(ejs, attributes, EN("group"))) != 0 && ejsIsDefined(ejs, vp)) {
        vp = ejsToString(ejs, vp);
        //  TODO - these are thread-safe on mac, but not on all systems. use getgrnam_r
        if ((gp = getgrnam(ejsToMulti(ejs, vp))) == 0) {
            ejsThrowArgError(ejs, "Cannot find group %@", vp);
            return;
        }
        *gid = gp->gr_gid;

    } else if ((vp = ejsGetPropertyByName(ejs, attributes, EN("gid"))) != 0 && ejsIsDefined(ejs, vp)) {
        if (ejsIs(ejs, vp, Number)) {
            *gid = ejsGetInt(ejs, vp);
        }
    }
    if ((vp = ejsGetPropertyByName(ejs, attributes, EN("user"))) != 0 && ejsIsDefined(ejs, vp)) {
        if ((pp = getpwnam(ejsToMulti(ejs, vp))) == 0) {
            ejsThrowArgError(ejs, "Cannot find user %@", vp);
            return;
        }
        *uid = pp->pw_uid;
    } else if ((vp = ejsGetPropertyByName(ejs, attributes, EN("uid"))) != 0 && ejsIsDefined(ejs, vp)) {
        if (ejsIs(ejs, vp, Number)) {
            *uid = ejsGetInt(ejs, vp);
        }
    }
#else
    *uid = *gid = -1;
#endif
}


/*
    function makeDir(attributes: Object = null): Void
  
    Options: permissions, owner, group
 */
static EjsObj *makePathDir(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    EjsObj      *attributes, *permissions;
    int         rc, perms, uid, gid;
    
    attributes = (argc >= 1) ? argv[0] : 0;
    perms = 0755;
    gid = uid = -1;
    if (argc == 1) {
        getUserGroup(ejs, attributes, &uid, &gid);
        if ((permissions = ejsGetPropertyByName(ejs, attributes, EN("permissions"))) != 0) {
            perms = ejsGetInt(ejs, permissions);
        }
    }
    if (mprGetPathInfo(fp->value, &info) < 0) {
        if ((rc = mprMakeDir(fp->value, perms, uid, gid, 1)) < 0) {
            if (rc == MPR_ERR_CANT_COMPLETE) {
                ejsThrowStateError(ejs, "Cannot set directory permissions. Error %d", mprGetError());
            } else {
                ejsThrowStateError(ejs, "Cannot make directory. Error %d", mprGetError());
            }
            return ESV(false);
        }
        ejsSetPathAttributes(ejs, fp->value, attributes);
    } else if (!info.isDir) {
        /* Not a directory */
        return ESV(false);

    } else if (attributes) {
        /* Existing, but attributes supplied. So set the attributes */
        ejsSetPathAttributes(ejs, fp->value, attributes);
    }
    return ESV(true);
}


#if DEPRECATED || 1
/*
    function makeLink(target: Path, hard: Boolean = false): Void
    Deprected in 2.3.0 
 */
static EjsObj *makePathLink(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *target;
    int     hard;

    target = ((EjsPath*) argv[0])->value;
    hard = (argc >= 2) ? (argv[1] == ESV(true)) : 0;
    if (mprMakeLink(fp->value, target, hard) < 0) {
        ejsThrowIOError(ejs, "Cannot make link");
    }
    return 0;
}
#endif


/*
    Make a temporary file. Creates a new, uniquely named temporary file. The path object specifies the directory
    to contain the temp file.
    NOTE: Still the callers responsibility to remove the temp file
  
    function temp(): Path
 */
static EjsPath *pathTemp(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;

    if ((path = mprGetTempPath(fp->value)) == NULL) {
        ejsThrowIOError(ejs, "Cannot make temp file");
        return 0;
    }
    return ejsCreatePathFromAsc(ejs, path);
}


/*
    function map(separator: String): Path
 */
static EjsPath *pa_map(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *sep;
    char    *path;
    int     separator;

    sep = (argc >= 1) ? ejsToMulti(ejs, argv[0]) : "/";
    separator = *sep;
    path = sclone(fp->value);
    mprMapSeparators(path, separator);
    return ejsCreatePathFromAsc(ejs, path);
}


/*
    function get mimeType(): String
 */
static EjsString *getMimeType(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprLookupMime(NULL, fp->value));
}


/*
    Get when the file was created or last modified.
  
    function get modified(): Date
 */
static EjsDate *getModifiedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(fp->value, &info);
    if (!info.valid) {
        return ESV(null);
    }
    return ejsCreateDate(ejs, ((MprTime) info.mtime) * 1000);
}


/*
    function get name(): String
 */
static EjsString *pa_name(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, fp->value);
}


/*
    function get natural(): Path
 */
static EjsPath *getNaturalPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetNativePath(fp->value));
}


/*
    function get normalize(): Path
 */
static EjsPath *normalizePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprNormalizePath(fp->value));
}


/*
    Get the parent directory of the absolute path of the file.
  
    function get parent(): Path
 */
static EjsPath *getPathParent(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetPathParent(fp->value));
}


/*
    Get the path permissions
  
    function get perms(): Number
 */
static EjsNumber *getPerms(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    if (mprGetPathInfo(fp->value, &info) < 0) {
        return ESV(null);
    }
    return ejsCreateNumber(ejs, info.perms);
}


/*
    Set the path permissions
  
    function set perms(perms: Number): Void
 */
static EjsObj *setPerms(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
#if !VXWORKS
    int     perms;

    perms = ejsGetInt(ejs, argv[0]);
    if (chmod(fp->value, perms) < 0) {
        ejsThrowIOError(ejs, "Cannot update permissions for %s", fp->value);
    }
#endif
    return 0;
}


/*
    Get a portable (unix-like) representation of the path
  
    function get portable(lower: Boolean = false): Path
 */
static EjsPath *getPortablePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;
    int     lower;

    lower = (argc >= 1 && argv[0] == ESV(true));
    path = mprGetPortablePath(fp->value);
    if (lower) {
        path = slower(path);
    }
    return ejsCreatePathFromAsc(ejs, path);
}


#if KEEP
/*
    Get the file contents as a byte array
  
    static function readBytes(path: String): ByteArray
 */
static EjsByteArray *readBytes(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile         *file;
    EjsByteArray    *result;
    cchar           *path;
    char            buffer[ME_MAX_BUFFER];
    int             bytes, offset, rc;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));
    path = ejsToMulti(ejs, argv[0]);

    file = mprOpenFile(path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cannot open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    result = ejsCreateByteArray(ejs, (int) mprGetFileSize(file));
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }

    rc = 0;
    offset = 0;
    while ((bytes = mprReadFile(file, buffer, ME_MAX_BUFFER)) > 0) {
        //  TODO - should use RC Value (== bytes)
        if (ejsCopyToByteArray(ejs, result, offset, buffer, bytes) < 0) {
            ejsThrowMemoryError(ejs);
            rc = -1;
            break;
        }
        offset += bytes;
    }
    ejsSetByteArrayPositions(ejs, result, 0, offset);
    mprCloseFile(file);
    return result;
}


/**
    Read the file contents as an array of lines.
  
    static function readLines(path: String): Array
 */
static EjsArray *readLines(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprBuf      *data;
    EjsArray    *result;
    cchar       *path;
    char        *start, *end, *cp, buffer[ME_MAX_BUFFER];
    int         bytes, rc, lineno;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));
    path = ejsToMulti(ejs, argv[0]);

    result = ejsCreateArray(ejs, 0);
    if (result == NULL) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    file = mprOpenFile(path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cannot open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    data = mprCreateBuf(0, (int) mprGetFileSize(file) + 1);
    result = ejsCreateArray(ejs, 0);
    if (result == NULL || data == NULL) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }

    rc = 0;
    while ((bytes = mprReadFile(file, buffer, ME_MAX_BUFFER)) > 0) {
        if (mprPutBlockToBuf(data, buffer, bytes) != bytes) {
            ejsThrowMemoryError(ejs);
            rc = -1;
            break;
        }
    }

    start = mprGetBufStart(data);
    end = mprGetBufEnd(data);
    for (lineno = 0, cp = start; cp < end; cp++) {
        if (*cp == '\n') {
            //  TODO - UNICODE ENCODING
            if (ejsSetProperty(ejs, result, lineno++, ejsCreateStringFromAsc(ejs, start, (int) (cp - start))) < 0) {
                break;
            }
            start = cp + 1;
        } else if (*cp == '\r') {
            start = cp + 1;
        }
    }
    if (cp > start) {
        //  TODO - UNICODE ENCODING
        ejsSetProperty(ejs, result, lineno++, ejsCreateStringFromAsc(ejs, start, (int) (cp - start)));
    }
    mprCloseFile(file);
    return result;
}


/*
    Read the file contents as a string
  
    static function readString(path: String): String
 */
static EjsString *readFileAsString(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprBuf      *data;
    cchar       *path;
    char        buffer[ME_MAX_BUFFER];
    int         bytes;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));
    path = ejsToMulti(ejs, argv[0]);

    file = mprOpenFile(path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cannot open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    data = mprCreateBuf(0, (int) mprGetFileSize(file) + 1);
    if (data == 0) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }
    while ((bytes = mprReadFile(file, buffer, ME_MAX_BUFFER)) > 0) {
        if (mprPutBlockToBuf(data, buffer, bytes) != bytes) {
            ejsThrowMemoryError(ejs);
            break;
        }
    }
    mprCloseFile(file);
    //  TODO - UNICODE ENCODING
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(data),  mprGetBufLength(data));
}


/*
    Get the file contents as an XML object
  
    static function readXML(path: String): XML
 */
static EjsXML *readXML(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return 0;
}
#endif


/*
    Return a relative path name for the file.
  
    function get relative(): Path
 */
static EjsPath *relativePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetRelPath(fp->value, 0));
}


/*
    Return a relative path name for the file from the given origin
  
    function relativeTo(origin: Path = null): Path
 */
static EjsPath *relativeToPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *origin;

    origin = (argc >= 1) ? ((EjsPath*) argv[0])->value : 0;
    return ejsCreatePathFromAsc(ejs, mprGetRelPath(fp->value, origin));
}


/*
    Remove the file associated with the File object. This may be a file or directory.
  
    function remove(): Boolean
 */
static EjsObj *removePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    //  TODO - workaround for isLink
    info.isLink = 0;
    if (mprGetPathInfo(fp->value, &info) == 0 || info.isLink == 1) {
        if (mprDeletePath(fp->value) < 0) {
            return ESV(false);
        }
    }
    return ESV(true);
}


/*
    Rename the file
  
    function rename(to: Path): Void
 */
static EjsObj *renamePathFile(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsPath     *to;

    assert(argc == 1 && ejsIs(ejs, argv[0], Path));
    to = (EjsPath*) argv[0];
    unlink((char*) to->value);
    if (rename(fp->value, to->value) < 0) {
        ejsThrowIOError(ejs, "Cannot rename %s to %s, error %d", fp->value, to->value, errno);
        return 0;
    }
    return ESV(true);
}


/*
    Resolve paths against others. Returns a normalized path.
  
    function resolve(...paths): Path
 */
static EjsPath *resolvePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsPath     *result;
    cchar       *next;
    int         i;

    args = (EjsArray*) argv[0];
    result = fp;
    for (i = 0; i < args->length; i++) {
        if ((next = getPathString(ejs, ejsGetProperty(ejs, args, i))) == NULL) {
            return 0;
        }
        result = ejsCreatePathFromAsc(ejs, mprResolvePath(result->value, next));
    }
    return result;
}


/*
    Return the root directory component
  
    function root(other: Object): Boolean
 */
static EjsPath *rootPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    cchar           *cp;

    fs = mprLookupFileSystem(fp->value);
    fp = ejsCreatePathFromAsc(ejs, mprGetAbsPath(fp->value));
    if ((cp = strpbrk(fp->value, fs->separators)) != 0) {
        return ejsCreatePathFromAsc(ejs, snclone(fp->value, cp - fp->value + 1));
    }
    return fp;
}


/*
    Return true if the paths refer to the same file.
  
    function same(other: Object): Boolean
 */
static EjsBoolean *isPathSame(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *other;
    int     rc;

    if (ejsIs(ejs, argv[0], String)) {
        other = ejsToMulti(ejs, argv[0]);
    } else if (ejsIs(ejs, argv[0], Path)) {
        other = ((EjsPath*) (argv[0]))->value;
    } else {
        return ESV(false);
    }
    rc = mprSamePath(fp->value, other);
    if (rc) {
        return ESV(true);
    }
    return ESV(false);
    // return (mprSamePath(fp->value, other) ? ESV(true) : ESV(false));
}


/*
    function get separator(): String
 */
static EjsString *pathSeparator(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    cchar           *cp;

    if ((cp = mprGetFirstPathSeparator(fp->value)) != 0) {
        return ejsCreateStringFromMulti(ejs, cp, 1);
    }
    fs = mprLookupFileSystem(fp->value);
    return ejsCreateStringFromMulti(ejs, fs->separators, 1);
}


/*
    Get the size of the file associated with this Path
  
    function get size(): Number
 */
static EjsNumber *getPathFileSize(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    if (mprGetPathInfo(fp->value, &fp->info) < 0) {
        return ESV(minusOne);
    }
    return ejsCreateNumber(ejs, (MprNumber) fp->info.size);
}


/*  Deprected in 2.3.0 */

#if DEPRECATED || 1
/**
    function symlink(target: Path): Void

    Create the path as a symbolic link.
    This will remove any pre-existing path and then create a symbolic link to refer to the target.
    NOTE: this will copy the target on systems that don't support symlinks
    NOTE: this will re-create the link if it already exists
  */
static EjsVoid *path_symlink(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *target;

    if ((target = ejsToMulti(ejs, argv[0])) == 0) {
        return 0;
    }
    unlink(fp->value);
#if ME_UNIX_LIKE
    if (symlink(target, fp->value) < 0) {
        ejsThrowIOError(ejs, "Cannot create symlink %s to refer to %s, error %d", fp->value, target, errno);
        return 0;
    }
#else
    //  TODO - does not work for directories
    if (mprCopyPath(target, fp->value, 0644) < 0) {
        ejsThrowIOError(ejs, "Cannot copy %s to %s, error %d", target, fp->value, errno);
        return 0;
    }
#endif
    return 0;
}
#endif


/*
    override function toJSON(): String
 */
static EjsString *pathToJSON(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprBuf  *buf;
    int     i, c, len;

    buf = mprCreateBuf(0, 0);
    len = (int) strlen(fp->value);
    mprPutCharToBuf(buf, '"');
    for (i = 0; i < len; i++) {
        c = fp->value[i];
        if (c == '"' || c == '\\') {
            mprPutCharToBuf(buf, '\\');
            mprPutCharToBuf(buf, c);
        } else {
            mprPutCharToBuf(buf, c);
        }
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    function toString(): String
 */
static EjsString *pathToString(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, fp->value);
}


/*
    function trimExt(): Path
 */
static EjsPath *trimExt(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprTrimPathExt(fp->value));
}


/*
    function truncate(size: Number): Void
 */
static EjsObj *truncatePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    int     size;

    size = ejsGetInt(ejs, argv[0]);
    if (mprTruncateFile(fp->value, size) < 0) {
        ejsThrowIOError(ejs, "Cannot truncate %s", fp->value);
    }
    return 0;
}


/*
    Return a windows path name for the path on Windows|Cygwin systems. Otherwise returns and absolute path.
    function get absolute(): Path
 */
static EjsPath *windowsPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, mprGetWinPath(fp->value));
}


#if KEEP
/*
    Put the file contents
  
    static function write(path: String, permissions: Number, ...args): void
 */
static EjsObj *writeToFile(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    EjsArray    *args;
    char        *path, *data;
    int         i, bytes, length, permissions;

    assert(argc == 3);

    path = ejsToMulti(ejs, argv[0]);
    permissions = ejsGetInt(ejs, argv[1]);
    args = (EjsArray*) argv[2];

    /*
        Create fails if already present
     */
    mprDeletePath(path);
    file = mprOpenFile(path, O_CREAT | O_WRONLY | O_BINARY, permissions);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cannot create %s", path);
        mprCloseFile(file);
        return 0;
    }

    for (i = 0; i < args->length; i++) {
        data = ejsToMulti(ejs, ejsToString(ejs, ejsGetProperty(ejs, args, i)));
        length = (int) strlen(data);
        bytes = mprWriteFile(file, data, length);
        if (bytes != length) {
            ejsThrowIOError(ejs, "Write error to %s", path);
            break;
        }
    }
    mprCloseFile(file);
    return 0;
}
#endif


static cchar *getPathString(Ejs *ejs, EjsObj *vp)
{
    if (ejsIs(ejs, vp, Path)) {
        return ((EjsPath*) vp)->value;
    }
    return (char*) ejsToMulti(ejs, vp);
}

/*********************************** Factory **********************************/

PUBLIC EjsPath *ejsCreatePath(Ejs *ejs, EjsString *path)
{
    EjsPath     *fp;

    if ((fp = ejsCreateObj(ejs, ESV(Path), 0)) == 0) {
        return 0;
    }
    pathConstructor(ejs, fp, 1, (EjsObj**) (void*) &path);
    return fp;
}


PUBLIC EjsPath *ejsCreatePathFromAsc(Ejs *ejs, cchar *value)
{
    return ejsCreatePath(ejs, ejsCreateStringFromAsc(ejs, value));
}


static void managePath(EjsPath *path, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(path->value);
        mprMark(path->files);
    }
}


PUBLIC void ejsCreatePathType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", "Path"), sizeof(EjsPath), S_Path, ES_Path_NUM_CLASS_PROP, managePath, 
        EJS_TYPE_OBJ | EJS_TYPE_IMMUTABLE_INSTANCES);
    type->helpers.cast = (EjsCastHelper) castPath;
    type->helpers.clone = (EjsCloneHelper) clonePath;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokePathOperator;
}


PUBLIC void ejsConfigurePathType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Path"))) == 0) {
        return;
    }
    //  TODO - rename all and use pa_ prefix
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, pathConstructor);
    ejsBindMethod(ejs, prototype, ES_Path_absolute, absolutePath);
    ejsBindMethod(ejs, prototype, ES_Path_accessed, getAccessedDate);
    ejsBindAccess(ejs, prototype, ES_Path_attributes, getAttributes, NULL);
    ejsBindMethod(ejs, prototype, ES_Path_basename, getPathBasename);
    ejsBindMethod(ejs, prototype, ES_Path_components, getPathComponents);
    ejsBindMethod(ejs, prototype, ES_Path_copy, copyPath);
    ejsBindMethod(ejs, prototype, ES_Path_created, getCreatedDate);
    ejsBindMethod(ejs, prototype, ES_Path_dirname, getPathDirname);
    ejsBindMethod(ejs, prototype, ES_Path_exists, getPathExists);
    ejsBindMethod(ejs, prototype, ES_Path_extension, getPathExtension);
    ejsBindMethod(ejs, prototype, ES_Path_files, ejsGetPathFiles);
    ejsBindMethod(ejs, prototype, ES_Path_iterator_get, getPathIterator);
    ejsBindMethod(ejs, prototype, ES_Path_iterator_getValues, getPathValues);
    ejsBindMethod(ejs, prototype, ES_Path_hasDrive, pathHasDrive);
    ejsBindMethod(ejs, prototype, ES_Path_isAbsolute, isPathAbsolute);
    ejsBindMethod(ejs, prototype, ES_Path_isDir, isPathDir);
    ejsBindMethod(ejs, prototype, ES_Path_isLink, isPathLink);
    ejsBindMethod(ejs, prototype, ES_Path_isRegular, isPathRegular);
    ejsBindMethod(ejs, prototype, ES_Path_isRelative, isPathRelative);
    ejsBindMethod(ejs, prototype, ES_Path_join, joinPath);
    ejsBindMethod(ejs, prototype, ES_Path_joinExt, joinPathExt);
    ejsBindMethod(ejs, prototype, ES_Path_length, pathLength);
#if ES_Path_link
    ejsBindMethod(ejs, prototype, ES_Path_link, path_link);
#endif
    ejsBindMethod(ejs, prototype, ES_Path_linkTarget, pathLinkTarget);
    ejsBindMethod(ejs, prototype, ES_Path_makeDir, makePathDir);
#if DEPRECATED || 1
    ejsBindMethod(ejs, prototype, ES_Path_makeLink, makePathLink);
#endif
    ejsBindMethod(ejs, prototype, ES_Path_temp, pathTemp);
    ejsBindMethod(ejs, prototype, ES_Path_map, pa_map);
    ejsBindAccess(ejs, prototype, ES_Path_mimeType, getMimeType, NULL);
    ejsBindMethod(ejs, prototype, ES_Path_modified, getModifiedDate);
    ejsBindMethod(ejs, prototype, ES_Path_name, pa_name);
    ejsBindMethod(ejs, prototype, ES_Path_natural, getNaturalPath);
    ejsBindMethod(ejs, prototype, ES_Path_normalize, normalizePath);
    ejsBindMethod(ejs, prototype, ES_Path_parent, getPathParent);
    ejsBindAccess(ejs, prototype, ES_Path_perms, getPerms, setPerms);
    ejsBindMethod(ejs, prototype, ES_Path_portable, getPortablePath);
    ejsBindMethod(ejs, prototype, ES_Path_relative, relativePath);
    ejsBindMethod(ejs, prototype, ES_Path_relativeTo, relativeToPath);
    ejsBindMethod(ejs, prototype, ES_Path_remove, removePath);
    ejsBindMethod(ejs, prototype, ES_Path_rename, renamePathFile);
    ejsBindMethod(ejs, prototype, ES_Path_resolve, resolvePath);
    ejsBindMethod(ejs, prototype, ES_Path_root, rootPath);
    ejsBindMethod(ejs, prototype, ES_Path_same, isPathSame);
    ejsBindMethod(ejs, prototype, ES_Path_separator, pathSeparator);
    ejsBindMethod(ejs, prototype, ES_Path_setAttributes, path_setAttributes);
    ejsBindMethod(ejs, prototype, ES_Path_size, getPathFileSize);
#if DEPRECATED || 1
    ejsBindMethod(ejs, prototype, ES_Path_symlink, path_symlink);
#endif
    ejsBindMethod(ejs, prototype, ES_Path_toJSON, pathToJSON);
    ejsBindMethod(ejs, prototype, ES_Path_toString, pathToString);
    ejsBindMethod(ejs, prototype, ES_Path_trimExt, trimExt);
    ejsBindMethod(ejs, prototype, ES_Path_truncate, truncatePath);
    ejsBindMethod(ejs, prototype, ES_Path_windows, windowsPath);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsPot.c"
 */
/************************************************************************/

/**
    ejsPot.c - Property Object class (Objects with properties)

    This is the base for all scripted classes.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Defines **********************************/

#define CMP_QNAME(a,b) ((a)->name == (b)->name && (a)->space == (b)->space)
#define CMP_NAME(a,b) ((a)->name == (b)->name)

/****************************** Forward Declarations **************************/

static int  growSlots(Ejs *ejs, EjsPot *obj, int size);
static int  hashProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname);
static void removeHashEntry(Ejs *ejs, EjsPot *obj, EjsName qname);

/************************************* Code ***********************************/

PUBLIC EjsAny *ejsCreateEmptyPot(Ejs *ejs)
{
    return ejsCreatePot(ejs, ESV(Object), 0);
}


PUBLIC EjsAny *ejsClonePot(Ejs *ejs, EjsAny *obj, bool deep)
{
    EjsPot      *dest, *src;
    EjsSlot     *dp, *sp;
    EjsType     *type;
    EjsObj      *vp;
    int         numProp, i;

    if (!ejsIsPot(ejs, obj)) {
        assert(ejsIsPot(ejs, obj));
        return NULL;
    }
    src = (EjsPot*) obj;
    type = TYPE(src);
    numProp = src->numProp;
    if ((dest = ejsCreatePot(ejs, type, numProp)) == 0) {
        return 0;
    }
    dest->obj = src->obj;
    dest->isBlock = src->isBlock;
    dest->isFrame = src->isFrame;
    dest->isFunction = src->isFunction;
    dest->isPrototype = src->isPrototype;
    dest->isType = src->isType;
    dest->numProp = numProp;
    dest->shortScope = src->shortScope;
    
    dp = dest->properties->slots;
    sp = src->properties->slots;

    /*
        NOTE: Object pots do not inherit prototype properties, whereas class instances do.
     */
    for (i = 0; i < numProp; i++, sp++, dp++) {
        *dp = *sp;
        dp->hashChain = -1;
        vp = sp->value.ref;
        if (deep && vp) {
            if (ejsIsFunction(ejs, vp) && !ejsIsType(ejs, vp)) {
                ;
            } else if ((ejsIsType(ejs, vp) && ((EjsType*) vp)->mutable) || 
                      (!ejsIsType(ejs, vp) && TYPE(vp)->mutableInstances)) {
#if ME_MEMORY_DEBUG
                EjsName qname = ejsGetPropertyName(ejs, src, i);
                mprSetName(dp->value.ref, qname.name->value);
                // mprTrace(0, "CLONE %N", qname);
#endif
                dp->value.ref = ejsClone(ejs, vp, deep);
            }
        }
    }
    if (dest->numProp > EJS_HASH_MIN_PROP) {
        ejsIndexProperties(ejs, dest);
    }
    mprCopyName(dest, src);
    return dest;
}


/*
    Fix trait type references to point to mutable types in the current interpreter. Only needed after cloning global.
 */
PUBLIC void ejsFixTraits(Ejs *ejs, EjsPot *obj)
{
    EjsSlot     *sp;
    EjsType     *type;
    int         numProp, i;

    if (VISITED(obj)) {
        return;
    }
    SET_VISITED(obj, 1);
    numProp = obj->numProp;
    sp = obj->properties->slots;
    
    for (i = 0; i < numProp; i++, sp++) {
        if (sp->trait.type && sp->trait.type->mutable) {
            assert(sp->trait.type->qname.name);
            if ((type = ejsGetPropertyByName(ejs, ejs->global, sp->trait.type->qname)) != 0) {
                sp->trait.type = type;
            } else {
                assert(0);
            }
        }
        if (ejsIsPot(ejs, sp->value.ref)) {
            ejsFixTraits(ejs, sp->value.ref);
        }
    }
    SET_VISITED(obj, 0);
}


static EjsObj *prepareAccessors(Ejs *ejs, EjsPot *obj, int slotNum, int64 *attributes, EjsObj *value)
{
    EjsFunction     *fun;
    EjsTrait        *trait;

    fun = ejsGetProperty(ejs, obj, slotNum);

    if (*attributes & EJS_TRAIT_SETTER) {
        if (ejsIsFunction(ejs, fun)) {
            /* Existing getter, add a setter */
            fun->setter = (EjsFunction*) value;
            if ((trait = ejsGetPropertyTraits(ejs, obj, slotNum)) != 0) {
                *attributes |= trait->attributes;
            }
        } else {
            /* No existing getter, must define a dummy getter - will not be called */
            fun = (EjsFunction*) ejsCloneFunction(ejs, ESV(nop), 0);
            fun->setter = (EjsFunction*) value;
        }
        value = (EjsObj*) fun;

    } else if (*attributes & EJS_TRAIT_GETTER) {
        if (ejsIsFunction(ejs, fun) && ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_SETTER)) {
            /* Existing getter and setter - preserve any defined setter, overwrite getter */
            if (fun->setter) {
                ((EjsFunction*) value)->setter = fun->setter;
                *attributes |= EJS_TRAIT_SETTER;
            }
        }
    }
    return value;
}


/*
    Define (or redefine) a property and set its name, type, attributes and property value.
 */
static int definePotProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname, EjsType *propType, int64 attributes, 
    EjsObj *value)
{
    EjsFunction     *fun;
    int             priorSlot;

    assert(ejs);
    assert(ejsIsPot(ejs, obj));
    assert(slotNum >= -1);

    if (attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER) && !ejsIsFunction(ejs, value)) {
        ejsThrowTypeError(ejs, "Property \"%@\" is not a function", qname.name);
        return 0;
    }
    priorSlot = ejsLookupProperty(ejs, obj, qname);
    if (slotNum < 0) {
        if (priorSlot < 0) {
            slotNum = obj->numProp;
        } else {
            slotNum = priorSlot;
        }
    }
    assert(priorSlot < 0 || priorSlot == slotNum);

    if (slotNum >= obj->numProp && !DYNAMIC(obj)) {
        if (obj->properties == 0 || slotNum >= obj->properties->size) {
            if (growSlots(ejs, obj, slotNum + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return EJS_ERR;
            }
        }
        obj->numProp = slotNum + 1;
    }
    if (priorSlot < 0 && ejsSetPropertyName(ejs, obj, slotNum, qname) < 0) {
        return EJS_ERR;
    }
    if (attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER)) {
        value = prepareAccessors(ejs, obj, slotNum, &attributes, value);
    }
    if (value) {
        if (ejsSetProperty(ejs, obj, slotNum, value ? value: ESV(null)) < 0) {
            return EJS_ERR;
        }
    }
    if (ejsSetPropertyTraits(ejs, obj, slotNum, propType, (int) attributes) < 0) {
        return EJS_ERR;
    }
    if (value && ejsIsFunction(ejs, value)) {
        fun = ((EjsFunction*) value);
        if (!ejsIsNativeFunction(ejs, fun) && ejsIsType(ejs, obj)) {
            ((EjsType*) obj)->hasScriptFunctions = 1;
        }
#if UNUSED
        if (fun->staticMethod && ejsIsType(ejs, obj)) {
            type = (EjsType*) obj;
            if (!type->isInterface) {
                /* For static methods, find the right base class and set thisObj to speed up later invocations */
                fun->boundThis = obj;
            }
        }
#endif
    }
    return slotNum;
}


/*
    Delete an instance property. To delete class properties, use the type as the obj. This sets the property to null.
    It does not reclaim the property slot.
 */
static int deletePotProperty(Ejs *ejs, EjsPot *obj, int slotNum)
{
    EjsName     qname;
    EjsSlot     *sp;

    assert(obj);
    assert(ejsIsPot(ejs, obj));
    assert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numProp) {
        ejsThrowReferenceError(ejs, "Invalid property slot to delete");
        return EJS_ERR;
    }
    qname = ejsGetPotPropertyName(ejs, obj, slotNum);
    if (qname.name) {
        removeHashEntry(ejs, obj, qname);
    }
    sp = &obj->properties->slots[slotNum];
    sp->value.ref = ESV(undefined);
    sp->trait.type = 0;
    sp->trait.attributes = EJS_TRAIT_DELETED | EJS_TRAIT_HIDDEN;
    return 0;
}


static int deletePotPropertyByName(Ejs *ejs, EjsPot *obj, EjsName qname)
{
    int     slotNum;

    assert(ejsIsPot(ejs, obj));

    slotNum = ejsLookupPotProperty(ejs, obj, qname);
    if (slotNum < 0) {
        ejsThrowReferenceError(ejs, "Property does not exist");
        return EJS_ERR;
    }
    return deletePotProperty(ejs, obj, slotNum);
}


static EjsPot *getPotProperty(Ejs *ejs, EjsPot *obj, int slotNum)
{
    assert(ejsIsPot(ejs, obj));
    assert(obj);
    assert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numProp) {
        ejsThrowReferenceError(ejs, "Property at slot \"%d\" is not found", slotNum);
        return 0;
    }
    return obj->properties->slots[slotNum].value.ref;
}


static int getPotPropertyCount(Ejs *ejs, EjsPot *obj)
{
    assert(obj);
    assert(ejsIsPot(ejs, obj));

    return obj->numProp;
}


PUBLIC EjsName ejsGetPotPropertyName(Ejs *ejs, EjsPot *obj, int slotNum)
{
    EjsName     qname;

    assert(obj);
    assert(ejsIsPot(ejs, obj));
    assert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numProp) {
        qname.name = 0;
        qname.space = 0;
        return qname;
    }
    return obj->properties->slots[slotNum].qname;
}


/*
    Lookup a property with a namespace qualifier in an object and return the slot if found. Return EJS_ERR if not found.
    If qname.space is NULL, then only return a positive slot if there is only one property of the given name.
    Only the name portion is hashed. The namespace is not included in the hash. This is used to do a one-step lookup 
    for properties regardless of the namespace.
 */
PUBLIC int ejsLookupPotProperty(struct Ejs *ejs, EjsPot *obj, EjsName qname)
{
    EjsProperties   *props;
    EjsHash         *hash;
    EjsSlot         *slots, *sp, *np;
    int             slotNum, index, prior;

    assert(qname.name);
    assert(ejsIsPot(ejs, obj));

    if ((props = obj->properties) == 0 || obj->numProp == 0) {
        return -1;
    }
    slots = props->slots;
    if ((hash = props->hash) == 0 || hash->size == 0) {
        /* No hash. Just do a linear search */
        if (qname.space) {
            for (slotNum = 0; slotNum < obj->numProp; slotNum++) {
                sp = &slots[slotNum];
                if (CMP_QNAME(&sp->qname, &qname)) {
                    return slotNum;
                }
            }
            return -1;
        } else {
            for (slotNum = 0, prior = -1; slotNum < obj->numProp; slotNum++) {
                sp = &slots[slotNum];
                if (CMP_NAME(&sp->qname, &qname)) {
                    if (prior >= 0) {
                        /* Multiple properties with the same name */
                        return -1;
                    }
                    prior = slotNum;
                }
            }
            return prior;
        }

    } else {
        /*
            Find the property in the hash chain if it exists. Note the hash does not include the namespace portion.
            We assume that names rarely clash with different namespaces. We do this so variable lookup and do a one
            hash probe and find matching names. Lookup will then pick the right namespace.
         */
        assert(props->hash);
        assert(props->hash->size > 0);
        index = whash(qname.name->value, qname.name->length) % props->hash->size;
        if (qname.space) {
            assert(hash->buckets);
            assert(index < hash->size);
            for (slotNum = hash->buckets[index]; slotNum >= 0; slotNum = slots[slotNum].hashChain) {
                sp = &slots[slotNum];
                if (CMP_QNAME(&sp->qname, &qname)) {
                    return slotNum;
                }
            }
        } else {
            for (slotNum = hash->buckets[index]; slotNum >= 0; slotNum = sp->hashChain) {
                sp = &slots[slotNum];
                if (CMP_NAME(&sp->qname, &qname)) {
                    /* Now ensure there are no more matching names - must be unique in the "name" only */
                    for (np = sp; np->hashChain >= 0; ) {
                        np = &slots[np->hashChain];
                        if (CMP_NAME(&sp->qname, &np->qname)) {
                            /* Multiple properties with the same name */
                            return -1;
                        }
                    }
                    return slotNum;
                }
            }
        }
    }
    return -1;
}


/*
    Validate the supplied slot number. If set to -1, then return the next available property slot number.
    Grow the object if required and update numProp
 */
PUBLIC int ejsCheckSlot(Ejs *ejs, EjsPot *obj, int slotNum)
{
    assert(ejsIsPot(ejs, obj));

    //  TODO - should this be here or only in the VM. probably only in the VM.
    //  TODO -- or move this routine to the VM
    if (slotNum < 0 || slotNum >= obj->numProp) {
        if (!DYNAMIC(obj)) {
            if (ejsIs(ejs, obj, Null)) {
                ejsThrowReferenceError(ejs, "Object is null");
            } else if (ejsIs(ejs, obj, Void)) {
                ejsThrowReferenceError(ejs, "Object is undefined");
            } else {
                ejsThrowReferenceError(ejs, "Object is not extendable");
            }
            return EJS_ERR;
        }
        if (slotNum < 0) {
            slotNum = obj->numProp;
        }
        if (obj->properties == 0 || slotNum >= obj->properties->size) {
            if (growSlots(ejs, obj, slotNum + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return EJS_ERR;
            }
        }
        if (slotNum > obj->numProp) {
            obj->numProp = slotNum;
        }
        obj->numProp++;
    }
    assert(obj->numProp <= obj->properties->size);
    return slotNum;
}


/**
    Set the value of a property.
    @param slot If slot is -1, then allocate the next free slot
    @return Return the property slot if successful. Return < 0 otherwise.
 */
static int setPotProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsObj *value)
{
    assert(ejs);
    assert(obj);
    assert(ejsIsPot(ejs, obj));
    assert(value);

    if ((slotNum = ejsCheckSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    assert(slotNum < obj->numProp);
    assert(obj->numProp <= obj->properties->size);
    obj->properties->slots[slotNum].value.ref = value;
    return slotNum;
}


/*
    Set the name for a property. Objects maintain a hash lookup for property names. This is hash is created on demand 
    if there are more than N properties. If an object is not dynamic, it will use the types name hash. If dynamic, 
    then the types name hash will be copied when required. 
 */
static int setPotPropertyName(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname)
{
    EjsProperties   *props;

    assert(obj);
    assert(ejsIsPot(ejs, obj));
    assert(qname.name);
    assert(qname.space);

    if ((slotNum = ejsCheckSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    assert(slotNum < obj->numProp);
    props = obj->properties;

    /* Remove the old hash entry if the name will change */
    if (props->slots[slotNum].hashChain >= 0) {
        if (CMP_QNAME(&props->slots[slotNum].qname, &qname)) {
            return slotNum;
        }
        removeHashEntry(ejs, obj, props->slots[slotNum].qname);
    }
    props->slots[slotNum].qname = qname;
    
    assert(slotNum < obj->numProp);
    assert(obj->numProp <= props->size);
    
    if (props->hash || obj->numProp > EJS_HASH_MIN_PROP) {
        if (hashProperty(ejs, obj, slotNum, qname) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
    }
    return slotNum;
}


/******************************* Slot Routines ********************************/
/*
    Grow and object and update numProp and numTraits if required
 */
PUBLIC int ejsGrowPot(Ejs *ejs, EjsPot *obj, int numProp)
{
    assert(ejsIsPot(ejs, obj));

    if (obj->properties == 0 || numProp > obj->properties->size) {
        if (growSlots(ejs, obj, numProp) < 0) {
            return EJS_ERR;
        }
    }
    if (numProp > obj->numProp) {
        obj->numProp = numProp;
    }
    return 0;
}


//  TODO-- inconsistent with growObject which takes numProp. This takes incr.
/*
    Grow the slots, traits, and names by the specified "incr". The new slots|traits|names are created at the "offset"
    Does not update numProp or numTraits.
 */
PUBLIC int ejsInsertPotProperties(Ejs *ejs, EjsPot *obj, int incr, int offset)
{
    EjsSlot         *sp, *slots;
    int             i, size, mark;

    assert(obj);
    assert(ejsIsPot(ejs, obj));
    assert(incr >= 0);

    if (incr <= 0) {
        return 0;
    }
    size = obj->numProp + incr;
    if (obj->properties == 0 || obj->properties->size < size) {
        if (growSlots(ejs, obj, size) < 0) {
            return EJS_ERR;
        }
    }
    obj->numProp += incr;
    assert(obj->numProp <= obj->properties->size);
    slots = obj->properties->slots;
    for (mark = offset + incr, i = obj->numProp - 1; i >= mark; i--) {
        sp = &slots[i - mark];
        slots[i] = *sp;
    }
    ejsZeroSlots(ejs, &slots[offset], incr);
    if (ejsIndexProperties(ejs, obj) < 0) {
        return EJS_ERR;
    }   
    return 0;
}


/*
    Allocate or grow the slots storage for an object. Does not update numProp.
 */
static int growSlots(Ejs *ejs, EjsPot *obj, int slotCount)
{
    EjsProperties   *props;
    ssize           size;
    int             factor, oldSize;

    assert(obj);
    assert(ejsIsPot(ejs, obj));
    assert(slotCount > 0);
    assert(obj->properties == 0 || slotCount > obj->properties->size);

    props = obj->properties;
    oldSize = props ? props->size : 0;
    
    if (slotCount > oldSize) {
        if (slotCount > EJS_LOTSA_PROP) {
            factor = max(oldSize / 4, EJS_ROUND_PROP);
            slotCount = (slotCount + factor) / factor * factor;
        }
        slotCount = EJS_PROP_ROUNDUP(slotCount);
        size = sizeof(EjsProperties) + (sizeof(EjsSlot) * slotCount);

        if (props == 0) {
            assert(obj->numProp == 0);
            assert(slotCount > 0);
            if ((props = mprAllocZeroed(size)) == 0) {
                return EJS_ERR;
            }
            obj->properties = props;
            ejsZeroSlots(ejs, props->slots, slotCount);
            obj->separateSlots = 1;
        } else {
            if (obj->separateSlots) {
                assert(props->size > 0);
                props = mprRealloc(props, size);
            } else {
                if ((props = mprAlloc(size)) != 0) {
                    memcpy(props, obj->properties, sizeof(EjsProperties) + obj->properties->size * sizeof(EjsSlot));
                    obj->properties = props;
                    obj->separateSlots = 1;
                }
            }
            if (props == 0) {
                return EJS_ERR;
            }
            ejsZeroSlots(ejs, &props->slots[props->size], (slotCount - props->size));
            obj->properties = props;
        }
        props->size = slotCount;
    }
    assert(obj->numProp <= props->size);
    return 0;
}


/*
    Remove a slot and name. Copy up all other properties. WARNING: this can only be used before property binding and 
    should only be used by the compiler.
 */
static void removeSlot(Ejs *ejs, EjsPot *obj, int slotNum, int compact)
{
    EjsSlot     *slots;
    int         i;

    assert(obj);
    assert(ejsIsPot(ejs, obj));
    assert(slotNum >= 0);
    assert(compact);

    if (obj->properties) {
        slots = obj->properties->slots;
        if (compact) {
            for (i = slotNum + 1; i < obj->numProp; i++) {
                slots[i - 1] = slots[i];
            }
            obj->numProp--;
            i--;
        } else {
            i = slotNum;
        }
        ejsZeroSlots(ejs, &slots[i], 1);
        ejsIndexProperties(ejs, obj);
    }
}


PUBLIC void ejsZeroSlots(Ejs *ejs, EjsSlot *slots, int count)
{
    EjsSlot     *sp;

    assert(slots);
    assert(count >= 0);

    if (slots) {
        //  TODO OPT. If hashChans were biased by +1 and NULL was allowed for names, then a simple zero would suffice.
        for (sp = &slots[count - 1]; sp >= slots; sp--) {
            sp->value.ref = ESV(null);
            sp->hashChain = -1;
            //  TODO -- why set names to this. Better to set to null?
            sp->qname.name = ESV(empty);
            sp->qname.space = ESV(empty);
            sp->trait.type = 0;
            sp->trait.attributes = 0;
        }
    }
}


PUBLIC void ejsCopySlots(Ejs *ejs, EjsPot *dest, int destOff, EjsPot *src, int srcOff, int count)
{
    EjsSlot     *sp, *dp;

    assert(dest->properties);
    assert(src->properties);
    assert(srcOff < src->numProp);
    assert(destOff < dest->numProp);

    for (sp = &src->properties->slots[srcOff], dp = &dest->properties->slots[destOff]; count > 0; count--) {
        *dp = *sp;
        dp->hashChain = -1;
        dp++;
        sp++;
    }
}


/*
    Remove a property and copy up all other properties. WARNING: This does much more than just a delete and should 
    only be used by the compiler.
 */
PUBLIC int ejsRemovePotProperty(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsPot      *obj;

    assert(ejsIsPot(ejs, vp));

    if (!ejsIsPot(ejs, vp)) {
        ejsThrowTypeError(ejs, "Object is not configurable");
        return EJS_ERR;
    }
    obj = vp;
    assert(ejs);
    assert(obj);
    if (slotNum < 0 || slotNum >= obj->numProp) {
        return EJS_ERR;
    }
    removeSlot(ejs, obj, slotNum, 1);
    return 0;
}


/*********************************** Traits ***********************************/

static EjsTrait *getPotPropertyTraits(Ejs *ejs, EjsPot *obj, int slotNum)
{
    assert(ejsIsPot(ejs, obj));
    if (slotNum < 0 || slotNum >= obj->numProp) {
        return NULL;
    }
    return &obj->properties->slots[slotNum].trait;
}


static int setPotPropertyTraits(Ejs *ejs, EjsPot *obj, int slotNum, EjsType *type, int attributes)
{
    assert(ejsIsPot(ejs, obj));
    assert(slotNum >= 0);

    if ((slotNum = ejsCheckSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    if (type) {
        obj->properties->slots[slotNum].trait.type = type;
    }
    if (attributes != -1) {
        obj->properties->slots[slotNum].trait.attributes = attributes;
    }
    return slotNum;
}


/******************************* Hash Routines ********************************/
/*
    Exponential primes
 */
static int hashSizes[] = {
     19, 29, 59, 79, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 0
};


PUBLIC int ejsGetHashSize(int numProp)
{
    int     i;

    for (i = 0; hashSizes[i]; i++) {
        if (numProp < hashSizes[i]) {
            return hashSizes[i];
        }
    }
    return hashSizes[i - 1];
}


static int hashProperty(Ejs *ejs, EjsPot *obj, int slotNum, EjsName qname)
{
    EjsProperties   *props;
    EjsHash         *hash;
    EjsName         *slotName;
    EjsSlot         *slots;
    int             chainSlotNum, lastSlot, index;

    assert(ejsIsPot(ejs, obj));

    props = obj->properties;
    if (props == NULL || props->hash == NULL || props->hash->size < obj->numProp) {
        /*  Remake the entire hash */
        return ejsIndexProperties(ejs, obj);
    }
    hash = props->hash;
    slots = props->slots;
    index = whash(qname.name->value, qname.name->length) % hash->size;

    /* Scan the collision chain */
    lastSlot = -1;
    chainSlotNum = hash->buckets[index];
    assert(chainSlotNum < obj->numProp);
    assert(chainSlotNum < props->size);

    while (chainSlotNum >= 0) {
        slotName = &slots[chainSlotNum].qname;
        if (CMP_QNAME(slotName, &qname)) {
            return 0;
        }
        assert(lastSlot != chainSlotNum);
        lastSlot = chainSlotNum;
        assert(chainSlotNum != slots[chainSlotNum].hashChain);
        chainSlotNum = slots[chainSlotNum].hashChain;
        assert(0 <= lastSlot && lastSlot < props->size);
    }
    if (lastSlot >= 0) {
        assert(lastSlot < obj->numProp);
        assert(lastSlot != slotNum);
        slots[lastSlot].hashChain = slotNum;

    } else {
        /* Start a new hash chain */
        hash->buckets[index] = slotNum;
    }
    slots[slotNum].hashChain = -2;
    slots[slotNum].qname = qname;
    return 0;
}


/*
    Allocate or grow the properties storage for an object. This routine will also manage the hash index for the object. 
    If numInstanceProp is < 0, then grow the number of properties by an increment. Otherwise, set the number of properties 
    to numInstanceProp. We currently don't allow reductions.
 */
//  TODO TODO -- rename
PUBLIC int ejsIndexProperties(Ejs *ejs, EjsPot *obj)
{
    EjsSlot         *sp;
    EjsHash         *oldHash, *hash;
    int             i, newHashSize;

    assert(obj);
    assert(ejsIsPot(ejs, obj));

    if (obj->properties == 0) {
        return 0;
    }
    if (obj->numProp <= EJS_HASH_MIN_PROP && obj->properties->hash == 0) {
        /* Too few properties */
        return 0;
    }
    /*
        Reallocate the hash buckets if the hash needs to grow larger
     */
    oldHash = obj->properties->hash;
    newHashSize = ejsGetHashSize(obj->numProp);
    if (oldHash == NULL || oldHash->size < newHashSize) {
        hash = (EjsHash*) mprAlloc(sizeof(EjsHash) + (newHashSize * sizeof(int)));
        if (hash == 0) {
            return EJS_ERR;
        }
        hash->buckets = (int*) (((char*) hash) + sizeof(EjsHash));
        hash->size = newHashSize;
        assert(newHashSize > 0);
        obj->properties->hash = hash;
        obj->separateHash = 1;
    }
    hash = obj->properties->hash;
    assert(hash);
    memset(hash->buckets, -1, hash->size * sizeof(int));

    /*
        Clear out hash linkage
     */
    if (oldHash) {
        for (sp = obj->properties->slots, i = 0; i < obj->numProp; i++, sp++) {
            sp->hashChain = -1;
        }
    }

    /*
        Rehash existing properties
     */
    for (sp = obj->properties->slots, i = 0; i < obj->numProp; i++, sp++) {
        if (sp->qname.name && hashProperty(ejs, obj, i, sp->qname) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


static void removeHashEntry(Ejs *ejs, EjsPot *obj, EjsName qname)
{
    EjsSlot     *sp;
    EjsName     *nextName;
    int         index, slotNum, lastSlot, *buckets;

    assert(ejsIsPot(ejs, obj));

    if (obj->properties->hash == 0) {
        /*
            No hash. Just do a linear search
         */
        for (slotNum = 0; slotNum < obj->numProp; slotNum++) {
            sp = &obj->properties->slots[slotNum];
            if (CMP_QNAME(&sp->qname, &qname)) {
                //  TODO -- would null be better
                sp->qname.name = ESV(empty);
                sp->qname.space = ESV(empty);
                sp->hashChain = -1;
                return;
            }
        }
        assert(0);
        return;
    }
    index = whash(qname.name->value, qname.name->length) % obj->properties->hash->size;
    slotNum = obj->properties->hash->buckets[index];
    lastSlot = -1;
    buckets = obj->properties->hash->buckets;
    while (slotNum >= 0) {
        sp = &obj->properties->slots[slotNum];
        nextName = &sp->qname;
        if (CMP_QNAME(nextName, &qname)) {
            if (lastSlot >= 0) {
                obj->properties->slots[lastSlot].hashChain = obj->properties->slots[slotNum].hashChain;
            } else {
                buckets[index] = obj->properties->slots[slotNum].hashChain;
            }
            //  TODO -- null would be better
            sp->qname.name = ESV(empty);
            sp->qname.space = ESV(empty);
            sp->hashChain = -1;
            return;
        }
        lastSlot = slotNum;
        slotNum = obj->properties->slots[slotNum].hashChain;
    }
    assert(0);
}


PUBLIC int ejsCompactPot(Ejs *ejs, EjsPot *obj)
{
    EjsSlot     *slots, *src, *dest;
    int         i, removed;

    assert(ejsIsPot(ejs, obj));

    src = dest = slots = obj->properties->slots;
    for (removed = i = 0; i < obj->numProp; i++, src++) {
        if (!ejsIsDefined(ejs, src->value.ref)) {
            removed++;
            continue;
        }
        *dest++ = *src;
    }
    obj->numProp -= removed;
    ejsIndexProperties(ejs, obj);
    return obj->numProp;
}


PUBLIC bool ejsMatchName(Ejs *ejs, EjsName *a, EjsName *b)
{
    return a->name == b->name && a->space == b->space;
}


/************************************ Factory *********************************/
/*
    Create an object which is an instance of a given type. NOTE: only initialize the Object base class. It is up to the 
    caller to complete the initialization for all other base classes by calling the appropriate constructors. The numProp 
    arg is the number of property slots to pre-allocate. It is typically zero and slots are allocated on-demand. If the 
    type creates dynamic instances, then the property slots are allocated separately and can grow. 
 */
PUBLIC void *ejsCreatePot(Ejs *ejs, EjsType *type, int numProp)
{
    EjsPot      *obj, *prototype;

    assert(type);
    
    prototype = type->prototype;
    if (type->hasInstanceVars) {
        numProp = max(numProp, prototype->numProp);
    }
    if (type->dynamicInstances) {
        if ((obj = ejsAlloc(ejs, type, 0)) == 0) {
            return 0;
        }
        if (numProp > 0) {
            growSlots(ejs, obj, numProp);
        }
        SET_DYNAMIC(obj, 1);
    } else {
        if ((obj = ejsAlloc(ejs, type, sizeof(EjsProperties) + numProp * sizeof(EjsSlot))) == 0) {
            return 0;
        }
        if (numProp > 0) {
            obj->properties = (EjsProperties*) &(((char*) obj)[type->instanceSize]);
            obj->properties->size = numProp;
        }
    }
    obj->numProp = numProp;
    if (numProp > 0) {
        if (type->hasInstanceVars) {
            if (prototype->numProp > 0) {
                ejsCopySlots(ejs, obj, 0, prototype, 0, prototype->numProp);
            }
            ejsZeroSlots(ejs, &obj->properties->slots[prototype->numProp], obj->properties->size - prototype->numProp);
            if (numProp > EJS_HASH_MIN_PROP) {
                ejsIndexProperties(ejs, obj);
            }
        } else {
            ejsZeroSlots(ejs, obj->properties->slots, obj->properties->size);
        }
    }
    ejsSetMemRef(obj);
    return obj;
}


/*
    Manage the object properties for the garbage collector
 */
PUBLIC void ejsManagePot(void *ptr, int flags)
{
    EjsSlot     *sp;
    EjsPot      *obj;
    int         i, numProp;

    if (ptr) {
        obj = (EjsPot*) ptr;

        if (flags & MPR_MANAGE_MARK) {
            if (obj->separateSlots) {
                mprMark(obj->properties);
            }
            if (obj->separateHash) {
                mprMark(obj->properties->hash);
            }
            /*
                Cache numProp incase the object grows while traversing
             */
            numProp = obj->numProp;
            for (sp = obj->properties->slots, i = 0; i < numProp; i++, sp++) {
                if (sp->qname.name) {
                    mprMark(sp->qname.name);
                    mprMark(sp->qname.space);
                    mprMark(sp->value.ref);
#if FUTURE
                    mprMark(sp->trait.type);
#endif
                }
            }
        }
    }
}


PUBLIC void ejsCreatePotHelpers(Ejs *ejs)
{
    EjsHelpers      *helpers;

    ejs->service->potHelpers = ejs->service->objHelpers;
    helpers = &ejs->service->potHelpers;
    helpers->clone                  = (EjsCloneHelper) ejsClonePot;
    helpers->create                 = (EjsCreateHelper) ejsCreatePot;
    helpers->defineProperty         = (EjsDefinePropertyHelper) definePotProperty;
    helpers->deleteProperty         = (EjsDeletePropertyHelper) deletePotProperty;
    helpers->deletePropertyByName   = (EjsDeletePropertyByNameHelper) deletePotPropertyByName;
    helpers->getProperty            = (EjsGetPropertyHelper) getPotProperty;
    helpers->getPropertyCount       = (EjsGetPropertyCountHelper) getPotPropertyCount;
    helpers->getPropertyName        = (EjsGetPropertyNameHelper) ejsGetPotPropertyName;
    helpers->getPropertyTraits      = (EjsGetPropertyTraitsHelper) getPotPropertyTraits;
    helpers->lookupProperty         = (EjsLookupPropertyHelper) ejsLookupPotProperty;
    helpers->setProperty            = (EjsSetPropertyHelper) setPotProperty;
    helpers->setPropertyName        = (EjsSetPropertyNameHelper) setPotPropertyName;
    helpers->setPropertyTraits      = (EjsSetPropertyTraitsHelper) setPotPropertyTraits;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsRegExp.c"
 */
/************************************************************************/

/**
    ejsRegExp.c - RegExp type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */
/********************************** Includes **********************************/


#include    "pcre.h"

/********************************** Defines ***********************************/

#if !defined(ME_MAX_REGEX_MATCHES)
    #define ME_MAX_REGEX_MATCHES 64
#endif

/********************************* Forwards ***********************************/

static char *makeFlags(EjsRegExp *rp);
static int parseFlags(EjsRegExp *rp, wchar *flags);

/******************************************************************************/
/*
    Cast the operand to the specified type

    function cast(type: Type) : Object
 */
static EjsAny *castRegExp(Ejs *ejs, EjsRegExp *rp, EjsType *type)
{
    wchar   *pattern;
    char    *flags;
    ssize   len, flen;
    int     i, j;

    switch (type->sid) {
    case S_Boolean:
        return ESV(true);

    case S_String:
        flags = makeFlags(rp);
        len = wlen(rp->pattern);
        flen = wlen(flags);
        pattern = mprAlloc((len * 2 + flen + 1) * sizeof(wchar));
        /*
            Convert to a form that is a valid, parsable as regular expression literal
         */
        pattern[0] = '/';
        for (i = 0, j = 1; i < len; i++) {
            if (rp->pattern[i] == '/') {
                pattern[j++] = '\\';
            }
            pattern[j++] = rp->pattern[i];
        }
        pattern[j++] = '/';
        for (i = 0; i < flen; i++) {
            pattern[j++] = flags[i];
        }
        pattern[j] = 0;
        return ejsCreateStringFromAsc(ejs, pattern);

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


/*********************************** Methods **********************************/
/*
    RegExp constructor

    RegExp(pattern: String, flags: String = null)
 */

static EjsRegExp *regex_Constructor(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    cchar       *errMsg;
    int         column, errCode;

    rp->pattern = wclone(ejsToString(ejs, argv[0])->value);
    rp->options = PCRE_JAVASCRIPT_COMPAT;

    if (argc == 2) {
        rp->options |= parseFlags(rp, ejsToString(ejs, argv[1])->value);
    }
    if (rp->compiled) {
        free(rp->compiled);
    }
    if ((rp->compiled = pcre_compile2(rp->pattern, rp->options, &errCode, &errMsg, &column, NULL)) == 0) {
        ejsThrowArgError(ejs, "Cannot compile regular expression '%s'. Error %s at column %d", rp->pattern, errMsg, column);
        return 0;
    }
    return rp;
}


static EjsNumber *regex_getLastIndex(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, rp->endLastMatch);
}


/*
    function set lastIndex(value: Number): Void
 */
static EjsObj *regex_setLastIndex(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    rp->endLastMatch = (int) ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function exec(str: String, start: Number = 0): Array
 */
static EjsArray *regex_exec(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    EjsArray    *results;
    EjsString   *match, *str;
    int         matches[ME_MAX_REGEX_MATCHES * 3];
    int         count, start, len, i, index;

    str = (EjsString*) argv[0];
    if (argc == 2) {
        start = (int) ejsGetNumber(ejs, argv[1]);
    } else {
        start = rp->endLastMatch;
    }
    if (start < 0 || start >= str->length) {
        rp->endLastMatch = 0;
        return ESV(null);
    }
    rp->matched = 0;
    assert(rp->compiled);
    count = pcre_exec(rp->compiled, NULL, str->value, (int) str->length, start, 0, matches, sizeof(matches) / sizeof(int));
    if (count < 0) {
        rp->endLastMatch = 0;
        return ESV(null);
    }
    results = ejsCreateArray(ejs, count);
    for (index = 0, i = 0; i < count; i++, index += 2) {
        len = matches[index + 1] - matches[index];
        match = ejsCreateString(ejs, &str->value[matches[index]], len);
        ejsSetProperty(ejs, results, i, match);
        if (index == 0) {
            rp->matched = match;
        }
    }
    if (rp->global) {
        /* Only save if global flag used as per spec */
        rp->startLastMatch = matches[0];
        rp->endLastMatch = matches[1];
    }
    return results;
}


static EjsBoolean *regex_getGlobalFlag(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->global);
}


static EjsBoolean *regex_getIgnoreCase(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->ignoreCase);
}


static EjsBoolean *regex_getMultiline(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->multiline);
}


static EjsString *regex_getSource(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateString(ejs, rp->pattern, wlen(rp->pattern));
}


static EjsString *regex_matched(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    if (rp->matched == 0) {
        return ESV(null);
    }
    return rp->matched;
}


static EjsNumber *regex_start(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, rp->startLastMatch);
}


static EjsBoolean *regex_sticky(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, rp->sticky);
}


static EjsBoolean *regex_test(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    EjsString   *str;
    int         count;

    str = (EjsString*) argv[0];
    assert(rp->compiled);
    count = pcre_exec(rp->compiled, NULL, str->value, (int) str->length, rp->endLastMatch, 0, 0, 0);
    if (count < 0) {
        rp->endLastMatch = 0;
        return ESV(false);
    }
    return ESV(true);
}


PUBLIC EjsString *ejsRegExpToString(Ejs *ejs, EjsRegExp *rp)
{
    return (EjsString*) castRegExp(ejs, rp, ESV(String));
}

/*********************************** Factory **********************************/
/*
    Create an initialized regular expression object. The pattern should NOT include the slash delimiters. 
 */
PUBLIC EjsRegExp *ejsCreateRegExp(Ejs *ejs, cchar *pattern, cchar *flags)
{
    EjsRegExp   *rp;
    cchar       *errMsg;
    int         column, errCode;

    if ((rp = ejsCreateObj(ejs, ESV(RegExp), 0)) == 0) {
        return 0;
    }
    rp->pattern = sclone(pattern);
    rp->options = parseFlags(rp, (wchar*) flags);
    rp->compiled = pcre_compile2(rp->pattern, rp->options, &errCode, &errMsg, &column, NULL);
    if (rp->compiled == NULL) {
        ejsThrowArgError(ejs, "Cannot compile regular expression '%s'. Error %s at column %d", rp->pattern, errMsg, column);
        return 0;
    }
    return rp;
}


/*
    Parse a regular expression string. The string should include the slash delimiters and may contain appended flags. 
    For example: /abc/ or /abc/g
 */
PUBLIC EjsRegExp *ejsParseRegExp(Ejs *ejs, EjsString *pattern)
{
    EjsRegExp   *rp;
    cchar       *errMsg;
    char        *cp, *dp;
    wchar       *flags;
    int         column, errCode;

    if (pattern->length == 0 || pattern->value[0] != '/') {
        ejsThrowArgError(ejs, "Bad regular expression pattern. Must start with '/'");
        return 0;
    }
    if ((rp = ejsCreateObj(ejs, ESV(RegExp), 0)) == 0) {
        return 0;
    }
    /*
        Strip off flags for passing to pcre_compile2
     */
    if (pattern->value[0] == '/') {
        rp->pattern = sclone(&pattern->value[1]);
        if ((flags = wrchr(rp->pattern, '/')) != 0) {
            if (flags == rp->pattern) {
                ejsThrowArgError(ejs, "Bad regular expression pattern. Must end with '/'");
                return 0;
            }
            rp->options = parseFlags(rp, &flags[1]);
            *flags = 0;
        }
        /*
            NOTE: we don't expect backquotes to be quoted. That only happens when interpreting literal js code and JSON
         */
        for (dp = cp = rp->pattern; *cp; ) {
            if (*cp == '\\' && cp[1] == '/') {
                cp++;
            }
            *dp++ = *cp++;
        }
        *dp++ = '\0';

    } else {
        rp->pattern = sclone(&pattern->value[1]);
    }
    rp->compiled = pcre_compile2(rp->pattern, rp->options, &errCode, &errMsg, &column, NULL);
    if (rp->compiled == NULL) {
        ejsThrowArgError(ejs, "Cannot compile regular expression '%s'. Error %s at column %d", rp->pattern, errMsg, column);
        return 0;
    }
    return rp;
}


static int parseFlags(EjsRegExp *rp, wchar *flags)
{
    wchar       *cp;
    int         options;

    if (flags == 0 || *flags == '\0') {
        return 0;
    }
    options = PCRE_JAVASCRIPT_COMPAT;
    for (cp = flags; *cp; cp++) {
        switch (tolower((uchar) *cp)) {
        case 'g':
            rp->global = 1;
            break;
        case 'i':
            rp->ignoreCase = 1;
            options |= PCRE_CASELESS;
            break;
        case 'm':
            rp->multiline = 1;
            options |= PCRE_MULTILINE;
            break;
        case 's':
            options |= PCRE_DOTALL;
            break;
        case 'y':
            rp->sticky = 1;
            break;
        case 'x':
            options |= PCRE_EXTENDED;
            break;
        case 'X':
            options |= PCRE_EXTRA;
            break;
        case 'U':
            options |= PCRE_UNGREEDY;
            break;
        }
    }
    return options;
}


static char *makeFlags(EjsRegExp *rp)
{
    char    buf[16], *cp;

    cp = buf;
    if (rp->global) {
        *cp++ = 'g';
    }
    if (rp->ignoreCase) {
        *cp++ = 'i';
    }
    if (rp->multiline) {
        *cp++ = 'm';
    }
    if (rp->sticky) {
        *cp++ = 'y';
    }
    if (rp->options & PCRE_DOTALL) {
        *cp++ = 's';
    }
    if (rp->options & PCRE_EXTENDED) {
        *cp++ = 'x';
    }
    if (rp->options & PCRE_EXTRA) {
        *cp++ = 'X';
    }
    if (rp->options & PCRE_UNGREEDY) {
        *cp++ = 'U';
    }
    *cp++ = '\0';
    return sclone(buf);
}


static void manageRegExp(EjsRegExp *rp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(rp->pattern);

    } else if (flags & MPR_MANAGE_FREE) {
        if (rp->compiled) {
            free(rp->compiled);
            rp->compiled = 0;
        }
    }
}


PUBLIC void ejsCreateRegExpType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", "RegExp"), sizeof(EjsRegExp), S_RegExp, ES_RegExp_NUM_CLASS_PROP,
        manageRegExp, EJS_TYPE_OBJ | EJS_TYPE_MUTABLE_INSTANCES);
    type->helpers.cast = (EjsCastHelper) castRegExp;
}


PUBLIC void ejsConfigureRegExpType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "RegExp"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, regex_Constructor);
    ejsBindMethod(ejs, prototype, ES_RegExp_exec, regex_exec);
    ejsBindAccess(ejs, prototype, ES_RegExp_lastIndex, regex_getLastIndex, regex_setLastIndex);
    ejsBindMethod(ejs, prototype, ES_RegExp_global, regex_getGlobalFlag);
    ejsBindMethod(ejs, prototype, ES_RegExp_ignoreCase, regex_getIgnoreCase);
    ejsBindMethod(ejs, prototype, ES_RegExp_multiline, regex_getMultiline);
    ejsBindMethod(ejs, prototype, ES_RegExp_source, regex_getSource);
    ejsBindMethod(ejs, prototype, ES_RegExp_matched, regex_matched);
    ejsBindMethod(ejs, prototype, ES_RegExp_start, regex_start);
    ejsBindMethod(ejs, prototype, ES_RegExp_sticky, regex_sticky);
    ejsBindMethod(ejs, prototype, ES_RegExp_test, regex_test);
    ejsBindMethod(ejs, prototype, ES_RegExp_toString, ejsRegExpToString);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsSocket.c"
 */
/************************************************************************/

/**
    ejsSocket.c - Socket class. This implements TCP/IP v4 and v6 connectivity.
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Forwards *********************************/

static void enableSocketEvents(EjsSocket *sp, int (*proc)(EjsSocket *sp, MprEvent *event));
static int socketIOEvent(EjsSocket *sp, MprEvent *event);
static int socketListenEvent(EjsSocket *listen, MprEvent *event);

/************************************ Methods *********************************/
/*
    function Socket()
 */
static EjsSocket *sock_Socket(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    sp->ejs = ejs;
    sp->sock = mprCreateSocket(NULL);
    if (sp->sock == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    return sp;
}


/*
    function accept(): Socket
 */
PUBLIC EjsSocket *sock_accept(Ejs *ejs, EjsSocket *listen, int argc, EjsObj **argv)
{
    MprSocket   *sock;
    EjsSocket   *sp;

    if ((sock = mprAcceptSocket(listen->sock)) == 0) {
        ejsThrowIOError(ejs, "Cannot accept new socket");
        return 0;
    }
    if ((sp = ejsCreateSocket(ejs, sock, listen->async)) != 0) {
        if (sp->async) {
            sp->mask |= MPR_READABLE;
            enableSocketEvents(sp, socketIOEvent);
        } else {
            mprSetSocketBlockingMode(sp->sock, 1);
        }
    }
    return sp;
}


/*
    function get address(): String
 */
PUBLIC EjsString *sock_address(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, sp->address);
}


/*
    function get async(): Boolean
 */
PUBLIC EjsBoolean *sock_async(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return (sp->async) ? ESV(true) : ESV(false);
}


/*
    function set async(enable: Boolean): Void
 */
PUBLIC EjsObj *sock_set_async(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    sp->async = (argv[0] == ESV(true));
    return 0;
}


/*
    function close(): Void
 */
static EjsObj *sock_close(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    ejsSendEvent(ejs, sp->emitter, "close", NULL, sp);
    if (sp->sock) {
        mprCloseSocket(sp->sock, 0);
        sp->sock = 0;
    }
    return 0;
}


/*
    function connect(address): Void
 */
static EjsObj *sock_connect(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsString       *address;

    address = (EjsString*) argv[0];
    if (ejsIs(ejs, address, Number)) {
        sp->address = sclone("127.0.0.1");
        sp->port = (int) ((EjsNumber*) address)->value;
    } else {
        if (!ejsIs(ejs, address, String)) {
            address = ejsToString(ejs, address);
        }
        sp->address = ejsToMulti(ejs, address);
        mprParseSocketAddress(sp->address, &sp->address, &sp->port, NULL, 0);
        if (sp->address == 0) {
            sp->address = sclone("127.0.0.1");
        }
        if (sp->port == 0) {
            ejsThrowArgError(ejs, "Address must have a port");
            return 0;
        }
    }
    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    if (mprConnectSocket(sp->sock, sp->address, sp->port, 0) < 0) {
        ejsThrowArgError(ejs, "Cannot open client socket");
        return 0;
    }
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketIOEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    ejsSendEvent(ejs, sp->emitter, "writable", NULL, sp);
    return 0;
}


/**
    function get isEof(): Boolean
 */
static EjsObj *sock_isEof(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return (sp->sock == 0 || mprIsSocketEof(sp->sock)) ? ESV(true) : ESV(false);
}


/**
    function listen(address): Void
    @param address Can be either a "ip", "ip:port" or port
 */
static EjsObj *sock_listen(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsString   *address;

    address = (EjsString*) argv[0];
    if (ejsIs(ejs, address, Number)) {
        sp->address = sclone("");
        sp->port = (int) ((EjsNumber*) address)->value;
    } else {
        if (!ejsIs(ejs, address, String)) {
            address = ejsToString(ejs, address);
        }
        sp->address = ejsToMulti(ejs, address);
        //  TODO - should listen to secure and permit https://IP:PORT
        mprParseSocketAddress(sp->address, &sp->address, &sp->port, NULL, 80);
    }
    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    if (mprListenOnSocket(sp->sock, sp->address, sp->port, 0) == SOCKET_ERROR) {
        ejsThrowArgError(ejs, "Cannot open listening socket");
        return 0;
    }
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketListenEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    return 0;
}


/*
    function off(name, observer: Function): Void
 */
static EjsObj *sock_off(Ejs *ejs, EjsSocket *sp, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, sp->emitter, argv[0], argv[1]);
    return 0;
}


/*
    function on(name: [String|Array], observer: Function): Socket
 */
PUBLIC EjsSocket *sock_on(Ejs *ejs, EjsSocket *sp, int argc, EjsAny **argv)
{
    ejsAddObserver(ejs, &sp->emitter, argv[0], argv[1]);
    return sp;
}


/*
    function get port(): Number
 */
static EjsNumber *sock_port(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, sp->port);
}


/*
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsNumber *sock_read(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsByteArray    *ba;
    ssize           nbytes, offset, count;

    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    ba = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]) : -1;

    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (count < 0) {
        count = ba->size - offset;
    }
    if (count <= 0) {
        return ESV(zero);
    }
    nbytes = mprReadSocket(sp->sock, &ba->value[offset], count);
    if (nbytes < 0) {
        /* If async, Caller must test "isEof" to determine if eof or error */
        return ESV(null);
    }
    ba->writePosition += nbytes;
    sp->mask |= MPR_READABLE;
    enableSocketEvents(sp, socketIOEvent);
    return ejsCreateNumber(ejs, (int) nbytes);
}


/*
    function get remoteAddress(): String
 */
static EjsString *sock_remoteAddress(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, sp->address);
}


static ssize writeSocketData(Ejs *ejs, EjsSocket *sp)
{
    EjsByteArray    *ba;
    ssize           nbytes, count;

    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    ba = sp->data;
    nbytes = 0;
    count = 0;
    if (ba && (count = ejsGetByteArrayAvailableData(ba)) > 0) {
        nbytes = mprWriteSocket(sp->sock, &ba->value[ba->readPosition], count);
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Cannot write to socket");
            return 0;
        }
        ba->readPosition += nbytes;
    }
    if (ejsGetByteArrayAvailableData(ba) == 0) {
        if (sp->emitter) {
            ejsSendEvent(ejs, sp->emitter, "writable", NULL, sp);
        }
        if (sp->async) {
            sp->mask &= ~MPR_WRITABLE;
        }
    } else if (sp->async) {
        if (nbytes < count) {
            sp->mask |= MPR_WRITABLE;
        } else {
            sp->mask &= ~MPR_WRITABLE;
        }
    }
    return nbytes;
}


/*
    function write(...data): Number
 */
static EjsNumber *sock_write(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    ssize     nbytes;

    if (sp->data) {
        /* Reset pointers if empty */
        ejsResetByteArray(ejs, sp->data);
    } else {
        sp->data = ejsCreateByteArray(ejs, -1);
    } 
    if (ejsWriteToByteArray(ejs, sp->data, 1, &argv[0]) < 0) {
        return 0;
    }
    if ((nbytes = writeSocketData(ejs, sp)) < 0) {
        return 0;
    }
    if (sp->async) {
        enableSocketEvents(sp, socketIOEvent);
    }
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}


/*********************************** Support **********************************/

static void enableSocketEvents(EjsSocket *sp, int (*proc)(EjsSocket *sp, MprEvent *event))
{
    Ejs     *ejs;

    ejs = sp->ejs;
    assert(sp->sock);
    
    if (sp->sock->handler == 0) {
        mprAddSocketHandler(sp->sock, sp->mask, ejs->dispatcher, (MprEventProc) proc, sp, 0);
    } else {
        mprEnableSocketEvents(sp->sock, sp->mask);
    }
}


static int socketListenEvent(EjsSocket *listen, MprEvent *event)
{
    Ejs     *ejs;

    ejs = listen->ejs;
    if (listen->emitter) {
        ejsSendEvent(ejs, listen->emitter, "accept", NULL, listen);
    }
    if (listen->sock) {
        enableSocketEvents(listen, socketListenEvent);
    }
    return 0;
}


static int socketIOEvent(EjsSocket *sp, MprEvent *event)
{
    Ejs     *ejs;

    ejs = sp->ejs;
    if (sp->sock) {
        if (event->mask & MPR_READABLE) {
            if (sp->emitter) {
                ejsSendEvent(ejs, sp->emitter, "readable", NULL, sp);
            }
            sp->mask |= MPR_READABLE;
        } 
        if (event->mask & MPR_WRITABLE) {
            writeSocketData(ejs, sp);
        }
        if (sp->sock) {
            enableSocketEvents(sp, socketIOEvent);
        }
    }
    return 0;
}


/*********************************** Factory **********************************/
/*  
   Manage the object properties for the garbage collector
 */
static void manageSocket(EjsSocket *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(sp->emitter);
        mprMark(sp->data);
        mprMark(sp->sock);
        mprMark(sp->address);
        mprMark(sp->mutex);
    }
}


PUBLIC EjsSocket *ejsCreateSocket(Ejs *ejs, MprSocket *sock, bool async)
{
    EjsSocket   *sp;

    sp = ejsCreateObj(ejs, ejsGetTypeByName(ejs, N(EJS_EJS_NAMESPACE, "Socket")), 0);
    sp->ejs = ejs;
    sp->sock = sock;
    sp->async = async;
    return sp;
}


PUBLIC void ejsConfigureSocketType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Socket"), sizeof(EjsSocket), manageSocket,
            EJS_TYPE_OBJ | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, sock_Socket);
    ejsBindMethod(ejs, prototype, ES_Socket_accept, sock_accept);
    ejsBindMethod(ejs, prototype, ES_Socket_address, sock_address);
    ejsBindAccess(ejs, prototype, ES_Socket_async, sock_async, sock_set_async);
    ejsBindMethod(ejs, prototype, ES_Socket_close, sock_close);
    ejsBindMethod(ejs, prototype, ES_Socket_connect, sock_connect);
    ejsBindMethod(ejs, prototype, ES_Socket_isEof, sock_isEof);
    ejsBindMethod(ejs, prototype, ES_Socket_listen, sock_listen);
    ejsBindMethod(ejs, prototype, ES_Socket_off, sock_off);
    ejsBindMethod(ejs, prototype, ES_Socket_on, sock_on);
    ejsBindMethod(ejs, prototype, ES_Socket_port, sock_port);
    ejsBindMethod(ejs, prototype, ES_Socket_read, sock_read);
    ejsBindMethod(ejs, prototype, ES_Socket_remoteAddress, sock_remoteAddress);
    ejsBindMethod(ejs, prototype, ES_Socket_write, sock_write);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsString.c"
 */
/************************************************************************/

/**
    ejsString.c - Ejscript string class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */
/********************************** Includes **********************************/


#include    "pcre.h"

/*********************************** Locals ***********************************/

//  TODO - should not be fixed
#if !defined(ME_MAX_REGEX_MATCHES)
    #define ME_MAX_REGEX_MATCHES 128
#endif

static int internHashSizes[] = {
     389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 0
};

/***************************** Forward Declarations ***************************/

static EjsString *buildString(Ejs *ejs, EjsString *result, wchar *str, ssize len);
static ssize indexof(wchar *str, ssize len, EjsString *pattern, ssize patternLength, int dir);
static void linkString(EjsString *head, EjsString *sp);
static void manageIntern(EjsIntern *intern, int flags);
static int rebuildIntern(EjsIntern *intern);
static void unlinkString(EjsString *sp);

/************************************* Code ***********************************/
/*
    Cast the string operand to a primitive type
 */
static EjsAny *castString(Ejs *ejs, EjsString *sp, EjsType *type)
{
    assert(sp);
    assert(type);

    switch (type->sid) {
    case S_Boolean:
        if (sp != ESV(empty)) {
            return ESV(true);
        }
        return ESV(false);

    case S_Number:
        return ejsParse(ejs, sp->value, S_Number);

    case S_Path:
        return ejsCreatePath(ejs, sp);

    case S_RegExp:
        return ejsParseRegExp(ejs, sp);

    case S_String:
        return sp;

    case S_Uri:
        return ejsCreateUri(ejs, sp);

    default:
        ejsThrowTypeError(ejs, "Cannot cast to required type");
        return 0;
    }
}


static EjsString *cloneString(Ejs *ejs, EjsString *sp, bool deep)
{
    /* Strings are immutable, interned and shared across all interps */
    return sp;
}


/*
    Get a string element. Slot numbers correspond to character indicies.
 */
static EjsString *getStringProperty(Ejs *ejs, EjsString *sp, int index)
{
    if (index < 0 || index >= sp->length) {
        return ESV(empty);
    }
    return ejsCreateString(ejs, &sp->value[index], 1);
}


static EjsAny *coerceStringOperands(Ejs *ejs, EjsAny *lhs, int opcode,  EjsAny *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToString(ejs, rhs));

    /*
        Overloaded operators
     */
    case EJS_OP_MUL:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToNumber(ejs, rhs));

    case EJS_OP_REM:
        return 0;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_OR:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        return ejsInvokeOperator(ejs, lhs, opcode, ejsToString(ejs, rhs));

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT:
        return ejsInvokeOperator(ejs, ejsToBoolean(ejs, lhs), opcode, rhs);

    case EJS_OP_NOT:
    case EJS_OP_NEG:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (((EjsString*) lhs) ? ESV(true) : ESV(false));

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (((EjsString*) lhs) ? ESV(false): ESV(true));

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return ESV(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


static EjsAny *invokeStringOperator(Ejs *ejs, EjsString *lhs, int opcode, EjsString *rhs, void *data)
{
    EjsAny  *result, *arg;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if (!ejsIs(ejs, lhs, String) || !ejsIs(ejs, rhs, String)) {
            if ((result = coerceStringOperands(ejs, lhs, opcode, rhs)) != 0) {
                return result;
            }
        }
    }
    /*
        Types now match, both strings
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        //  OPT -- should use lhs == rhs
        if (lhs->value == rhs->value) {
            assert(lhs == rhs);
            return ESV(true);
        }
        return ESV(false);

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        //  OPT -- should use lhs == rhs
        if (lhs->value != rhs->value) {
            assert(lhs != rhs);
            return ESV(true);
        }
        return ESV(false);

    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs, 
            mprMemcmp(lhs->value, lhs->length * sizeof(wchar), rhs->value, rhs->length * sizeof(wchar)) < 0);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs, 
            mprMemcmp(lhs->value, lhs->length * sizeof(wchar), rhs->value, rhs->length * sizeof(wchar)) <= 0);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, 
            mprMemcmp(lhs->value, lhs->length * sizeof(wchar), rhs->value, rhs->length * sizeof(wchar)) > 0);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, 
                mprMemcmp(lhs->value, lhs->length * sizeof(wchar), rhs->value, rhs->length * sizeof(wchar)) >= 0);

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs == 0) ? ESV(true): ESV(false));


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return ESV(false);

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsJoinString(ejs, lhs, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_OR:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);

#if EXTENSIONS || 1
    /*
        Overloaded
     */
    case EJS_OP_SUB:
        arg = rhs;
        return ejsRunFunctionBySlot(ejs, lhs, ES_String_MINUS, 1, &arg);

    case EJS_OP_REM:
        arg = rhs;
        return ejsRunFunctionBySlot(ejs, lhs, ES_String_MOD, 1, &arg);
#endif

    case EJS_OP_NEG:
    case EJS_OP_LOGICAL_NOT:
    case EJS_OP_NOT:
        /* Already handled in coerceStringOperands */
    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    assert(0);
}


/*
    Lookup an string index.
 */
static int lookupStringProperty(Ejs *ejs, EjsString *sp, EjsName qname)
{
    int     index;

    //  TODO UNICODE
    if (!isdigit((uchar) qname.name->value[0])) {
        return EJS_ERR;
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index < sp->length) {
        return index;
    }
    return EJS_ERR;
}


/************************************ Methods *********************************/
/*
    String constructor

        function String()
        function String(str: String)
 */
static EjsString *stringConstructor(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args;

    assert(argc == 0 || (argc == 1 && ejsIs(ejs, argv[0], Array)));
    sp->length = 0;

    if (argc == 1) {
        args = (EjsArray*) argv[0];
        if (args->length > 0) {
            return ejsToString(ejs, ejsGetProperty(ejs, args, 0));
        }
    }
    return ejsInternString(sp);
}


/*
    Do a case sensitive comparison between this string and another.

    function caseCompare(compare: String): Number
 */
static EjsNumber *caseCompare(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     result;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));

    result = wcmp(sp->value, ((EjsString*) argv[0])->value);
    return ejsCreateNumber(ejs, result);
}


/*
    Do a case insensitive comparison between this string and another.

    function caselessCompare(compare: String): Number
 */
static EjsNumber *caselessCompare(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     result;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));

    result = wcasecmp(sp->value, ((EjsString*) argv[0])->value);
    return ejsCreateNumber(ejs, result);
}


/*
    Return a string containing the character at a given index

    function charAt(index: Number): String
 */
static EjsString *charAt(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     index;

    assert(argc == 1 && ejsIs(ejs, argv[0], Number));
    index = ejsGetInt(ejs, argv[0]);
    if (index < 0 || index >= sp->length) {
        return ESV(empty);
    }
    return ejsCreateString(ejs, &sp->value[index], 1);
}


/*
    Return an integer containing the character at a given index

    function charCodeAt(index: Number = 0): Number
 */

static EjsNumber *charCodeAt(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     index;

    index = (argc == 1) ? ejsGetInt(ejs, argv[0]) : 0;
    if (index < 0) {
        index = (int) sp->length -1 ;
    }
    if (index < 0 || index >= sp->length) {
        return ESV(nan);
    }
    return ejsCreateNumber(ejs, (uchar) sp->value[index]);
}


/*
    Catenate args to a string and return a new string.

    function concat(...args): String
 */
static EjsString *concatString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsString   *result, *str;
    int         i;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));
    args = (EjsArray*) argv[0];

    result = (EjsString*) ejsClone(ejs, sp, 0);
    for (i = 0; i < args->length; i++) {
        str = ejsToString(ejs, ejsGetProperty(ejs, args, i));
        if ((result = ejsJoinString(ejs, result, str)) == NULL) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return result;
}


/**
    Check if a string contains the pattern (string or regexp)

    function contains(pattern: Object): Boolean
 */
static EjsBoolean *containsString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsObj      *pat;
    EjsString   *spat;

    pat = argv[0];

    if (ejsIs(ejs, pat, String)) {
        spat = (EjsString*) pat;
        return ejsCreateBoolean(ejs, wcontains(sp->value, spat->value) != 0);

    } else if (ejsIs(ejs, pat, RegExp)) {
        EjsRegExp   *rp;
        int         count;
        rp = (EjsRegExp*) argv[0];
        count = pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, 0, 0, 0, 0);
        return ejsCreateBoolean(ejs, count >= 0);
    }
    ejsThrowTypeError(ejs, "Wrong argument type");
    return 0;
}


/**
    Check if a string ends with a given pattern

    function endsWith(pattern: String): Boolean
 */
static EjsBoolean *endsWith(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *pattern;
    ssize       len;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));

    pattern = (EjsString*) argv[0];
    len = pattern->length;
    if (len > sp->length) {
        return ESV(false);
    }
    return ejsCreateBoolean(ejs, wncmp(&sp->value[sp->length - len], pattern->value, len) == 0);
}


/*
    Lookup a token value. This will be called recursively for each name portion of a token. i.e. ${part.part.part}
 */
static int getTokenValue(Ejs *ejs, EjsObj *obj, cchar *fullToken, cchar *token, MprBuf *buf, cchar *fill, EjsString *join)
{
    EjsAny      *vp;
    EjsString   *svalue;
    char        *rest, *first;

    rest = (char*) (schr(token, '.') ? sclone(token) : token);
    first = stok(rest, ".", &rest);
    
    if ((vp = ejsGetPropertyByName(ejs, obj, EN(first))) != 0) {
        if (rest && ejsIsPot(ejs, vp)) {
            return getTokenValue(ejs, vp, fullToken, rest, buf, fill, join);
        } else {
            if (ejsIs(ejs, vp, Array)) {
                svalue = ejsJoinArray(ejs, vp, join); 
            } else {
                svalue = ejsToString(ejs, vp);
            }
            mprPutStringToBuf(buf, svalue->value);
        }
    } else {
        if (fill) {
            if (smatch(fill, "${}")) {
                mprPutStringToBuf(buf, "${");
                mprPutStringToBuf(buf, fullToken);
                mprPutCharToBuf(buf, '}');
            } else if (*fill) {
                mprPutStringToBuf(buf, fill);
            }
        } else {
            ejsThrowReferenceError(ejs, "Missing property %s", fullToken);
            return 0;
        }
    }
    return 1;
}


/*
    function expand(obj: Object, options: Object): String

    Options:
        fill: String to use for missing properties. Set to null to throw.

    Expand ${token} references. Tokens are be simple properties that may include "." references.
 */
static EjsString *expandString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    MprBuf      *buf;
    EjsAny      *obj, *options, *vp;
    EjsString   *join;
    char        *src, *cp, *tok, *fill;

    fill = 0;
    join = ejsCreateStringFromAsc(ejs, " ");
    if (argc < 1) {
        ejsThrowArgError(ejs, "Missing object argument");
        return 0;
    }
    obj = argv[0];
    options = (argc >= 2) ? argv[1] : 0;
    if (options) {
        if ((vp = ejsGetPropertyByName(ejs, options, EN("fill"))) != 0) {
            if (vp != ESV(null) && vp != ESV(undefined)) {
                fill = ejsToMulti(ejs, vp);
            }
        }
        if ((vp = ejsGetPropertyByName(ejs, options, EN("join"))) != 0) {
            if (vp != ESV(null) && vp != ESV(undefined)) {
                join = ejsToString(ejs, vp);
            }
        }
    }
    if (sp->length == 0) {
        return ESV(empty);
    }
    //  UNICODE
    if (schr(sp->value, '$') == 0) {
        return sp;
    }
    buf = mprCreateBuf(0, 0);
    for (src = (char*) sp->value; src < &sp->value[sp->length]; ) {
        if (*src == '$' && src[1] == '{') {
            if (src > sp->value && src[-1] == '$') {
                for (++src; *src != '}' && src < &sp->value[sp->length]; ) {
                    mprPutCharToBuf(buf, *src++);
                }
            } else {
                src += 2;
                for (cp = src; *cp != '}' && cp < &sp->value[sp->length]; cp++) ;
                tok = snclone(src, cp - src);
                if (!getTokenValue(ejs, obj, tok, tok, buf, fill, join)) {
                    return 0;
                }
                src = cp + 1;
            }
        } else {
            mprPutCharToBuf(buf, *src++);
        }
    }
    mprAddNullToBuf(buf);
    return ejsCreateString(ejs, mprGetBufStart(buf), mprGetBufLength(buf));
}


/**
    Format the arguments

    function format(...args): String

    Format:         %[modifier][width][precision][type]
    Modifiers:      +- #,
 */
static EjsString *formatString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args, *inner;
    EjsString   *result;
    EjsAny      *value;
    wchar       *buf, fmt[32];
    ssize       i, flen, start, len, last;
    int         c, nextArg, kind;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));

    args = (EjsArray*) argv[0];

    /*
        Flatten the args if there is only one element and it is itself an array. This happens when invoked
        via the overloaded operator '%' which in turn invokes format()
     */
    if (args->length == 1) {
        inner = ejsGetProperty(ejs, args, 0);
        if (ejsIs(ejs, inner, Array)) {
            args = inner;
        }
    }
    if ((result = ejsCreateBareString(ejs, ME_MAX_BUFFER)) == NULL) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    result->length = 0;

    /*
        Parse the format string and extract one specifier at a time.
     */
    last = 0;
    for (i = 0, nextArg = 0; i < sp->length; i++) {
        c = sp->value[i];
        if (c != '%') {
            continue;
        }
        if (i > last) {
            result = buildString(ejs, result, &sp->value[last], i - last);
        }
        /*
            Find the end of the format specifier and determine the format type (kind)
         */
        start = i++;
        i += mspn(&sp->value[i], "-+ #,0*123456789.");
        kind = sp->value[i];

        if (strchr("cdefginopsSuxX", kind)) {
            len = i - start + 1;
            wncopy(fmt, (sizeof(fmt) / sizeof(wchar)) - 4, &sp->value[start], len);

            if (nextArg < args->length) {
                value = ejsGetProperty(ejs, args, nextArg);
            } else {
                value = ESV(null);
            }
            buf = 0;
            //  OPT
            switch (kind) {
            case 'o':
                value = ejsToNumber(ejs, value);
                flen = sizeof(fmt) - len + 1;
                mtow(&fmt[len - 1], flen, "Lo", 2);
                buf = wfmt(fmt, (int64) ejsGetNumber(ejs, value));
                break;
            case 'd': case 'i': case 'u':
                value = ejsToNumber(ejs, value);
                flen = sizeof(fmt) - len + 1;
                mtow(&fmt[len - 1], flen, ".0f", 3);
                buf = wfmt(fmt, ejsGetNumber(ejs, value));
                break;

            case 'e': case 'g': case 'f':
                value = ejsToNumber(ejs, value);
                buf = wfmt(fmt, ejsGetNumber(ejs, value));
                break;

            case 's':
                value = ejsToString(ejs, value);
                buf = wfmt(fmt, ejsToMulti(ejs, value));
                break;

            case 'X': case 'x':
                buf = wfmt(fmt, (int64) ejsGetNumber(ejs, value));
                break;

            case 'n':
                buf = wfmt(fmt, 0);
                break;
                    
            case 'c':
                buf = wfmt(fmt, (int) ejsGetNumber(ejs, value));
                break;

            default:
                ejsThrowArgError(ejs, "Bad format specifier");
                return 0;
            }
            result = buildString(ejs, result, buf, wlen(buf));
            last = i + 1;
            nextArg++;

        } else if (kind == '%') {
            wchar percent[1];
            percent[0] = '%';
            result = buildString(ejs, result, percent, 1);
            last = i + 1;
        }
    }
    if (sp->length > last) {
        result = buildString(ejs, result, &sp->value[last], sp->length - last);
    }
    return ejsInternString(result);
}


/*
    Create a string from character codes

    static function fromCharCode(...codes): String
 */
static EjsString *fromCharCode(Ejs *ejs, EjsString *unused, int argc, EjsObj **argv)
{
    EjsString   *result;
    EjsArray    *args;
    EjsObj      *vp;
    int         i;

    assert(argc == 1 && ejsIs(ejs, argv[0], Array));
    args = (EjsArray*) argv[0];

    if ((result = (EjsString*) ejsCreateBareString(ejs, argc + 1)) == NULL) {
        return 0;
    }
    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, args, i);
        result->value[i] = ejsGetInt(ejs, ejsToNumber(ejs, vp));
    }
    result->value[i] = '\0';
    result->length = args->length;
    return ejsInternString(result);
}


/*
    Function to iterate and return the next character code.
    NOTE: this is not a method of String. Rather, it is a callback function for Iterator
 */
static EjsNumber *nextStringKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsString   *sp;

    sp = (EjsString*) ip->target;

    if (!ejsIs(ejs, sp, String)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < sp->length) {
        return ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator function get(): Iterator
 */
static EjsIterator *getStringIterator(Ejs *ejs, EjsObj *sp, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, sp, -1, nextStringKey, 0, NULL);
}


/*
    Function to iterate and return the next string character (as a string).
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsString *nextStringValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsString   *sp;

    sp = (EjsString*) ip->target;
    if (!ejsIs(ejs, sp, String)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < sp->length) {
        return ejsCreateString(ejs, &sp->value[ip->index++], 1);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator function getValues(): Iterator
 */
static EjsIterator *getStringValues(Ejs *ejs, EjsObj *sp, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, sp, -1, nextStringValue, 0, NULL);
}


/*
    Get the length of a string.
    @return Returns the number of characters in the string

    override function get length(): Number
 */

static EjsNumber *stringLength(Ejs *ejs, EjsString *ap, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ap->length);
}


/*
    Return the position of the first occurance of a substring

    function indexOf(pattern: String, startIndex: Number = 0): Number
 */
static EjsNumber *indexOf(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;
    ssize       start, index, patternLength;

    assert(1 <= argc && argc <= 2);
    assert(ejsIs(ejs, argv[0], String));

    pattern = (EjsString*) argv[0];
    patternLength = (int) pattern->length;

    if (argc == 2) {
        start = ejsGetInt(ejs, argv[1]);
        if (start > sp->length) {
            start = sp->length;
        }
        if (start < 0) {
            start = 0;
        }
    } else {
        start = 0;
    }
    index = indexof(&sp->value[start], sp->length - start, pattern, patternLength, 1);
    if (index < 0) {
        return ESV(minusOne);
    }
    return ejsCreateNumber(ejs, (MprNumber) (index + start));
}


static EjsBoolean *isAlpha(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    wchar       *cp;

    if (sp->length == 0) {
        return ESV(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isalpha((uchar) *cp)) {
            return ESV(false);
        }
    }
    return ESV(true);
}


static EjsBoolean *isAlphaNum(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    wchar       *cp;

    if (sp->length == 0) {
        return ESV(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isalnum((uchar) *cp)) {
            return ESV(false);
        }
    }
    return ESV(true);
}


static EjsBoolean *isDigit(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    wchar       *cp;

    if (sp->length == 0) {
        return ESV(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isdigit((uchar) *cp)) {
            return ESV(false);
        }
    }
    return ESV(true);
}


static EjsBoolean *isLower(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    wchar       *cp;

    if (sp->length == 0) {
        return ESV(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!islower((int) *cp)) {
            return ESV(false);
        }
    }
    return ESV(true);
}


static EjsBoolean *isSpace(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    wchar       *cp;

    if (sp->length == 0) {
        return ESV(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (*cp & 0x80 || !isspace((uchar) *cp)) {
            return ESV(false);
        }
    }
    return ESV(true);
}


static EjsBoolean *isUpper(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    wchar       *cp;

    if (sp->length == 0) {
        return ESV(false);
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!isupper((int) *cp)) {
            return ESV(false);
        }
    }
    return ESV(true);
}


/*
    Return the position of the last occurance of a substring

    function lastIndexOf(pattern: String, start: Number = -1): Number
 */
static EjsNumber *lastIndexOf(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;
    ssize       start, patternLength, index;

    assert(1 <= argc && argc <= 2);

    pattern = (EjsString*) argv[0];
    patternLength = (int) pattern->length;

    if (argc == 2) {
        start = ejsGetInt(ejs, argv[1]);
        if (start >= (int) sp->length) {
            start = (int) sp->length - 1;
        }
        if (start < 0) {
            start = 0;
        }
    } else {
        start = 0;
    }
    index = indexof(sp->value, sp->length, pattern, patternLength, -1);
    if (index < 0) {
        return ESV(minusOne);
    }
    return ejsCreateNumber(ejs, (MprNumber) index);
}


/*
    Match a pattern

    function match(pattern: RegExp): Array
 */
static EjsArray *match(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsRegExp   *rp;
    EjsArray    *results;
    EjsString   *match;
    int         matches[ME_MAX_REGEX_MATCHES * 3];
    int         i, count, len, resultCount;

    rp = (EjsRegExp*) argv[0];
    rp->endLastMatch = 0;
    results = NULL;
    resultCount = 0;

    do {
        count = pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, rp->endLastMatch, 0, matches, 
            sizeof(matches) / sizeof(int));
        if (count <= 0) {
            break;
        }
        if (results == 0) {
            results = ejsCreateArray(ejs, count);
        }
        for (i = 0; i < count * 2; i += 2) {
            len = matches[i + 1] - matches[i];
            match = ejsCreateString(ejs, &sp->value[matches[i]], len);
            ejsSetProperty(ejs, results, resultCount++, match);
            if (rp->global) {
                if (matches[1] == rp->endLastMatch) {
                    rp->endLastMatch++;
                } else {
                    rp->endLastMatch = matches[1];
                }
                break;
            }
        }
    } while (rp->global);
    if (results == NULL) {
        return ESV(null);
    }
    return results;
}


static EjsString *printable(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    wchar           buf[16];
    ssize           len;
    int             i, j, k, nonprint;

    nonprint = 0;
    for (i = 0; i < sp->length; i++)  {
        if (!isprint((uchar) sp->value[i])) {
            nonprint++;
        }
    }
    if (nonprint == 0) {
        return sp;
    }
    if ((result = ejsCreateBareString(ejs, sp->length + (nonprint * 6) + 1)) == NULL) {
        return 0;
    }
    for (i = 0, j = 0; i < sp->length; i++)  {
        if (isprint((uchar) sp->value[i])) {
            result->value[j++] = sp->value[i];
        } else {
            result->value[j++] = '\\';
            result->value[j++] = 'u';
            itosbuf(buf, 4, (uchar) sp->value[i], 16);
            len = wlen(buf);
            for (k = (int) len; k < 4; k++) {
                result->value[j++] = '0';
            }
            for (k = 0; buf[k]; k++) {
                result->value[j++] = buf[k];
            }
        }
    }
    result->value[j] = '\0';
    result->length = j;
    return ejsInternString(result);
}


static EjsString *quote(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;

    if ((result = ejsCreateBareString(ejs, sp->length + 2)) == NULL) {
        return 0;
    }
    memcpy(&result->value[1], sp->value, sp->length);
    result->value[0] = '"';
    result->value[sp->length + 1] = '"';
    result->value[sp->length + 2] = '\0';
    result->length = sp->length + 2;
    return ejsInternString(result);
}


/*
    Remove characters and return a new string.

    function remove(start: Number, end: Number = -1): String

 */
static EjsString *removeCharsFromString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    ssize           start, end, i, j;

    assert(1 <= argc && argc <= 2);

    start = ejsGetInt(ejs, argv[0]);
    end = ejsGetInt(ejs, argv[1]);

    if (start < 0) {
        start += sp->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end += sp->length;
    }
    if (end < 0) {
        end = 0;
    }
    if (start >= sp->length) {
        start = sp->length - 1;
    }
    if (end > sp->length) {
        end = sp->length;
    }
    if ((result = ejsCreateBareString(ejs, sp->length - (end - start))) == NULL) {
        return 0;
    }
    for (j = i = 0; i < start; i++, j++) {
        result->value[j] = sp->value[i];
    }
    for (i = end; i < sp->length; i++, j++) {
        result->value[j] = sp->value[i];
    }
    result->value[j] = '\0';
    return ejsInternString(result);
}


static EjsString *getReplacementText(Ejs *ejs, EjsFunction *fn, int count, int *matches, EjsString *sp)
{
    EjsAny  *result, *argv[ME_MAX_REGEX_MATCHES * 3];
    int     i, offset, argc;

    assert(fn);
    
    argc = 0;
    argv[argc++] = ejsCreateString(ejs, &sp->value[matches[0]], matches[1] - matches[0]);
    for (i = 1; i < count; i++) {
        offset = i * 2;
        argv[argc++] = ejsCreateString(ejs, &sp->value[matches[offset]], matches[offset + 1] - matches[offset]);
    }
    argv[argc++] = ejsCreateNumber(ejs, matches[0]);
    argv[argc++] = sp;
    if ((result = ejsRunFunction(ejs, fn, ejs->global, argc, argv)) == 0) {
        return 0;
    }
    return (EjsString*) ejsToString(ejs, result);
}


/*
    Search and replace

    function replace(pattern: (String|Regexp), replacement: (String|Function)): String
 */
static EjsString *replace(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result, *replacement, *pattern;
    EjsFunction *replacementFunction;
    wchar       cbuf[1];
    ssize       patternLength, index;
    int         matches[ME_MAX_REGEX_MATCHES * 3], enabled;

    result = 0;
    if (argc == 1) {
        replacement = ESV(empty);
        replacementFunction = 0;
    } else if (ejsIsFunction(ejs, argv[1])) {
        replacementFunction = (EjsFunction*) argv[1];
        replacement = 0;
    } else {
        replacement = (EjsString*) ejsToString(ejs, argv[1]);
        replacementFunction = 0;
    }
    if (ejsIs(ejs, argv[0], RegExp)) {
        EjsRegExp   *rp;
        wchar       *cp, *lastReplace, *end;
        ssize       endLastMatch, startNextMatch, submatch;
        int         count;

        rp = (EjsRegExp*) argv[0];

        result = ejsCreateBareString(ejs, ME_MAX_BUFFER);
        result->length = 0;
        startNextMatch = endLastMatch = 0;
        do {
            if (startNextMatch > sp->length) {
                break;
            }
            count = pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, (int) startNextMatch, 0, matches,
                    sizeof(matches) / sizeof(int));
            if (count <= 0) {
                break;
            }
            if (endLastMatch < matches[0]) {
                /* Append prior string text */
                result = buildString(ejs, result, &sp->value[endLastMatch], matches[0] - endLastMatch);
            }
            /*
                Process the replacement template
             */
            if (replacementFunction) {
                enabled = mprEnableGC(0);
                replacement = getReplacementText(ejs, replacementFunction, count, matches, sp);
                mprEnableGC(enabled);
            }
            end = &replacement->value[replacement->length];
            lastReplace = replacement->value;

            for (cp = replacement->value; cp < end; ) {
                if (*cp == '$') {
                    if (lastReplace < cp) {
                        result = buildString(ejs, result, lastReplace, (int) (cp - lastReplace));
                    }
                    switch (*++cp) {
                    case '$':
                        cbuf[0] = '$';
                        result = buildString(ejs, result, cbuf, 1);
                        break;
                    case '&':
                        /* Replace the matched string */
                        result = buildString(ejs, result, &sp->value[matches[0]], matches[1] - matches[0]);
                        break;
                    case '`':
                        /* Insert the portion that preceeds the matched string */
                        result = buildString(ejs, result, sp->value, matches[0]);
                        break;
                    case '\'':
                        /* Insert the portion that follows the matched string */
                        result = buildString(ejs, result, &sp->value[matches[1]], sp->length - matches[1]);
                        break;
                    default:
                        /* Insert the nth submatch */
                        if (isdigit((uchar) *cp)) {
                            submatch = (int) wtoi(cp);
                            while (isdigit((uchar) *++cp))
                                ;
                            cp--;
                            if (submatch < count) {
                                submatch *= 2;
                                result = buildString(ejs, result, 
                                    &sp->value[matches[submatch]], matches[submatch + 1] - matches[submatch]);
                            }
                        } else {
                            ejsThrowArgError(ejs, "Bad replacement $ specification");
                            return 0;
                        }
                    }
                    lastReplace = cp + 1;
                }
                cp++;
            }
            if (lastReplace < cp && lastReplace < end) {
                result = buildString(ejs, result, lastReplace, (int) (cp - lastReplace));
            }
            endLastMatch = matches[1];
            if (startNextMatch == endLastMatch) {
                if (rp->multiline) {
                    if ((cp = strchr(&sp->value[endLastMatch], '\n')) != 0) {
                        startNextMatch = (int) (cp - sp->value + 1);
                    } else {
                        break;
                    }
                } else {
                    startNextMatch++;
                }
            } else {
                startNextMatch = endLastMatch;
            }
        } while (rp->global);

        if (endLastMatch < sp->length) {
            /* Append remaining string text */
            result = buildString(ejs, result, &sp->value[endLastMatch], sp->length - endLastMatch);
        }
    } else {
        pattern = ejsToString(ejs, argv[0]);
        patternLength = pattern->length;
        index = indexof(sp->value, sp->length, pattern, patternLength, 1);
        if (index >= 0) {
            if ((result = ejsCreateBareString(ejs, ME_MAX_BUFFER)) == NULL) {
                return 0;
            }
            result->length = 0;
            result = buildString(ejs, result, sp->value, index);
            if (replacementFunction) {
                matches[0] = matches[2] = (int) index;
                matches[1] = matches[3] = (int) (index + patternLength);
                enabled = mprEnableGC(0);
                replacement = getReplacementText(ejs, replacementFunction, 2, matches, sp);
                mprEnableGC(enabled);
            }
            result = buildString(ejs, result, replacement->value, replacement->length);
            index += patternLength;
            if (index < sp->length) {
                result = buildString(ejs, result, &sp->value[index], sp->length - index);
            }
        } else {
            result = ejsClone(ejs, sp, 0);
        }
    }
    return ejsInternString(result);
}


static EjsString *reverseString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *rp;
    wchar       *cp;
    ssize       i;

    if (sp->length <= 1) {
        return sp;
    }
    if ((rp = ejsCreateBareString(ejs, sp->length)) == 0) {
        return 0;
    }
    cp = rp->value;
    for (i = sp->length - 1; i >= 0; i--) {
        *cp++ = sp->value[i];
    }
    return ejsInternString(rp);
}


/*
    Search for a pattern
    function search(pattern: (String | RegExp)): Number
 */
static EjsNumber *searchString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsRegExp   *rp;
    EjsString   *pattern;
    ssize       index, patternLength;
    int         count, matches[ME_MAX_REGEX_MATCHES * 3];

    if (ejsIs(ejs, argv[0], String)) {
        pattern = (EjsString*) argv[0];
        patternLength = (int) pattern->length;
        index = indexof(sp->value, sp->length, pattern, patternLength, 1);
        return ejsCreateNumber(ejs, (MprNumber) index);

    } else if (ejsIs(ejs, argv[0], RegExp)) {
        rp = (EjsRegExp*) argv[0];
        count = pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, 0, 0, matches, sizeof(matches) / sizeof(int));
        if (count < 0) {
            return ESV(minusOne);
        }
        return ejsCreateNumber(ejs, matches[0]);

    } else {
        ejsThrowTypeError(ejs, "Wrong argument type");
    }
    return 0;
}


/*
    Return a substring. End is one past the last character.

    function slice(start: Number, end: Number = -1, step: Number = 1): String
 */
static EjsString *sliceString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    ssize           start, end, step, i, j, size;

    assert(1 <= argc && argc <= 3);

    start = ejsGetInt(ejs, argv[0]);
    if (argc >= 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = sp->length;
    }
    if (argc == 3) {
        step = ejsGetInt(ejs, argv[2]);
    } else {
        step = 1;
    }
    if (start < 0) {
        start += sp->length;
    }
    if (start < 0) {
        start = 0;
    } else if (start >= sp->length) {
        start = sp->length;
    }
    if (end < 0) {
        end += sp->length;
    }
    if (end < 0) {
        end = 0;
    } if (end >= sp->length) {
        end = sp->length;
    }
    if (step == 0) {
        step = 1;
    }
    size = (start < end) ? end - start : start - end;
    if ((result = ejsCreateBareString(ejs, ((size / (ssize) abs(((int) step))) + 1))) == NULL) {
        return 0;
    }
    if (step > 0) {
        for (i = start, j = 0; i < end; i += step) {
            result->value[j++] = sp->value[i];
        }
    } else {
        for (i = start, j = 0; i > end; i += step) {
            result->value[j++] = sp->value[i];
        }
    }
    result->value[j] = '\0';
    result->length = j;
    return ejsInternString(result);
}


/*
    Split a string

    function split(delimiter: (String | RegExp), limit: Number = -1): Array
 */
static EjsArray *split(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *results;
    EjsString   *elt, *delim;
    wchar       *cp, *mark, *end;
    ssize      limit;

    assert(1 <= argc && argc <= 2);

    limit = (argc == 2) ? ejsGetInt(ejs, argv[1]): MAXSSIZE;
    results = ejsCreateArray(ejs, 0);

    if (ejsIs(ejs, argv[0], String)) {
        delim = (EjsString*) argv[0];
        if (delim->length == 0) {
            for (cp = sp->value; (--limit != -1) && *cp; cp++) {
                ejsSetProperty(ejs, results, -1, ejsCreateString(ejs, cp, 1));
            }
        } else {
            end = &sp->value[sp->length];
            for (mark = cp = sp->value; limit > 0 && mark < end; mark++, limit--) {
                if (wncmp(mark, delim->value, delim->length) == 0) {
                    elt = ejsCreateString(ejs, cp, (int) (mark - cp));
                    ejsSetProperty(ejs, results, -1, elt);
                    cp = mark + delim->length;
                    mark = cp - 1;
                }
            }
            elt = ejsCreateString(ejs, cp, (int) (mark - cp));
            ejsSetProperty(ejs, results, -1, elt);
        }
        return results;

    } else if (ejsIs(ejs, argv[0], RegExp)) {
        EjsRegExp   *rp;
        EjsString   *match;
        int         matches[ME_MAX_REGEX_MATCHES * 3], count, resultCount;
        
        rp = (EjsRegExp*) argv[0];
        rp->endLastMatch = 0;
        resultCount = 0;
        while (1) {
            count = (int) pcre_exec(rp->compiled, NULL, sp->value, (int) sp->length, rp->endLastMatch, 0, matches, 
                sizeof(matches) / sizeof(int));
            if (count <= 0) {
                break;
            }
            match = ejsCreateString(ejs, &sp->value[rp->endLastMatch], matches[0] - rp->endLastMatch);
            ejsSetProperty(ejs, results, resultCount++, match);
            if (matches[1] == rp->endLastMatch) {
                /* Catch patterns that match the empty string - prevents infinite loop */
                rp->endLastMatch = matches[1] + 1;
            } else {
                rp->endLastMatch = matches[1];
            }
        }
        if (rp->endLastMatch < sp->length) {
            match = ejsCreateString(ejs, &sp->value[rp->endLastMatch], sp->length - rp->endLastMatch);
            ejsSetProperty(ejs, results, resultCount, match);
        } else {
            ejsSetProperty(ejs, results, resultCount, ESV(empty));
        }
        return results;
    }

    ejsThrowTypeError(ejs, "Wrong argument type");
    return 0;
}


/**
    Check if a string starts with a given pattern

    function startsWith(pattern: String): Boolean
 */
static EjsBoolean *startsWith(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *pattern;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));

    pattern = (EjsString*) argv[0];
    return ejsCreateBoolean(ejs, wncmp(&sp->value[0], pattern->value, pattern->length) == 0);
}


/*
    Extract a substring. Simple routine with positive indicies.

    function substring(start: Number, end: Number = -1): String
 */
static EjsString *substring(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    ssize   start, end, tmp;

    start = ejsGetInt(ejs, argv[0]);
    if (argc == 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = sp->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (start >= sp->length) {
        start = sp->length - 1;
    }
    if (end < 0) {
        end = sp->length;
    }
    if (end > sp->length) {
        end = sp->length;
    }
    /*
        Swap if start is bigger than end
     */
    if (start > end) {
        tmp = start;
        start = end;
        end = tmp;
    }
    return ejsSubstring(ejs, sp, start, (int) (end - start));
}


/*
    Convert the string to camelCase. Return a new string.

    function toCamel(): String
 */
static EjsString *toCamel(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result;

    if ((result = ejsCreateBareString(ejs, sp->length)) == 0) {
        return 0;
    }
    memcpy(result->value, sp->value, sp->length * sizeof(wchar));
    result->value[0] = tolower((uchar) sp->value[0]);
    return ejsInternString(result);
}


/*
    Convert a string to a literal string representation. Wrap in quotes and backquote any quotes or backquotes.
 */
PUBLIC EjsString *ejsToLiteralString(Ejs *ejs, EjsObj *vp)
{
    EjsString   *sp;
    MprBuf      *buf;
    int         i, c;

    if (ejsIs(ejs, vp, String)) {
        sp = (EjsString*) vp;
    } else {
        sp = ejsToString(ejs, vp);
    }
    buf = mprCreateBuf(0, 0);
    mprPutCharToBuf(buf, '"');
    for (i = 0; i < sp->length; i++) {
        c = sp->value[i];
        if (c == '"' || c == '\\') {
            mprPutCharToBuf(buf, '\\');
            mprPutCharToBuf(buf, c);
        } else {
            mprPutCharToBuf(buf, c);
        }
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    Convert the string to lower case.

    function toLowerCase(locale: String = null): String
 */
static EjsString *toLowerCase(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    return ejsToLower(ejs, sp);
}


/*
    Convert the string to PascalCase. Return a new string.

    function toPascal(): String
 */
static EjsString *toPascal(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result;

    if ((result = ejsCreateBareString(ejs, sp->length)) == 0) {
        return 0;
    }
    memcpy(result->value, sp->value, sp->length * sizeof(wchar));
    result->value[0] = toupper((uchar) sp->value[0]);
    return ejsInternString(result);
}


/*
    Convert to a string

    override function toString(): String
 */
static EjsString *stringToString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    return sp;
}


/*
    Convert the string to upper case.
    @return Returns a new upper case version of the string.
    @spec ejs-11

    function toUpperCase(locale: String = null): String
 */
static EjsString *toUpperCase(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    return ejsToUpper(ejs, sp);
}


/*
    Scan the input and tokenize according to the format string

    function tokenize(format: String): Array
 */
static EjsArray *tokenize(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *result;
    wchar       *cp, *buf;
    cchar       *fmt;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));

    buf = sp->value;
    fmt = ejsToMulti(ejs, argv[0]);
    result = ejsCreateArray(ejs, 0);

    for (fmt = ejsToMulti(ejs, argv[0]); *fmt && buf < &sp->value[sp->length]; ) {
        if (*fmt++ != '%') {
            continue;
        }
        switch (*fmt) {
        case 's':
            for (cp = buf; *cp; cp++) {
                if (isspace((uchar) *cp)) {
                    break;
                }
            }
            ejsSetProperty(ejs, result, -1, ejsSubstring(ejs, sp, (int) (buf - sp->value), (int) (cp - buf)));
            buf = cp;
            break;

        case 'd':
            ejsSetProperty(ejs, result, -1, ejsParse(ejs, buf, S_Number));
            while (*buf && !isspace((uchar) *buf)) {
                buf++;
            }
            break;

        default:
            ejsThrowArgError(ejs, "Bad format specifier");
            return 0;
        }
        while (*buf && isspace((uchar) *buf)) {
            buf++;
        }
    }
    return result;
}


static EjsString *trim(Ejs *ejs, EjsString *sp, EjsString *pattern, int where)
{
    wchar       *start, *end, *mark;
    ssize       index, patternLength;

    if (pattern == 0) {
        start = sp->value;
        if (where & MPR_TRIM_START) {
            for (; start < &sp->value[sp->length]; start++) {
                if (!isspace((uchar) *start)) {
                    break;
                }
            }
        }
        end = &sp->value[sp->length - 1];
        if (where & MPR_TRIM_END) {
            for (end = &sp->value[sp->length - 1]; end >= start; end--) {
                if (!isspace((uchar) *end)) {
                    break;
                }
            }
        }
        end++;
    } else {
        patternLength = pattern->length;
        if (patternLength <= 0 || patternLength > sp->length) {
            return sp;
        }
        mark = sp->value;
        if (where & MPR_TRIM_START) {
            for (; &mark[patternLength] <= &sp->value[sp->length]; mark += patternLength) {
                index = indexof(mark, patternLength, pattern, patternLength, 1);
                if (index != 0) {
                    break;
                }
            }
        }
        start = mark;

        mark = &sp->value[sp->length - patternLength];
        if (where & MPR_TRIM_END) {
            for (; mark >= sp->value; mark -= patternLength) {
                index = indexof(mark, patternLength, pattern, patternLength, 1);
                if (index != 0) {
                    break;
                }
            }
        }
        end = mark + patternLength;
    }
    return ejsSubstring(ejs, sp, (int) (start - sp->value), (int) (end - start));
}


/**
    Returns a trimmed copy of the string. Normally used to trim white space, but can be used to trim any substring
    from the start or end of the string.
    @param str May be set to a substring to trim from the string. If not set, it defaults to any white space.
    @return Returns a (possibly) modified copy of the string

    function trim(str: String = null): String
 */
static EjsString *trimString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;

    if (argc == 0) {
        return trim(ejs, sp, NULL, MPR_TRIM_START | MPR_TRIM_END);

    } else {
        pattern = (EjsString*) ejsToString(ejs, argv[0]);
        return trim(ejs, sp, pattern, MPR_TRIM_START | MPR_TRIM_END);
    }
}


/*  
    function trimStart(str: String = null): String
 */
static EjsString *trimStartString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;

    assert(argc == 0 || (argc == 1 && ejsIs(ejs, argv[0], String)));

    if (argc == 0) {
        return trim(ejs, sp, NULL, MPR_TRIM_START);

    } else {
        pattern = (EjsString*) argv[0];
        return trim(ejs, sp, pattern, MPR_TRIM_START);
    }
}


/*  
    function trimEnd(str: String = null): String
 */
static EjsString *trimEndString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString   *pattern;

    assert(argc == 0 || (argc == 1 && ejsIs(ejs, argv[0], String)));

    if (argc == 0) {
        return trim(ejs, sp, NULL, MPR_TRIM_END);

    } else {
        pattern = (EjsString*) argv[0];
        return trim(ejs, sp, pattern, MPR_TRIM_END);
    }
}

/*********************************** Support **********************************/
#if UNUSED
/**
    Fast append a string. This modifies the original "dest" string. BEWARE: strings are meant to be immutable.
    Only use this when constructing strings.
 */
static int catString(Ejs *ejs, EjsString *dest, char *str, ssize len)
{
    EjsString   *castSrc;
    char        *oldBuf, *buf;
    int         oldLen, newLen;

    assert(dest);

    castSrc = 0;

    oldBuf = dest->value;
    oldLen = dest->length;
    newLen = oldLen + len + 1;

#if FUTURE
    if (newLen < MPR_SLAB_STR_MAX) {
        buf = oldBuf;
    } else {
#endif
        buf = (char*) mprRealloc(oldBuf, newLen);
        if (buf == 0) {
            return -1;
        }
        dest->value = buf;
#if FUTURE
    }
#endif
    memcpy(&buf[oldLen], str, len);
    dest->length += len;
    buf[dest->length] = '\0';

    return 0;
}
#endif


/*
    Append the given string to the result
 */
static EjsString *buildString(Ejs *ejs, EjsString *result, wchar *str, ssize len)
{
    EjsString   *newBuf;
    ssize       room, size, extra;

    assert(result);

    room = mprGetBlockSize(result) - sizeof(EjsString);
    if ((result->length + len + 1) >= room) {
        extra = max(result->length / 8, len);
        size = max(result->length + extra, 512);
        if ((newBuf = ejsCreateBareString(ejs, size)) == NULL) {
            return NULL;
        }
        memcpy(newBuf->value, result->value, result->length * sizeof(wchar));
        newBuf->length = result->length;
        result = newBuf;
    }
    memcpy(&result->value[result->length], str, len * sizeof(wchar));
    result->length += len;
    result->value[result->length] = 0;
    /* Don't intern */
    return result;
}


/*
    Find a substring. Search forward or backwards. Return the index in the string where the pattern was found.
    Return -1 if not found.
 */
static ssize indexof(wchar *str, ssize len, EjsString *pattern, ssize patternLength, int dir)
{
    wchar       *s1, *s2;
    ssize       i, j;

    assert(dir == 1 || dir == -1);

    if (dir > 0) {
        for (i = 0; i < len; i++) {
            s1 = &str[i];
            for (j = 0, s2 = pattern->value; j < patternLength; s1++, s2++, j++) {
                if (*s1 != *s2) {
                    break;
                }
            }
            if (*s2 == '\0') {
                return i;
            }
        }
    } else {
        for (i = len - 1; i >= 0; i--) {
            s1 = &str[i];
            for (j = 0, s2 = pattern->value; j < patternLength; s1++, s2++, j++) {
                if (*s1 != *s2) {
                    break;
                }
            }
            if (*s2 == '\0') {
                return i;
            }
        }
    }
    return -1;
}

/******************************************** String API *******************************************/

PUBLIC int ejsAtoi(Ejs *ejs, EjsString *sp, int radix)
{
    int     num, i;

    num = 0;
    for (i = 0; i < (int) sp->length; i++) {
        num = num * radix + (sp->value[i] - '0');
    }
    return num;
}


PUBLIC EjsString *ejsJoinString(Ejs *ejs, EjsString *s1, EjsString *s2)
{
    EjsString   *result;
    ssize       len;

    if (s1->length == 0) {
        return s2;
    }
    if (s2->length == 0) {
        return s1;
    }
    len = s1->length + s2->length;
    if ((result = ejsCreateBareString(ejs, len)) == NULL) {
        return NULL;
    }
    memcpy(result->value, s1->value, s1->length * sizeof(wchar));
    memcpy(&result->value[s1->length], s2->value, s2->length * sizeof(wchar));
    return ejsInternString(result);
}



/*
    Join a set of unicode string arguments onto another.
    TODO - rename to join
 */
PUBLIC EjsString *ejsJoinStrings(Ejs *ejs, EjsString *src, ...)
{
    EjsString   *sp, *result;
    va_list     args;
    ssize       len;

    va_start(args, src);
    for (len = 0, sp = src; sp; ) {
        sp = va_arg(args, EjsString*);
        len += sp->length;
    }
    if ((result = ejsCreateBareString(ejs, len)) == NULL) {
        return NULL;
    }
    result->length = 0;
    va_start(args, src);
    for (sp = src; sp; ) {
        sp = va_arg(args, EjsString*);
        memcpy(&result->value[result->length], src->value, src->length);
        result->length += src->length;
    }
    va_end(args);
    return ejsInternString(result);
}


PUBLIC int ejsStartsWithAsc(Ejs *ejs, EjsString *sp, cchar *pat)
{
    ssize   i;

    assert(sp);
    assert(pat);

    if (pat == 0 || *pat == '\0') {
        return 0;
    }
    for (i = 0; pat[i] && i < sp->length; i++) {
        if (sp->value[i] != pat[i]) {
            break;
        }
    }
    if (pat[i]) {
        return -1;
    }
    return 0;
}


PUBLIC int ejsCompareAsc(Ejs *ejs, EjsString *sp, cchar *str)
{
    wchar       *s1;
    cchar       *s2;
    int         rc;

    s1 = sp->value;
    s2 = str;

    if (s1 == 0) {
        return -1;
    }
    if (s2 == 0) {
        return 1;
    }
    if ((cchar*) s1 == s2) {
        return 0;
    }
    for (rc = 0; *s1 && *s2 && rc == 0; s1++, s2++) {
        rc = *s1 - *s2;
    }
    if (rc) {
        return rc < 0 ? -1 : 1;
    }
    if (*s1 == '\0' && *s2) {
        return -1;
    }
    if (*s2 == '\0' && *s1) {
        return 1;
    }
    return rc;
}


/*
    Compare interned strings
 */
PUBLIC int ejsCompareString(Ejs *ejs, EjsString *sp1, EjsString *sp2)
{
    wchar       *s1;
    wchar       *s2;
    int         rc;

    s1 = sp1->value;
    s2 = sp2->value;

    if (s1 == s2) {
        /* No need to compare interned strings char-by-char */
        return 0;
    } else if (s1 == 0) {
        return -1;
    } else if (s2 == 0) {
        return 1;
    }
    for (rc = 0; *s1 && *s2 && rc == 0; s1++, s2++) {
        rc = *s1 - *s2;
    }
    if (rc) {
        return rc < 0 ? -1 : 1;
    } else if (*s1 == '\0' && *s2) {
        return -1;
    } else if (*s2 == '\0' && *s1) {
        return 1;
    }
    assert(0);
    return 0;
}


PUBLIC int ejsCompareSubstring(Ejs *ejs, EjsString *sp1, EjsString *sp2, ssize offset, ssize len)
{
    assert(0 <= len && len < MAXINT);

    if (offset < 0 || offset >= sp2->length) {
        return -1;
    }
    return ejsCompareWide(ejs, sp1, &sp2->value[offset], len);
}


PUBLIC int ejsCompareWide(Ejs *ejs, EjsString *sp1, wchar *sp2, ssize len)
{
    wchar       *s1;
    wchar       *s2;
    int         rc;

    assert(0 <= len && len < MAXINT);

    s1 = sp1->value;
    s2 = sp2;

    if (s1 == s2) {
        return 0;
    } else if (s1 == 0) {
        return -1;
    } else if (s2 == 0) {
        return 1;
    }
    for (rc = 0; len > 0 && *s1 && *s2 && rc == 0; s1++, s2++, len--) {
        rc = *s1 - *s2;
    }
    if (rc) {
        return rc < 0 ? -1 : 1;
    } else if (len == 0) {
        return 0;
    } else if (*s1 == 0 && *s2 == 0) {
        return 0;
    } else if (*s1 == '\0' && *s2) {
        return -1;
    } else if (*s2 == '\0' && *s1) {
        return 1;
    }
    return 0;
}


/*
    Return the index in a unicode string of a given unicode character code. Return -1 if not found.
 */
PUBLIC int ejsContainsChar(Ejs *ejs, EjsString *sp, int charPat)
{
    int     i;

    assert(sp);

    for (i = 0; i < sp->length; i++) {
        if (sp->value[i] == charPat) {
            return i;
        }
    }
    return -1;
}


#if UNUSED && KEEP
/*
    Return TRUE if a unicode string contains a given unicode string after doing a case insensitive comparison.
 */
PUBLIC int ejsContainsStringAnyCase(Ejs *ejs, EjsString *sp, EjsString *pat)
{
    int     i, j;

    assert(sp);
    assert(pat);
    assert(pat->value);

    for (i = 0; i < sp->length; i++) {
        for (j = 0; j < pat->length; j++) {
            //  TODO UNICODE - tolower only works for ASCII
            if (tolower((uchar) sp->value[i]) != tolower((uchar) pat->value[j])) {
                break;
            }
        }
        if (j == pat->length) {
            return 1;
        }
    }
    return 0;
}
#endif


PUBLIC int ejsContainsAsc(Ejs *ejs, EjsString *sp, cchar *pat)
{
    ssize   len;
    int     i, j, k;

    assert(sp);

    if (pat == 0 || *pat == '\0' || sp == 0) {
        return 0;
    }
    len = strlen(pat);
    
    for (i = 0; i < sp->length; i++) {
        for (j = 0, k = i; j < len; j++, k++) {
            if (sp->value[k] != pat[j]) {
                break;
            }
        }
        if (j == len) {
            return i;
        }
    }
    return -1;
}


PUBLIC int ejsContainsString(Ejs *ejs, EjsString *sp, EjsString *pat)
{
    int     i, j, k;

    assert(sp);
    assert(pat);
    assert(pat->value);

    if (pat == 0 || pat->value == 0) {
        return 0;
    }
    for (i = 0; i < sp->length; i++) {
        for (j = 0, k = i; j < pat->length; j++, k++) {
            if (sp->value[k] != pat->value[j]) {
                break;
            }
        }
        if (j == pat->length) {
            return 1;
        }
    }
    return -1;
}


PUBLIC char *ejsToMulti(Ejs *ejs, EjsAny *ev)
{
    if (ev == 0) {
        ev = ESV(empty);
    }
    if (!ejsIs(ejs, ev, String)) {
        if ((ev = ejsCast(ejs, ev, String)) == 0) {
            return MPR->emptyString;
        }
    }
    assert(ejsIs(ejs, ev, String));
    //  UNICODE
#if ME_CHAR_LEN == 1
{
    EjsString   *s = (EjsString*) ev;
    char        *ptr;
    ptr = mprMemdupMem(s->value, s->length + 1);
    ptr[s->length] = '\0';
    return ptr;
}
#else
    return awtom(((EjsString*) ev)->value, NULL);
#endif
}


PUBLIC EjsString *ejsSprintf(Ejs *ejs, cchar *fmt, ...)
{
    va_list     ap;
    char        *result;

    assert(fmt);

    va_start(ap, fmt);
    result = sfmtv(fmt, ap);
    va_end(ap);
    return ejsCreateStringFromAsc(ejs, result);
}


/*
    Get a substring from "src" starting at "start" of length "len"
    If len < 0, use entire string.
 */
PUBLIC EjsString *ejsSubstring(Ejs *ejs, EjsString *src, ssize start, ssize len)
{
    EjsString   *result;

    assert(src);
    assert(start >= 0);
    assert((start + len) <= src->length);

    if (len < 0) {
        len = src->length - start;
    }
    if (len < 0 || (start + len) > src->length || start < 0) {
        return ESV(empty);
    }
    len = min(len, src->length);
    if ((result = ejsCreateBareString(ejs, len)) == NULL) {
        return NULL;
    }
    memcpy(result->value, &src->value[start], len);
    return ejsInternString(result);
}


PUBLIC EjsString *ejsToLower(Ejs *ejs, EjsString *sp)
{
    EjsString   *result;
    int         i;

    assert(sp);
    assert(sp->value);

    result = (EjsString*) ejsCreateBareString(ejs, sp->length);
    for (i = 0; i < sp->length; i++) {
        result->value[i] = tolower((uchar) sp->value[i]);
    }
    return ejsInternString(result);
}


PUBLIC EjsString *ejsToUpper(Ejs *ejs, EjsString *sp)
{
    EjsString   *result;
    int         i;

    assert(sp);
    assert(sp->value);

    result = (EjsString*) ejsCreateBareString(ejs, sp->length);
    for (i = 0; i < sp->length; i++) {
        result->value[i] = toupper((uchar) sp->value[i]);
    }
    return ejsInternString(result);
}


#if UNUSED && KEEP
PUBLIC EjsString *ejsTrimString(Ejs *ejs, EjsString *sp, cchar *pat, int flags)
{
    EjsString   *result;
    wchar       *start, *end;
    cchar       *p;
    int         plen, trimmed;

    assert(pat);

    start = sp->value;
    plen = strlen(pat);
    trimmed = 0;

    if (flags & MPR_TRIM_START) {
        for (; *start; start++) {
            for (p = pat; *p; p++) {
                if (*start == *p) {
                    break;
                }
            }
            if (*start != *p) {
                break;
            }
            trimmed++;
        }
    }

    if (flags & MPR_TRIM_END) {
        for (end = &sp->value[sp->length]; end > start; end--) {
            for (p = pat; *p; p++) {
                if (*start == *p) {
                    break;
                }
            }
            if (*start != *p) {
                break;
            }
            trimmed++;
        }
    }
    result = ejsCreateBareString(ejs, sp->length - trimmed);
    memcpy(result->value, start, result->length);
    return ejsInternString(result);
}
#endif


PUBLIC EjsString *ejsTruncateString(Ejs *ejs, EjsString *sp, ssize len)
{
    EjsString   *result;

    assert(sp);

    len = min(len, sp->length);
    result = ejsCreateBareString(ejs, len);
    memcpy(result->value, sp->value, len);
    return ejsInternString(result);
}


/*********************************** Interning *********************************/

static void revive(EjsString *sp)
{
    MprMem  *mp;

    mp = (MprMem*) MPR_GET_MEM(sp);
    mp->mark = MPR->heap->mark;
}


/*
    Intern a unicode string. Lookup a string and return an interned string (this may be an existing interned string)
 */
PUBLIC EjsString *ejsInternString(EjsString *str)
{
    EjsString   *head, *sp;
    EjsIntern   *ip;
    ssize       i, len;
    int         index, step;

    ip = ((EjsService*) MPR->ejsService)->intern;
    step = 0;

    lock(ip);
    ip->accesses++;
    index = whash(str->value, str->length) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next, step++) {
            if (str == sp) {
                revive(sp);
                unlock(ip);
                return sp;
            }
            if (sp->length == str->length) {
                //  TODO but they are the same?
                len = min(sp->length, str->length);
                //  OPT
                for (i = 0; i < len; i++) {
                    if (sp->value[i] != str->value[i]) {
                        break;
                    }
                }
                if (i == sp->length && i == str->length) {
                    ip->reuse++;
                    revive(sp);
                    unlock(ip);
                    return sp;
                }
            }
        }
    }
    ip->count++;
    linkString(head, str);
    if (step > EJS_MAX_COLLISIONS && ip->count > (ip->size/2)) {
        /*  Remake the entire hash - should not happen often */
        //  OPT - BAD holding lock while rebuildingIntern
        rebuildIntern(ip);
    }
    unlock(ip);
    return str;
}


/*
    Intern a wide C string and return an interned wide string
 */
PUBLIC EjsString *ejsInternWide(Ejs *ejs, wchar *value, ssize len)
{
    EjsString   *head, *sp;
    EjsIntern   *ip;
    ssize       i, end;
    int         index, step;

    assert(0 <= len && len < MAXINT);

    ip = ejs->service->intern;
    step = 0;

    lock(ip);
    //  TODO - accesses should be debug only
    ip->accesses++;
    index = whash(value, len) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next, step++) {
            //  TODO - why not compare sp->value with value?
            if (sp->length == len) {
                end = min(sp->length, len);
                for (i = 0; i < end && value[i]; i++) {
                    if (sp->value[i] != value[i]) {
                        break;
                    }
                }
                if (i == sp->length) {
                    ip->reuse++;
                    revive(sp);
                    unlock(ip);
                    return sp;
                }
            }
        }
    }
    if ((sp = ejsAlloc(ejs, ESV(String), (len + 1) * sizeof(wchar))) != NULL) {
        memcpy(sp->value, value, len * sizeof(wchar));
        sp->value[len] = 0;
    }
    sp->length = len;
    ip->count++;
    linkString(head, sp);
    if (step > EJS_MAX_COLLISIONS && ip->count > (ip->size/2)) {
        /*  Remake the entire hash - should not happen often */
        //  OPT - BAD holding lock while rebuildingIntern
        rebuildIntern(ip);
    }
    unlock(ip);
    return sp;
}


PUBLIC EjsString *ejsInternAsc(Ejs *ejs, cchar *value, ssize len)
{
    EjsString   *head, *sp;
    EjsIntern   *ip;
    ssize       i, end;
    int         index, step;

    assert(0 <= len && len < MAXINT);

    step = 0;
    ip = ejs->service->intern;

    lock(ip);
    ip->accesses++;
    assert(ip->size > 0);
    index = shash(value, len) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next, step++) {
            if (sp->length == len) {
                end = min(len, sp->length);
                for (i = 0; i < end && value[i]; i++) {
                    if (sp->value[i] != (uchar) value[i]) {
                        break;
                    }
                }
                if (i == sp->length) {
                    ip->reuse++;
                    revive(sp);
                    unlock(ip);
                    return sp;
                }
            }
        }
    }
    if ((sp = ejsAlloc(ejs, ESV(String), (len + 1) * sizeof(wchar))) != NULL) {
#if ME_CHAR_LEN > 1
        for (i = 0; i < len; i++) {
            sp->value[i] = value[i];
        }
        sp->length = len;
#else
        memcpy(sp->value, value, len * sizeof(wchar));
#endif
        sp->value[len] = 0;
    }
    sp->length = len;
    ip->count++;
    linkString(head, sp);
    if (step > EJS_MAX_COLLISIONS && ip->count > (ip->size/2)) {
        /*  Remake the entire hash - should not happen often */
        //  OPT - BAD holding lock while rebuildingIntern
        rebuildIntern(ip);
    }
    unlock(ip);
    return sp;
}


#if ME_CHAR_LEN == 1
PUBLIC EjsString *ejsInternMulti(Ejs *ejs, cchar *value, ssize len)
{
    return ejsInternAsc(ejs, value, len);
}

#else /* ME_CHAR_LEN > 1 */

PUBLIC EjsString *ejsInternMulti(Ejs *ejs, cchar *value, ssize len)
{
    EjsString   *head, *sp, src;
    ssize       i, end;
    int         index;

    assert(0 < len && len < MAXINT);

    len = mtow(NULL, MAXSSIZE, value, len);
    assert(len < MAXINT);

    /*
        Have to convert the multibyte string to unicode before comparision. Convert into an EjsString to it is ready
        to intern if not found.
     */
    if ((src = ejsAlloc(ejs, ESV(String), (len + 1) * sizeof(wchar))) != NULL) {
        src->length = mtow(src->value, len + 1, value, len);
        value = src->value;
    }
    lock(ip);
    ip->accesses++;
    index = whash(value, len) % ip->size;
    if ((head = &ip->buckets[index]) != NULL) {
        for (sp = head->next; sp != head; sp = sp->next) {
            end = min(len, sp->length);
            for (i = 0; i < end && value[i]; i++) {
                if (sp->value[i] != sp->value[i]) {
                    break;
                }
            }
            if (i == sp->length && value[i] == 0) {
                ip->reuse++;
                revive(sp);
                unlock(ip);
                return sp;
            }
        }
    }
    ip->count++;
    linkString(head, src);
    if (step > EJS_MAX_COLLISIONS && ip->count > (ip->size/2)) {
        /*  Remake the entire hash - should not happen often */
        //  OPT - BAD holding lock while rebuildingIntern
        rebuildIntern(ip);
    }
    unlock(ip);
    return sp;
}
#endif /* ME_CHAR_LEN > 1 */


static int getInternHashSize(int size)
{
    int     i;

    for (i = 0; i < internHashSizes[i]; i++) {
        if (size < internHashSizes[i]) {
            return internHashSizes[i];
        }
    }
    return internHashSizes[i - 1];
}


static int rebuildIntern(EjsIntern *ip)
{
    EjsString   *oldBuckets, *sp, *next, *head;
    int         i, newSize, oldSize;

    assert(ip);

    oldBuckets = ip->buckets;
    newSize = getInternHashSize(ip->size + 1);
    oldSize = 0;
    if (oldBuckets) {
        oldSize = ip->size;
        if (oldSize >= newSize) {
            return 0;
        }
    }
    mprTrace(6, "Grow string intern new size %d old size %d, count %d, sizeof(EjsString) %d", 
        newSize, oldSize, ip->count, sizeof(EjsString));

    if ((ip->buckets = mprAllocZeroed((newSize * sizeof(EjsString)))) == NULL) {
        return MPR_ERR_MEMORY;
    }
    ip->size = newSize;
    for (i = 0; i < newSize; i++) {
        sp = &ip->buckets[i];
        sp->next = sp->prev = sp;
    }
    if (oldBuckets) {
        for (i = 0; i < oldSize; i++) {
            head = &oldBuckets[i];
            for (sp = head->next; sp != head; sp = next) {
                next = sp->next;
                sp->next = sp->prev = sp;
                ejsInternString(sp);
            }
        }
    }
    return 0;
}


/*
    Must be called locked
 */
static void linkString(EjsString *head, EjsString *sp)
{
    assert(sp != head);
    assert(sp->next == NULL || sp->next == sp);
    assert(sp->prev == NULL || sp->next == sp);

    sp->next = head->next;
    sp->prev = head;
    head->next->prev = sp;
    head->next = sp;
    assert(sp != sp->next);
    assert(sp != sp->prev);
}


/*
    Unlink a string from the intern cache. This unlinks from the hash chains. 
    This routine is idempotent. ejsDestroyIntern takes advantage of this.
    Must be called locked.
 */
static void unlinkString(EjsString *sp)
{
    /*
        Some strings are not interned (ejsCreateBareString). These have sp->next == NULL.
     */
    if (sp->next) {
        sp->prev->next = sp->next;
        sp->next->prev = sp->prev;
        sp->next = sp->prev = sp;
    }
}


/*********************************** Factory **********************************/

PUBLIC EjsString *ejsCreateString(Ejs *ejs, wchar *value, ssize len)
{
    if (value == 0) {
        return ESV(empty);
    }
    if (len < 0) {
        len = slen(value);
    }
    return ejsInternWide(ejs, value, len);
}


PUBLIC EjsString *ejsCreateStringFromAsc(Ejs *ejs, cchar *value)
{
    if (value == NULL) {
        value = "";
    }
    return ejsInternAsc(ejs, value, slen(value));
}


PUBLIC EjsString *ejsCreateStringFromMulti(Ejs *ejs, cchar *value, ssize len)
{
    assert(0 <= len && len < MAXINT);
    if (value == 0 || len < 0) {
        return ESV(empty);
    }
    return ejsInternMulti(ejs, value, len);
}


PUBLIC EjsString *ejsCreateStringFromBytes(Ejs *ejs, cchar *value, ssize len)
{
    assert(0 <= len && len < MAXINT);
    return ejsInternAsc(ejs, value, len);
}


/*
    Create an empty string object and do not intern. Caller's should call ejsInternString when the string value is defined.
 */
PUBLIC EjsString *ejsCreateBareString(Ejs *ejs, ssize len)
{
    EjsString   *sp;
    
    assert(0 <= len && len < MAXINT);
    if ((sp = ejsAlloc(ejs, ESV(String), (len + 1) * sizeof(wchar))) != NULL) {
        sp->length = len;
        sp->value[0] = 0;
        sp->value[len] = 0;
    }
    return sp;
}


#if UNUSED && KEEP
PUBLIC EjsString *ejsCreateNonInternedString(Ejs *ejs, wchar *value, ssize len)
{
    EjsString   *sp;
    
    assert(0 <= len && len < MAXINT);
    if ((sp = ejsAlloc(ejs, ESV(String), (len + 1) * sizeof(wchar))) != NULL) {
        memcpy(sp->value, value, (len + 1) * sizeof(wchar));
        sp->length = len;
        sp->value[len] = 0;
    }
    return sp;
}
#endif


PUBLIC void ejsManageString(EjsString *sp, int flags)
{
    EjsIntern   *ip;
    MprMem      *mp;

    if (flags & MPR_MANAGE_MARK) {
        mprMark(TYPE(sp));

    } else if (flags & MPR_MANAGE_FREE) {
        mp = MPR_GET_MEM(sp);
        /*
            Other threads race with this if doing parallel GC (the default). The revive() routine may have 
            marked the string, so test here if it has been revived and only free if not.
            OPT - better to be lock free and try lock. If failed, GC will get next time
         */
        if (MPR->ejsService) {
            ip = ((EjsService*) MPR->ejsService)->intern;
            lock(ip);
            if (mp->mark != MPR->heap->mark) {
                ip->count--;
                unlinkString(sp);
            }
            unlock(ip);
        }
    }
}


PUBLIC EjsIntern *ejsCreateIntern(EjsService *sp)
{
    EjsIntern   *intern;
    
    intern = mprAllocObj(EjsIntern, manageIntern);
    intern->mutex = mprCreateLock();
    rebuildIntern(intern);
    return intern;
}


PUBLIC void ejsDestroyIntern(EjsIntern *ip)
{
    EjsString   *sp, *head, *next;
    int         i;

    /*
        Unlink strings now as when they are freed later, the intern structure may not exist in memory.
     */
    lock(ip);
    for (i = ip->size - 1; i >= 0; i--) {
        head = &ip->buckets[i];
        for (sp = head->next; sp != head; sp = next) {
            next = sp->next;
            ip->count--;
            unlinkString(sp);
        }
    }
    unlock(ip);
}


static void manageIntern(EjsIntern *intern, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(intern->buckets);
        mprMark(intern->mutex);

    } else if (flags & MPR_MANAGE_FREE) {
        ejsDestroyIntern(intern);
    }
}


PUBLIC void ejsInitStringType(Ejs *ejs, EjsType *type)
{
    type->helpers.cast = (EjsCastHelper) castString;
    type->helpers.clone = (EjsCloneHelper) cloneString;
    type->helpers.getProperty = (EjsGetPropertyHelper) getStringProperty;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeStringOperator;
    type->helpers.lookupProperty = (EjsLookupPropertyHelper) lookupStringProperty;
    type->numericIndicies = 1;
}


PUBLIC void ejsConfigureStringType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "String"))) == 0) {
        return;
    }
    ejsBindMethod(ejs, type, ES_String_fromCharCode, fromCharCode);
    ejsBindConstructor(ejs, type, stringConstructor);
    
    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_String_caseCompare, caseCompare);
    ejsBindMethod(ejs, prototype, ES_String_caselessCompare, caselessCompare);
    ejsBindMethod(ejs, prototype, ES_String_charAt, charAt);
    ejsBindMethod(ejs, prototype, ES_String_charCodeAt, charCodeAt);
    ejsBindMethod(ejs, prototype, ES_String_concat, concatString);
    ejsBindMethod(ejs, prototype, ES_String_contains, containsString);
    ejsBindMethod(ejs, prototype, ES_String_endsWith, endsWith);
    ejsBindMethod(ejs, prototype, ES_String_expand, expandString);
    ejsBindMethod(ejs, prototype, ES_String_format, formatString);
    ejsBindMethod(ejs, prototype, ES_String_iterator_get, getStringIterator);
    ejsBindMethod(ejs, prototype, ES_String_iterator_getValues, getStringValues);
    ejsBindMethod(ejs, prototype, ES_String_indexOf, indexOf);
    ejsBindMethod(ejs, prototype, ES_String_isDigit, isDigit);
    ejsBindMethod(ejs, prototype, ES_String_isAlpha, isAlpha);
    ejsBindMethod(ejs, prototype, ES_String_isAlphaNum, isAlphaNum);
    ejsBindMethod(ejs, prototype, ES_String_isLower, isLower);
    ejsBindMethod(ejs, prototype, ES_String_isSpace, isSpace);
    ejsBindMethod(ejs, prototype, ES_String_isUpper, isUpper);
    ejsBindMethod(ejs, prototype, ES_String_lastIndexOf, lastIndexOf);
    ejsBindMethod(ejs, prototype, ES_String_length, stringLength);
    ejsBindMethod(ejs, prototype, ES_String_match, match);
    ejsBindMethod(ejs, prototype, ES_String_remove, removeCharsFromString);
    ejsBindMethod(ejs, prototype, ES_String_slice, sliceString);
    ejsBindMethod(ejs, prototype, ES_String_split, split);
    ejsBindMethod(ejs, prototype, ES_String_printable, printable);
    ejsBindMethod(ejs, prototype, ES_String_quote, quote);
    ejsBindMethod(ejs, prototype, ES_String_replace, replace);
    ejsBindMethod(ejs, prototype, ES_String_reverse, reverseString);
    ejsBindMethod(ejs, prototype, ES_String_search, searchString);
    ejsBindMethod(ejs, prototype, ES_String_startsWith, startsWith);
    ejsBindMethod(ejs, prototype, ES_String_substring, substring);
    ejsBindMethod(ejs, prototype, ES_String_toCamel, toCamel);
    ejsBindMethod(ejs, prototype, ES_String_toJSON, ejsToLiteralString);
    ejsBindMethod(ejs, prototype, ES_String_toLowerCase, toLowerCase);
    ejsBindMethod(ejs, prototype, ES_String_toPascal, toPascal);
    ejsBindMethod(ejs, prototype, ES_String_toString, stringToString);
    ejsBindMethod(ejs, prototype, ES_String_toUpperCase, toUpperCase);
    ejsBindMethod(ejs, prototype, ES_String_tokenize, tokenize);
    ejsBindMethod(ejs, prototype, ES_String_trim, trimString);
    ejsBindMethod(ejs, prototype, ES_String_trimStart, trimStartString);
    ejsBindMethod(ejs, prototype, ES_String_trimEnd, trimEndString);

#if FUTURE
    ejsBindMethod(ejs, prototype, ES_String_LBRACKET, operLBRACKET);
    ejsBindMethod(ejs, prototype, ES_String_PLUS, operPLUS);
    ejsBindMethod(ejs, prototype, ES_String_MINUS, operMINUS);
    ejsBindMethod(ejs, prototype, ES_String_LT, operLT);
    ejsBindMethod(ejs, prototype, ES_String_GT, operGT);
    ejsBindMethod(ejs, prototype, ES_String_EQ, operEQ);
    ejsBindMethod(ejs, prototype, ES_String_MOD, operMOD);
    ejsBindMethod(ejs, prototype, ES_String_MUL, operMUL);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsSystem.c"
 */
/************************************************************************/

/*
    ejsSystem.c -- System class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Methods *********************************/
/*
    function get hostname(): String
 */
static EjsString *system_hostname(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprGetHostName());
}


/*
    function get ipaddr(): String
 */
static EjsString *system_ipaddr(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    //  TODO - move this into MPR and call mprSetIpAddr
#if ME_UNIX_LIKE || ME_WIN_LIKE
    struct addrinfo *res, *reslist, hints;
    cchar           *ip;
    char            ipaddr[ME_MAX_PATH], service[ME_MAX_PATH];
    int             rc;

    if ((ip = mprGetIpAddr(ejs)) != 0) {
        return ejsCreateStringFromAsc(ejs, mprGetIpAddr(ejs));
    }
    memset((char*) &hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_INET;
    hints.ai_flags = AI_PASSIVE;
    if ((rc = getaddrinfo(mprGetHostName(), NULL, &hints, &reslist)) == 0) {
        ip = 0;
        //  TODO - support IPv6
        for (res = reslist; res; res = res->ai_next) {
            if (getnameinfo(res->ai_addr, (socklen_t) res->ai_addrlen, ipaddr, (int) sizeof(ipaddr) - 1, service, 
                    (int) sizeof(service) - 1, NI_NUMERICHOST | NI_NUMERICSERV | NI_NOFQDN) == 0) {
                if (strncmp(ipaddr, "10.", 3) == 0 || strncmp(ipaddr, "127.", 4) == 0 ||
                     strncmp(ipaddr, "169.", 4) == 0 || strncmp(ipaddr, "172.", 4) == 0 ||
                     strncmp(ipaddr, "192.", 4) == 0) {
                    if (ip == 0) {
                        ip = sclone(ipaddr);
                    }
                } else {
                    ip = sclone(ipaddr);
                    break;
                }
            }
        }
        return ejsCreateStringFromAsc(ejs, ip ? ip : "127.0.0.1");
    } else {
        mprError("Cannot get IP address, check system hostname. Error %d.\n", rc);
    }
#endif
    return ESV(null);
}


#if ES_System_tmpdir
/*
    function get tmpdir(): Path
 */
static EjsPath *system_tmpdir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar   *dir;

#if WINCE
    dir = "/Temp";
#elif ME_WIN_LIKE
{
    MprFileSystem   *fs;
    fs = mprLookupFileSystem("/");
    dir = sclone(getenv("TEMP"));
#if UNUSED
    mprMapSeparators(dir, defaultSep(fs));
#endif
}
#elif VXWORKS
    dir = ".";
#else
    dir = "/tmp";
#endif
    return ejsCreatePathFromAsc(ejs, dir);
}
#endif

/************************************ Factory *********************************/

PUBLIC void ejsConfigureSystemType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "System"), 0, 0, 0)) == 0) {
        return;
    }
    ejsBindMethod(ejs, type, ES_System_hostname, system_hostname);
    ejsBindMethod(ejs, type, ES_System_ipaddr, system_ipaddr);
#if ES_System_tmpdir
    ejsBindMethod(ejs, type, ES_System_tmpdir, system_tmpdir);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsTimer.c"
 */
/************************************************************************/

/*
    ejsTimer.c -- Timer class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Code ************************************/
/*
    Create a new timer

    function Timer(period: Number, callback: Function, ...args)
 */
static EjsTimer *timer_constructor(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc >= 2);
    assert(ejsIs(ejs, argv[0], Number));
    assert(ejsIsFunction(ejs, argv[1]));
    assert(ejsIs(ejs, argv[2], Array));

    tp->period = ejsGetInt(ejs, argv[0]);
    tp->callback = (EjsFunction*) argv[1];
    tp->args = (EjsArray*) argv[2];
    tp->repeat = 0;
    tp->drift = 1;
    tp->ejs = ejs;
    return tp;
}


/*
    function get drift(): Boolean
 */
static EjsBoolean *timer_get_drift(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc == 0);
    return ejsCreateBoolean(ejs, tp->drift);
}


/*
    function set drift(period: Boolean): Void
 */
static EjsObj *timer_set_drift(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc == 1 && ejsIs(ejs, argv[0], Boolean));
    tp->drift = ejsGetBoolean(ejs, argv[0]);
    return 0;
}


/*
    function get onerror(): Function
 */
static EjsFunction *timer_get_onerror(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc == 0);
    return tp->onerror;
}


/*
    function set onerror(callback: Function): Void
 */
static EjsObj *timer_set_onerror(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    tp->onerror = (EjsFunction*) argv[0];
    return 0;
}


/*
    function get period(): Number
 */
static EjsNumber *timer_get_period(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc == 0);
    return ejsCreateNumber(ejs, tp->period);
}


/*
    function set period(period: Number): Void
 */
static EjsObj *timer_set_period(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc == 1 && ejsIs(ejs, argv[0], Number));

    tp->period = ejsGetInt(ejs, argv[0]);
    return 0;
}


/*
    function get repeat(): Boolean
 */
static EjsBoolean *timer_get_repeat(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc == 0);
    return ejsCreateBoolean(ejs, tp->repeat);
}


/*
    function set repeat(enable: Boolean): Void
 */
static EjsObj *timer_set_repeat(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    assert(argc == 1 && ejsIs(ejs, argv[0], Boolean));

    tp->repeat = ejsGetBoolean(ejs, argv[0]);
    if (tp->event) {
        mprEnableContinuousEvent(tp->event, tp->repeat);
    }
    return 0;
}


static int timerCallback(EjsTimer *tp, MprEvent *e)
{
    Ejs         *ejs;
    EjsObj      *thisObj, *error;

    assert(tp);
    assert(tp->args);
    assert(tp->callback);

    ejs = tp->ejs;
    thisObj = (tp->callback->boundThis) ? tp->callback->boundThis : tp;
    ejsRunFunction(ejs, tp->callback, thisObj, tp->args->length, tp->args->data);
    if (ejs->exception) {
        if (tp->onerror) {
            error = ejs->exception;
            ejsClearException(ejs);
            ejsRunFunction(ejs, tp->onerror, thisObj, 1, &error);
        } else {
            mprError("Uncaught exception in timer\n%s", ejsGetErrorMsg(ejs, 1));
            ejsClearException(ejs);
        }
    }
    if (!tp->repeat) {
        mprRemoveRoot(tp);
        tp->event = 0;
        tp->ejs = 0;
    }
    return 0;
}


/*
    function start(): Timer
 */
static EjsTimer *timer_start(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    int     flags;

    if (tp->event == 0) {
        flags = tp->repeat ? MPR_EVENT_CONTINUOUS : 0;
        tp->event = mprCreateEvent(ejs->dispatcher, "timer", tp->period, (MprEventProc) timerCallback, tp, flags);
        if (tp->event == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return tp;
}


/*
    function stop(): Void
 */
static EjsObj *timer_stop(Ejs *ejs, EjsTimer *tp, int argc, EjsObj **argv)
{
    if (tp->event) {
        mprStopContinuousEvent(tp->event);
        mprRemoveRoot(tp);
        tp->event = 0;
    }
    return 0;
}

/*********************************** Helpers **********************************/

static void manageTimer(EjsTimer *tp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        /* Pooled interpreter being abandoned */
        if (tp->ejs->abandoned) {
            if (tp->event) {
                mprRemoveEvent(tp->event);
                tp->event = 0;
            }
        }
        mprMark(tp->ejs);
        mprMark(tp->event);
        mprMark(tp->callback);
        mprMark(tp->onerror);
        mprMark(tp->args);

    } else if (flags & MPR_MANAGE_FREE) {
        if (tp->event) {
            mprRemoveEvent(tp->event);
        }
    }
}


/*********************************** Factory **********************************/

PUBLIC void ejsConfigureTimerType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Timer"), sizeof(EjsTimer), manageTimer,
            EJS_TYPE_OBJ | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, timer_constructor);
    ejsBindMethod(ejs, prototype, ES_Timer_start, timer_start);
    ejsBindMethod(ejs, prototype, ES_Timer_stop, timer_stop);

    ejsBindAccess(ejs, prototype, ES_Timer_drift, timer_get_drift, timer_set_drift);
    ejsBindAccess(ejs, prototype, ES_Timer_period, timer_get_period, timer_set_period);
    ejsBindAccess(ejs, prototype, ES_Timer_onerror, timer_get_onerror, timer_set_onerror);
    ejsBindAccess(ejs, prototype, ES_Timer_repeat, timer_get_repeat, timer_set_repeat);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsType.c"
 */
/************************************************************************/

/**
    ejsType.c - Type class

    The type class is the base class for all types (classes) in the system.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/***************************** Forward Declarations ***************************/

static EjsType *createBootType(Ejs *ejs, EjsType *baseType, int slotNum, int size, void *manager, int64 attributes);
static EjsType *createTypeVar(Ejs *ejs, EjsType *typeType, int numProp);
static void finishBootType(Ejs *ejs, int slotNum, EjsName qname, EjsType *type);
static void fixInstanceSize(Ejs *ejs, EjsType *type);
static int fixupPrototypeProperties(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom);
static int fixupTypeImplements(Ejs *ejs, EjsType *type, int makeRoom);
static int inheritProperties(Ejs *ejs, EjsType *type, EjsPot *obj, int destOffset, EjsPot *baseBlock, int srcOffset, 
    int count, bool resetScope);
static void manageDefault(EjsObj *ev, int flags);
static void manageType(EjsType *type, int flags);
static int64 setDefaultAttributes(EjsType *type, int size, int64 attributes);
static void zeroSlots(Ejs *ejs, EjsPot *obj, int count, EjsAny *null);

/******************************************************************************/
/*
    Handcraft the Object, Type, Null, String, and Block types.
 */
PUBLIC int ejsCreateBootstrapTypes(Ejs *ejs)
{
    EjsObj      *null;
    EjsPot      *immutable;
    EjsType     *blockType, *nullType, *objectType, *stringType, *typeType;

    assert(ejs);

    ejsCreateObjHelpers(ejs);
    ejsCreatePotHelpers(ejs);
    ejsCreateBlockHelpers(ejs);

    /*
        Partially create the core types. Bit of a chicken-an-egg problem. Finish creating types below after 
        the "" and null values have been created.
     */
    typeType   = createBootType(ejs, 0, S_Type, sizeof(EjsType), manageType, 
        EJS_TYPE_BLOCK | EJS_TYPE_DYNAMIC_INSTANCES);
    objectType = createBootType(ejs, typeType, S_Object, sizeof(EjsPot), ejsManagePot, 
        EJS_TYPE_POT | EJS_TYPE_DYNAMIC_INSTANCES);
    blockType  = createBootType(ejs, typeType, S_Block, sizeof(EjsBlock), ejsManageBlock, 
        EJS_TYPE_POT | EJS_TYPE_DYNAMIC_INSTANCES);
    stringType = createBootType(ejs, typeType, S_String, sizeof(EjsString), ejsManageString, 
        EJS_TYPE_OBJ | EJS_TYPE_IMMUTABLE_INSTANCES);
    nullType   = createBootType(ejs, typeType, S_Null, sizeof(EjsNull), manageDefault, EJS_TYPE_OBJ);
    SET_TYPE(typeType, objectType);

    /*
        Create the immutable set and then manually zero after creating "null"
     */
    ejs->service->immutable = immutable = ejsCreatePot(ejs, objectType, 0);
    ejsGrowPot(ejs, immutable, max(EJS_NUM_GLOBAL, ES_global_NUM_CLASS_PROP));
    mprSetName(immutable, "immutable");
    ESV(null) = null = ejsCreateObj(ejs, nullType, 0);
    mprSetName(ESV(null), "null value");
    zeroSlots(ejs, immutable, immutable->numProp, null);

    /*
        Preset some essential types and values so we can finish up the types
     */
    ESV(Object) = objectType;
    ESV(String) = stringType;
    ESV(null) = null;
    ESV(empty) = ejsCreateStringFromAsc(ejs, "");

    finishBootType(ejs, ES_String, N("ejs", "String"), stringType);
    finishBootType(ejs, ES_Object, N("ejs", "Object"), objectType);
    finishBootType(ejs, ES_Block, N("ejs", "Block"), blockType);
    finishBootType(ejs, ES_Null, N("ejs", "Null"), nullType);
    finishBootType(ejs, ES_Type, N("ejs", "Type"), typeType);

    ejsInitStringType(ejs, stringType);
    ejsInitTypeType(ejs, typeType);
    ejsInitBlockType(ejs, blockType);
    ejsInitNullType(ejs, nullType);
    return 0;
}


static EjsType *createBootType(Ejs *ejs, EjsType *baseType, int slotNum, int size, void *manager, int64 attributes)
{
    EjsType     *type;

    assert(0 <= slotNum && slotNum < EJS_MAX_SPECIAL);

    if ((type = createTypeVar(ejs, NULL, 0)) == NULL) {
        return 0;
    }
    SET_TYPE(type, baseType);
    type->sid = slotNum;
    attributes = setDefaultAttributes(type, size, attributes);
    attributes = ejsSetTypeAttributes(type, size, manager, attributes);
    ejsSetTypeHelpers(type, attributes);
    return type;
}


static void finishBootType(Ejs *ejs, int slotNum, EjsName qname, EjsType *type)
{
    type->qname = qname;
    mprSetName(type, qname.name->value);
    ejsAddImmutable(ejs, slotNum, type->qname, type);

    if ((type->prototype = ejsCreatePot(ejs, ESV(Object), 0)) == 0) {
        return;
    }
    mprSetName(type->prototype, qname.name->value);
    type->prototype->isPrototype = 1;
}


/*
    Create a new type and initialize. BaseType is the super class for instances of the type being created. The
    returned EjsType will be an instance of EjsType. numTypeProp and numInstanceProp should be set to the number
    of non-inherited properties.
 */
PUBLIC EjsType *ejsCreateType(Ejs *ejs, EjsName qname, EjsModule *up, EjsType *baseType, EjsPot *prototype, 
        int sid, int numTypeProp, int numInstanceProp, int size, void *manager, int64 attributes)
{
    EjsType     *type;
    
    assert(ejs);
    assert(size >= 0);
    
    if ((type = createTypeVar(ejs, ESV(Type), numTypeProp)) == 0) {
        return 0;
    }
    attributes = setDefaultAttributes(type, size, attributes);
    attributes = ejsSetTypeAttributes(type, size, manager, attributes);
    ejsSetTypeHelpers(type, attributes);
    type->sid = sid;
    type->qname = qname;
    type->constructor.name = qname.name;
    type->module = up;
    type->baseType = baseType;

    //  UNICODE
    mprSetName(type, qname.name->value);

    if (prototype) {
        type->prototype = prototype;
    } else {
        if ((type->prototype = ejsCreatePot(ejs, ESV(Object), numInstanceProp)) == 0) {
            return 0;
        }
        //  UNICODE
        mprSetName(type->prototype, qname.name->value);
    }
    type->prototype->isPrototype = 1;

    if (baseType && ejsFixupType(ejs, type, baseType, 0) < 0) {
        return 0;
    }
    return type;
}


/*
    Create a native built-in type. This is used for the core native classes of the language.
 */
PUBLIC EjsType *ejsCreateCoreType(Ejs *ejs, EjsName qname, int size, int sid, int numTypeProp, void *manager, int64 attributes)
{
    EjsType     *type;

#if ME_DEBUG
    if (attributes & EJS_TYPE_POT) {
        if (size > sizeof(EjsPot)) {
            assert(attributes & EJS_TYPE_DYNAMIC_INSTANCES);
            attributes |= EJS_TYPE_DYNAMIC_INSTANCES;
        }
    }
#endif
    if ((type = ejsCreateType(ejs, qname, NULL, NULL, NULL, sid, numTypeProp, 0, size, manager, attributes)) == 0) {
        ejs->hasError = 1;
        return 0;
    }
    if (!type->mutable && type->sid >= 0) {
        ejsAddImmutable(ejs, type->sid, type->qname, type);
    }
    return type;
}


PUBLIC EjsType *ejsFinalizeCoreType(Ejs *ejs, EjsName qname)
{
    EjsType     *type;

    if ((type = ejsGetTypeByName(ejs, qname)) == 0) {
        mprError("Cannot find %N type", qname);
        return 0;
    }
    if (type->configured) {
        return 0;
    }
    type->configured = 1;
    return type;
}


/*
    Returns false if the type has already been finalized
 */
PUBLIC EjsType *ejsFinalizeScriptType(Ejs *ejs, EjsName qname, int size, void *manager, int64 attributes)
{
    EjsType     *type;

    if ((type = ejsGetTypeByName(ejs, qname)) == 0) {
        mprError("Cannot find %N type", qname);
        return 0;
    }
    if (type->configured) {
        return 0;
    }
    attributes = setDefaultAttributes(type, size, attributes);
    attributes = ejsSetTypeAttributes(type, size, manager, attributes);
    ejsSetTypeHelpers(type, attributes);

    if (!type->mutable && type->sid >= 0) {
        ejsAddImmutable(ejs, type->sid, type->qname, type);
    }
    type->manager = manager ? (MprManager) manager : (MprManager) manageDefault;
    type->configured = 1;
    return type;
}


PUBLIC EjsType *ejsConfigureType(Ejs *ejs, EjsType *type, EjsModule *up, EjsType *baseType, int numTypeProp, 
        int numInstanceProp, int64 attributes)
{
    type->module = up;

    /* Don't set default attributes */
    attributes &= ~(EJS_TYPE_BLOCK | EJS_TYPE_OBJ | EJS_TYPE_POT);
    ejsSetTypeAttributes(type, type->instanceSize, type->manager, attributes);
    /* Don't modify helpers */

    if (numTypeProp > 0 && ejsGrowPot(ejs, &type->constructor.block.pot, numTypeProp) < 0) {
        return 0;
    }
    if (numInstanceProp > 0) {
        ejsGrowPot(ejs, type->prototype, numInstanceProp);
    }
    if (baseType && ejsFixupType(ejs, type, baseType, 0) < 0) {
        return 0;
    }
    return type;
}



PUBLIC EjsType *ejsCreateArchetype(Ejs *ejs, EjsFunction *fun, EjsPot *prototype)
{
    EjsName     qname;
    EjsType     *type, *baseType;
    EjsCode     *code;
    EjsString   *name;

    if (prototype == 0 && fun) {
        prototype = ejsGetPropertyByName(ejs, fun, N(NULL, "prototype"));
    }
    baseType = prototype ? TYPE(prototype): ESV(Object);
    name = (fun && fun->name) ? fun->name : ejsCreateStringFromAsc(ejs, "-type-from-function-");
    qname.space = ejsCreateStringFromAsc(ejs, EJS_PROTOTYPE_NAMESPACE);
    qname.name = name;
    type = ejsCreateType(ejs, qname, NULL, baseType, prototype, -1, 0, 0, EST(Object)->instanceSize, 0, 
        EJS_TYPE_POT | EJS_TYPE_DYNAMIC_INSTANCES);
    if (type == 0) {
        return 0;
    }
    if (fun) {
        code = fun->body.code;
        /*  using ESV(Object) as the return type because the Yahoo module pattern returns {} in the constructor */
        ejsInitFunction(ejs, (EjsFunction*) type, type->qname.name, code->byteCode, code->codeLen, 
            fun->numArgs, fun->numDefault, code->numHandlers, ESV(Object), EJS_TRAIT_HIDDEN | EJS_TRAIT_FIXED, 
            code->module, NULL, fun->strict);
        type->constructor.activation = ejsClone(ejs, fun->activation, 0);
        type->constructor.boundThis = 0;
        type->constructor.boundArgs = 0;
        type->constructor.isConstructor = 1;
        type->constructor.block.pot.isBlock = 1;
        type->constructor.block.pot.isFunction = 1;
        type->hasConstructor = 1;
        type->constructor.block.scope = fun->block.scope;
        fun->archetype = type;
    }
    ejsApplyPotHelpers(ejs->service, type);
    return type;
}


/*
    OPT - should be able to just read in the attributes without having to stuff some in var and some in type.
    Should eliminate all the specific fields and just use BIT MASKS.
    NOTE: EJS_TYPE_IMMUTABLE_INSTANCES overrides EJS_TYPE_MUTABLE_INSTANCES.
 */
static int64 setDefaultAttributes(EjsType *type, int size, int64 attributes)
{
    if ((attributes & (EJS_TYPE_POT | EJS_TYPE_BLOCK | EJS_TYPE_OBJ)) == 0) {
        attributes |= EJS_TYPE_POT;
    }
    if (attributes & EJS_TYPE_POT) {
        if (size && size != sizeof(EjsPot)) {
            attributes |= EJS_TYPE_MUTABLE_INSTANCES;
        }
        
    } else if (attributes & EJS_TYPE_BLOCK) {
        if (size && size != sizeof(EjsBlock)) {
            attributes |= EJS_TYPE_MUTABLE_INSTANCES;
        }
    } else if (attributes & EJS_TYPE_OBJ) {
        if (size && size != sizeof(EjsObj)) {
            attributes |= EJS_TYPE_MUTABLE_INSTANCES;
        }
    }
    return attributes;
}


PUBLIC int64 ejsSetTypeAttributes(EjsType *type, int size, MprManager manager, int64 attributes)
{
    if (attributes & EJS_TYPE_POT) {
        type->isPot = 1;
        if (manager == 0) {
            manager = ejsManagePot;
        }
        if (size == 0) {
            size = sizeof(EjsPot);
        }
        if (size != sizeof(EjsBlock)) {
            attributes |= EJS_TYPE_MUTABLE_INSTANCES;
        }
        
    } else if (attributes & EJS_TYPE_BLOCK) {
        type->isPot = 1;
        if (manager == 0) {
            manager = (MprManager) ejsManageBlock;
        }
        if (size == 0) {
            size = sizeof(EjsBlock);
        }
        if (size != sizeof(EjsBlock)) {
            attributes |= EJS_TYPE_MUTABLE_INSTANCES;
        }
    } else if (attributes & EJS_TYPE_OBJ) {
        type->isPot = 0;
        if (manager == 0) {
            manager = (MprManager) manageDefault;
        }
        if (size == 0) {
            size = sizeof(EjsObj);
        }
        if (size != sizeof(EjsObj)) {
            attributes |= EJS_TYPE_MUTABLE_INSTANCES;
        }
    }
    if (attributes & EJS_TYPE_CALLS_SUPER) {
        type->callsSuper = 1;
    }
    if (attributes & EJS_TYPE_DYNAMIC_INSTANCES) {
        type->dynamicInstances = 1;
    }
    if (attributes & EJS_TYPE_FINAL) {
        type->final = 1;
    }
    if (attributes & EJS_TYPE_FIXUP) {
        type->needFixup = 1;
    }
    if (attributes & EJS_TYPE_HAS_CONSTRUCTOR) {
        type->hasConstructor = 1;
    }
    if (attributes & EJS_TYPE_HAS_INSTANCE_VARS) {
        type->hasInstanceVars = 1;
    }
    if (attributes & EJS_TYPE_INTERFACE) {
        type->isInterface = 1;
    }
    if (attributes & EJS_TYPE_HAS_TYPE_INITIALIZER) {
        type->hasInitializer = 1;
    }
    if (attributes & EJS_TYPE_MUTABLE) {
        assert(type->mutable == 0);
        type->mutable = 1;
    }
    /* IMMUTABLE takes precedence */
    if (attributes & EJS_TYPE_IMMUTABLE_INSTANCES) {
        type->mutableInstances = 0;
    } else if (attributes & EJS_TYPE_MUTABLE_INSTANCES) {
        type->mutableInstances = 1;
    }
    if (attributes & EJS_TYPE_NUMERIC_INDICIES) {
        type->numericIndicies = 1;
    } 
    if (attributes & EJS_TYPE_VIRTUAL_SLOTS) {
        type->virtualSlots = 1;
    }
    type->manager = manager;
    type->instanceSize = size;
    return attributes;
}


PUBLIC void ejsSetTypeHelpers(EjsType *type, int64 attributes)
{
    if (attributes & EJS_TYPE_BLOCK) {
        ejsApplyBlockHelpers(MPR->ejsService, type);
        type->isPot = 1;

    } else if (attributes & EJS_TYPE_POT) {
        ejsApplyPotHelpers(MPR->ejsService, type);
        type->isPot = 1;

    } else if (attributes & EJS_TYPE_OBJ) {
        ejsApplyObjHelpers(MPR->ejsService, type);
        type->isPot = 0;
    }
}


PUBLIC EjsType *ejsGetType(Ejs *ejs, int slotNum)
{
    EjsType     *type;

    if (slotNum < 0 || slotNum >= ((EjsPot*) ejs->global)->numProp) {
        return 0;
    }
    type = ejsGetProperty(ejs, ejs->global, slotNum);
    if (type == 0 || !ejsIsType(ejs, type)) {
        return 0;
    }
    return type;
}


PUBLIC EjsPot *ejsGetPrototype(Ejs *ejs, EjsAny *obj)
{
    return TYPE(obj)->prototype;
}


PUBLIC EjsType *ejsGetTypeByName(Ejs *ejs, EjsName qname)
{
    return ejsGetPropertyByName(ejs, ejs->global, qname);
}


static int inheritProperties(Ejs *ejs, EjsType *type, EjsPot *obj, int destOffset, EjsPot *baseBlock, int srcOffset, 
        int count, bool resetScope)
{
    EjsFunction     *fun;
    EjsObj          *vp;
    int             i;

    assert(obj);
    assert(baseBlock);
    assert(count > 0);
    assert(destOffset < obj->numProp);
    assert((destOffset + count) <= obj->numProp);
    assert(srcOffset < baseBlock->numProp);
    assert((srcOffset + count) <= baseBlock->numProp);

    ejsCopySlots(ejs, obj, destOffset, baseBlock, srcOffset, count);
    
    if (resetScope) {
        for (i = destOffset; i < (destOffset + count); i++) {
            fun = ejsGetProperty(ejs, obj, i);
            if (ejsIsFunction(ejs, fun)) {
                fun = ejsCloneFunction(ejs, fun, 0);
                ejsSetProperty(ejs, obj, i, fun);
                fun->boundThis = 0;
                fun->boundArgs = 0;
                fun->block.scope = (EjsBlock*) type;
            }
        }
    }
    for (i = destOffset; i < (destOffset + count); i++) {
        if ((vp = ejsGetProperty(ejs, obj, i)) != 0 && !ejsIs(ejs, vp, Null) && !ejsIsFunction(ejs, vp)) {
            if (ejsIsType(ejs, vp)) {
                ejsSetProperty(ejs, obj, i, ESV(null));
            }
        }
    }
    ejsIndexProperties(ejs, obj);
    return 0;
}


static void fixInstanceSize(Ejs *ejs, EjsType *type)
{
    EjsType     *tp;

    for (tp = type->baseType; tp && tp != ESV(Object); tp = tp->baseType) {
        if (tp->instanceSize > type->instanceSize) {
            type->instanceSize = tp->instanceSize;
        }
    }
}


/*
    Fixup a type. This is used by the compiler and loader when it must first define a type when its base type or
    property types may not yet be defined (ie. forward references. Consequently, it must fixup the type and its 
    counts of inherited properties. It must also copy inherited slots and traits.
 */
PUBLIC int ejsFixupType(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom)
{
    assert(ejs);
    assert(type);
    assert(type != baseType);

    type->needFixup = 0;
    type->baseType = baseType;
    
    if (baseType) {
        //  TODO-- should be able to remove the || baseType->hasBaseConstructors
        if (baseType->hasConstructor || baseType->hasBaseConstructors) {
            type->hasBaseConstructors = 1;
        }
        //  TODO -- when compiling baseType is always != ESV(Object)
        //  TODO - should not explicity reference objecttype
        if (baseType != ESV(Object) && baseType->dynamicInstances) {
            type->dynamicInstances = 1;
        }
        type->hasInstanceVars |= baseType->hasInstanceVars;
    }
    if (type->implements) {
        if (fixupTypeImplements(ejs, type, makeRoom) < 0) {
            return EJS_ERR;
        }
    }
    if (baseType) {
        if (type->implements || baseType->prototype->numProp > 0) {
            fixupPrototypeProperties(ejs, type, baseType, makeRoom);
        }
        if (baseType->isPot && baseType != ESV(Object)) {
            type->isPot = 1;
        }
   }
    fixInstanceSize(ejs, type);
    return 0;
}


static int fixupTypeImplements(Ejs *ejs, EjsType *type, int makeRoom)
{
    EjsType         *iface;
    EjsBlock        *bp;
    EjsNamespace    *nsp;
    int             next, offset, itotal, icount, nextNsp;

    assert(type);
    assert(type->implements);

    itotal = 0;
    for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
        if (!iface->isInterface) {
            itotal += iface->constructor.block.pot.numProp;
            type->hasInstanceVars |= iface->hasInstanceVars;
        }
    }
    if (makeRoom) {
        offset = type->constructor.block.pot.numProp;
        if (itotal > 0 && ejsGrowPot(ejs, (EjsPot*) type, offset + itotal) < 0) {
            return EJS_ERR;
        }
    } else {
        offset = type->constructor.block.pot.numProp - itotal;
    }
    for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
        if (!iface->isInterface) {
            icount = iface->constructor.block.pot.numProp;
            if (inheritProperties(ejs, type, (EjsPot*) type, offset, (EjsPot*) iface, 0, icount, 1) < 0) {
                return EJS_ERR;
            }
            offset += icount;
            for (nextNsp = 0; 
                    (nsp = (EjsNamespace*) mprGetNextItem(&iface->constructor.block.namespaces, &nextNsp)) != 0;) {
                ejsAddNamespaceToBlock(ejs, (EjsBlock*) type, nsp);
            }
            for (bp = iface->constructor.block.scope; bp; bp = bp->scope) {
                for (nextNsp = 0; (nsp = (EjsNamespace*) mprGetNextItem(&bp->namespaces, &nextNsp)) != 0;) {
                    ejsAddNamespaceToBlock(ejs, (EjsBlock*) type, nsp);
                }
            }
        }
    }
    return 0;
}


static int fixupPrototypeProperties(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom)
{
    EjsType     *iface;
    EjsPot      *basePrototype;
    int         count, offset, next;

    assert(type != baseType);
    assert(type->prototype);
    assert(baseType->prototype);
    
    basePrototype = baseType->prototype;

    if (makeRoom) {
        count = 0;
        assert(basePrototype);
        /* Must inherit if the type has instance vars */
        if (basePrototype && baseType->hasInstanceVars) {
            count = basePrototype->numProp;
        }
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            if (!iface->isInterface && iface->prototype) {
                count += iface->prototype->numProp - iface->numInherited;
            }
        }
        if (count > 0 && ejsInsertPotProperties(ejs, type->prototype, count, 0) < 0) {
            return EJS_ERR;
        }
    }
    offset = 0;
    if (baseType->hasInstanceVars) {
        assert(type->prototype->numProp >= basePrototype->numProp);
        if (inheritProperties(ejs, type, type->prototype, offset, basePrototype, 0, basePrototype->numProp, 0) < 0) {
            return EJS_ERR;
        }
        type->numInherited = basePrototype->numProp;
        offset += basePrototype->numProp;
    }
    if (type->implements) {
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            if (iface->isInterface) {
                continue;
            }
            /* Only come here for implemented classes */
            if (iface->prototype == 0) {
                continue;
            }
            count = iface->prototype->numProp - iface->numInherited;
            if (inheritProperties(ejs, type, type->prototype, offset, iface->prototype, iface->numInherited, count, 1) < 0) {
                return EJS_ERR;
            }
            type->numInherited += count;
            offset += count;
        }
    }
    return 0;
}


/*
    Set the native method function for a function property
 */
PUBLIC int ejsBindMethod(Ejs *ejs, EjsAny *obj, int slotNum, void *nativeProc)
{
    return ejsBindFunction(ejs, obj, slotNum, nativeProc);
}


PUBLIC int ejsBindAccess(Ejs *ejs, void *obj, int slotNum, void *getter, void *setter)
{
    EjsFunction     *fun;

    if (getter) {
        if (ejsBindFunction(ejs, obj, slotNum, getter) < 0) {
            return EJS_ERR;
        }
    }
    if (setter) {
        fun = ejsGetProperty(ejs, obj, slotNum);
        if (fun == 0 || !ejsIsFunction(ejs, fun) || fun->setter == 0 || !ejsIsFunction(ejs, fun->setter)) {
            ejs->hasError = 1;
            mprError("Attempt to bind non-existant setter function for slot %d in \"%s\"", slotNum, mprGetName(obj));
            return EJS_ERR;
        }
        fun = fun->setter;
        if (fun->body.code) {
            mprError("Setting a native method on a non-native function \"%@\" in \"%s\"", fun->name, mprGetName(obj));
            ejs->hasError = 1;
        }
        fun->body.proc = setter;
        fun->isNativeProc = 1;
    }
    return 0;
}


/*
    Set the native method function for a function property
 */
PUBLIC int ejsBindFunction(Ejs *ejs, EjsAny *obj, int slotNum, void *nativeProc)
{
    EjsFunction     *fun;

    if (ejsGetLength(ejs, obj) < slotNum) {
        ejs->hasError = 1;
        mprError("Attempt to bind non-existant function for slot %d in \"%s\"", slotNum, mprGetName(obj));
        return EJS_ERR;
    }
    fun = ejsGetProperty(ejs, obj, slotNum);
    if (fun == 0 || !ejsIsFunction(ejs, fun)) {
        assert(fun);
        ejs->hasError = 1;
        mprError("Attempt to bind non-existant function for slot %d in \"%s\"", slotNum, mprGetName(obj));
        return EJS_ERR;
    }
    if (fun->body.code) {
        mprError("Setting a native method on a non-native function \"%@\" in \"%s\"", fun->name, mprGetName(obj));
        ejs->hasError = 1;
    }
    assert(fun->body.proc == 0);
    fun->body.proc = nativeProc;
    fun->isNativeProc = 1;
    return 0;
}


PUBLIC void ejsBindConstructor(Ejs *ejs, EjsType *type, void *nativeProc)
{
    assert(type->hasConstructor);
    assert(type->constructor.isConstructor);
    assert(type->constructor.block.pot.isBlock);
    assert(type->constructor.block.pot.isFunction);
    assert(type->constructor.body.proc == 0);

    type->constructor.body.proc = nativeProc;
    type->constructor.isNativeProc = 1;
}


/*
    Define a global public function. Returns a positive slot number, otherwise a negative MPR error.
 */
PUBLIC int ejsDefineGlobalFunction(Ejs *ejs, EjsString *name, EjsProc fn)
{
    EjsFunction *fun;
    EjsName     qname;

    if ((fun = ejsCreateFunction(ejs, name, NULL, -1, 0, 0, 0, ESV(Object), 0, NULL, NULL, 0)) == 0) {
        return MPR_ERR_MEMORY;
    }
    fun->body.proc = fn;
    fun->isNativeProc = 1;
    qname.space = ejsCreateStringFromAsc(ejs, EJS_PUBLIC_NAMESPACE);
    qname.name = name;
    return ejsSetPropertyByName(ejs, ejs->global, qname, fun);
}


/*
    Return true if target is an instance of type or a sub class of it.
 */
PUBLIC bool ejsIsA(Ejs *ejs, EjsAny *target, EjsType *type)
{
    assert(type);

    if (!ejsIsType(ejs, type) || target == 0) {
        return 0;
    }
    return ejsIsTypeSubType(ejs, TYPE(target), type);
}


/*
    Return true if "target" is a "type", subclass of "type" or implements "type".
 */
PUBLIC bool ejsIsTypeSubType(Ejs *ejs, EjsType *target, EjsType *type)
{
    EjsType     *tp, *iface;
    int         next;

    assert(target);
    assert(type);
    
    if (!ejsIsType(ejs, target) || !ejsIsType(ejs, type)) {
        return 0;
    }
    /*
        See if target is a subtype of type
     */
    for (tp = target; tp; tp = tp->baseType) {
        /*
            All strings are interned, so this will test equality of types even across interpreters.
            This permits using code from another interpreter.
         */
        if (tp->qname.name == type->qname.name && tp->qname.space == type->qname.space) {
            return 1;
        }
    }
    /*
        See if target implements type
     */
    if (target->implements) {
        for (next = 0; (iface = mprGetNextItem(target->implements, &next)) != 0; ) {
            if (iface->qname.name == type->qname.name && iface->qname.space == type->qname.space) {
                return 1;
            }
        }
    }
    return 0;
}


/*
    This call is currently only used to update the type namespace after resolving a run-time namespace.
 */
PUBLIC void ejsSetTypeName(Ejs *ejs, EjsType *type, EjsName qname)
{
    type->qname = qname;
}


/*
    Define namespaces for a class. Inherit the protected and internal namespaces from all base classes.
 */
PUBLIC void ejsDefineTypeNamespaces(Ejs *ejs, EjsType *type)
{
    if (type->baseType) {
        /*
            Inherit the base class's protected and internal namespaces
         */
        ejsInheritBaseClassNamespaces(ejs, type, type->baseType);
    }
    //  TODO - add readonly here
    ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PROTECTED_NAMESPACE);
    ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PRIVATE_NAMESPACE);
}


static void zeroSlots(Ejs *ejs, EjsPot *obj, int count, EjsAny *null)
{
    EjsSlot     *slots, *sp;

    assert(obj);
    assert(count >= 0);

    slots = obj->properties->slots;
    for (sp = &slots[count - 1]; sp >= slots; sp--) {
        sp->value.ref = null;
        sp->hashChain = -1;
        sp->trait.type = 0;
        sp->trait.attributes = 0;
    }
}

/************************************ Helpers *********************************/
/*
    Copy a type

    function copy(type: Object): Object
 */
static EjsType *cloneTypeVar(Ejs *ejs, EjsType *src, bool deep)
{
    EjsType     *dest;

    if (! ejsIsType(ejs, src)) {
        ejsThrowTypeError(ejs, "Expecting a Type object");
        return 0;
    }
    dest = (EST(Function)->helpers.clone)(ejs, src, deep);
    if (dest == 0) {
        return dest;
    }
    //  TODO OPT
    dest->baseType = src->baseType;
    dest->callsSuper = src->callsSuper;
    dest->dynamicInstances = src->dynamicInstances;
    dest->final = src->final;
    dest->hasBaseConstructors = src->hasBaseConstructors;
    dest->hasBaseInitializers = src->hasBaseInitializers;
    dest->hasConstructor = src->hasConstructor;
    dest->hasInitializer = src->hasInitializer;
    dest->hasInstanceVars = src->hasInstanceVars;
    dest->hasMeta = src->hasMeta;
    dest->hasScriptFunctions = src->hasScriptFunctions;
    dest->helpers = src->helpers;
    dest->implements = src->implements;
    dest->initialized = src->initialized;
    dest->instanceSize = src->instanceSize;
    dest->isInterface = src->isInterface;
    dest->isPot = src->isPot;
    dest->manager = src->manager;
    dest->mutable = src->mutable;
    dest->mutableInstances = src->mutableInstances;
    dest->mutex = src->mutex;
    dest->module = src->module;
    dest->numericIndicies = src->numericIndicies;
    dest->numInherited = src->numInherited;
    dest->prototype = src->prototype;
    dest->qname = src->qname;
    dest->sid = src->sid;
    dest->typeData = src->typeData;
    dest->virtualSlots = src->virtualSlots;
    return dest;
}


/*
    Create a new Type object. numProp is the number of property slots to pre-allocate.
 */
static EjsType *createTypeVar(Ejs *ejs, EjsType *typeType, int numProp)
{
    EjsType     *type;
    EjsPot      *obj;
    char        *start;
    ssize       typeSize;
    int         sizeHash, dynamic;

    assert(ejs);
    
    /*
        If the compiler is building itself (empty mode), then the types themselves must be dynamic. Otherwise, the type
        is fixed and will contain the names hash and traits in one memory block. 
        NOTE: don't confuse this with dynamic objects.
     */
    sizeHash = 0;
    if (numProp < 0 || ejs->empty) {
        dynamic = 1;
        typeSize = sizeof(EjsType);
        numProp = 0;
    } else {
        dynamic = 0;
        typeSize = sizeof(EjsType) + sizeof(EjsProperties);
        typeSize += (int) sizeof(EjsSlot) * numProp;
        if (numProp > EJS_HASH_MIN_PROP) {
            sizeHash = ejsGetHashSize(numProp);
            typeSize += sizeof(EjsHash) + (sizeHash * (int) sizeof(EjsSlot*));
        }
    }
    if ((type = mprAllocBlock(typeSize, MPR_ALLOC_ZERO | MPR_ALLOC_MANAGER)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    mprSetManager(type, (MprManager) manageType);
    mprInitList(&type->constructor.block.namespaces, MPR_LIST_STABLE);
    obj = (EjsPot*) type;
    SET_TYPE(obj, typeType);
    SET_DYNAMIC(obj, dynamic);
    obj->isType = 1;
    obj->isBlock = 1;
    ejsSetMemRef(obj);

    if (!dynamic) {
        /*
            This is for a fixed type. This is the normal case when not compiling. Layout is:
                Slots: sizeof(EjsSlot) * numProp
                Hash:  ejsGetHashSize(numslots)
         */
        start = (char*) type + sizeof(EjsType);
        if (numProp > 0) {
            obj->properties = (EjsProperties*) start;
            obj->properties->size = numProp;
            ejsZeroSlots(ejs, obj->properties->slots, numProp);
            start += sizeof(EjsProperties) + sizeof(EjsSlot) * numProp;
        }
        if (sizeHash > 0) {
            obj->properties->hash = (EjsHash*) start;
            obj->properties->hash->buckets = (int*) (start + sizeof(EjsHash));
            obj->properties->hash->size = sizeHash;
            memset(obj->properties->hash->buckets, -1, sizeHash * sizeof(int));
            start += sizeof(EjsHash) + sizeof(int) * sizeHash;
        }
        assert((start - (char*) type) <= typeSize);
    }
    return type;
}


static int setTypeProperty(Ejs *ejs, EjsType *type, int slotNum, EjsObj *value)
{
    if (slotNum < 0 && !DYNAMIC(type)) {
        ejsThrowTypeError(ejs, "Object is not dynamic");
        return EJS_ERR;
    }
    return (EST(Block)->helpers.setProperty)(ejs, type, slotNum, value);
}


/*********************************** Factory **********************************/
/*
    Default manager for instances
 */
static void manageDefault(EjsObj *ev, int flags)
{
#if ME_DEBUG
    if (flags & MPR_MANAGE_MARK) {
        assert(!TYPE(ev)->isPot);
    }
#endif
}


static void manageType(EjsType *type, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManageFunction(&type->constructor, flags);
        mprMark(type->qname.name);
        mprMark(type->qname.space);
        mprMark(type->prototype);
        mprMark(type->baseType);
        mprMark(type->mutex);
        mprMark(type->implements);
        mprMark(type->module);
        mprMark(type->typeData);
    }
}


PUBLIC void ejsInitTypeType(Ejs *ejs, EjsType *type)
{
    type->helpers.clone        = (EjsCloneHelper) cloneTypeVar;
    type->helpers.create       = (EjsCreateHelper) createTypeVar;
    type->helpers.setProperty  = (EjsSetPropertyHelper) setTypeProperty;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsUri.c"
 */
/************************************************************************/

/*
    ejsUri.c - Uri class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/************************************ Forwards ********************************/

static EjsUri *completeUri(Ejs *ejs, EjsUri *up, EjsObj *missing, int includeQuery);
static int same(Ejs *ejs, HttpUri *u1, HttpUri *u2, int exact);
static HttpUri *createHttpUriFromHash(Ejs *ejs, EjsObj *arg, int flags);
static HttpUri *toHttpUri(Ejs *ejs, EjsObj *arg, int dup);
static EjsUri *uri_join(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv);

/************************************ Helpers *********************************/
#if UNUSED && KEEP
//  keep this for when the cast helper is reversed
/*
    Convert an arg to a URI. Can handle strings, paths, URIs and object hashes. Will cast all else to strings and then
    parse.
 */
static EjsUri *castToUri(Ejs *ejs, EjsObj *arg)
{
    EjsUri  *up;

    up = ejsCreateObj(ejs, ESV(Uri), 0);
    if (ejsIs(ejs, arg, String)) {
        up->uri = httpCreateUri(up, ejsToMulti(ejs, arg), 0);

    } else if (ejsIs(ejs, arg, Uri)) {
        up->uri = httpCloneUri(((EjsUri*) arg)->uri, 0);

    } else if (ejsIs(ejs, arg, Path)) {
        ustr = ((EjsPath*) arg)->path;
        up->uri = httpCreateUri(up, ustr, 0);

    } else if (ejsGetLength(ejs, arg) > 0) {
        up->uri = createHttpUriFromHash(ejs, up, arg, 0);

    } else {
        arg = (EjsObj) ejsToString(ejs, arg);
        up->uri = httpCreateUri(up, ejsToMulti(ejs, arg), 0);
    }
    return up;
}
#endif


static EjsUri *cloneUri(Ejs *ejs, EjsUri *src, bool deep)
{
    EjsUri     *dest;

    if ((dest = ejsCreateObj(ejs, TYPE(src), 0)) == 0) {
        return 0;
    }
    /*  NOTE: a deep copy will complete the uri */
    dest->uri = httpCloneUri(src->uri, deep ? HTTP_COMPLETE_URI : 0);
    return dest;
}


static EjsAny *coerceUriOperands(Ejs *ejs, EjsUri *lhs, int opcode,  EjsAny *rhs)
{
    HttpUri     *uri;
    char        *ustr;

    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        uri = lhs->uri;
        ustr = httpFormatUri(uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, ustr), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        }
        uri = lhs->uri;
        ustr = httpFormatUri(uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
        return ejsInvokeOperator(ejs, ejsCreateStringFromAsc(ejs, ustr), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return ESV(true);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return ESV(false);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return ESV(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


static EjsAny *invokeUriOperator(Ejs *ejs, EjsUri *lhs, int opcode,  EjsUri *rhs, void *data)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceUriOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*  Types now match, both Uris
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        if (lhs == rhs || (lhs->uri == rhs->uri)) {
            return ESV(true);
        }
        return ejsCreateBoolean(ejs,  same(ejs, lhs->uri, rhs->uri, 1));

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        return ejsCreateBoolean(ejs,  !same(ejs, lhs->uri, rhs->uri, 1));

    /*  NOTE: these only compare the paths */
    case EJS_OP_COMPARE_LT:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) < 0);

    case EJS_OP_COMPARE_LE:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) <= 0);

    case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) > 0);

    case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs,  scmp(lhs->uri->path, rhs->uri->path) >= 0);

    /*  
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return ((lhs->uri->path) ? ESV(true): ESV(false));

    case EJS_OP_COMPARE_ZERO:
        return ((lhs->uri->path == 0) ? ESV(true): ESV(false));


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return ESV(false);

    /*  
        Binary operators
     */
    case EJS_OP_ADD:
        return uri_join(ejs, lhs, 1, (EjsObj**) (void*) &rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    assert(0);
}


/************************************ Methods *********************************/

/*  
    Constructor
    function Uri(uri: Uri)
    function Uri(path: String)
    function Uri(parts: Object)
 */
static EjsUri *uri_constructor(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (argc >= 0) {
        up->uri = toHttpUri(ejs, argv[0], 1);
    }
    return up;
}


/*  
    Make an absolute reference for "this" URI.

    function absolute(base): Uri
 */
static EjsUri *uri_absolute(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    HttpUri     *uri, *baseUri;

    if (argc >= 1) {
        baseUri = toHttpUri(ejs, argv[0], 0);
        result = cloneUri(ejs, up, 0);
        uri = result->uri;
        if (uri->path && uri->path[0] != '/') {
            httpJoinUriPath(uri, baseUri, uri);
        }
        httpCompleteUri(result->uri, baseUri);
    } else {
        result = cloneUri(ejs, up, 0);
        httpCompleteUri(result->uri, NULL);
    }
    httpNormalizeUri(result->uri);
    return result;
}


/*  
    function get basename(): Uri
 */
static EjsUri *uri_basename(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    char        *path, *cp;
    int         len;

    np = cloneUri(ejs, up, 0);
    path = np->uri->path;
    if (path == 0) {
        return ESV(null);
    }
    len = (int) strlen(path);
    if (path[len - 1] == '/') {
        *path = '\0';
    } else {
        if ((cp = strrchr(path, '/')) != 0) {
            np->uri->path = &cp[1];
        }
    }
    return np;
}


/*  
    function complete(missing = null): Uri
 */
static EjsUri *uri_complete(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri  *result;

    result = cloneUri(ejs, up, 0);
    return completeUri(ejs, result, (argc >= 1) ? argv[0] : 0, 1);
}


/*  
    Break a uri into components
  
    function components(): Object
 */
static EjsObj *uri_components(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    HttpUri     *uri;

    uri = up->uri;
    obj = ejsCreateEmptyPot(ejs);

    if (uri->scheme) {
        ejsSetPropertyByName(ejs, obj, EN("scheme"), ejsCreateStringFromAsc(ejs, uri->scheme));
    }
    if (uri->host) {
        ejsSetPropertyByName(ejs, obj, EN("host"), ejsCreateStringFromAsc(ejs, uri->host));
    }
    if (uri->port > 0) {
        ejsSetPropertyByName(ejs, obj, EN("port"), ejsCreateNumber(ejs, uri->port));
    }
    if (uri->path) {
        ejsSetPropertyByName(ejs, obj, EN("path"), ejsCreateStringFromAsc(ejs, uri->path));
    }
    if (uri->reference) {
        ejsSetPropertyByName(ejs, obj, EN("reference"), ejsCreateStringFromAsc(ejs, uri->reference));
    }
    if (uri->query) {
        ejsSetPropertyByName(ejs, obj, EN("query"), ejsCreateStringFromAsc(ejs, uri->query));
    }
    return obj;
}


/*  
    Decode a Uri
    static function decode(str: String): String
 */
static EjsString *uri_decode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    Decode a Uri component
    static function decodeComponent(str: String): String
 */
static EjsString *uri_decodeComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    function get dirname(): Uri
 */
static EjsUri *uri_dirname(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    char        *path, *cp;
    int         len;

    np = cloneUri(ejs, up, 0);
    path = np->uri->path;
    if (path == 0) {
        return ESV(null);
    }
    len = (int) strlen(path);
    if (path[len - 1] == '/') {
        if (len > 1) {
            path[len - 1] = '\0';
        }
    } else {
        if ((cp = strrchr(path, '/')) != 0) {
            if (cp > path) {
                *cp = '\0';
            } else {
                cp[1] = '\0';
            }
        }
    }
    return np;
}


/*  
    Uri Encode a string
    function encode(str: String): String
 */
static EjsString *uri_encode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_URI));
}


/*  
    Encode a Uri component
    static function encodeComponent(str: String): String
 */
static EjsString *uri_encodeComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_URI_COMPONENT));
}


/*  
    Get the Uri extension
    static function get extension(): String?
 */
static EjsString *uri_extension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->ext == 0) {
        return ESV(null);
    }    
    return ejsCreateStringFromAsc(ejs, up->uri->ext);
}


/*  
    Set the Uri extension
    static function set extension(ext: String?): Void
 */
static EjsObj *uri_set_extension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    if (argv[0] == ESV(null)) {
        uri->ext = 0;
        uri->path = mprTrimPathExt(uri->path);
    } else {
        uri->ext = ejsToMulti(ejs, argv[0]);
        uri->path = sjoin(mprTrimPathExt(uri->path), uri->ext, NULL);
    }
    return 0;
}


/*  
    Determine if the uri has an extension
    static function get hasExtension(): Boolean
 */
static EjsBoolean *uri_hasExtension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->ext);
}


/*  
    Determine if the uri has a host
    static function get hasHost(): Boolean
 */
static EjsBoolean *uri_hasHost(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->host);
}


/*  
    Determine if the uri has a port
    static function get hasPort(): Boolean
 */
static EjsBoolean *uri_hasPort(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->port > 0);
}


/*  
    Determine if the uri has a query
    static function get hasQuery(): Boolean
 */
static EjsBoolean *uri_hasQuery(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->query);
}


/*  
    Determine if the uri has a reference
    static function get hasReference(): Boolean
 */
static EjsBoolean *uri_hasReference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->reference);
}


/*  
    Determine if the uri has a scheme
    static function get hasScheme(): Boolean
 */
static EjsBoolean *uri_hasScheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->scheme);
}


/*  
    Get the host portion
    static function get host(): String?
 */
static EjsString *uri_host(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->host == 0) {
        return ESV(null);
    }    
    return ejsCreateStringFromAsc(ejs, up->uri->host);
}


/*  
    Set the host portion
    static function set host(name: String?): Void
 */
static EjsObj *uri_set_host(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->host = (argv[0] == ESV(null)) ? 0 : ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    function get isAbsolute(): Boolean
 */
static EjsBoolean *uri_isAbsolute(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, up->uri->path[0] == '/');
}


/*  
    Determine if the file name is a directory. This 
    function get isDir(): Boolean
 */
static EjsBoolean *uri_isDir(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return ejsCreateBoolean(ejs, uri->path[strlen(uri->path) - 1] == '/');
}


/*  
    Join uri segments
    function join(...others): Uri
 */
static EjsUri *uri_join(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    EjsObj      *arg;
    EjsArray    *args;
    HttpUri     *uri, *other, *oldUri;
    int         i;

    args = (EjsArray*) argv[0];
    result = cloneUri(ejs, up, 0);
    uri = result->uri;
    for (i = 0; i < args->length; i++) {
        arg = ejsGetProperty(ejs, args, i);
        if ((other = toHttpUri(ejs, arg, 0)) == NULL) {
            return 0;
        }
        oldUri = uri;
        uri = httpJoinUri(oldUri, 1, &other);
    }
    result->uri = uri;
    return result;
}


/*  
    Join extension
    function joinExt(ext: String): Uri
 */
static EjsUri *uri_joinExt(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;
    char        *ext;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    ext = ejsToMulti(ejs, argv[0]);
    if (ext && *ext == '.') {
        ext++;
    }
    nuri->ext = ext;
    nuri->path = sjoin(mprTrimPathExt(nuri->path), ".", nuri->ext, NULL);
    return np;
}


/*  
    function local(): Uri
 */
static EjsUri *uri_local(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;

    if ((result = cloneUri(ejs, up, 0)) != 0) {
        httpMakeUriLocal(result->uri);
    }
    return result;
}


/*  
    Get the mimeType
    function mimeType(): String?
 */
static EjsString *uri_mimeType(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->ext == 0) {
        return ESV(null);
    }
    return ejsCreateStringFromAsc(ejs, mprLookupMime(NULL, up->uri->ext));
}


/*  
    function get normalize(): Uri
 */
static EjsUri *uri_normalize(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;

    np = cloneUri(ejs, up, 0);
    np->uri->path = httpNormalizeUriPath(up->uri->path);
    return np;
}


/*  
    Get the path portion
    static function get path(): String?
 */
static EjsString *uri_path(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->path == 0) {
        return ESV(null);
    }    
    return ejsCreateStringFromAsc(ejs, up->uri->path);
}


/*  
    Set the path portion
    static function set path(path: String?): Void
 */
static EjsObj *uri_set_path(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (argv[0] == ESV(null)) {
        up->uri->path = 0;
        up->uri->ext = 0;
    } else {
        up->uri->path = httpNormalizeUriPath(ejsToMulti(ejs, argv[0]));
        up->uri->ext = mprGetPathExt(up->uri->path);
    }
    return 0;
}


/*  
    Get the port portion
    static function get port(): Number?
 */
static EjsNumber *uri_port(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;
    
    uri = up->uri;
    if (uri->port <= 0) {
        return ESV(null);
#if KEEP
        if (uri->host == 0) {
            return ESV(null);
        }
        if (uri->scheme == 0 || strcmp(uri->scheme, "http") == 0) {
            return ejsCreateNumber(ejs, 80);
        } else if (uri->scheme && strcmp(uri->scheme, "https") == 0) {
            return ejsCreateNumber(ejs, 443);
        }
#endif
    }
    return ejsCreateNumber(ejs, up->uri->port);
}


/*  
    Set the port portion
    static function set port(port: Number?): Void
 */
static EjsObj *uri_set_port(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->port = (argv[0] == ESV(null)) ? 0 : ejsGetInt(ejs, argv[0]);
    return 0;
}


/*
    Get the reference portion
    static function get reference(): String?
 */
static EjsString *uri_reference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->reference == 0) {
        return ESV(null);
    }    
    return ejsCreateStringFromAsc(ejs, up->uri->reference);
}


/*  
    Set the reference portion
    static function set reference(reference: String?): Void
 */
static EjsObj *uri_set_reference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->reference = (argv[0] == ESV(null)) ? 0 : ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    Replace the Uri extension
    static function set replaceExt(ext: String): Uri
 */
static EjsUri *uri_replaceExtension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;
    char        *ext;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    nuri->path = mprTrimPathExt(nuri->path);
    ext = ejsToMulti(ejs, argv[0]);
    if (ext && *ext == '.') {
        ext++;
    }
    nuri->ext = ext;
    nuri->path = sjoin(mprTrimPathExt(nuri->path), ".", nuri->ext, NULL);
    return np;
}


//  TODO - Uri should get a cast helper. Then this API and others can be typed.
/*  
    function resolve(target): Uri
 */
static EjsUri *uri_resolve(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    HttpUri     *uri, *target;

    uri = up->uri;
    target = toHttpUri(ejs, argv[0], 0);
    result = ejsCreateObj(ejs, ESV(Uri), 0);
    uri = httpResolveUri(uri, 1, &target, 0);
    if (up->uri == uri) {
        uri = httpCloneUri(uri, 0);
    }
    result->uri = uri;
    return result;
}


/*  
    function relative(base): Uri
 */
static EjsUri *uri_relative(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *result;
    HttpUri     *baseUri;

    baseUri = toHttpUri(ejs, argv[0], 0);
    result = ejsCreateObj(ejs, ESV(Uri), 0);
    result->uri = httpGetRelativeUri(baseUri, up->uri, 1);
    return result;
}


/*  
    Get the scheme portion
    static function get scheme(): String?
 */
static EjsString *uri_scheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->scheme == 0) {
        return ESV(null);
    }
    return ejsCreateStringFromAsc(ejs, up->uri->scheme);
}


/*  
    Set the scheme portion
    static function set scheme(scheme: String?): Void
 */
static EjsObj *uri_set_scheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->scheme = (argv[0] == ESV(null)) ? 0 : ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    Get the query portion
    static function get query(): String?
 */
static EjsString *uri_query(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->query == 0) {
        return ESV(null);
    }    
    return ejsCreateStringFromAsc(ejs, up->uri->query);
}


/*  
    Set the query portion
    static function set query(query: String): Void
 */
static EjsObj *uri_set_query(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->query = (argv[0] == ESV(null)) ? 0 : ejsToMulti(ejs, argv[0]);
    return 0;
}


/*  
    Compare two Uris
    function same(other: String, exact: Boolean = false): Boolean
 */
static EjsObj *uri_same(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri  *other;
    int     exact;

    other = (EjsUri*) argv[0];
    exact = (argc == 2 && argv[1] == ESV(true));
    return ejsCreateBoolean(ejs, same(ejs, up->uri, other->uri, exact));
}


/*  
    Expand a template with {word} tokens from the given options objects

    function template(pattern: String, ...options): Uri
 */
static EjsUri *uri_template(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsArray    *options;
    EjsObj      *obj, *value;
    MprBuf      *buf;
    cchar       *pattern, *cp, *ep, *str;
    char        *token;
    int         i, len;

    pattern = ejsToMulti(ejs, argv[0]);
    options = (EjsArray*) argv[1];

    buf = mprCreateBuf(-1, -1);
    for (cp = pattern; *cp; cp++) {
        if (*cp == '~' && (cp == pattern || cp[-1] != '\\')) {
            for (i = 0; i < options->length; i++) {
                obj = options->data[i];
                if ((value = ejsGetPropertyByName(ejs, obj, N(NULL, "scriptName"))) != 0 && ejsIsDefined(ejs, value)) {
                    str = ejsToMulti(ejs, value);
                    if (str && *str) {
                        mprPutStringToBuf(buf, str);
                        break;
                    } else {
                        value = 0;
                    }
                }
            }
        } else if (*cp == '{' && (cp == pattern || cp[-1] != '\\')) {
            if ((ep = strchr(++cp, '}')) != 0) {
                len = (int) (ep - cp);
                token = mprMemdup(cp, len + 1);
                token[len] = '\0';
                value = 0;
                for (i = 0; i < options->length; i++) {
                    obj = options->data[i];
                    if ((value = ejsGetPropertyByName(ejs, obj, N(NULL, token))) != 0 && ejsIsDefined(ejs, value)) {
                        str = ejsToMulti(ejs, value);
                        if (str && *str) {
                            mprPutStringToBuf(buf, str);
                            break;
                        } else {
                            value = 0;
                        }
                    }
                }
                if (!ejsIsDefined(ejs, value)) {
                    //  TODO - remove this. Should not be erasing the prior "/"
                    if (cp >= &pattern[2] && cp[-2] == '/') {
                        mprAdjustBufEnd(buf, -1);
                    }
                }
                cp = ep;
            }
        } else {
            mprPutCharToBuf(buf, *cp);
        }
    }
    mprAddNullToBuf(buf);
    return ejsCreateUriFromAsc(ejs, mprGetBufStart(buf));
}


/* 
   function toString(): String
 */
static EjsString *uri_toString(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return ejsCreateStringFromAsc(ejs, httpUriToString(uri, 0));
}


/* 
   function toLocalString(): String
 */
static EjsString *uri_toLocalString(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return ejsCreateStringFromAsc(ejs, httpFormatUri(NULL, NULL, 0, uri->path, uri->reference, uri->query, 0));
}


/*  
    function trimExt(): Uri
 */
static EjsUri *uri_trimExt(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    nuri->ext = 0;
    nuri->path = mprTrimPathExt(nuri->path);
    return np;
}


/*  
    function set uri(value: String): Void
 */
static EjsObj *uri_set_uri(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri = httpCreateUri(ejsToMulti(ejs, argv[0]), 0);
    return 0;
}

/*********************************** Helpers **********************************/

#if UNUSED && KEEP
static char *uriToString(Ejs *ejs, EjsUri *up)
{
    HttpUri     *uri;

    uri = up->uri;
    return httpFormatUri(uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
}
#endif


static EjsUri *completeUri(Ejs *ejs, EjsUri *up, EjsObj *missing, int includeQuery)
{
    EjsUri      *missingUri;

    if (!ejsIsDefined(ejs, missing)) {
        missingUri = 0;
    } else if (ejsGetLength(ejs, missing) > 0) {
        missingUri = ejsCreateObj(ejs, ESV(Uri), 0);
        missingUri->uri = createHttpUriFromHash(ejs, missing, HTTP_COMPLETE_URI);
    } else {
        missingUri = ejsToUri(ejs, missing);
    }
    if (missingUri == 0) {
        if (!includeQuery) {
            up->uri->query = NULL;
        }
        httpCompleteUri(up->uri, NULL);
    } else {
        httpCompleteUri(up->uri, missingUri->uri);
    }
    return up;
}


static HttpUri *toHttpUri(Ejs *ejs, EjsObj *arg, int dup)
{
    HttpUri     *uri;

    if (!ejsIsDefined(ejs, arg)) {
        arg = ESV(empty);
    } 
    if (ejsIs(ejs, arg, String)) {
        uri = httpCreateUri(ejsToMulti(ejs, arg), 0);

    } else if (ejsIs(ejs, arg, Uri)) {
        if (dup) {
            uri = httpCloneUri(((EjsUri*) arg)->uri, 0);
        } else {
            uri = ((EjsUri*) arg)->uri;
        }

    } else if (ejsIs(ejs, arg, Path)) {
        uri = httpCreateUri(((EjsPath*) arg)->value, 0);

    } else if (ejsGetLength(ejs, arg) > 0) {
        uri = createHttpUriFromHash(ejs, arg, 0);

    } else {
        arg = (EjsObj*) ejsToString(ejs, arg);
        uri = httpCreateUri(ejsToMulti(ejs, arg), 0);
    }
    return uri;
}


static int same(Ejs *ejs, HttpUri *u1, HttpUri *u2, int exact)
{
    if (u1 == u2) {
        return 1;
    }
    if ((u1->scheme && !u2->scheme) || (!u1->scheme && u2->scheme)) {
        return 0;
    }
    if (u1->scheme && strcmp(u1->scheme, u2->scheme) != 0) {
        return 0;
    }
    if ((u1->host && !u2->host) || (!u1->host && u2->host)) {
        return 0;
    }
    if (u1->host && strcmp(u1->host, u2->host) != 0) {
        return 0;
    }
    if ((u1->path && !u2->path) || (!u1->path && u2->path)) {
        return 0;
    }
    if (u1->path && strcmp(u1->path, u2->path) != 0) {
        return 0;
    }
    if (u1->port != u2->port) {
        return 0;
    }
    if (exact) {
        if ((u1->reference && !u2->reference) || (!u1->reference && u2->reference)) {
            return 0;
        }
        if (u1->reference && strcmp(u1->reference, u2->reference) != 0) {
            return 0;
        }
        if ((u1->query && !u2->query) || (!u1->query && u2->query)) {
            return 0;
        }
        if (u1->query && strcmp(u1->query, u2->query) != 0) {
            return 0;
        }
    }
    return 1;
}


static HttpUri *createHttpUriFromHash(Ejs *ejs, EjsObj *arg, int flags)
{
    EjsObj      *schemeObj, *hostObj, *portObj, *pathObj, *referenceObj, *queryObj, *uriObj;
    cchar       *scheme, *host, *path, *reference, *query;
    int         port;

    /*
        This permits a uri property override. Used in ejs.web::View.getOptions()
     */
    uriObj = ejsGetPropertyByName(ejs, arg, EN("uri"));
    if (uriObj) {
        return toHttpUri(ejs, uriObj, 1);
    }
    schemeObj = ejsGetPropertyByName(ejs, arg, EN("scheme"));
    scheme = ejsIs(ejs, schemeObj, String) ? ejsToMulti(ejs, schemeObj) : 0;

    hostObj = ejsGetPropertyByName(ejs, arg, EN("host"));
    host = ejsIs(ejs, hostObj, String) ? ejsToMulti(ejs, hostObj) : 0;

    port = 0;
    if ((portObj = ejsGetPropertyByName(ejs, arg, EN("port"))) != 0) {
        if (ejsIs(ejs, portObj, Number)) {
            port = ejsGetInt(ejs, portObj);
        } else if (ejsIs(ejs, portObj, String)) {
            port = (int) stoi(ejsToMulti(ejs, portObj));
        }
    }
    pathObj = ejsGetPropertyByName(ejs, arg, EN("path"));
    path = ejsIs(ejs, pathObj, String) ? ejsToMulti(ejs, pathObj) : 0;

    referenceObj = ejsGetPropertyByName(ejs, arg, EN("reference"));
    reference = ejsIs(ejs, referenceObj, String) ? ejsToMulti(ejs, referenceObj) : 0;

    queryObj = ejsGetPropertyByName(ejs, arg, EN("query"));
    query = ejsIs(ejs, queryObj, String) ? ejsToMulti(ejs, queryObj) : 0;

    return httpCreateUriFromParts(scheme, host, port, path, reference, query, flags);
}


/*  
    Decode a Uri (ECMA Standard)

    function decodeURI(str: String): String
 */
static EjsObj *decodeURI(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    Decode a Uri component (ECMA Standard)
    function decodeURIComponent(str: String): String
 */
static EjsObj *decodeURIComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprUriDecode(ejsToMulti(ejs, argv[0])));
}


/*  
    Uri Encode a string (ECMA Standard)
    function encodeURI(str: String): String
 */
static EjsObj *encodeURI(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_JS_URI));
}


/*  
    Encode a Uri component (ECMA Standard)
    static function encodeComponent(str: String): String
 */
static EjsObj *encodeURIComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    char    *encoded;

    encoded = mprUriEncode(ejsToMulti(ejs, argv[0]), MPR_ENCODE_JS_URI_COMPONENT);
    return (EjsObj*) ejsCreateStringFromAsc(ejs, encoded);
}


/*********************************** Factory **********************************/

PUBLIC EjsUri *ejsCreateUri(Ejs *ejs, EjsString *path)
{
    EjsUri      *up;

    if ((up = ejsCreateObj(ejs, ESV(Uri), 0)) == NULL) {
        return 0;
    }
    uri_constructor(ejs, up, 1, (EjsObj**) (void*) &path);
    return up;
}


PUBLIC EjsUri *ejsCreateUriFromAsc(Ejs *ejs, cchar *path)
{
    EjsUri      *up;
    EjsObj      *arg;

    if ((up = ejsCreateObj(ejs, ESV(Uri), 0)) == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateStringFromAsc(ejs, path);
    uri_constructor(ejs, up, 1, (EjsObj**) &arg);
    return up;
}


PUBLIC EjsUri *ejsCreateUriFromParts(Ejs *ejs, cchar *scheme, cchar *host, int port, cchar *path, cchar *query, cchar *reference, 
    int flags)
{
    EjsUri      *up;

    if ((up = ejsCreateObj(ejs, ESV(Uri), 0)) == 0) {
        return 0;
    }
    up->uri = httpCreateUriFromParts(scheme, host, port, path, reference, query, flags);
    return up;
}


static void manageUri(EjsUri *up, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(up->uri);
    }
}


PUBLIC void ejsConfigureUriType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Uri"), sizeof(EjsUri), manageUri,
            EJS_TYPE_OBJ | EJS_TYPE_MUTABLE_INSTANCES)) != 0) {
        type->helpers.clone = (EjsCloneHelper) cloneUri;
        //  TODO - Add cast helper to cast from Strings, Paths etc.
        type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeUriOperator;

        ejsBindMethod(ejs, type, ES_Uri_decode, uri_decode);
        ejsBindMethod(ejs, type, ES_Uri_decodeComponent, uri_decodeComponent);
        ejsBindMethod(ejs, type, ES_Uri_encode, uri_encode);
        ejsBindMethod(ejs, type, ES_Uri_encodeComponent, uri_encodeComponent);
        ejsBindMethod(ejs, type, ES_Uri_template, uri_template);

        prototype = type->prototype;
        ejsBindConstructor(ejs, type, uri_constructor);
        ejsBindMethod(ejs, prototype, ES_Uri_absolute, uri_absolute);
        ejsBindMethod(ejs, prototype, ES_Uri_basename, uri_basename);
        ejsBindMethod(ejs, prototype, ES_Uri_complete, uri_complete);
        ejsBindMethod(ejs, prototype, ES_Uri_components, uri_components);
        ejsBindMethod(ejs, prototype, ES_Uri_dirname, uri_dirname);
        ejsBindAccess(ejs, prototype, ES_Uri_extension, uri_extension, uri_set_extension);
        ejsBindMethod(ejs, prototype, ES_Uri_hasExtension, uri_hasExtension);
        ejsBindMethod(ejs, prototype, ES_Uri_hasHost, uri_hasHost);
        ejsBindMethod(ejs, prototype, ES_Uri_hasPort, uri_hasPort);
        ejsBindMethod(ejs, prototype, ES_Uri_hasQuery, uri_hasQuery);
        ejsBindMethod(ejs, prototype, ES_Uri_hasReference, uri_hasReference);
        ejsBindMethod(ejs, prototype, ES_Uri_hasScheme, uri_hasScheme);
        ejsBindAccess(ejs, prototype, ES_Uri_host, uri_host, uri_set_host);
        ejsBindMethod(ejs, prototype, ES_Uri_isAbsolute, uri_isAbsolute);
        ejsBindMethod(ejs, prototype, ES_Uri_isDir, uri_isDir);
        ejsBindMethod(ejs, prototype, ES_Uri_join, uri_join);
        ejsBindMethod(ejs, prototype, ES_Uri_joinExt, uri_joinExt);
        ejsBindMethod(ejs, prototype, ES_Uri_local, uri_local);
        ejsBindMethod(ejs, prototype, ES_Uri_mimeType, uri_mimeType);
        ejsBindMethod(ejs, prototype, ES_Uri_normalize, uri_normalize);
        ejsBindAccess(ejs, prototype, ES_Uri_path, uri_path, uri_set_path);
        ejsBindAccess(ejs, prototype, ES_Uri_port, uri_port, uri_set_port);
        ejsBindAccess(ejs, prototype, ES_Uri_scheme, uri_scheme, uri_set_scheme);
        ejsBindAccess(ejs, prototype, ES_Uri_query, uri_query, uri_set_query);
        ejsBindAccess(ejs, prototype, ES_Uri_reference, uri_reference, uri_set_reference);
        ejsBindMethod(ejs, prototype, ES_Uri_replaceExt, uri_replaceExtension);
        ejsBindMethod(ejs, prototype, ES_Uri_relative, uri_relative);
        ejsBindMethod(ejs, prototype, ES_Uri_resolve, uri_resolve);
        ejsBindMethod(ejs, prototype, ES_Uri_same, uri_same);
        ejsBindMethod(ejs, prototype, ES_Uri_toString, uri_toString);
        ejsBindMethod(ejs, prototype, ES_Uri_toLocalString, uri_toLocalString);
        ejsBindMethod(ejs, prototype, ES_Uri_trimExt, uri_trimExt);
        ejsBindAccess(ejs, prototype, ES_Uri_uri, uri_toString, uri_set_uri);
    }
    ejsBindMethod(ejs, ejs->global, ES_decodeURI, decodeURI);
    ejsBindMethod(ejs, ejs->global, ES_decodeURIComponent, decodeURIComponent);
    ejsBindMethod(ejs, ejs->global, ES_encodeURI, encodeURI);
    ejsBindMethod(ejs, ejs->global, ES_encodeURIComponent, encodeURIComponent);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsVoid.c"
 */
/************************************************************************/

/**
    ejsVoid.c - Ejscript Void class (aka undefined)

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************* Void Helpers *******************************/
/*
    Cast the void operand to a primitive type
 */

static EjsAny *castVoid(Ejs *ejs, EjsVoid *vp, EjsType *type)
{
    switch (type->sid) {
    case S_Boolean:
        return ESV(false);

    case S_Number:
        return ESV(nan);

    case S_Object:
        return vp;

    case S_String:
        return ejsCreateStringFromAsc(ejs, "undefined");

    case S_Uri:
        return ejsCreateUriFromAsc(ejs, "undefined");
            
    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}



static EjsAny *coerceVoidOperands(Ejs *ejs, EjsVoid *lhs, int opcode, EjsVoid *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (!ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);
        }
        /* Fall through */

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ESV(nan), opcode, rhs);

    /*
     *  Comparision
     */
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        return ESV(false);

    case EJS_OP_COMPARE_NE:
        if (ejsIs(ejs, rhs, Null)) {
            return ESV(false);
        }
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return ESV(true);

    case EJS_OP_COMPARE_EQ:
        if (ejsIs(ejs, rhs, Null)) {
            return ESV(true);
        }
        return ESV(false);

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return ESV(false);

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return ESV(true);

    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}



static EjsObj *invokeVoidOperator(Ejs *ejs, EjsVoid *lhs, int opcode, EjsVoid *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = coerceVoidOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*
     *  Types match, left and right types are both "undefined"
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return ESV(true);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return ESV(nan);

    /*
     *  Binary operators
     */
    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ESV(nan);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    assert(0);
}


/*
    iterator native function get(): Iterator
 */
static EjsIterator *getVoidIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return ejsCreateIterator(ejs, np, -1, NULL, 0, NULL);
}


static EjsObj *getVoidProperty(Ejs *ejs, EjsVoid *unused, int slotNum)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
    return 0;
}


/*********************************** Factory **********************************/
/*
    We don't actually create any instances. We just use a reference to the undefined singleton instance.
 */
PUBLIC EjsVoid *ejsCreateUndefined(Ejs *ejs)
{
    return (EjsVoid*) ESV(undefined);
}


PUBLIC void ejsCreateVoidType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", "Void"), sizeof(EjsVoid), S_Void, ES_Void_NUM_CLASS_PROP, NULL, 
        EJS_TYPE_OBJ);

    type->helpers.cast             = (EjsCastHelper) castVoid;
    type->helpers.invokeOperator   = (EjsInvokeOperatorHelper) invokeVoidOperator;
    type->helpers.getProperty      = (EjsGetPropertyHelper) getVoidProperty;

    ejsAddImmutable(ejs, ES_undefined, EN("undefined"), ejsCreateObj(ejs, type, 0));
    mprSetName(ESV(undefined), "undefined");
}


PUBLIC void ejsConfigureVoidType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "Void"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_Void_iterator_get, getVoidIterator);
    ejsBindMethod(ejs, prototype, ES_Void_iterator_getValues, getVoidIterator);
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsWebSocket.c"
 */
/************************************************************************/

/**
    ejsWebSocket.c - WebSocket class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */
/********************************** Includes **********************************/



#if ME_HTTP_WEB_SOCKETS
/*********************************** Forwards *********************************/

static void onWebSocketEvent(EjsWebSocket *ws, int event, EjsAny *data, HttpPacket *packet);
static EjsObj *startWebSocketRequest(Ejs *ejs, EjsWebSocket *ws);
static bool waitForHttpState(EjsWebSocket *ws, int state, MprTicks timeout, int throw);
static bool waitForReadyState(EjsWebSocket *ws, int state, MprTicks timeout, int throw);
static void webSocketNotify(HttpConn *conn, int state, int notifyFlags);

/************************************ Methods *********************************/
/*  
    function WebSocket(uri: Uri, protocols = null, options)

    options = {
        certificate: Path,
        verify: Boolean,
    }
 */
static EjsWebSocket *wsConstructor(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    EjsAny      *certificate;
    bool        verify;

    assert(ejsIsPot(ejs, ws));

    ejsLoadHttpService(ejs);
    ws->ejs = ejs;
    verify = 0;

    ws->uri = httpUriToString(((EjsUri*) argv[0])->uri, 0);
    if (argc >= 2) {
        if (ejsIs(ejs, argv[1], Array)) {
            ws->protocols = sclone((ejsToString(ejs, argv[1]))->value);
        } else if (ejsIs(ejs, argv[1], String)) {
            ws->protocols = sclone(((EjsString*) argv[1])->value);
        } else {
            ws->protocols = sclone("chat");
        }
    } else {
        ws->protocols = sclone("chat");
    }
    if (*ws->protocols == '\0') {
        ejsThrowArgError(ejs, "Bad protocol");
        return 0;
    }
    if (argc >= 3) {
        ws->frames = ejsGetPropertyByName(ejs, argv[2], EN("frames")) == ESV(true);
        verify = ejsGetPropertyByName(ejs, argv[2], EN("verify")) == ESV(true);
        if ((certificate = ejsGetPropertyByName(ejs, argv[2], EN("certificate"))) != 0) {
            ws->certFile = ejsToMulti(ejs, argv[0]);
        }
    }
    if ((ws->conn = httpCreateConn(MPR->httpService, NULL, ejs->dispatcher)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    httpSetAsync(ws->conn, 1);
    httpPrepClientConn(ws->conn, 0);
    httpSetConnNotifier(ws->conn, webSocketNotify);
    httpSetWebSocketProtocols(ws->conn, ws->protocols);
    httpSetConnContext(ws->conn, ws);
    if (sstarts(ws->uri, "wss")) {
        ws->ssl = mprCreateSsl(0);
        mprVerifySslIssuer(ws->ssl, verify);
        mprVerifySslPeer(ws->ssl, verify);
#if FUTURE
        if (!hp->caFile) {
            //TODO - Some define for this.
            hp->caFile = mprJoinPath(mprGetAppDir(), "http-ca.crt");
        }
        mprSetSslCaFile(hp->ssl, hp->caFile);
        mprSetSslCaFile(hp->ssl, mprJoinPath(mprGetAppDir(), "http-ca.crt"));
#endif
    }
    startWebSocketRequest(ejs, ws);
    return ws;
}


/*
    function get binaryType(): String
    NOTE: always returns ByteArray
 */
static EjsString *ws_binaryType(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, "ByteArray");
}


/*  
    function get bufferedAmount(): Number

    Returns amount of buffered send data
 */
static EjsNumber *ws_bufferedAmount(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) ws->conn->writeq->count);
}


/*  
    function close(status: Number = 1000, reason: String? = ""): Void
 */
static EjsObj *ws_close(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    HttpConn    *conn;
    char        *reason;
    int         status;

    conn = ws->conn;
    if (conn) {
        status = argc == 0 ? WS_STATUS_OK : ejsGetInt(ejs, argv[0]);
        if (status <= 999 || status >= WS_STATUS_MAX || status == WS_STATUS_NO_STATUS || status == WS_STATUS_COMMS_ERROR) {
            ejsThrowArgError(ejs, "Bad status");
            return 0;
        }
        reason = (argc >= 1) ? ejsToMulti(ejs, argv[1]): 0; 
        if (slen(reason) >= 124) {
            ejsThrowArgError(ejs, "Close reason is too long. Must be less than 124 bytes");
            return 0;
        }
        httpSendClose(conn, status, reason);
    }
    return 0;
}


/*  
    function get extensions(): String
 */
static EjsString *ws_extensions(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    return ESV(empty);
}


/*
    function off(name, observer: function): Void
 */
static EjsObj *ws_off(Ejs *ejs, EjsWebSocket *ws, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, ws->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function on(name, observer: function): Http
 */
static EjsWebSocket *ws_on(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    EjsFunction     *observer;
    HttpConn        *conn;

    observer = (EjsFunction*) argv[1];
    if (observer->boundThis == 0 || observer->boundThis == ejs->global) {
        observer->boundThis = ws;
    }
    ejsAddObserver(ejs, &ws->emitter, argv[0], observer);

    conn = ws->conn;
    if (conn->readq && conn->readq->count > 0) {
        //  TODO - can't have NULL as data
        onWebSocketEvent(ws, HTTP_EVENT_READABLE, 0, 0);
    }
    //  TODO - don't need to test finalizedConnector
    if (!conn->tx->finalizedConnector && 
            !conn->error && HTTP_STATE_CONNECTED <= conn->state && conn->state < HTTP_STATE_FINALIZED &&
            conn->writeq->ioCount == 0) {
        onWebSocketEvent(ws, HTTP_EVENT_WRITABLE, 0, 0);
    }
    return ws;
}


/*  
    function get protocol(): String
 */
static EjsString *ws_protocol(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, ws->protocols);
}


/*  
    function get readyState(): Number
 */
static EjsNumber *ws_readyState(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    //  TODO - should have API for this
    return ejsCreateNumber(ejs, (MprNumber) ws->conn->rx->webSocket->state);
}


/*  
    function send(...content): Number
 */
static EjsNumber *ws_send(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *ba;
    EjsAny          *arg;
    ssize           nbytes;
    int             i;

    args = (EjsArray*) argv[0];
    if (ws->conn->state < HTTP_STATE_PARSED && !waitForHttpState(ws, HTTP_STATE_PARSED, -1, 1)) {
        return ESV(null);
    }
    nbytes = 0;
    for (i = 0; i < args->length; i++) {
        if ((arg = ejsGetProperty(ejs, args, i)) != 0) {
            if (ejsIs(ejs, arg, ByteArray)) {
                ba = (EjsByteArray*) arg;
                nbytes = ejsGetByteArrayAvailableData(ba);
                nbytes = httpSendBlock(ws->conn, WS_MSG_BINARY, (cchar*) &ba->value[ba->readPosition], nbytes, HTTP_BLOCK);
            } else {
                nbytes = httpSend(ws->conn, ejsToMulti(ejs, arg));
            }
            if (nbytes < 0) {
                return ESV(null);
            }
        }
    }
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}


/*  
    function sendBlock(content, options): Number
 */
static EjsNumber *ws_sendBlock(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    EjsByteArray    *ba;
    EjsAny          *content, *vp;
    ssize           nbytes;
    cchar           *str;
    int             last, mode, type, flags;

    assert(argc == 2);

    if (ws->conn->state < HTTP_STATE_PARSED && !waitForHttpState(ws, HTTP_STATE_PARSED, -1, 1)) {
        return ESV(null);
    }
    content = argv[0];
    last = ejsGetPropertyByName(ejs, argv[1], EN("last")) != ESV(false);
    if ((vp = ejsGetPropertyByName(ejs, argv[1], EN("mode"))) != 0) {
        mode = (int) ejsGetNumber(ejs, vp);
        if (mode != HTTP_BUFFER && mode != HTTP_BLOCK && mode != HTTP_NON_BLOCK) {
            ejsThrowArgError(ejs, "Bad message mode");
            return 0;
        }
    } else {
        mode = HTTP_BUFFER;
    }
    if ((vp = ejsGetPropertyByName(ejs, argv[1], EN("type"))) != 0) {
        type = (int) ejsGetNumber(ejs, vp);
        if (type != WS_MSG_CONT && type != WS_MSG_TEXT && type != WS_MSG_BINARY) {
            ejsThrowArgError(ejs, "Bad message type");
            return 0;
        }
    } else {
        type = WS_MSG_TEXT;
    }
    flags = mode;
    if (!last) {
        flags |= HTTP_MORE;
    }
    if (ejsIs(ejs, content, ByteArray)) {
        ba = (EjsByteArray*) content;
        nbytes = ejsGetByteArrayAvailableData(ba);
        nbytes = httpSendBlock(ws->conn, type, (cchar*) &ba->value[ba->readPosition], nbytes, flags);
    } else {
        str = ejsToMulti(ejs, content);
        nbytes = httpSendBlock(ws->conn, type, str, slen(str), flags);
    }
    if (nbytes < 0) {
        ejsThrowIOError(ejs, "Cannot send block");
        return 0;
    }
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}


/*
    function get url(): Uri
 */
static EjsUri *ws_url(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    return ejsCreateUriFromAsc(ejs, ws->uri);
}


/*
    Wait for a request to complete. Timeout is in msec. Timeout < 0 means use default inactivity and request timeouts.
    Timeout of zero means no timeout.

    function wait(state: Number, timeout: Number = -1): Boolean
 */
static EjsUri *ws_wait(Ejs *ejs, EjsWebSocket *ws, int argc, EjsObj **argv)
{
    MprTicks    timeout;
    int         state;

    state = argc >= 1 ? ejsGetInt(ejs, argv[0]) : WS_STATE_CLOSED;
    timeout = argc >= 2 ? ejsGetInt(ejs, argv[1]) : -1;
    if (timeout == 0) {
        timeout = MPR_MAX_TIMEOUT;
    }
    if (!waitForReadyState(ws, state, timeout, 0)) {
        return ESV(false);
    }
    return ESV(true);
}

/*********************************** Support **********************************/

static EjsObj *startWebSocketRequest(Ejs *ejs, EjsWebSocket *ws)
{
    HttpConn        *conn;

    conn = ws->conn;
    if (ws->certFile) {
        if (!ws->ssl) {
            ws->ssl = mprCreateSsl(0);
        }
        mprSetSslCertFile(ws->ssl, ws->certFile);
    }
    if (httpConnect(conn, "GET", ws->uri, ws->ssl) < 0) {
        ejsThrowIOError(ejs, "Cannot issue request for \"%s\"", ws->uri);
        return 0;
    }
    httpEnableConnEvents(ws->conn);
    return 0;
}


static void onWebSocketEvent(EjsWebSocket *ws, int event, EjsAny *data, HttpPacket *packet)
{
    Ejs             *ejs;
    EjsAny          *eobj;
    EjsFunction     *fn;
    HttpRx          *rx;
    cchar           *eventName, *reason;
    int             slot, status;

    ejs = ws->ejs;
    rx = ws->conn->rx;
    eobj = ejsCreateObj(ejs, ESV(Object), 0);
    slot = -1;
    eventName = 0;

    switch(event) {
    case HTTP_EVENT_READABLE:
        slot = ES_WebSocket_onmessage;
        eventName = "readable";
        assert(data);
        ejsSetPropertyByName(ejs, eobj, EN("data"), data);
        ejsSetPropertyByName(ejs, eobj, EN("last"), ejsCreateBoolean(ejs, packet->last));
        ejsSetPropertyByName(ejs, eobj, EN("type"), ejsCreateNumber(ejs, packet->type));
        break;

    case HTTP_EVENT_ERROR:
        eventName = "error";
        slot = ES_WebSocket_onerror;
        break;

    case HTTP_EVENT_APP_OPEN:
        slot = ES_WebSocket_onopen;
        eventName = "headers";
        if (rx->webSocket) {
            httpSetWebSocketPreserveFrames(ws->conn, ws->frames);
        }
        break;

    case HTTP_EVENT_DESTROY:
        if (ws->closed) {
            break;
        }
        ws->closed = 1;
        /* Fall through to close */

    case HTTP_EVENT_APP_CLOSE:
        eventName = "complete";
        slot = ES_WebSocket_onclose;
        status = (rx && rx->webSocket) ? rx->webSocket->closeStatus: WS_STATUS_COMMS_ERROR;
        reason = (rx && rx->webSocket) ? rx->webSocket->closeReason: ws->conn->errorMsg;
        ejsSetPropertyByName(ejs, eobj, EN("code"), ejsCreateNumber(ejs, status));
        ejsSetPropertyByName(ejs, eobj, EN("reason"), ejsCreateStringFromAsc(ejs, reason));
        ejsSetPropertyByName(ejs, eobj, EN("wasClean"), ejsCreateBoolean(ejs, status != WS_STATUS_COMMS_ERROR));
        break;
    }
    if (slot >= 0) {
        if (ws->emitter) {
            ejsSendEvent(ejs, ws->emitter, eventName, ws, data);
        }
        fn = ejsGetProperty(ejs, ws, slot);
        if (ejsIsFunction(ejs, fn) && !ejs->exception) {
            ejsRunFunction(ejs, fn, ws, 1, &eobj);
        }
    }
}


/*
    Connection callback
 */
static void webSocketNotify(HttpConn *conn, int event, int arg)
{
    Ejs             *ejs;
    EjsWebSocket    *ws;
    EjsByteArray    *ba;
    EjsAny          *data;
    HttpPacket      *packet;
    MprBuf          *content;
    ssize           len;

    if ((ws = httpGetConnContext(conn)) == 0) {
        return;
    }
    ejs = ws->ejs;
    if (!ejs->service) {
        /* Shutting down */
        return;
    }
    switch (event) {
    case HTTP_EVENT_STATE:
        if (arg == HTTP_STATE_CONTENT) {
            ws->protocol = (char*) httpGetHeader(conn, "Sec-WebSocket-Protocol");
            mprTrace(3, "Web socket protocol %s", ws->protocol);
            onWebSocketEvent(ws, HTTP_EVENT_APP_OPEN, 0, 0);
        }
        break;
    
    case HTTP_EVENT_READABLE:
        packet = httpGetPacket(conn->readq);
        content = packet->content;
        if (packet->type == WS_MSG_TEXT) {
            data = ejsCreateStringFromBytes(ejs, mprGetBufStart(content), mprGetBufLength(content));
        } else {
            len = httpGetPacketLength(packet);
            assert(len > 0);
            if ((ba = ejsCreateByteArray(ejs, len)) == 0) {
                return;
            }
            memcpy(ba->value, mprGetBufStart(content), len);
            ejsSetByteArrayPositions(ejs, ba, -1, len);
            data = ba;
        }
        onWebSocketEvent(ws, event, data, packet);
        break;

    case HTTP_EVENT_ERROR:
        if (!ws->error && !ws->closed) {
            ws->error = 1;
            onWebSocketEvent(ws, event, 0, 0);
            ws->closed = 1;
            onWebSocketEvent(ws, HTTP_EVENT_APP_CLOSE, 0, 0);
        }
        break;

    case HTTP_EVENT_APP_CLOSE:
        if (!ws->closed) {
            ws->closed = 1;
            onWebSocketEvent(ws, event, 0, 0);
        }
        break;
    }
}


static bool waitForHttpState(EjsWebSocket *ws, int state, MprTicks timeout, int throw)
{
    Ejs             *ejs;
    MprTicks        mark, remaining;
    HttpConn        *conn;
    HttpUri         *location, *uri;
    char            *url;
    int             count, redirectCount, success, rc;

    assert(state >= HTTP_STATE_PARSED);

    ejs = ws->ejs;
    conn = ws->conn;
    assert(conn->state >= HTTP_STATE_CONNECTED);

    if (conn->state >= state) {
        return 1;
    }
    if (conn->state < HTTP_STATE_CONNECTED) {
        if (throw && ejs->exception == 0) {
            ejsThrowIOError(ejs, "Http request failed: not connected");
        }
        return 0;
    }
    if (!conn->async) {
        httpFinalize(conn);
    }
    redirectCount = 0;
    success = count = 0;
    mark = mprGetTicks();
    remaining = timeout;
    while (conn->state < state && count <= conn->retries && redirectCount < 16 && 
           !conn->error && !ejs->exiting && !mprIsStopping(conn)) {
        count++;
        if ((rc = httpWait(conn, HTTP_STATE_PARSED, remaining)) == 0) {
            if (httpNeedRetry(conn, &url)) {
                if (url) {
                    location = httpCreateUri(url, 0);
                    uri = httpJoinUri(conn->tx->parsedUri, 1, &location);
                    ws->uri = httpUriToString(uri, HTTP_COMPLETE_URI);
                }
                count--; 
                redirectCount++;
            } else if (httpWait(conn, state, remaining) == 0) {
                success = 1;
                break;
            }
        } else {
            if (rc == MPR_ERR_CANT_CONNECT) {
                httpError(conn, HTTP_CODE_COMMS_ERROR, "Connection error");
            } else if (rc == MPR_ERR_TIMEOUT) {
                if (timeout > 0) {
                    httpError(conn, HTTP_CODE_REQUEST_TIMEOUT, "Request timed out");
                }
            } else {
                httpError(conn, HTTP_CODE_NO_RESPONSE, "Client request error");
            }
            break;
        }
        if (conn->rx) {
            if (conn->rx->status == HTTP_CODE_REQUEST_TOO_LARGE || conn->rx->status == HTTP_CODE_REQUEST_URL_TOO_LARGE) {
                /* No point retrying */
                break;
            }
        }
        if (timeout > 0) {
            remaining = mprGetRemainingTicks(mark, timeout);
            if (count > 0 && remaining <= 0) {
                break;
            }
        }
        /* Force a new connection */
        if (conn->rx == 0 || conn->rx->status != HTTP_CODE_UNAUTHORIZED) {
            httpSetKeepAliveCount(conn, -1);
        }
        httpPrepClientConn(conn, 1);
        if (startWebSocketRequest(ejs, ws) < 0) {
            return 0;
        }
        if (!conn->async) {
            httpFinalize(conn);
        }
    }
    if (!success) {
        if (throw && ejs->exception == 0) {
            ejsThrowIOError(ejs, "Http request failed: %s", (conn->errorMsg) ? conn->errorMsg : "");
        }
        return 0;
    }
    return 1;
}


static bool waitForReadyState(EjsWebSocket *ws, int state, MprTicks timeout, int throw)
{
    Ejs             *ejs;
    HttpConn        *conn;
    HttpRx          *rx;
    MprTicks        mark, remaining, inactivityTimeout;
    int             eventMask;

    ejs = ws->ejs;
    conn = ws->conn;
    rx = conn->rx;
    assert(conn->state >= HTTP_STATE_CONNECTED);

    if (!rx || !rx->webSocket) {
        return 0;
    }
    eventMask = MPR_READABLE;
    if (!conn->tx->finalizedConnector) {
        eventMask |= MPR_WRITABLE;
    }
    if (rx->webSocket->state < state) {
        httpSetupWaitHandler(conn, eventMask);
    }
    if (mprGetDebugMode()) {
        inactivityTimeout = timeout = MPR_MAX_TIMEOUT;
    } else {
        inactivityTimeout = timeout < 0 ? conn->limits->inactivityTimeout : MPR_MAX_TIMEOUT;
    }
    if (timeout < 0) {
        timeout = conn->limits->requestTimeout;
    }
    mark = mprGetTicks();
    remaining = timeout;
    while (conn->state < HTTP_STATE_CONTENT || rx->webSocket->state < state) {
        if (conn->error || ejs->exiting || mprIsStopping(conn) || remaining < 0) {
            break;
        }
        mprWaitForEvent(conn->dispatcher, min(inactivityTimeout, remaining));
        remaining = mprGetRemainingTicks(mark, timeout);
    }
    return rx->webSocket->state >= state;
}


/*********************************** Factory **********************************/

/*  
    Manage the object properties for the garbage collector
 */
static void manageWebSocket(EjsWebSocket *ws, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ws->conn);
        mprMark(ws->emitter);
        mprMark(ws->ssl);
        mprMark(ws->certFile);
        mprMark(ws->protocols);
        mprMark(ws->protocol);
        mprMark(ws->uri);
        ejsManagePot((EjsPot*) ws, flags);

    } else if (flags & MPR_MANAGE_FREE) {
        if (ws->conn && ws->ejs->service) {
            httpDestroyConn(ws->conn);
            ws->conn = 0;
        }
    }
}


PUBLIC void ejsConfigureWebSocketType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "WebSocket"), sizeof(EjsWebSocket), 
            manageWebSocket, EJS_TYPE_POT)) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, wsConstructor);
    ejsBindMethod(ejs, prototype, ES_WebSocket_bufferedAmount, ws_bufferedAmount);
    ejsBindMethod(ejs, prototype, ES_WebSocket_binaryType, ws_binaryType);
    ejsBindMethod(ejs, prototype, ES_WebSocket_close, ws_close);
    ejsBindMethod(ejs, prototype, ES_WebSocket_extensions, ws_extensions);
    ejsBindMethod(ejs, prototype, ES_WebSocket_off, ws_off);
    ejsBindMethod(ejs, prototype, ES_WebSocket_on, ws_on);
    ejsBindMethod(ejs, prototype, ES_WebSocket_protocol, ws_protocol);
    ejsBindMethod(ejs, prototype, ES_WebSocket_readyState, ws_readyState);
    ejsBindMethod(ejs, prototype, ES_WebSocket_send, ws_send);
    ejsBindMethod(ejs, prototype, ES_WebSocket_sendBlock, ws_sendBlock);
    ejsBindMethod(ejs, prototype, ES_WebSocket_url, ws_url);
    ejsBindMethod(ejs, prototype, ES_WebSocket_wait, ws_wait);
}
#endif /* ME_HTTP_WEB_SOCKETS */

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsWorker.c"
 */
/************************************************************************/

/*
    ejsWorker - VM Worker thread classes

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */
/********************************** Includes **********************************/



/*********************************** Locals ***********************************/

typedef struct Message {
    EjsWorker   *worker;
    cchar       *callback;
    char        *data;
    EjsObj      *message;
    EjsObj      *stack;
    int         callbackSlot;
} Message;

/*********************************** Forwards *********************************/

static void addWorker(Ejs *ejs, EjsWorker *worker);
static int join(Ejs *ejs, EjsObj *workers, int timeout);
static void handleError(Ejs *ejs, EjsWorker *worker, EjsObj *exception, int throwOutside);
static void loadFile(EjsWorker *insideWorker, cchar *filename);
static void removeWorker(EjsWorker *worker);
static int workerMain(EjsWorker *worker, MprEvent *event);
static EjsObj *workerPreload(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv);

/************************************ Methods *********************************/

static EjsWorker *initWorker(Ejs *ejs, EjsWorker *worker, Ejs *baseVM, cchar *name, EjsArray *search, cchar *scriptFile)
{
    Ejs             *wejs;
    EjsWorker       *self;
    EjsName         sname;
    static int      workerSeqno = 0;

    ejsBlockGC(ejs);
    if (worker == 0) {
        worker = ejsCreateWorker(ejs);
    }
    worker->ejs = ejs;
    worker->state = EJS_WORKER_BEGIN;

    if (name) {
        worker->name = sclone(name);
    } else {
        lock(ejs);
        worker->name = sfmt("worker-%d", workerSeqno++);
        unlock(ejs);
    }
    /*
        Create a new interpreter and an "inside" worker object and pair it with the current "outside" worker.
        The worker interpreter gets a new dispatcher
     */
    if (baseVM) {
        if ((wejs = ejsCloneVM(baseVM)) == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    } else {
        if ((wejs = ejsCreateVM(0, 0, ejs->flags)) == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        if (ejsLoadModules(wejs, 0, 0) < 0) {
            return 0;
        }
    }
    worker->pair = self = ejsCreateWorker(wejs);
    self->state = EJS_WORKER_BEGIN;
    self->ejs = wejs;
    self->inside = 1;
    self->pair = worker;
    self->name = sjoin("inside-", worker->name, NULL);
    if (search) {
        ejsSetSearchPath(ejs, (EjsArray*) search);
    }

    //  TODO - these should be don't delete
    ejsSetProperty(ejs, worker, ES_Worker_name, ejsCreateStringFromAsc(ejs, self->name));
    ejsSetProperty(wejs, self,  ES_Worker_name, ejsCreateStringFromAsc(wejs, self->name));

    sname = ejsName(wejs, EJS_WORKER_NAMESPACE, "self");
    ejsSetPropertyByName(wejs, wejs->global, sname, self);

    /*
        Workers have a dedicated namespace to enable viewing of the worker globals (self, onmessage, postMessage...)
     */
    ejsDefineReservedNamespace(wejs, wejs->global, NULL, EJS_WORKER_NAMESPACE);
    
    addWorker(ejs, worker);

    if (scriptFile) {
        worker->scriptFile = sclone(scriptFile);
        worker->state = EJS_WORKER_STARTED;
        if (mprCreateEvent(wejs->dispatcher, "workerMain", 0, (MprEventProc) workerMain, self, 0) < 0) {
            mprRemoveItem(ejs->workers, worker);
            ejsThrowStateError(ejs, "Cannot create worker event");
            return 0;
        }
    }
    return worker;
}


static EjsWorker *workerConstructor(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    EjsArray    *search;
    EjsObj      *options, *value;
    cchar       *name, *scriptFile;

    ejsBlockGC(ejs);

    scriptFile = (argc >= 1 && argv[0] != ESV(null)) ? ((EjsPath*) argv[0])->value : 0;
    options = (argc == 2 && argv[1] != ESV(null)) ? (EjsObj*) argv[1]: NULL;
    name = 0;
    search = 0;
    if (options) {
        search = ejsGetPropertyByName(ejs, options, EN("search"));
        value = ejsGetPropertyByName(ejs, options, EN("name"));
        if (ejsIs(ejs, value, String)) {
            name = ejsToMulti(ejs, value);
        }
    }
    worker->ejs = ejs;
    worker->state = EJS_WORKER_BEGIN;
    return initWorker(ejs, worker, 0, name, search, scriptFile);
}


/*
    Add a worker object to the list of running workers for this interpreter
 */
static void addWorker(Ejs *ejs, EjsWorker *worker) 
{
    assert(ejs == worker->ejs);
    assert(worker);
    assert(worker->state == EJS_WORKER_BEGIN);
    assert(!worker->inside);

    //  OPT - locking not needed
    lock(ejs);
    assert(ejs->workers->length < 10);
    mprAddItem(ejs->workers, worker);
    unlock(ejs);
}


static void removeWorker(EjsWorker *worker) 
{
    Ejs     *ejs;

    assert(!worker->inside);
    assert(worker);

    ejs = worker->ejs;
    if (ejs) {
        lock(ejs);
        if (ejs->workers) {
            mprRemoveItem(ejs->workers, worker);
        }
        if (ejs->joining) {
            mprSignalDispatcher(ejs->dispatcher);
        }
        /* Accelerate GC */
        if (worker->pair) {
            worker->pair->ejs = 0;
            worker->pair->pair = 0;
            worker->pair = 0;
        }
        worker->ejs = 0;        
        unlock(ejs);
    }
}


/*
    Called when destroying ejs
 */
PUBLIC void ejsRemoveWorkers(Ejs *ejs)
{
    EjsWorker   *worker;
    int         next;

    for (next = 0; (worker = mprGetNextItem(ejs->workers, &next)) != NULL; ) {
#if UNUSED
        worker->ejs = 0;
#else
        removeWorker(worker);
#endif
    }
    ejs->workers = 0;
}


/*
    Start a worker thread. This is called by eval() and load(). Not by preload() or by Worker(). It always joins.
 */
static EjsObj *startWorker(Ejs *ejs, EjsWorker *outsideWorker, int timeout)
{
    EjsWorker   *insideWorker;
    Ejs         *inside;
    EjsString   *result;

    assert(ejs);
    assert(outsideWorker);
    assert(!outsideWorker->inside);
    assert(outsideWorker->state == EJS_WORKER_BEGIN);
    assert(outsideWorker->pair);
    assert(outsideWorker->pair->ejs);

    mprTrace(5, "Worker.startWorker");

    if (outsideWorker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = outsideWorker->pair;
    assert(insideWorker->inside);
    assert(insideWorker->state == EJS_WORKER_BEGIN);
    inside = insideWorker->ejs;

    outsideWorker->state = EJS_WORKER_STARTED;

    if (mprCreateEvent(inside->dispatcher, "workerMain", 0, (MprEventProc) workerMain, insideWorker, 0) < 0) {
        ejsThrowStateError(ejs, "Cannot create worker event");
        return 0;
    }
    if (timeout == 0) {
        return ESV(undefined);
    } 
    if (timeout < 0) {
        timeout = MAXINT;
    }
    if (join(ejs, (EjsObj*) outsideWorker, timeout) < 0) {
        return ESV(undefined);
    }
    result = ejsToJSON(inside, inside->result, NULL);
    if (result == 0) {
        return ESV(null);
    }
    return ejsDeserialize(ejs, result);
}


/*
    function clone(deep: Boolean = null): Worker
 */
static EjsWorker *workerClone(Ejs *ejs, EjsWorker *baseWorker, int argc, EjsObj **argv)
{
    return initWorker(ejs, 0, baseWorker->pair->ejs, 0, 0, 0);
}


/*
    static function fork(): Worker
 */
static EjsWorker *workerFork(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    return initWorker(ejs, 0, ejs, 0, 0, 0);
}


/*
    function eval(script: String, timeout: Boolean = -1): Obj
 */
static EjsObj *workerEval(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    int     timeout;

    assert(ejsIs(ejs, argv[0], String));

    worker->scriptLiteral = (EjsString*) argv[0];
    timeout = argc == 2 ? ejsGetInt(ejs, argv[1]): MAXINT;
    return startWorker(ejs, worker, timeout);
}


/*
    static function exit()
 */
static EjsObj *workerExit(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    /*
        Setting exiting causes the VM to suspend processing this interpreter
     */
    ejs->exiting = 1;
    ejsAttention(ejs);
    return 0;
}


/*
    Return true if the join is successful
 */
static int reapJoins(Ejs *ejs, EjsObj *workers)
{
    EjsWorker   *worker;
    EjsArray    *set;
    int         i, completed, joined, count;

    lock(ejs);
    completed = 0;
    joined = 0;

    if (workers == 0 || ejsIs(ejs, workers, Null)) {
        /* Join all */
        count = mprGetListLength(ejs->workers);
        for (i = 0; i < count; i++) {
            worker = mprGetItem(ejs->workers, i);
            if (worker->state >= EJS_WORKER_COMPLETE) {
                completed++;
            }
        }
        if (completed == count) {
            joined = 1;
        }
    } else if (ejsIs(ejs, workers, Array)) {
        /* Join a set */
        set = (EjsArray*) workers;
        for (i = 0; i < set->length; i++) {
            worker = (EjsWorker*) set->data[i];
            if (worker->state >= EJS_WORKER_COMPLETE) {
                completed++;
            }
        }
        if (completed == set->length) {
            joined = 1;
        }
    } else if (TYPE(workers) == ESV(Worker)) {
        /* Join one worker */
        worker = (EjsWorker*) workers;
        if (worker->state >= EJS_WORKER_COMPLETE) {
            joined = 1;
        }
    }
    unlock(ejs);
    return joined;
}


static int join(Ejs *ejs, EjsObj *workers, int timeout)
{
    MprTicks    mark;
    int         result, remaining;

    mprTrace(5, "Worker.join: joining %d", ejs->joining);
    
    mark = mprGetTicks();
    remaining = timeout;
    do {
        ejs->joining = !reapJoins(ejs, workers);
        if (!ejs->joining) {
            break;
        }
        if (mprShouldAbortRequests()) {
            ejsThrowStateError(ejs, "Program instructed to exit");
            break;
        }
        mprWaitForEvent(ejs->dispatcher, remaining);
        remaining = (int) mprGetRemainingTicks(mark, timeout);
    } while (remaining > 0 && !ejs->exception);

    if (ejs->exception) {
        return 0;
    }
    result = (ejs->joining) ? MPR_ERR_TIMEOUT: 0;
    ejs->joining = 0;
    mprTrace(7, "Worker.join: result %d", result);
    return result;
}


/*
    static function join(workers: Object = null, timeout: Number = -1): Boolean
 */
static EjsObj *workerJoin(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    EjsObj      *workers;
    int         timeout;

    workers = (argc > 0) ? argv[0] : NULL;
    timeout = (argc == 2) ? ejsGetInt(ejs, argv[1]) : MAXINT;

    return (join(ejs, workers, timeout) == 0) ? ESV(true): ESV(false);
}


/*
    Load a file into the worker. This can be a script file or a module. This runs on the inside interpreter
 */
static void loadFile(EjsWorker *worker, cchar *path)
{
    Ejs         *ejs;
    cchar       *cp;

    assert(worker->inside);
    assert(worker->pair && worker->pair->ejs);

    ejs = worker->ejs;
    if ((cp = strrchr(path, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) != 0) {
        if (ejs->service->loadScriptFile == 0) {
            ejsThrowIOError(ejs, "load: Compiling is not enabled for %s", path);
            return;
        }
        (ejs->service->loadScriptFile)(ejs, path, NULL);

    } else {
        /* Error reporting via thrown exceptions */
        ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, path), -1, -1, EJS_LOADER_RELOAD);
    }
}


/*
    function load(script: Path, timeout: Number = 0): Void
 */
static EjsObj *workerLoad(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    int     timeout;

    assert(argc == 0 || ejsIs(ejs, argv[0], Path));

    worker->scriptFile = sclone(((EjsPath*) argv[0])->value);
    timeout = argc == 2 ? ejsGetInt(ejs, argv[1]): 0;
    return startWorker(ejs, worker, timeout);
}


/*
    static function lookup(name: String): Worker
 */
static EjsWorker *workerLookup(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsWorker   *worker;
    cchar       *name;
    int         next;

    name = ejsToMulti(ejs, argv[0]);
    lock(ejs);
    for (next = 0; (worker = mprGetNextItem(ejs->workers, &next)) != NULL; ) {
        if (worker->name && strcmp(name, worker->name) == 0) {
            unlock(ejs);
            return worker;
        }
    }
    unlock(ejs);
    return ESV(null);
}


/*
    Process a message sent from postMessage. This may run inside the worker or outside in the parent depending on the
    direction of the message. But it ALWAYS runs in the appropriate thread for the interpreter.
 */
static int doMessage(Message *msg, MprEvent *mprEvent)
{
    Ejs         *ejs;
    EjsObj      *event, *frame;
    EjsWorker   *worker;
    EjsFunction *callback;
    EjsObj      *argv[1];

    worker = msg->worker;
    worker->gotMessage = 1;
    ejs = worker->ejs;
    assert(!ejs->exception);

    event = 0;
    ejsBlockGC(ejs);

    callback = ejsGetProperty(ejs, worker, msg->callbackSlot);

    switch (msg->callbackSlot) {
    case ES_Worker_onerror:
        event = ejsCreateObj(ejs, ESV(ErrorEvent), 0);
        break;
            
    case ES_Worker_onclose:
    case ES_Worker_onmessage:
        event = ejsCreateObj(ejs, ESV(Event), 0);
        break;
            
    default:
        assert(msg->callbackSlot == 0);
        return 0;
    }
    worker->event = event;
    if (msg->data) {
        ejsSetProperty(ejs, event, ES_Event_data, ejsCreateStringFromAsc(ejs, msg->data));
    }
    if (msg->message) {
        ejsSetProperty(ejs, event, ES_ErrorEvent_message, msg->message);
    }
    if (msg->stack) {
        ejsSetProperty(ejs, event, ES_ErrorEvent_stack, msg->stack);
        if ((frame = ejsGetProperty(ejs, msg->stack, 0)) != 0 && !ejsIs(ejs, frame, Void)) {
            ejsSetProperty(ejs, event, ES_ErrorEvent_filename, ejsGetPropertyByName(ejs, frame, EN("filename")));
            ejsSetProperty(ejs, event, ES_ErrorEvent_lineno, ejsGetPropertyByName(ejs, frame, EN("lineno")));
        }
    }
    assert(!ejs->exception);

    if (callback == 0 || ejsIs(ejs, callback, Null)) {
        if (msg->callbackSlot == ES_Worker_onmessage) {
            mprTrace(6, "Discard message as no onmessage handler defined for worker");
            
        } else if (msg->callbackSlot == ES_Worker_onerror) {
            if (ejsIs(ejs, msg->message, String)) {
                ejsThrowError(ejs, "Exception in Worker: %@", ejsToString(ejs, msg->message));
            } else {
                ejsThrowError(ejs, "Exception in Worker: %s", ejsGetErrorMsg(worker->pair->ejs, 1));
            }
        } else {
            /* Ignore onclose message */
        }

    } else if (!ejsIsFunction(ejs, callback)) {
        ejsThrowTypeError(ejs, "Worker callback %s is not a function", msg->callback);

    } else {
        assert(!ejs->exception);
        argv[0] = event;
        ejsRunFunction(ejs, callback, worker, 1, argv);
    }
    if (msg->callbackSlot == ES_Worker_onclose) {
        assert(!worker->inside);
        worker->state = EJS_WORKER_COMPLETE;
        mprTrace(5, "Worker.doMessage: complete");
        /* Worker and insider interpreter are now eligible for garbage collection */
        removeWorker(worker);
    }
    mprSignalDispatcher(ejs->dispatcher);
    worker->event = 0;
    return 0;
}


/*
    function preeval(script: String): Object
    NOTE: this blocks. 
 */
static EjsObj *workerPreeval(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    Ejs         *inside;
    EjsWorker   *insideWorker;
    EjsString   *result;

    assert(!worker->inside);

    if (worker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = worker->pair;
    assert(insideWorker->inside);
    inside = insideWorker->ejs;

    (inside->service->loadScriptLiteral)(inside, (EjsString*) argv[0], NULL);
    if (inside->exception) {
        handleError(ejs, worker, inside->exception, 1);
        return 0;
    }
    result = ejsToJSON(inside, inside->result, NULL);
    if (result == 0) {
        return ESV(null);
    }
    return ejsDeserialize(ejs, result);
}


/*
    function preload(path: Path): Object
    NOTE: this blocks. 
 */
static EjsObj *workerPreload(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    Ejs         *inside;
    EjsWorker   *insideWorker;
    EjsString   *result;

    assert(argc > 0 && ejsIs(ejs, argv[0], Path));
    assert(!worker->inside);

    if (worker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = worker->pair;
    assert(insideWorker->inside);
    inside = insideWorker->ejs;

    loadFile(worker->pair, ((EjsPath*) argv[0])->value);
    if (inside->exception) {
        handleError(ejs, worker, inside->exception, 1);
        return 0;
    }
    result = ejsToJSON(inside, inside->result, NULL);
    if (result == 0) {
        return ESV(null);
    }
    return ejsDeserialize(ejs, result);
}


static void manageMessage(Message *msg, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(msg->data);
        mprMark(msg->message);
        mprMark(msg->stack);
    }
}


static Message *createMessage()
{ 
    return mprAllocObj(Message, manageMessage);
}


/*
    Post a message to this worker. Note: the worker is the destination worker which may be the parent.

    function postMessage(data: Object, ports: Array = null): Void
 */
static EjsObj *workerPostMessage(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    EjsString       *data;
    EjsWorker       *target;
    MprDispatcher   *dispatcher;
    Message         *msg;

    if (worker->state >= EJS_WORKER_CLOSED) {
        ejsThrowStateError(ejs, "Worker has completed");
        return 0;
    }
    /*
        Create the event with serialized data in the originating interpreter. It owns the data.
     */
    ejsBlockGC(ejs);
    if ((data = ejsToJSON(ejs, argv[0], NULL)) == 0) {
        ejsThrowArgError(ejs, "Cannot serialize message data");
        return 0;
    }
    if ((msg = createMessage()) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    target = worker->pair;
    msg->data = ejsToMulti(ejs, data);
    msg->worker = target;
    msg->callback = "onmessage";
    msg->callbackSlot = ES_Worker_onmessage;

    dispatcher = target->ejs->dispatcher;
    mprCreateEvent(dispatcher, "postMessage", 0, doMessage, msg, 0);
    return 0;
}


/*
    Worker thread main procedure. Worker is the inside worker.
 */
static int workerMain(EjsWorker *insideWorker, MprEvent *event)
{
    Ejs             *outside, *inside;
    EjsWorker       *outsideWorker;
    MprDispatcher   *dispatcher;
    Message         *msg;

    assert(insideWorker->inside);
    outsideWorker = insideWorker->pair;
    assert(!outsideWorker->inside);
    assert(insideWorker->state == EJS_WORKER_BEGIN);

    outside = outsideWorker->ejs;
    inside = insideWorker->ejs;
    insideWorker->state = EJS_WORKER_STARTED;
    
    /*
        Run the script or file
     */
    if (outsideWorker->scriptFile) {
        loadFile(insideWorker, outsideWorker->scriptFile);

    } else if (outsideWorker->scriptLiteral) {
        if (outside->service->loadScriptLiteral == 0) {
            ejsThrowIOError(outside, "worker: Compiling is not enabled");
            return 0;
        }
        (outside->service->loadScriptLiteral)(inside, outsideWorker->scriptLiteral, NULL);
    }
    /*
        Check for exceptions
     */
    if (inside->exception) {
        handleError(outside, outsideWorker, inside->exception, 0);
        inside->exception = 0;
    }
    ejsBlockGC(inside);
    if ((msg = createMessage()) == 0) {
        ejsThrowMemoryError(outside);
        return 0;
    }
    /*
        Post "onclose" finalization message
     */
    msg->worker = outsideWorker;
    msg->callback = "onclose";
    msg->callbackSlot = ES_Worker_onclose;

    insideWorker->state = EJS_WORKER_CLOSED;
    outsideWorker->state = EJS_WORKER_CLOSED;
    dispatcher = outside->dispatcher;
    mprCreateEvent(dispatcher, "doMessage", 0, (MprEventProc) doMessage, msg, 0);
    return 0;
}


/*
    function terminate(): Void
 */
static EjsObj *workerTerminate(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{    
    if (worker->state == EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has not yet started");
        return 0;
    }
    if (worker->state >= EJS_WORKER_COMPLETE) {
        return 0;
    }
    /*
        Switch to the inside worker if called from outside
     */
    assert(worker->pair && worker->pair->ejs);
    ejs = (!worker->inside) ? worker->pair->ejs : ejs;
    ejs->exiting = 1;
    mprSignalDispatcher(ejs->dispatcher);
    return 0;
}


/*
    function waitForMessage(timeout: Number = -1): Boolean
 */
static EjsBoolean *workerWaitForMessage(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    MprTicks    mark, remaining;
    int         timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]): MAXINT;
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTicks();
    remaining = timeout;

    worker->gotMessage = 0;
    do {
        mprWaitForEvent(ejs->dispatcher, (int) remaining);
        remaining = mprGetRemainingTicks(mark, timeout);
    } while (!worker->gotMessage && remaining > 0 && !ejs->exception);

    if (worker->gotMessage) {
        worker->gotMessage = 0;
        return ESV(true);
    } else {
        return ESV(true);
    }
}


/*
    WARNING: the inside interpreter owns the exception object. Must fully extract all fields
 */
static void handleError(Ejs *ejs, EjsWorker *worker, EjsObj *exception, int throwOutside)
{
    Ejs             *inside;
    EjsObj          *e;
    MprDispatcher   *dispatcher;
    Message         *msg;

    assert(!worker->inside);
    assert(exception);
    assert(ejs == worker->ejs);

    ejsBlockGC(ejs);
    if ((msg = createMessage()) == 0) {
        ejsThrowMemoryError(ejs);
        return;
    }
    msg->worker = worker;
    msg->callback = "onerror";
    msg->callbackSlot = ES_Worker_onerror;
    inside = worker->pair->ejs;
    
    inside->exception = 0;
    e = ejsDeserialize(ejs, ejsSerialize(inside, exception, 0));
    inside->exception = exception;

    /*
        Inside interpreter owns the exception object, so must fully extract all exception. 
        Allocate into the outside worker's interpreter.
     */
    if (ejsIsError(inside, exception)) {
        msg->message = ejsGetPropertyByName(ejs, e, EN("message"));
        msg->stack = ejsGetPropertyByName(ejs, e, EN("stack"));
    } else {
        msg->message = e;
        msg->stack = 0;
    }
    if (throwOutside) {
        if (msg->stack) {
            ejsThrowStateError(ejs, "%@\n%@", ejsToString(ejs, msg->message), ejsToString(ejs, msg->stack));
        } else {
            ejsThrowStateError(ejs, "%@", ejsToString(ejs, msg->message));
        }
    }
    dispatcher = ejs->dispatcher;
    mprCreateEvent(dispatcher, "doMessage-error", 0, (MprEventProc) doMessage, msg, 0);
}


PUBLIC EjsWorker *ejsCreateWorker(Ejs *ejs)
{
    return ejsCreateObj(ejs, ESV(Worker), 0);
}


static void manageWorker(EjsWorker *worker, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(worker, flags);
        mprMark(worker->name);
        mprMark(worker->ejs);
        mprMark(worker->event);
        mprMark(worker->pair);
        mprMark(worker->scriptFile);
        mprMark(worker->scriptLiteral);

    } else if (flags & MPR_MANAGE_FREE) {
        if (!worker->inside) {
            removeWorker(worker);
        }
        if (worker->pair) {
            if (worker->pair->pair) {
                worker->pair->pair = 0;
            }
            worker->pair = 0;
        }
    }
}


PUBLIC void ejsConfigureWorkerType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs", "Worker"), sizeof(EjsWorker), manageWorker, 
            EJS_TYPE_POT | EJS_TYPE_MUTABLE_INSTANCES)) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, workerConstructor);
    ejsBindMethod(ejs, type, ES_Worker_exit, workerExit);
    ejsBindMethod(ejs, type, ES_Worker_join, workerJoin);
    ejsBindMethod(ejs, type, ES_Worker_lookup, workerLookup);
    ejsBindMethod(ejs, type, ES_Worker_fork, workerFork);
    ejsBindMethod(ejs, prototype, ES_Worker_clone, workerClone);
    ejsBindMethod(ejs, prototype, ES_Worker_eval, workerEval);
    ejsBindMethod(ejs, prototype, ES_Worker_load, workerLoad);
    ejsBindMethod(ejs, prototype, ES_Worker_preload, workerPreload);
    ejsBindMethod(ejs, prototype, ES_Worker_preeval, workerPreeval);
    ejsBindMethod(ejs, prototype, ES_Worker_postMessage, workerPostMessage);
    ejsBindMethod(ejs, prototype, ES_Worker_terminate, workerTerminate);
    ejsBindMethod(ejs, prototype, ES_Worker_waitForMessage, workerWaitForMessage);

    ejsAddImmutable(ejs, S_Event, N("ejs", "Event"), ejsGetTypeByName(ejs, N("ejs", "Event")));
    ejsAddImmutable(ejs, S_ErrorEvent, N("ejs", "ErrorEvent"), ejsGetTypeByName(ejs, N("ejs", "ErrorEvent")));
}

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsXML.c"
 */
/************************************************************************/

/**
    ejsXML.c - XML type.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/****************************** Forward Declarations **************************/
/*
    XML methods
 */
static EjsObj *loadXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);
static EjsObj *saveXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);
static EjsObj *xmlToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv);
static EjsObj *xml_parent(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);

static bool allDigitsForXml(EjsString *name);
static bool deepCompare(EjsXML *lhs, EjsXML *rhs);
static ssize readStringData(MprXml *xp, void *data, char *buf, ssize size);
static ssize readFileData(MprXml *xp, void *data, char *buf, ssize size);

/*********************************** Helpers **********************************/

static EjsXML *createXml(Ejs *ejs, EjsType *type, int size)
{
    return ejsCreateXML(ejs, 0, N(NULL, NULL), NULL, NULL);
}


PUBLIC EjsAny *cloneXml(Ejs *ejs, EjsXML *xml, bool deep)
{
    EjsXML      *root, *elt;
    int         next;

    if (xml == 0) {
        return 0;
    }
    if (xml->kind == EJS_XML_LIST) {
        root = ejsCreateXMLList(ejs, xml->targetObject, xml->targetProperty);
    } else {
        root = ejsCreateXML(ejs, xml->kind, xml->qname, NULL, xml->value);
    }
    if (root == 0) {
        return 0;
    }
    //  TODO - must copy inScopeNamespaces?

    if (xml->attributes) {
        root->attributes = mprCreateList(-1, 0);
        for (next = 0; (elt = (EjsXML*) mprGetNextItem(xml->attributes, &next)) != 0; ) {
            elt = ejsClone(ejs, elt, 1);
            if (elt) {
                elt->parent = root;
                mprAddItem(root->attributes, elt);
            }
        }
    }
    if (xml->elements) {
        root->elements = mprCreateList(-1, 0);
        for (next = 0; (elt = mprGetNextItem(xml->elements, &next)) != 0; ) {
            assert(ejsIsXML(ejs, elt));
            elt = ejsClone(ejs, elt, 1);
            if (elt) {
                elt->parent = root;
                mprAddItem(root->elements, elt);
            }
        }
    }
    if (mprHasMemError(ejs)) {
        return 0;
    }
    return root;
}


/*
    Cast the object operand to a primitive type
 */
static EjsAny *castXml(Ejs *ejs, EjsXML *xml, EjsType *type)
{
    EjsXML      *item;
    EjsObj      *result;
    MprBuf      *buf;

    assert(ejsIsXML(ejs, xml));

    if (type == ESV(XMLList)) {
        return xml;
    }

    switch (type->sid) {
    case S_Object:

    case S_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case S_Number:
        result = castXml(ejs, xml, ESV(String));
        return ejsToNumber(ejs, result);

    case S_String:
        if (xml->kind == EJS_XML_ELEMENT) {
            if (xml->elements == 0) {
                return ESV(empty);
            }
            if (xml->elements && mprGetListLength(xml->elements) == 1) {
                //  TODO - what about PI and comments?
                item = mprGetFirstItem(xml->elements);
                if (item->kind == EJS_XML_TEXT) {
                    return item->value;
                }
            }
        }
        buf = mprCreateBuf(ME_MAX_BUFFER, -1);
        if (ejsXMLToBuf(ejs, buf, xml, -1) < 0) {
            return 0;
        }
        return ejsCreateStringFromAsc(ejs, (char*) buf->start);

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


static int deleteXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName qname)
{
    EjsXML      *item;
    bool        removed;
    int         next;

    removed = 0;

    if (qname.name->value[0] == '@') {
        /* @ and @* */
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                assert(qname.name->value[0] == '@');
                if (qname.name->value[1] == '*' || wcmp(item->qname.name->value, &qname.name->value[1]) == 0) {
                    mprRemoveItemAtPos(xml->attributes, next - 1);
                    item->parent = 0;
                    removed = 1;
                    next -= 1;
                }
            }
        }

    } else {
        /* name and * */
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                assert(item->qname.name);
                if (qname.name->value[0] == '*' || ejsCompareString(ejs, item->qname.name, qname.name) == 0) {
                    mprRemoveItemAtPos(xml->elements, next - 1);
                    item->parent = 0;
                    removed = 1;
                    next -= 1;
                }
            }
        }
    }
    return (removed) ? 0 : EJS_ERR;
}


static EjsObj *getXmlNodeName(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) xml->qname.name;
}


/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML  *xml;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < mprGetListLength(xml->elements)) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsObj *getXmlIterator(Ejs *ejs, EjsObj *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, xml, -1, nextXmlKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML      *xml, *vp;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListLength(xml->elements); ip->index++) {
        vp = (EjsXML*) mprGetItem(xml->elements, ip->index);
        if (vp == 0) {
            continue;
        }
        ip->index++;
        return (EjsObj*) vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsObj *getXmlValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, -1, nextXmlValue, 0, NULL);
}


static int getXmlPropertyCount(Ejs *ejs, EjsXML *xml)
{
    return mprGetListLength(xml->elements);
}


/*
    Lookup a property by name. There are 7 kinds of lookups:
         prop, @att, [prop], *, @*, .name, .@name
 */
static EjsObj *getXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName qname)
{
    EjsXML      *item, *result, *list;
    int         next, nextList;

    result = 0;

    assert(xml->kind < 5);
    if (isdigit((uchar) qname.name->value[0]) && allDigitsForXml(qname.name)) {
        /*
            Consider xml as a list with only one entry == xml. Then return the 0'th entry
         */
        return (EjsObj*) xml;
    }

    if (qname.name->value[0] == '@') {
        /* @ and @* */
        result = ejsCreateXMLList(ejs, xml, qname);
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                assert(qname.name->value[0] == '@');
                if (qname.name->value[1] == '*' || wcmp(item->qname.name->value, &qname.name->value[1]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                }
            }
        }

    } else if (qname.name->value[0] == '.') {
        /* Decenders (do ..@ also) */
        result = ejsGetXMLDescendants(ejs, xml, qname);

    } else {
        /* name and * */
        result = ejsCreateXMLList(ejs, xml, qname);
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (item->kind == EJS_XML_LIST) {
                    list = item;
                    for (nextList = 0; (item = mprGetNextItem(list->elements, &nextList)) != 0; ) {
                        assert(item->qname.name);
                        if (qname.name->value[0] == '*' || ejsCompareString(ejs, item->qname.name, qname.name) == 0) {
                            result = ejsAppendToXML(ejs, result, item);
                        }
                    }

                } else if (item->qname.name) {
                    assert(item->qname.name);
                    if (qname.name->value[0] == '*' || ejsCompareString(ejs, item->qname.name, qname.name) == 0) {
                        result = ejsAppendToXML(ejs, result, item);
                    }
                }
            }
        }
    }
    return (EjsObj*) result;
}


static EjsObj *invokeXmlOperator(Ejs *ejs, EjsXML *lhs, int opcode,  EjsXML *rhs)
{
    EjsObj      *result;

    if ((result = ejsCoerceOperands(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs)) != 0) {
        return result;
    }
    switch (opcode) {
    case EJS_OP_COMPARE_EQ:
        return (EjsObj*) ejsCreateBoolean(ejs, deepCompare(lhs, rhs));

    case EJS_OP_COMPARE_NE:
        return (EjsObj*) ejsCreateBoolean(ejs, !deepCompare(lhs, rhs));

    default:
        return ejsInvokeOperatorDefault(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs);
    }
}


/*
    Set a property attribute by name.
 */
static int setXmlPropertyAttributeByName(Ejs *ejs, EjsXML *xml, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *attribute, *xvalue, *lastElt;
    EjsString   *sv;
    EjsName     qn;
    wchar       *str;
    int         index, last, next;

    /*
        Attribute. If the value is an XML list, convert to a space separated string
     */
    xvalue = (EjsXML*) value;
    if (ejsIsXML(ejs, xvalue) && xvalue->kind == EJS_XML_LIST) {
        str = 0;
        for (next = 0; (elt = mprGetNextItem(xvalue->elements, &next)) != 0; ) {
            sv = (EjsString*) ejsCast(ejs, (EjsObj*) elt, String);
            str = mrejoin(str, NULL, " ", sv->value, NULL);
        }
        value = (EjsObj*) ejsCreateString(ejs, str, -1);

    } else {
        value = ejsCast(ejs, value, String);
    }
    assert(ejsIs(ejs, value, String));

    /*
        Find the first attribute that matches. Delete all other attributes of the same name.
     */
    index = 0;
    if (xml->attributes) {
        lastElt = 0;
        for (last = -1, index = -1; (elt = mprGetPrevItem(xml->attributes, &index)) != 0; ) {
            assert(qname.name->value[0] == '@');
            if (wcmp(elt->qname.name->value, &qname.name->value[1]) == 0) {
                if (last >= 0) {
                    mprRemoveItemAtPos(xml->attributes, last);
                }
                last = index;
                lastElt = elt;
            }
        }
        if (lastElt) {
            /*
                Found a match. So replace its value
             */
            lastElt->value = (EjsString*) value;
            return last;

        } else {
            index = mprGetListLength(xml->attributes);
        }
    }
    //  TODO - namespace work to do here

    /*
        Not found. Create a new attribute node
     */
    assert(ejsIs(ejs, value, String));
    qn.space = NULL;
    qn.name = ejsSubstring(ejs, qname.name, 1, -1);
    attribute = ejsCreateXML(ejs, EJS_XML_ATTRIBUTE, qn, xml, (EjsString*) value);
    if (xml->attributes == 0) {
        xml->attributes = mprCreateList(-1, 0);
    }
    mprSetItem(xml->attributes, index, attribute);
    return index;
}


/*
    Create a value node. If the value is an XML node already, we are done. Otherwise, cast the value to a string
    and create a text child node containing the string value.
 */
static EjsXML *createValueNode(Ejs *ejs, EjsXML *elt, EjsObj *value)
{
    EjsXML      *text;
    EjsString   *str;

    if (ejsIsXML(ejs, value)) {
        return (EjsXML*) value;
    }
    if ((str = (EjsString*) ejsCast(ejs, value, String)) == NULL) {
        return 0;
    }
    if (mprGetListLength(elt->elements) == 1) {
        /*
            Update an existing text element
         */
        text = mprGetFirstItem(elt->elements);
        if (text->kind == EJS_XML_TEXT) {
            text->value = str;
            return elt;
        }
    }

    /*
        Create a new text element
     */
    if (str->value && str->value[0] != '\0') {
        text = ejsCreateXML(ejs, EJS_XML_TEXT, N(NULL, NULL), elt, str);
        elt = ejsAppendToXML(ejs, elt, text);
    }
    return elt;
}


/*
    Set a property by name
    There are 7 kinds of qname's: prop, @att, [prop], *, @*, .name, .@name
 */
static int setXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *xvalue, *rp, *lastElt;
    EjsObj      *originalValue;
    int         index, last;

    last = 0;
    lastElt = 0;

    mprTrace(9, "XMLSet %@.%@ = \"%@\"", xml->qname.name, qname.name, ejsCast(ejs, value, String));

    if (isdigit((uchar) qname.name->value[0]) && allDigitsForXml(qname.name)) {
        ejsThrowTypeError(ejs, "Integer indicies for set are not allowed");
        return EJS_ERR;
    }

    if (xml->kind != EJS_XML_ELEMENT) {
        //  TODO spec requires this -- but why? -- surely throw?
        return 0;
    }

    /*
        Massage the value type.
     */
    originalValue = value;

    xvalue = (EjsXML*) value;
    if (ejsIsXML(ejs, xvalue)) {
        if (xvalue->kind == EJS_XML_LIST) {
            value = cloneXml(ejs, xvalue, 1);

        } else if (xvalue->kind == EJS_XML_TEXT || xvalue->kind == EJS_XML_ATTRIBUTE) {
            value = ejsCast(ejs, originalValue, String);

        } else {
            value = cloneXml(ejs, xvalue, 1);
        }
    } else {
        value = ejsCast(ejs, value, String);
    }
    if (qname.name->value[0] == '@') {
        return setXmlPropertyAttributeByName(ejs, xml, qname, value);
    }
    /*
        Delete redundant elements by the same name.
     */
    if (xml->elements) {
        for (last = -1, index = -1; (elt = mprGetPrevItem(xml->elements, &index)) != 0; ) {
            if (qname.name->value[0] == '*' || (elt->kind == EJS_XML_ELEMENT && elt->qname.name == qname.name)) {
                /*
                    Must remove all redundant elements of the same name except the first one
                 */
                if (last >= 0) {
                    rp = mprGetItem(xml->elements, last);
                    rp->parent = 0;
                    mprRemoveItemAtPos(xml->elements, last);
                }
                last = index;
                lastElt = elt;
            }
        }
    }
    if (xml->elements == 0) {
        //  TODO - need routine to do this centrally so we can control the default number of elements in the list?
        xml->elements = mprCreateList(-1, 0);
    }
    elt = lastElt;
    index = last;

    if (qname.name->value[0] == '*') {
        /*
            Special case when called from XMLList to update the value of an element
         */
        xml = createValueNode(ejs, xml, value);

    } else if (elt == 0) {
        /*
            Not found. New node required.
         */
        elt = ejsCreateXML(ejs, EJS_XML_ELEMENT, qname, xml, NULL);
        if (elt == 0) {
            return 0;
        }
        index = mprGetListLength(xml->elements);
        xml = ejsAppendToXML(ejs, xml, createValueNode(ejs, elt, value));

    } else {
        /*
            Update existing element.
         */
        xml = ejsSetXMLElement(ejs, xml, index, createValueNode(ejs, elt, value));
    }

    if (xml == 0) {
        return EJS_ERR;
    }
    return index;
}


/****************************** Support Routines ****************************/
/*
    Deep compare
 */
static bool deepCompare(EjsXML *lhs, EjsXML *rhs)
{
    EjsXML      *l, *r;
    int         i;

    if (lhs == rhs) {
        return 1;
    }
    //  TODO - must compare all the namespaces?
    if (lhs->kind != rhs->kind) {
        return 0;

    } else  if (lhs->qname.name != rhs->qname.name) {
        return 0;

    } else if (mprGetListLength(lhs->attributes) != mprGetListLength(rhs->attributes)) {
        //  TODO - must compare all the attributes
        return 0;

    } else if (mprGetListLength(lhs->elements) != mprGetListLength(rhs->elements)) {
        //  TODO - must compare all the children
        return 0;

    } else if (lhs->value != rhs->value) {
        return 0;

    } else {
        for (i = 0; i < mprGetListLength(lhs->elements); i++) {
            l = mprGetItem(lhs->elements, i);
            r = mprGetItem(rhs->elements, i);
            if (! deepCompare(l, r)) {
                return 0;
            }
        }
    }
    return 1;
}


PUBLIC EjsXML *ejsGetXMLDescendants(Ejs *ejs, EjsXML *xml, EjsName qname)
{
    EjsXML          *item, *result;
    int             next;

    result = ejsCreateXMLList(ejs, xml, qname);
    if (result == 0) {
        return 0;
    }
    if (qname.name->value[0] == '.' && qname.name->value[1] == '@') {
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                if (qname.name->value[2] == '*' || wcmp(item->qname.name->value, &qname.name->value[2]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                }
            }
        }
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                result = ejsAppendToXML(ejs, result, ejsGetXMLDescendants(ejs, item, qname));
            }
        }

    } else {
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (qname.name->value[0] == '*' || wcmp(item->qname.name->value, &qname.name->value[1]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                } else {
                    result = ejsAppendToXML(ejs, result, ejsGetXMLDescendants(ejs, item, qname));
                }
            }
        }
    }
    return result;
}


/************************************ Methods ********************************/
/*
    native function XML(value: Object = null)
 */
static EjsObj *xmlConstructor(Ejs *ejs, EjsXML *thisObj, int argc, EjsObj **argv)
{
    EjsObj      *arg, *vp;
    wchar       *str;

    //  TODO - should be also able to handle a File object

    if (thisObj == 0) {
        /*
            Called as a function - cast the arg
         */
        if (argc > 0){
            if ((arg = ejsCast(ejs, argv[0], String)) == 0) {
                return 0;
            }
        }
        thisObj = ejsCreateXML(ejs, 0, N(NULL, NULL), NULL, NULL);
    }
    if (argc == 0) {
        return (EjsObj*) thisObj;
    }

    arg = argv[0];
    assert(arg);

    if (!ejsIsDefined(ejs, arg)) {
        return (EjsObj*) thisObj;
    }
    arg = ejsCast(ejs, argv[0], String);
    if (arg && ejsIs(ejs, arg, String)) {
        str = ((EjsString*) arg)->value;
        if (str == 0) {
            return 0;
        }
        while (isspace((uchar) *str)) str++;
        if (*str == '<') {
            /* XML Literal */
            ejsLoadXMLString(ejs, thisObj, (EjsString*) arg);

        } else {
            /* Load from file */
            loadXml(ejs, thisObj, argc, argv);
        }
    } else if (arg && ejsIsXML(ejs, arg)) {
        if ((vp = xmlToString(ejs, argv[0], 0, NULL)) != 0) {
            ejsLoadXMLString(ejs, thisObj, (EjsString*) vp);
        }

    } else {
        ejsThrowArgError(ejs, "Bad type passed to XML constructor");
        return 0;
    }
    return (EjsObj*) thisObj;
}


static EjsObj *loadXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprXml      *xp;
    cchar       *filename;

    assert(argc == 1 && ejsIs(ejs, argv[0], String));

    filename = ejsToMulti(ejs, argv[0]);
    file = mprOpenFile(filename, O_RDONLY, 0664);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cannot open: %s", filename);
        return 0;
    }
    //  TODO - convert to open/close
    xp = ejsCreateXmlParser(ejs, xml, filename);
    if (xp == 0) {
        ejsThrowMemoryError(ejs);
        mprCloseFile(file);
        return 0;
    }
    mprXmlSetInputStream(xp, readFileData, (void*) file);

    if (mprXmlParse(xp) < 0 && !ejsHasException(ejs)) {
        ejsThrowIOError(ejs, "Cannot parse XML file: %s\nDetails %s",  filename, mprXmlGetErrorMsg(xp));
    }
    mprCloseFile(file);
    return 0;
}


static EjsObj *saveXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    MprBuf      *buf;
    MprFile     *file;
    char        *filename;
    ssize       bytes, len;

    if (argc != 1 || !ejsIs(ejs, argv[0], String)) {
        ejsThrowArgError(ejs, "Bad args. Usage: save(filename);");
        return 0;
    }
    filename = awtom(((EjsString*) argv[0])->value, NULL);

    /*
        Create a buffer to hold the output. All in memory.
     */
    buf = mprCreateBuf(ME_MAX_BUFFER, -1);
    mprPutStringToBuf(buf, "<?xml version=\"1.0\"?>\n");

    if (ejsXMLToBuf(ejs, buf, xml, 0) < 0) {
        return 0;
    }
    file = mprOpenFile(filename,  O_CREAT | O_TRUNC | O_WRONLY | O_TEXT, 0664);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cannot open: %s, %d", filename, mprGetOsError(ejs));
        return 0;
    }
    len = mprGetBufLength(buf);
    bytes = mprWriteFile(file, buf->start, len);
    if (bytes != len) {
        ejsThrowIOError(ejs, "Cannot write to: %s", filename);
        mprCloseFile(file);
        return 0;
    }
    mprWriteFile(file, "\n", 1);
    mprCloseFile(file);
    return 0;
}


/*
    Convert to a JSON string

    override function toJSON(): String
 */
static EjsString *xmlToJson(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsString       *sp;
    MprBuf          *buf;
    cchar           *cp;

    /*
        Quote all quotes
     */
    sp = ejsToString(ejs, vp);
    buf = mprCreateBuf(-1, -1);
    mprPutCharToBuf(buf, '"');
    for (cp = ejsToMulti(ejs, sp); *cp; cp++) {
        if (*cp == '"') {
            mprPutCharToBuf(buf, '\\');
        }
        mprPutCharToBuf(buf, (uchar) *cp);
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    Convert the XML object to a string.

    function toString() : String
 */
static EjsObj *xmlToString(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return (TYPE(obj)->helpers.cast)(ejs, obj, ESV(String));
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    public override function get length(): int
 */
static EjsObj *xmlLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetListLength(xml->elements));
}


#if KEEP
/*
    Set the length. TODO - what does this do?
    public override function set length(value: int): void
 */
static EjsObj *setLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    int         length;

    assert(ejsIsXML(ejs, xml));

    if (argc != 1) {
        ejsThrowArgError(ejs, "usage: obj.length = value");
        return 0;
    }
    length = ejsVarToInteger(ejs, argv[0]);

    if (length < ap->length) {
        for (i = length; i < ap->length; i++) {
            if (ejsSetProperty(ejs, ap, i, ESV(undefined)) < 0) {
                //  TODO - DIAG
                return 0;
            }
        }

    } else if (length > ap->length) {
        if (ejsSetProperty(ejs, ap, length - 1, ESV(undefined)) < 0) {
            //  TODO - DIAG
            return 0;
        }
    }

    ap->length = length;
    return 0;
}
#endif


/*
    function parent(): XML
 */
static EjsObj *xml_parent(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (xml->parent && xml != xml->parent) ? (EjsObj*) xml->parent : (EjsObj*) ESV(null);
}

/********************************** Support **********************************/
/*
    Set an indexed element to an XML value
 */
PUBLIC EjsXML *ejsSetXMLElement(Ejs *ejs, EjsXML *xml, int index, EjsXML *node)
{
    EjsXML      *old;

    if (xml == 0 || node == 0) {
        return 0;
    }
    if (xml->elements == 0) {
        xml->elements = mprCreateList(-1, 0);

    } else {
        old = (EjsXML*) mprGetItem(xml->elements, index);
        if (old && old != node) {
            old->parent = 0;
        }
    }

    if (xml->kind != EJS_XML_LIST) {
        node->parent = xml;
    }
    mprSetItem(xml->elements, index, node);
    return xml;
}


PUBLIC EjsXML *ejsAppendToXML(Ejs *ejs, EjsXML *xml, EjsXML *node)
{
    EjsXML      *elt;
    int         next;

    if (xml == 0 || node == 0) {
        return 0;
    }
    if (xml->elements == 0) {
        xml->elements = mprCreateList(-1, 0);
    }
    if (node->kind == EJS_XML_LIST) {
        for (next = 0; (elt = mprGetNextItem(node->elements, &next)) != 0; ) {
            if (xml->kind != EJS_XML_LIST) {
                elt->parent = xml;
            }
            mprAddItem(xml->elements, elt);
        }
        xml->targetObject = node->targetObject;
        xml->targetProperty = node->targetProperty;

    } else {
        if (xml->kind != EJS_XML_LIST) {
            node->parent = xml;
        }
        mprAddItem(xml->elements, node);
    }
    return xml;
}


PUBLIC int ejsAppendAttributeToXML(Ejs *ejs, EjsXML *parent, EjsXML *node)
{
    if (parent->attributes == 0) {
        parent->attributes = mprCreateList(-1, 0);
    }
    node->parent = parent;
    return mprAddItem(parent->attributes, node);
}


static ssize readFileData(MprXml *xp, void *data, char *buf, ssize size)
{
    assert(xp);
    assert(data);
    assert(buf);
    assert(size > 0);

    return mprReadFile((MprFile*) data, buf, size);
}


static ssize readStringData(MprXml *xp, void *data, char *buf, ssize size)
{
    EjsXmlState *parser;
    ssize       len, rc;

    assert(xp);
    assert(buf);
    assert(size > 0);

    parser = (EjsXmlState*) xp->parseArg;

    if (parser->inputPos < parser->inputSize) {
        len = min(size, (parser->inputSize - parser->inputPos));
        rc = mprMemcpy(buf, size, &parser->inputBuf[parser->inputPos], len);
        parser->inputPos += len;
        return rc;
    }
    return 0;
}


static bool allDigitsForXml(EjsString *name)
{
    wchar       *cp;

    for (cp = name->value; *cp; cp++) {
        if (!isdigit((uchar) *cp) || *cp == '.') {
            return 0;
        }
    }
    return 1;
}


/*********************************** Factory **********************************/

PUBLIC EjsXML *ejsCreateXML(Ejs *ejs, int kind, EjsName qname, EjsXML *parent, EjsString *value)
{
    EjsXML      *xml;

    if ((xml = (EjsXML*) ejsAlloc(ejs, ESV(XML), 0)) == NULL) {
        return 0;
    }
    if (qname.name) {
        xml->qname = qname;
    }
    xml->kind = kind;
    xml->parent = parent;
    if (value) {
        xml->value = value;
    }
    return xml;
}


PUBLIC EjsXML *ejsConfigureXML(Ejs *ejs, EjsXML *xml, int kind, EjsString *name, EjsXML *parent, EjsString *value)
{
    xml->qname.name = name;
    xml->kind = kind;
    xml->parent = parent;
    if (value) {
        xml->value = value;
    }
    return xml;
}


/*
    Support routine. Not an class method
 */
PUBLIC void ejsLoadXMLString(Ejs *ejs, EjsXML *xml, EjsString *xmlString)
{
    EjsXmlState *parser;
    MprXml      *xp;

    xp = ejsCreateXmlParser(ejs, xml, "string");
    parser = mprXmlGetParseArg(xp);
    parser->inputBuf = ejsToMulti(ejs, xmlString);
    parser->inputSize = slen(parser->inputBuf);
    mprXmlSetInputStream(xp, readStringData, (void*) 0);

    if (mprXmlParse(xp) < 0 && !ejsHasException(ejs)) {
        ejsThrowSyntaxError(ejs, "Cannot parse XML string: %s", mprXmlGetErrorMsg(xp));
    }
}


PUBLIC void ejsLoadXMLAsc(Ejs *ejs, EjsXML *xml, cchar *xmlString)
{
    ejsLoadXMLString(ejs, xml, ejsCreateStringFromAsc(ejs, xmlString));
}


PUBLIC void ejsManageXML(EjsXML *xml, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(xml->parent);
        mprMark(xml->targetObject);
        mprMark(xml->attributes);
        mprMark(xml->elements);
        mprMark(xml->namespaces);
        mprMark(xml->qname.name);
        mprMark(xml->qname.space);
        mprMark(xml->value);
    }
}


PUBLIC void ejsCreateXMLType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", "XML"), sizeof(EjsXML), S_XML, ES_XML_NUM_CLASS_PROP, ejsManageXML, 
        EJS_TYPE_OBJ);

    /*
        Must not bind as XML uses get/setPropertyByName to defer to user XML elements over XML methods
     */
    type->constructor.block.nobind = 1;

    type->helpers.clone = (EjsCloneHelper) cloneXml;
    type->helpers.cast = (EjsCastHelper) castXml;
    type->helpers.create = (EjsCreateHelper) createXml;
    type->helpers.getPropertyByName = (EjsGetPropertyByNameHelper) getXmlPropertyByName;
    type->helpers.getPropertyCount = (EjsGetPropertyCountHelper) getXmlPropertyCount;
    type->helpers.deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteXmlPropertyByName;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) invokeXmlOperator;
    type->helpers.setPropertyByName = (EjsSetPropertyByNameHelper) setXmlPropertyByName;
}


PUBLIC void ejsConfigureXMLType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "XML"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, xmlConstructor);
    ejsBindMethod(ejs, prototype, ES_XML_length, xmlLength);
    ejsBindMethod(ejs, prototype, ES_XML_load, loadXml);
    ejsBindMethod(ejs, prototype, ES_XML_save, saveXml);
    ejsBindMethod(ejs, prototype, ES_XML_name, getXmlNodeName);
    ejsBindMethod(ejs, prototype, ES_XML_parent, (EjsProc) xml_parent);

    /*
        Override these methods
     */
    ejsBindMethod(ejs, prototype, ES_XML_toString, xmlToString);
    ejsBindMethod(ejs, prototype, ES_XML_toJSON, xmlToJson);
    ejsBindMethod(ejs, prototype, ES_XML_iterator_get, getXmlIterator);
    ejsBindMethod(ejs, prototype, ES_XML_iterator_getValues, getXmlValues);
#if FUTURE
    ejsBindMethod(ejs, prototype, ES_XML_parent, parent);
    ejsBindMethod(ejs, prototype, "valueOf", valueOf, NULL);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsXMLList.c"
 */
/************************************************************************/

/**
    ejsXMLList.c - XMLList type.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/****************************** Forward Declarations **************************/
/*
    XMLList methods
 */

#if KEEP
static EjsObj   *valueOf(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *xlLength(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *toXmlString(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *appendChild(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *attributes(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *child(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *comments(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *decendants(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildAfter(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildBefore(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *replace(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *setName(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *text(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
#endif

static bool allDigitsForXmlList(EjsString *name);
static EjsXML *resolve(Ejs *ejs, EjsXML *obj);
static EjsXML *shallowCopy(Ejs *ejs, EjsXML *xml);

/*********************************** Helpers **********************************/

static EjsXML *createXmlListVar(Ejs *ejs, EjsType *type, int size)
{
    return (EjsXML*) ejsCreateXMLList(ejs, NULL, N(NULL, NULL));
}


static EjsObj *cloneXmlList(Ejs *ejs, EjsXML *list, bool deep)
{
    EjsXML  *newList;

    //  TODO - implement deep copy
    newList = ejsCreateObj(ejs, TYPE(list), 0);
    if (newList == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    //  TODO incomplete
    return (EjsObj*) newList;
}


/*
    Cast the object operand to a primitive type
 */
static EjsObj *xlCast(Ejs *ejs, EjsXML *vp, EjsType *type)
{
    MprBuf      *buf;
    EjsObj      *result;
    EjsXML      *elt, *item;
    int         next;

    if (type == ESV(XML)) {
        return (EjsObj*) vp;
    }
    switch (type->sid) {
    case S_Object:

    case S_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, 1);

    case S_Number:
        result = xlCast(ejs, vp, ESV(String));
        result = (EjsObj*) ejsToNumber(ejs, result);
        return result;

    case S_String:
        buf = mprCreateBuf(ME_MAX_BUFFER, -1);
        if (mprGetListLength(vp->elements) == 1) {
            elt = mprGetFirstItem(vp->elements);
            if (elt->kind == EJS_XML_ELEMENT) {
                if (elt->elements == 0) {
                    return (EjsObj*) ESV(empty);
                }
                if (elt->elements && mprGetListLength(elt->elements) == 1) {
                    //  TODO - what about PI and comments?
                    item = mprGetFirstItem(elt->elements);
                    if (item->kind == EJS_XML_TEXT) {
                        return (EjsObj*) item->value;
                    }
                }
            }
        }
        for (next = 0; (elt = mprGetNextItem(vp->elements, &next)) != 0; ) {
            if (ejsXMLToBuf(ejs, buf, elt, -1) < 0) {
                return 0;
            }
            if (next < vp->elements->length) {
                mprPutStringToBuf(buf, " ");
            }
        }
        return (EjsObj*) ejsCreateStringFromAsc(ejs, (char*) buf->start);

    default:
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


//  TODO - seems the return code for delete should be boolean?

static int deleteXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname)
{
    EjsXML      *elt;
    int         index, next;

    if (isdigit((uchar) qname.name->value[0]) && allDigitsForXmlList(qname.name)) {
        index = ejsAtoi(ejs, qname.name, 10);

        elt = (EjsXML*) mprGetItem(list->elements, index);
        if (elt) {
            if (elt->parent) {
                if (elt->kind == EJS_XML_ATTRIBUTE) {
                    ejsDeletePropertyByName(ejs, (EjsObj*) elt->parent, elt->qname);
                } else {
                    //  TODO - let q be the property of parent where parent[q] == x[i]
                    mprRemoveItem(elt->parent->elements, elt);
                    elt->parent = 0;
                }
            }
        }
        //  Spec says return true even if index is out of range. We return 0 for true and < 0 for false.
        //  TODO - should ejs throw?
        return 0;
    }

    for (next = 0; (elt = mprGetNextItem(list->elements, &next)) != 0; ) {
        if (elt->kind == EJS_XML_ELEMENT /* && elt->parent */) {
            ejsDeletePropertyByName(ejs, (EjsObj*) elt /* TODO was elt->parent */, qname);
        }
    }
    return 0;
}


static int getXmlListPropertyCount(Ejs *ejs, EjsXML *list)
{
    return mprGetListLength(list->elements);
}


/*
    Lookup a property by name. There are 7 kinds of lookups:
         prop, @att, [prop], *, @*, .name, .@name
 */
static EjsObj *getXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname)
{
    EjsXML      *result, *subList, *item;
    int         nextItem;

    /*
        Get the n'th item in the list
     */
    if (isdigit((uchar) qname.name->value[0]) && allDigitsForXmlList(qname.name)) {
        return mprGetItem(list->elements, ejsAtoi(ejs, qname.name, 10));
    }

    result = ejsCreateXMLList(ejs, list, qname);

    /*
        Build a list of all the elements that themselves have a property qname
     */
    for (nextItem = 0; (item = mprGetNextItem(list->elements, &nextItem)) != 0; ) {
        if (item->kind == EJS_XML_ELEMENT) {
            subList = ejsGetPropertyByName(ejs, (EjsObj*) item, qname);
            assert(ejsIsXML(ejs, subList));
            ejsAppendToXML(ejs, result, subList);

        } else {
            //  TODO - do we ever get a list in a list?
            assert(0);
        }
    }
    return (EjsObj*) result;
}


static EjsObj *getXmlListNodeName(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    if (xml->targetProperty.name) {
        return (EjsObj*) xml->targetProperty.name;
    } else if (xml->targetObject) {
        return (EjsObj*) xml->targetObject->qname.name;
    } else {
        return ESV(null);
    }
}



/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlListKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML  *xml;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < mprGetListLength(xml->elements)) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsObj *getXmlListIterator(Ejs *ejs, EjsObj *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, xml, -1, nextXmlListKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlListValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML      *xml, *vp;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListLength(xml->elements); ip->index++) {
        vp = (EjsXML*) mprGetItem(xml->elements, ip->index);
        if (vp == 0) {
            continue;
        }
        ip->index++;
        return (EjsObj*) vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsObj *getXmlListValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, -1, nextXmlListValue, 0, NULL);
}


#if OLD
/*
    Handle all core operators. We currenly handle only === and !==
    TODO. Must implement: +, -, <, >, <=, >=, ==, ===, !=, !==, &, |
 */
static EjsObj *invokeOperator(Ejs *ejs, EjsXML *lhs, int opCode,  EjsXML *rhs)
{
    EjsObj      *l, *r;
    bool        boolResult;

    assert(ejsIsXML(ejs, lhs));
    assert(ejsIsXML(ejs, rhs));

    //  TODO - Complete
    switch (opCode) {
    case EJS_OP_COMPARE_EQ:
    case EJS_OP_COMPARE_STRICTLY_EQ:
        boolResult = (lhs == rhs);
        break;

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        boolResult = !(lhs == rhs);
        break;

    default:
        /*
            Cast to strings and re-invoke
         */
        l = ejsCast(ejs, lhs, String);
        r = ejsCast(ejs, rhs, String);
        return ejsInvokeOperator(ejs, l, opCode, r);
    }
    return (EjsObj*) ejsCreateBoolean(ejs, boolResult);
}
#endif


/*
    Set an alpha property by name.
 */
static int setAlphaPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *targetObject;
    int         count;

    targetObject = 0;

    count = ejsGetLength(ejs, (EjsObj*) list);
    if (count > 1) {
        //  TODO - why no error in spec?
        assert(0);
        return 0;
    }

    if (count == 0) {
        /*
            Empty list so resolve the real target object and append it to the list.
         */
        targetObject = resolve(ejs, list);
        if (targetObject == 0) {
            return 0;
        }
        if (ejsGetLength(ejs, (EjsObj*) targetObject) != 1) {
            return 0;
        }
        ejsAppendToXML(ejs, list, targetObject);
    }

    /*
        Update the element
     */
    assert(ejsGetLength(ejs, (EjsObj*) list) == 1);
    elt = mprGetItem(list->elements, 0);                        //  TODO OPT - GetFirstItem
    assert(elt);
    ejsSetPropertyByName(ejs, elt, qname, value);
    return 0;
}


static EjsXML *createElement(Ejs *ejs, EjsXML *list, EjsXML *targetObject, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *last, *attList;
    int         index;
    int         j;

    if (targetObject && ejsIsXML(ejs, targetObject) && targetObject->kind == EJS_XML_LIST) {

        /*
            If the target is a list it must have 1 element. So switch to it.
            TODO - could we get resolve to do this?
         */
        if (mprGetListLength(targetObject->elements) != 1) {
            /* Spec says so - TODO why no error? */
            return 0;
        }
        targetObject = mprGetFirstItem(targetObject->elements);
    }

    /*
        Return if the target object is not an XML element
     */
    if (!ejsIsXML(ejs, targetObject) || targetObject->kind != EJS_XML_ELEMENT) {
            /* Spec says so - TODO why no error? */
        return 0;
    }

    elt = ejsCreateXML(ejs, EJS_XML_ELEMENT, list->targetProperty, targetObject, NULL);

    if (list->targetProperty.name && list->targetProperty.name->value[0] == '@') {
        elt->kind = EJS_XML_ATTRIBUTE;
        attList = ejsGetPropertyByName(ejs, (EjsObj*) targetObject, list->targetProperty);
        if (attList && mprGetListLength(attList->elements) > 0) {
            /* Spec says so. But this surely means you can't update an attribute? */
            return 0;
        }
    } else if (list->targetProperty.name == NULL || qname.name->value[0] == '*') {
        elt->kind = EJS_XML_TEXT;
        elt->qname.name = 0;
    }

    index = mprGetListLength(list->elements);

    if (elt->kind != EJS_XML_ATTRIBUTE) {
        if (targetObject) {
            if (index > 0) {
                /*
                    Find the place of the last list item in the resolved target object.
                 */
                last = mprGetItem(list->elements, index - 1);
                j = mprLookupItem(targetObject->elements, last);
            } else {
                j = -1;
            } 
            if (j < 0) {
                j = mprGetListLength(targetObject->elements) - 1;
            }
            //  TODO - really need to wrap this ejsInsertXML(EjsXML *xml, int index, EjsXML *node)
            if (targetObject->elements == 0) {
                targetObject->elements = mprCreateList(-1, 0);
            }
            /*
                Insert into the target object
             */
            mprInsertItemAtPos(targetObject->elements, j + 1, elt);
        }

        if (ejsIsXML(ejs, value)) {
            if (((EjsXML*) value)->kind == EJS_XML_LIST) {
                elt->qname = ((EjsXML*) value)->targetProperty;
            } else {
                elt->qname = ((EjsXML*) value)->qname;
            }
        }

        /*
            Insert into the XML list
         */
        mprSetItem(list->elements, index, elt);
    }
    return (EjsXML*) mprGetItem(list->elements, index);
}


/*
    Update an existing element
 */
static int updateElement(Ejs *ejs, EjsXML *list, EjsXML *elt, int index, EjsObj *value)
{
    EjsXML      *node;
    int         i, j;

    if (!ejsIsXML(ejs, value)) {
        /* Not XML or XMLList -- convert to string */
        value = ejsCast(ejs, value, String);                //  TODO - seem to be doing this in too many places
    }
    mprSetItem(list->elements, index, value);

    if (elt->kind == EJS_XML_ATTRIBUTE) {
        assert(ejsIs(ejs, value, String));
        i = mprLookupItem(elt->parent->elements, elt);
        assert(i >= 0);
        ejsSetXMLElement(ejs, elt->parent, i, elt);
        //  TODO - why do this. Doesn't above do this?
        ejsSetPropertyByName(ejs, elt->parent, elt->qname, value);
        elt->value = (EjsString*) value;
    }

    if (ejsIsXML(ejs, value) && ((EjsXML*) value)->kind == EJS_XML_LIST) {
        value = (EjsObj*) shallowCopy(ejs, (EjsXML*) value);
        if (elt->parent) {
            index = mprLookupItem(elt->parent->elements, elt);
            assert(index >= 0);
            for (j = 0; j < mprGetListLength(((EjsXML*) value)->elements); j++) {
                mprInsertItemAtPos(elt->parent->elements, index, value);
            }
        }

    } else if (ejsIsXML(ejs, value) || elt->kind != EJS_XML_ELEMENT) {
        if (elt->parent) {
            index = mprLookupItem(elt->parent->elements, elt);
            assert(index >= 0);
            mprSetItem(elt->parent->elements, index, value);
            ((EjsXML*) value)->parent = elt->parent;
            if (ejsIs(ejs, value, String)) {
                node = ejsCreateXML(ejs, EJS_XML_TEXT, N(NULL, NULL), list, (EjsString*) value);
                mprSetItem(list->elements, index, node);
            } else {
                mprSetItem(list->elements, index, value);
            }
        }

    } else {
        ejsSetPropertyByName(ejs, elt, N(NULL, "*"), value);
    }
    return index;
}


/*
    Set a property by name.
 */
static int setXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName qname, EjsObj *value)
{
    EjsXML      *elt, *targetObject;
    int         index;

    if (!isdigit((uchar) qname.name->value[0])) {
        return setAlphaPropertyByName(ejs, list, qname, value);
    }

    /*
        Numeric property
     */
    targetObject = 0;
    if (list->targetObject) {
        /*
            Find the real underlying target object. May be an XML object or XMLList if it contains multiple elements.
         */
        targetObject = resolve(ejs, list->targetObject);
        if (targetObject == 0) {
            /* Spec says so - TODO why no error? */
            return 0;
        }
    }
    index = ejsAtoi(ejs, qname.name, 10);
    if (index >= mprGetListLength(list->elements)) {
        /*
            Create, then fall through to update
         */
        elt = createElement(ejs, list, targetObject, qname, value);
        if (elt == 0) {
            return 0;
        }

    } else {
        elt = mprGetItem(list->elements, index);
    }
    assert(elt);
    updateElement(ejs, list, elt, index, value);
    return index;
}


/*
    function parent(): XML
 */
static EjsObj *xl_parent(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return xml->targetObject ? (EjsObj*) xml->targetObject : (EjsObj*) ESV(null);
}

/******************************** Support Routines **************************/

static bool allDigitsForXmlList(EjsString *name)
{
    wchar       *cp;

    for (cp = name->value; *cp; cp++) {
        if (!isdigit((uchar) *cp) || *cp == '.') {
            return 0;
        }
    }
    return 1;
}


static EjsXML *shallowCopy(Ejs *ejs, EjsXML *xml)
{
    EjsXML      *root, *elt;
    int         next;

    assert(xml->kind == EJS_XML_LIST);

    if (xml == 0) {
        return 0;
    }
    if ((root = ejsCreateXMLList(ejs, xml->targetObject, xml->targetProperty)) == NULL) {
        return 0;
    }
    if (xml->elements) {
        root->elements = mprCreateList(-1, 0);
        for (next = 0; (elt = mprGetNextItem(xml->elements, &next)) != 0; ) {
            assert(ejsIsXML(ejs, elt));
            if (elt) {
                mprAddItem(root->elements, elt);
            }
        }
    }
    if (mprHasMemError(ejs)) {
        return 0;
    }
    return root;
}


/*
    Resolve empty XML list objects to an actual XML object. This is used by SetPropertyByName to find the actual 
    object to update. This method resolves the value of empty XMLLists. If the XMLList is not empty, the list will 
    be returned. If list is empty, this method attempts to create an element based on the list targetObject and 
    targetProperty.
 */
static EjsXML *resolve(Ejs *ejs, EjsXML *xml)
{
    EjsXML  *targetObject, *targetPropertyList;

    if (!ejsIsXML(ejs, xml) || xml->kind != EJS_XML_LIST) {
        /* Resolved to an XML object */
        return xml;
    }
    if (mprGetListLength(xml->elements) > 0) {
        /* Resolved to a list of items */
        return xml;
    }
    if (xml->targetObject == 0 || xml->targetProperty.name == NULL || xml->targetProperty.name->value[0] == '*') {
        /* End of chain an no more target objects */
        return 0;
    }
    targetObject = resolve(ejs, xml->targetObject);
    if (targetObject == 0) {
        return 0;
    }
    //  TODO - OPT. targetPropertyList is also being created below.
    targetPropertyList = ejsGetPropertyByName(ejs, (EjsObj*) targetObject, xml->targetProperty);
    if (targetPropertyList == 0) {
        return 0;
    }
    if (ejsGetLength(ejs, (EjsObj*) targetPropertyList) == 0) {
        /*
            Property does not exist in the target.
         */
        if (targetObject->kind == EJS_XML_LIST && ejsGetLength(ejs, (EjsObj*) targetObject) > 1) {
            return 0;
        }
        /*
            Create the property as an element (The text value will be optimized away).
         */
        ejsSetPropertyByName(ejs, targetObject, xml->targetProperty, ESV(empty));
        targetPropertyList = ejsGetPropertyByName(ejs, (EjsObj*) targetObject, xml->targetProperty);
    }
    return targetPropertyList;
}


/************************************ Methods ********************************/

static EjsObj *xmlListConstructor(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
#if FUTURE
    EjsObj      *vp;
    cchar       *str;

    if (argc == 1) {
        vp = argv[0];

        if (ejsIsObject(vp)) {
            /* Convert DOM to XML. Not implemented */;

        } else if (ejsIs(ejs, vp, String)) {
            str = ((EjsString*) vp)->value;
            if (str == 0) {
                return 0;
            }
            if (*str == '<') {
                /* XML Literal */
                return loadXmlString(ejs, (EjsXML*) thisObj, str);

            } else {
                /* Load from file */
                return load(ejs, (EjsXML*) thisObj, argc, argv);
            }
        } else {
            ejsThrowArgError(ejs, "Bad type passed to XML constructor");
            return 0;
        }
    }
#endif
    return (EjsObj*) thisObj;
}


/*
    Convert to a JSON string

    override function toJSON(): String
 */
static EjsObj *xmlListToJson(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsString       *sp;
    MprBuf          *buf;
    cchar           *cp;

    /*
        Quote all quotes
     */
    sp = ejsToString(ejs, vp);
    buf = mprCreateBuf(-1, -1);
    mprPutCharToBuf(buf, '"');
    for (cp = ejsToMulti(ejs, sp); *cp; cp++) {
        if (*cp == '"') {
            mprPutCharToBuf(buf, '\\');
        }
        mprPutCharToBuf(buf, (uchar) *cp);
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprGetBufStart(buf));
}


/*
    Convert the XML object to a string.

    function toString() : String
 */
static EjsObj *xmlListToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return (TYPE(vp)->helpers.cast)(ejs, vp, ESV(String));
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    public override function get length(): int
 */

static EjsObj *xlLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetListLength(xml->elements));
}


#if FUTURE
/*
    Set the length. TODO - what does this do?
    public override function set length(value: int): void
 */
static EjsObj *setLength(Ejs *ejs, EjsXMLList *xml, int argc, EjsObj **argv)
{
    int         length;

    assert(ejsIsXMLList(ejs, xml));

    if (argc != 1) {
        ejsThrowArgError(ejs, "usage: obj.length = value");
        return 0;
    }
    length = ejsVarToInteger(ejs, argv[0]);

#if KEEP
    if (length < ap->length) {
        for (i = length; i < ap->length; i++) {
            if (ejsSetProperty(ejs, ap, i, ESV(undefined)) < 0) {
                //  TODO - DIAG
                return 0;
            }
        }

    } else if (length > ap->length) {
        if (ejsSetProperty(ejs, ap, length - 1, ESV(undefined)) < 0) {
            //  TODO - DIAG
            return 0;
        }
    }

    ap->length = length;
#endif
    return 0;
}
#endif


/*********************************** Factory **********************************/

PUBLIC EjsXML *ejsCreateXMLList(Ejs *ejs, EjsXML *targetObject, EjsName targetProperty)
{
    EjsXML      *list;

    if ((list = (EjsXML*) ejsAlloc(ejs, ESV(XMLList), 0)) == NULL) {
        return 0;
    }
    list->kind = EJS_XML_LIST;
    list->elements = mprCreateList(-1, 0);
    list->targetObject = targetObject;

    if (targetProperty.name) {
        list->targetProperty.name = targetProperty.name;
    }
    return list;
}


PUBLIC void ejsCreateXMLListType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsCreateCoreType(ejs, N("ejs", "XMLList"), sizeof(EjsXML), S_XMLList, ES_XMLList_NUM_CLASS_PROP, 
        ejsManageXML, EJS_TYPE_OBJ);

    /*
        Must not bind as XML uses get/setPropertyByName to defer to user XML elements over XML methods
     */
    type->constructor.block.nobind = 1;

    type->helpers.clone = (EjsCloneHelper) cloneXmlList;
    type->helpers.cast = (EjsCastHelper) xlCast;
    type->helpers.create = (EjsCreateHelper) createXmlListVar;
    type->helpers.getPropertyByName = (EjsGetPropertyByNameHelper) getXmlListPropertyByName;
    type->helpers.getPropertyCount = (EjsGetPropertyCountHelper) getXmlListPropertyCount;
    type->helpers.deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteXmlListPropertyByName;
    type->helpers.invokeOperator = (EjsInvokeOperatorHelper) ejsInvokeOperatorDefault;
    type->helpers.setPropertyByName = (EjsSetPropertyByNameHelper) setXmlListPropertyByName;
}


PUBLIC void ejsConfigureXMLListType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeCoreType(ejs, N("ejs", "XMLList"))) == 0) {
        return;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, xmlListConstructor);
    ejsBindMethod(ejs, prototype, ES_XMLList_length, xlLength);
    ejsBindMethod(ejs, prototype, ES_XMLList_name, getXmlListNodeName);
    ejsBindMethod(ejs, prototype, ES_XMLList_parent, (EjsProc) xl_parent);
#if FUTURE
    ejsBindMethod(ejs, prototype, "name", name, NULL);
    ejsBindMethod(ejs, prototype, "valueOf", valueOf, NULL);
#endif
    ejsBindMethod(ejs, prototype, ES_XMLList_toJSON, xmlListToJson);
    ejsBindMethod(ejs, prototype, ES_XMLList_toString, xmlListToString);
    ejsBindMethod(ejs, prototype, ES_XMLList_iterator_get, getXmlListIterator);
    ejsBindMethod(ejs, prototype, ES_XMLList_iterator_getValues, getXmlListValues);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/core/src/ejsXMLLoader.c"
 */
/************************************************************************/

/**
    ejsXMLLoader.c - Load and save XML data.
 *
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************** Defines ***********************************/

#if !defined(ME_XML_MAX_NODE_DEPTH)
    #define ME_XML_MAX_NODE_DEPTH 2048
#endif

/****************************** Forward Declarations **************************/

static void indent(MprBuf *bp, int level);
static int  parserHandler(MprXml *xp, int state, cchar *tagName, cchar *attName, cchar *value);

/************************************* Code ***********************************/

static void manageXmlParser(EjsXmlState *parser, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(parser->inputBuf);
        mprMark(parser->filename);

    } else if (flags & MPR_MANAGE_FREE) {
    }
}


MprXml *ejsCreateXmlParser(Ejs *ejs, EjsXML *xml, cchar *filename)
{
    EjsXmlState *parser;
    MprXml      *xp;
    
    xp = mprXmlOpen(ME_MAX_BUFFER, -1);
    assert(xp);

    /*
        Create the parser stack
     */
    if ((parser = mprAllocObj(EjsXmlState, manageXmlParser)) == 0) {
        return 0;
    }
    parser->ejs = ejs;
    parser->nodeStack[0].obj = xml;
    
    //  TODO - these 2 are not really needed. Can use ejs->
    parser->xmlType = ESV(XML);
    parser->xmlListType = ESV(XMLList);
    parser->filename = filename;

    mprXmlSetParseArg(xp, parser);
    mprXmlSetParserHandler(xp, parserHandler);
    return xp;
}


/*
    XML parsing callback. Called for each elt and attribute/value pair. 
    For speed, we handcraft the object model here rather than calling 
    putXmlProperty.
 *
    "<!-- txt -->"      parserHandler(, , MPR_XML_COMMENT);
    "<elt"              parserHandler(, , MPR_XML_NEW_ELT);
    "...att=value"      parserHandler(, , MPR_XML_NEW_ATT);
    "<elt ...>"         parserHandler(, , MPR_XML_ELT_DEFINED);
    "<elt/>"            parserHandler(, , MPR_XML_SOLO_ELT_DEFINED);
    "<elt> ...<"        parserHandler(, , MPR_XML_ELT_DATA);
    "...</elt>"         parserHandler(, , MPR_XML_END_ELT);
 *
    Note: we recurse on every new nested elt.
 */

static int parserHandler(MprXml *xp, int state, cchar *tagName, cchar *attName, cchar *str)
{
    Ejs             *ejs;
    EjsXmlState     *parser;
    EjsXmlTagState  *tos;
    EjsString       *value;
    EjsXML          *xml, *node, *parent;

    parser = (EjsXmlState*) xp->parseArg;
    ejs = parser->ejs;
    tos = &parser->nodeStack[parser->topOfStack];
    xml = tos->obj;
    value = ejsCreateStringFromAsc(ejs, str);
    
    assert(xml);

    assert(state >= 0);
    assert(tagName && *tagName);

    switch (state) {
    case MPR_XML_PI:
        node = ejsCreateXML(ejs, EJS_XML_PROCESSING, N(NULL, NULL), xml, value);
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_COMMENT:
        node = ejsCreateXML(ejs, EJS_XML_COMMENT, N(NULL, NULL), xml, value);
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_NEW_ELT:
        if (parser->topOfStack > ME_XML_MAX_NODE_DEPTH) {
            ejsThrowSyntaxError(ejs,  "XML nodes nested too deeply in %s at line %d", parser->filename, 
                mprXmlGetLineNumber(xp));
            return MPR_ERR_BAD_SYNTAX;
        }
        if (xml->kind <= 0) {
            ejsConfigureXML(ejs, xml, EJS_XML_ELEMENT, ejsCreateStringFromAsc(ejs, tagName), xml, NULL);
        } else {
            xml = ejsCreateXML(ejs, EJS_XML_ELEMENT, N(NULL, tagName), xml, NULL);
            tos = &parser->nodeStack[++(parser->topOfStack)];
            tos->obj = (EjsXML*) xml;
            tos->attributes = 0;
            tos->comments = 0;
        }
        break;

    case MPR_XML_NEW_ATT:
        node = ejsCreateXML(ejs, EJS_XML_ATTRIBUTE, N(NULL, attName), xml, value);
        //  TODO - rc
        ejsAppendAttributeToXML(ejs, xml, node);
        //  TODO RC
        break;

    case MPR_XML_SOLO_ELT_DEFINED:
        if (parser->topOfStack > 0) {
            parent = parser->nodeStack[parser->topOfStack - 1].obj;
            //  TODO - rc
            ejsAppendToXML(ejs, parent, xml);
            parser->topOfStack--;
            assert(parser->topOfStack >= 0);
            tos = &parser->nodeStack[parser->topOfStack];
        }
        break;

    case MPR_XML_ELT_DEFINED:
        if (parser->topOfStack > 0) {
            parent = parser->nodeStack[parser->topOfStack - 1].obj;
            //  TODO - rc
            ejsAppendToXML(ejs, parent, xml);
        }
        break;

    case MPR_XML_ELT_DATA:
    case MPR_XML_CDATA:
        node = ejsCreateXML(ejs, EJS_XML_TEXT, N(NULL, attName), xml, value);
        //  TODO - rc
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_END_ELT:
        /*
            This is the closing element in a pair "<x>...</x>".
            Pop the stack frame off the elt stack
         */
        if (parser->topOfStack > 0) {
            parser->topOfStack--;
            assert(parser->topOfStack >= 0);
            tos = &parser->nodeStack[parser->topOfStack];
        }
        break;

    default:
        ejsThrowSyntaxError(ejs, "XML error in %s at %d\nDetails %s", parser->filename, mprXmlGetLineNumber(xp), 
            mprXmlGetErrorMsg(xp));
        assert(0);
        return MPR_ERR_BAD_SYNTAX;
    }
    return 0;
}


#if KEEP
static bool checkTagName(char *name)
{
    char    *cp;

    for (cp = name; *cp; cp++) {
        if (!isalnum((uchar) *cp) && *cp != '_' && *cp != '$' && *cp != '@') {
            return 0;
        }
    }
    return 1;
}
#endif


PUBLIC int ejsXMLToBuf(Ejs *ejs, MprBuf *buf, EjsXML *node, int indentLevel)
{
    EjsXML      *xml, *child, *attribute, *elt;
    int         sawElements, next;
    
    if (VISITED(node)) {
        return 0;
    }
    SET_VISITED(node, 1);

    if (node->kind == EJS_XML_LIST) {
        for (next = 0; (elt = mprGetNextItem(node->elements, &next)) != 0; ) {
            ejsXMLToBuf(ejs, buf, elt, indentLevel);
        }
        return 0;
    }
    assert(ejsIsXML(ejs, node));
    xml = (EjsXML*) node;
    
    switch (xml->kind) {
    case EJS_XML_ELEMENT:
        /*
            XML object is complex (has elements) so return full XML content.
         */
        if (indentLevel > 0) {
            mprPutCharToBuf(buf, '\n');
        }
        indent(buf, indentLevel);

        mprPutToBuf(buf, "<%@", xml->qname.name);
        if (xml->attributes) {
            for (next = 0; (attribute = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprPutToBuf(buf, " %@=\"%@\"",  attribute->qname.name, attribute->value);
            }
        }
        sawElements = 0;
        if (xml->elements) {
            mprPutStringToBuf(buf, ">"); 
            for (next = 0; (child = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (child->kind != EJS_XML_TEXT) {
                    sawElements++;
                }
    
                /* Recurse */
                if (ejsXMLToBuf(ejs, buf, child, indentLevel < 0 ? -1 : indentLevel + 1) < 0) {
                    return -1;
                }
            }
            if (sawElements && indentLevel >= 0) {
                mprPutCharToBuf(buf, '\n');
                indent(buf, indentLevel);
            }
            mprPutToBuf(buf, "</%@>", xml->qname.name);
            
        } else {
            /* Solo */
            mprPutStringToBuf(buf, "/>");
        }
        break;
        
    case EJS_XML_COMMENT:
        mprPutCharToBuf(buf, '\n');
        indent(buf, indentLevel);
        mprPutToBuf(buf, "<!--%@ -->", xml->value);
        break;
        
    case EJS_XML_ATTRIBUTE:
        /*
            Only here when converting solo attributes to a string
         */
        mprPutStringToBuf(buf, ejsToMulti(ejs, xml->value));
        break;
        
    case EJS_XML_TEXT:
        mprPutStringToBuf(buf, ejsToMulti(ejs, xml->value));
        break;
    }
    SET_VISITED(node, 0);
    return 0;
}


static void indent(MprBuf *bp, int level)
{
    int     i;

    for (i = 0; i < level; i++) {
        mprPutCharToBuf(bp, '\t');
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/ejs.db.sqlite/ejsSqlite.c"
 */
/************************************************************************/

/*
    ejsSqlite.c -- SQLite Database class

    Copyright (c) All Rights Reserved. See details at the end of the file.

    Todo:
        - should handle SQLITE_BUSY for multiuser access. Need to set the default timeout
        Useful: SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
 */
/********************************** Includes **********************************/



#if ME_COM_SQLITE && ME_EJS_DB
    /* Indent to no create dependency */
    #include    "sqlite3.h"


#ifndef ME_MAX_SQLITE_MEM
    #define ME_MAX_SQLITE_MEM      (2*1024*1024)   /**< Maximum buffering for Sqlite */
#endif
#ifndef ME_MAX_SQLITE_DURATION
    #define ME_MAX_SQLITE_DURATION 30000           /**< Database busy timeout */
#endif

/*********************************** Locals ***********************************/
/*
    Map allocation and mutex routines to use ejscript version.
 */
#define MAP_ALLOC   1
#define MAP_MUTEXES 0

#define THREAD_STYLE SQLITE_CONFIG_MULTITHREAD
//#define THREAD_STYLE SQLITE_CONFIG_SERIALIZED

/*
    Ejscript Sqlite class object
 */
typedef struct EjsSqlite {
    EjsPot          pot;            /* Extends Object */
    sqlite3         *sdb;           /* Sqlite handle */
    Ejs             *ejs;           /* Interp reference */
    int             memory;         /* In-memory database */
} EjsSqlite;

static int sqliteInitialized;

static void initSqlite();

/************************************ Code ************************************/
/*
    DB Constructor and also used for constructor for sub classes.

    function Sqlite(options: Object)

    Options forms:
        string
            file://name
        path
            filename
        { name: path }
 */
static EjsObj *sqliteConstructor(Ejs *ejs, EjsSqlite *db, int argc, EjsObj **argv)
{
    sqlite3         *sdb;
    EjsObj          *options;
    cchar           *path;

    sdb = 0;
    db->ejs = ejs;
    options = argv[0];
    
    if (!sqliteInitialized) {
        initSqlite();
    }
    /*
        TODO - this will create a database if it doesn't exist. Should have more control over creating databases.
     */
    if (ejsIs(ejs, options, Path) || ejsIs(ejs, options, String)) {
        path = ejsToMulti(ejs, ejsToString(ejs, options));
    } else {
        path = ejsToMulti(ejs, ejsToString(ejs, ejsGetPropertyByName(ejs, options, EN("name"))));
    }
#if MEMORY_BASED_SQLITE
    if (strncmp(path, "memory://", 9) == 0) {
        sdb = (sqlite3*) (size_t) stoi(&path[9], 10, NULL);

    } else {
#endif
        db->memory = 0;
        if (strncmp(path, "file://", 7) == 0) {
            path += 7;
        }
        if (strstr(path, "://") == NULL) {
            if (sqlite3_open(path, &sdb) != SQLITE_OK) {
                ejsThrowIOError(ejs, "Cannot open database %s", path);
                return 0;
            }
            sqlite3_soft_heap_limit(ME_MAX_SQLITE_MEM);
            sqlite3_busy_timeout(sdb, ME_MAX_SQLITE_DURATION);

        } else {
            ejsThrowArgError(ejs, "Unknown SQLite database URI %s", path);
            return 0;
        }
#if MEMORY_BASED_SQLITE
    }
#endif
    db->sdb = sdb;
    return (EjsObj*) db;
}


/*
    function close(): Void
 */
static int sqliteClose(Ejs *ejs, EjsSqlite *db, int argc, EjsObj **argv)
{
    assert(ejs);
    assert(db);

    if (db->sdb && !db->memory) {
        sqlite3_close(db->sdb);
        db->sdb = 0;
    }
    return 0;
}


/*
    function sql(cmd: String): Array

    Will support multiple sql cmds but will only return one result table.
 */
static EjsObj *sqliteSql(Ejs *ejs, EjsSqlite *db, int argc, EjsObj **argv)
{
    sqlite3         *sdb;
    sqlite3_stmt    *stmt;
    EjsArray        *result;
    EjsObj          *row;
    EjsObj          *svalue;
    EjsName         qname;
    char            *tableName;
    cchar           *tail, *colName, *cmd, *value, *defaultTableName;
    int             i, ncol, rc, retries, rowNum, len;

    assert(ejs);
    assert(db);

    cmd = ejsToMulti(ejs, argv[0]);
    retries = 0;
    sdb = db->sdb;
    if (sdb == 0) {
        ejsThrowIOError(ejs, "Database is closed");
        return 0;
    }
    result = ejsCreateArray(ejs, 0);
    if (result == 0) {
        return 0;
    }
    rc = SQLITE_OK;
    while (cmd && *cmd && (rc == SQLITE_OK || (rc == SQLITE_SCHEMA && ++retries < 2))) {
        stmt = 0;
        rc = sqlite3_prepare_v2(sdb, cmd, -1, &stmt, &tail);
        if (rc != SQLITE_OK) {
            continue;
        }
        if (stmt == 0) {
            /* Comment or white space */
            cmd = tail;
            continue;
        }
        defaultTableName = 0;
        ncol = sqlite3_column_count(stmt);
        for (rowNum = 0; ; rowNum++) {
            if (sqlite3_step(stmt) == SQLITE_ROW) {
                row = ejsCreateEmptyPot(ejs);
                if (row == 0) {
                    sqlite3_finalize(stmt);
                    return 0;
                }
                if (ejsSetProperty(ejs, (EjsObj*) result, rowNum, (EjsObj*) row) < 0) {
                    ejsThrowIOError(ejs, "Cannot update query result set");
                    return 0;
                }
                for (i = 0; i < ncol; i++) {
                    tableName = (char*) sqlite3_column_table_name(stmt, i);
                    if (defaultTableName == 0) {
                        defaultTableName = tableName;
                    }
                    colName = sqlite3_column_name(stmt, i);
                    value = (cchar*) sqlite3_column_text(stmt, i);

                    if (tableName == 0 || strcmp(tableName, defaultTableName) == 0) {
                        qname = EN(colName);
                    } else {
                        /*
                            Append the table name for columns from foreign tables. Convert to camel case (tableColumn)
                            Prefix with "_". ie. "_TableColumn"
                         */
                        len = (int) strlen(tableName) + 1;
                        tableName = sjoin("_", tableName, colName, NULL);
                        if (len > 3 && tableName[len - 1] == 's' && tableName[len - 2] == 'e' && tableName[len - 3] == 'i') {
                            tableName[len - 3] = 'y';
                            strcpy(&tableName[len - 2], colName);
                            len -= 2;
                        } else if (len > 2 && tableName[len - 1] == 's' && tableName[len - 2] == 'e') {
                            strcpy(&tableName[len - 2], colName);
                            len -= 2;
                        } else if (tableName[len - 1] == 's') {
                            strcpy(&tableName[len - 1], colName);
                            len--;
                        }
                        tableName[len] = toupper((uchar) tableName[len]);
                        qname = EN(tableName);
                    }
                    if (ejsLookupProperty(ejs, (EjsObj*) row, qname) < 0) {
                        svalue = (EjsObj*) ejsCreateStringFromMulti(ejs, value, slen(value));
                        if (ejsSetPropertyByName(ejs, (EjsObj*) row, qname, svalue) < 0) {
                            ejsThrowIOError(ejs, "Cannot update query result set name");
                            return 0;
                        }
                    }
                }
            } else {
                rc = sqlite3_finalize(stmt);
                stmt = 0;
                if (rc != SQLITE_SCHEMA) {
                    retries = 0;
                    for (cmd = tail; isspace((uchar) *cmd); cmd++) {
                        ;
                    }
                }
                break;
            }
        }
    }
    if (stmt) {
        rc = sqlite3_finalize(stmt);
    }
    if (rc != SQLITE_OK) {
        if (rc == sqlite3_errcode(sdb)) {
            ejsThrowIOError(ejs, "SQL error: %s", sqlite3_errmsg(sdb));
        } else {
            ejsThrowIOError(ejs, "Unspecified SQL error");
        }
        return 0;
    }
    return (EjsObj*) result;
}


/*********************************** Alloc ********************************/
#if MAP_ALLOC
/*
    Map memory allocations to use MPR permanent allocations
 */
static void *allocBlock(int size)
{
    return palloc(size);
}


static void freeBlock(void *ptr)
{
    pfree(ptr);
}


static void *reallocBlock(void *ptr, int size)
{
    return prealloc(ptr, size);
}


static int blockSize(void *ptr)
{
    return (int) psize(ptr);
}


static int roundBlockSize(int size)
{
    return MPR_ALLOC_ALIGN(size);
}


static int initAllocator(void *data)
{
    return 0;
}


static void termAllocator(void *data)
{
}


struct sqlite3_mem_methods mem = {
    allocBlock, freeBlock, reallocBlock, blockSize, roundBlockSize, initAllocator, termAllocator, NULL 
};

#endif /* MAP_ALLOC */

/*********************************** Mutex ********************************/
#if MAP_MUTEXES
/*
    Map mutexes to use MPR
 */

static int initMutex(void) { 
    return 0; 
}


static int termMutex(void) { 
    return 0; 
}


static sqlite3_mutex *allocMutex(int kind)
{
    MprMutex    *lock;

    if ((lock = mprCreateLock()) != 0) {
        mprHold(lock);
    }
    return (sqlite3_mutex*) lock;
}


static void freeMutex(sqlite3_mutex *mutex)
{
    mprRelease((MprMutex*) mutex);
}


static void enterMutex(sqlite3_mutex *mutex)
{
    mprLock((MprMutex*) mutex);
}


static int tryMutex(sqlite3_mutex *mutex)
{
    return mprTryLock((MprMutex*) mutex);
}


static void leaveMutex(sqlite3_mutex *mutex)
{
    mprUnlock((MprMutex*) mutex);
}


static int mutexIsHeld(sqlite3_mutex *mutex) { 
    assert(0); 
    return 0; 
}


static int mutexIsNotHeld(sqlite3_mutex *mutex) { 
    assert(0); 
    return 0; 
}


struct sqlite3_mutex_methods mut = {
    initMutex, termMutex, allocMutex, freeMutex, enterMutex, tryMutex, leaveMutex, mutexIsHeld, mutexIsNotHeld,
};

#endif /* MAP_MUTEXES */

/*********************************** Factory *******************************/

static int manageSqlite(EjsSqlite *db, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(db, flags);

    } else if (flags & MPR_MANAGE_FREE) {
        if (db->sdb) {
            sqliteClose(db->ejs, db, 0, 0);
        }
    }
    return 0;
}


static void initSqlite()
{
    ejsLockService();
    if (!sqliteInitialized) {
#if MAP_ALLOC
        sqlite3_config(SQLITE_CONFIG_MALLOC, &mem);
#endif
#if MAP_MUTEXES
        sqlite3_config(SQLITE_CONFIG_MUTEX, &mut);
#endif
        sqlite3_config(THREAD_STYLE);
        if (sqlite3_initialize() != SQLITE_OK) {
            mprError("Cannot initialize SQLite");
            return;
        }
        sqliteInitialized = 1;
    }
    ejsUnlockService();
}


static int configureSqliteTypes(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;
    
    if ((type = ejsFinalizeScriptType(ejs, N("ejs.db.sqlite", "Sqlite"), sizeof(EjsSqlite), manageSqlite,
            EJS_TYPE_POT)) == 0) {
        return 0;
    }
    prototype = type->prototype;
    ejsBindConstructor(ejs, type, sqliteConstructor);
    ejsBindMethod(ejs, prototype, ES_ejs_db_sqlite_Sqlite_close, sqliteClose);
    ejsBindMethod(ejs, prototype, ES_ejs_db_sqlite_Sqlite_sql, sqliteSql);
    return 0;
}


/*
    Module load entry point. This must be idempotent as it will be called for each new interpreter created.
 */
PUBLIC int ejs_db_sqlite_Init(Ejs *ejs, MprModule *mp)
{
    return ejsAddNativeModule(ejs, "ejs.db.sqlite", configureSqliteTypes, _ES_CHECKSUM_ejs_db_sqlite, EJS_LOADER_ETERNAL);
}

#endif /* ME_COM_SQLITE */

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/ejs.web/ejsHttpServer.c"
 */
/************************************************************************/

/*
    ejsHttpServer.c -- Ejscript Http Server.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */
/********************************** Includes **********************************/

#include    "me.h"

#if ME_EJS_WEB





/********************************** Forwards **********************************/

static EjsRequest *createRequest(EjsHttpServer *sp, HttpConn *conn);
static EjsHttpServer *lookupServer(Ejs *ejs, cchar *ip, int port);
static void setHttpPipeline(Ejs *ejs, EjsHttpServer *sp);
static void setupConnTrace(HttpConn *conn);
static void stateChangeNotifier(HttpConn *conn, int event, int arg);

/************************************ Code ************************************/
/*  
    function get address(): String
 */
static EjsString *hs_address(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (sp->ip) {
        return ejsCreateStringFromAsc(ejs, sp->ip);
    } 
    return ESV(null);
}


/*  
    function accept(): Request
 */
static EjsRequest *hs_accept(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    MprSocket   *sock;
    HttpConn    *conn;
    MprEvent    event;

    if ((sock = mprAcceptSocket(sp->endpoint->sock)) == 0) {
        /* Just ignore */
        return 0;
    }
    memset(&event, 0, sizeof(MprEvent));
    event.dispatcher = sp->endpoint->dispatcher;
    event.sock = sock;
    if ((conn = httpAcceptConn(sp->endpoint, &event)) == 0) {
        /* Just ignore */
        mprError("Cannot accept connection");
        return 0;
    }
    return createRequest(sp, conn);
}


/*  
    function get async(): Boolean
 */
static EjsObj *hs_async(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return (sp->async) ? ESV(true): ESV(false);
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *hs_set_async(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    sp->async = ejsGetBoolean(ejs, argv[0]);
    if (sp->endpoint) {
        httpSetEndpointAsync(sp->endpoint, sp->async);
    }
    return 0;
}


/*
    function get hostedDocuments(): Path
 */
static EjsPath *hs_hostedDocuments(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, ejs->hostedDocuments);
}


/*
    function get hostedHome(): Path
 */
static EjsPath *hs_hostedHome(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return ejsCreatePathFromAsc(ejs, ejs->hostedHome);
}


/*  
    function close(): Void
 */
static EjsObj *hs_close(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (sp->endpoint) {
        ejsSendEvent(ejs, sp->emitter, "close", NULL, sp);
        httpDestroyEndpoint(sp->endpoint);
        sp->endpoint = 0;
    }
    return 0;
}


/*  
    function get limits(): Object
 */
static EjsObj *hs_limits(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpLimits  *limits;

    if (sp->limits == 0) {
        sp->limits = ejsCreateEmptyPot(ejs);
        limits = (sp->endpoint) ? sp->endpoint->limits : ejs->http->serverLimits;
        assert(limits);
        ejsGetHttpLimits(ejs, sp->limits, limits, 1);
    }
    return sp->limits;
}


/*  
    function setLimits(limits: Object): Void
 */
static EjsObj *hs_setLimits(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    EjsObj      *vp, *app, *cache, *cacheLimits;
    HttpLimits  *limits;

    if (sp->limits == 0) {
        sp->limits = ejsCreateEmptyPot(ejs);
        limits = (sp->endpoint) ? sp->endpoint->limits : ejs->http->serverLimits;
        assert(limits);
        ejsGetHttpLimits(ejs, sp->limits, limits, 1);
    }
    ejsBlendObject(ejs, sp->limits, argv[0], EJS_BLEND_OVERWRITE);
    if (sp->endpoint) {
        limits = (sp->endpoint) ? sp->endpoint->limits : ejs->http->serverLimits;
        ejsSetHttpLimits(ejs, limits, sp->limits, 1);
    }
    if ((vp = ejsGetPropertyByName(ejs, sp->limits, EN("sessionTimeout"))) != 0) {
        app = ejsGetPropertyByName(ejs, ejs->global, N("ejs", "App"));
        cache = ejsGetProperty(ejs, app, ES_App_cache);
        if (cache && cache != ESV(null)) {
            cacheLimits = ejsCreateEmptyPot(ejs);
            ejsSetPropertyByName(ejs, cacheLimits, EN("lifespan"), vp);
            ejsCacheSetLimits(ejs, cache, cacheLimits);
        }
    }
    return 0;
}


/*
    function get isSecure(): Boolean
 */
static EjsObj *hs_isSecure(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return sp->ssl ? ESV(true): ESV(false);
}


/*
    function get hosted(): Boolean
 */
static EjsObj *hs_hosted(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return sp->hosted ? ESV(true): ESV(false);
}


/*
    function set hosted(value: Boolean): Void
 */
static EjsVoid *hs_set_hosted(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    sp->hosted = (argv[0] == ESV(true)) ? 1 : 0;
    return 0;
}


/*  
    function listen(endpoint): Void

    An endpoint can be either a "port" or "ip:port", or null. If hosted, this call does little -- just add to the
    ejs->httpServers list.
 */
static EjsVoid *hs_listen(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpEndpoint    *endpoint;
    HttpHost        *host;
    HttpRoute       *route;
    EjsString       *address;
    EjsObj          *loc;
    EjsPath         *documents;

    if (!sp->hosted) {
        loc = (argc >= 1) ? argv[0] : ESV(null);
        if (loc != ESV(null)) {
            address = ejsToString(ejs, loc);
            //  TODO should permit https://IP:PORT
            mprParseSocketAddress(address->value, &sp->ip, &sp->port, NULL, 0);
        } else {
            address = 0;
        }
        if (address == 0) {
            ejsThrowArgError(ejs, "Missing listen endpoint");
            return 0;
        }
        if (sp->endpoint) {
            httpDestroyEndpoint(sp->endpoint);
            sp->endpoint = 0;
        }
        /*
            The endpoint uses the ejsDispatcher. This is VERY important. All connections will inherit this also.
            This serializes all activity on one dispatcher.
         */
        if ((endpoint = httpCreateEndpoint(sp->ip, sp->port, ejs->dispatcher)) == 0) {
            ejsThrowIOError(ejs, "Cannot create Http endpoint object");
            return 0;
        }
        sp->endpoint = endpoint;
        host = httpCreateHost(NULL);
        httpSetHostName(host, sfmt("%s:%d", sp->ip, sp->port));
        route = httpCreateConfiguredRoute(host, 1);
        httpAddRouteMethods(route, "DELETE, HEAD, OPTIONS, PUT");
        httpSetRouteName(route, "default");
        httpAddRouteHandler(route, "ejsHandler", "");
        httpSetRouteTarget(route, "run", 0);
        httpFinalizeRoute(route);
        httpSetHostDefaultRoute(host, route);
        httpAddHostToEndpoint(endpoint, host);

        if (sp->limits) {
            ejsSetHttpLimits(ejs, endpoint->limits, sp->limits, 1);
        }
        if (sp->incomingStages || sp->outgoingStages || sp->connector) {
            setHttpPipeline(ejs, sp);
        }
        if (sp->ssl) {
            httpSecureEndpoint(endpoint, sp->ssl);
        }
        if (sp->name) {
            httpSetHostName(host, sp->name);
        }
        httpSetSoftware(endpoint->http, EJS_HTTPSERVER_NAME);
        httpSetEndpointAsync(endpoint, sp->async);
        httpSetEndpointContext(endpoint, sp);
        httpSetEndpointNotifier(endpoint, stateChangeNotifier);

        /*
            This is only required when http is using non-ejs handlers and/or filters
         */
        documents = ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_documents);
        if (ejsIs(ejs, documents, Path)) {
            httpSetRouteDocuments(route, documents->value);
        }
#if KEEP
        //  TODO -- what to do with home?
        //  TODO - if removed, then the "home" property should be removed?
        home = ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_home);
        if (ejsIs(ejs, home, Path)) {
            httpSetRoutDir(host, home->value);
        }
#endif
        if (httpStartEndpoint(endpoint) < 0) {
            httpDestroyEndpoint(sp->endpoint);
            sp->endpoint = 0;
            ejsThrowIOError(ejs, "Cannot listen on %s", address->value);
        }
    }
    if (ejs->httpServers == 0) {
       ejs->httpServers = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    }
    /* Remove to make sure old listening() registrations are removed */
    mprRemoveItem(ejs->httpServers, sp);
    mprAddItem(ejs->httpServers, sp);
    return 0;
}


/*  
    function get name(): String
 */
static EjsString *hs_name(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (sp->name) {
        return ejsCreateStringFromAsc(ejs, sp->name);
    }
    return ESV(null);
}


/*  
    function set name(hostname: String): Void
 */
static EjsObj *hs_set_name(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpHost    *host;

    sp->name = ejsToMulti(ejs, argv[0]);
    if (sp->endpoint && sp->name) {
        host = mprGetFirstItem(sp->endpoint->hosts);
        httpSetHostName(host, sp->name);
    }
    return 0;
}


/*  
    function off(name: [String|Array], observer: Function): Void
 */
static EjsObj *hs_off(Ejs *ejs, EjsHttpServer *sp, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, sp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function on(name: [String|Array], observer: Function): HttpServer
 */
static EjsHttpServer *hs_on(Ejs *ejs, EjsHttpServer *sp, int argc, EjsAny **argv)
{
    //  TODO -- should fire if currently readable / writable (also socket etc)
    ejsAddObserver(ejs, &sp->emitter, argv[0], argv[1]);
    return sp;
}


/*  
    function get port(): Number
 */
static EjsNumber *hs_port(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, sp->port);
}


/*  
    function run(): Void
 */
static EjsVoid *hs_run(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (!sp->hosted) {
        while (!ejs->exiting && !mprIsStopping()) {
            mprWaitForEvent(ejs->dispatcher, MAXINT); 
        }
    }
    return 0;
}


/*  
    function secure(keyFile: Path, certFile: Path!, protocols: Array? = null, ciphers: Array? = null): Void
 */
static EjsObj *hs_secure(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
#if ME_COM_SSL
    EjsArray    *protocols;
    cchar       *token;
    int         mask, protoMask, i;

    if (sp->ssl == 0 && ((sp->ssl = mprCreateSsl(1)) == 0)) {
        return 0;
    }
    if (!ejsIs(ejs, argv[0], Null)) {
        mprSetSslKeyFile(sp->ssl, ejsToMulti(ejs, argv[0]));
    }
    if (!ejsIs(ejs, argv[1], Null)) {
        mprSetSslCertFile(sp->ssl, ejsToMulti(ejs, argv[1]));
    }
    if (argc >= 3 && ejsIs(ejs, argv[2], Array)) {
        protocols = (EjsArray*) argv[2];
        protoMask = 0;
        for (i = 0; i < protocols->length; i++) {
            token = ejsToMulti(ejs, ejsGetProperty(ejs, protocols, i));
            mask = -1;
            if (*token == '-') {
                token++;
                mask = 0;
            } else if (*token == '+') {
                token++;
            }
            if (scaselesscmp(token, "SSLv2") == 0) {
                protoMask &= ~(MPR_PROTO_SSLV2 & ~mask);
                protoMask |= (MPR_PROTO_SSLV2 & mask);

            } else if (scaselesscmp(token, "SSLv3") == 0) {
                protoMask &= ~(MPR_PROTO_SSLV3 & ~mask);
                protoMask |= (MPR_PROTO_SSLV3 & mask);

            } else if (scaselesscmp(token, "TLSv1") == 0) {
                protoMask &= ~(MPR_PROTO_TLSV1 & ~mask);
                protoMask |= (MPR_PROTO_TLSV1 & mask);

            } else if (scaselesscmp(token, "ALL") == 0) {
                protoMask &= ~(MPR_PROTO_ALL & ~mask);
                protoMask |= (MPR_PROTO_ALL & mask);
            }
        }
        mprSetSslProtocols(sp->ssl, protoMask);
    }
    if (argc >= 4 && ejsIs(ejs, argv[3], Array)) {
        mprSetSslCiphers(sp->ssl, ejsToMulti(ejs, argv[3]));
    }
#else
    ejsThrowReferenceError(ejs, "SSL support was not included in the build");
#endif
    return 0;
}


/*  
    function setPipeline(incoming: Array, outgoing: Array, connector: String): Void
 */
static EjsObj *hs_setPipeline(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    sp->incomingStages = (EjsArray*) argv[0];
    sp->outgoingStages = (EjsArray*) argv[1];
    sp->connector = ejsToMulti(ejs, argv[2]);

    if (sp->endpoint) {
        /* NOTE: this will only impact future requests */
        setHttpPipeline(ejs, sp);
    }
    return 0;
}


/*  
    function trace(options): Void
 */
static EjsObj *hs_trace(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    ejsSetupHttpTrace(ejs, sp->trace, argv[0]);
    return 0;
}


/*  
    function get software(headers: Object = null): Void
 */
static EjsString *hs_software(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return ejsCreateStringFromAsc(ejs, EJS_HTTPSERVER_NAME);
}


/*  
    function verifyClients(caCertPath: Path, caCertFile: Path): Void
 */
static EjsObj *hs_verifyClients(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    //  TODO
    return 0;
}


static void receiveRequest(EjsRequest *req, MprEvent *event)
{
    Ejs             *ejs;
    EjsAny          *argv[1];
    EjsFunction     *onrequest;
    HttpConn        *conn;
    
    conn = req->conn;
    ejs = req->ejs;
    assert(ejs);

    onrequest = ejsGetProperty(ejs, req->server, ES_ejs_web_HttpServer_onrequest);
    if (!ejsIsFunction(ejs, onrequest)) {
        ejsThrowStateError(ejs, "HttpServer.onrequest is not a function");
        return;
    }
    argv[0] = req;
    ejsRunFunction(ejs, onrequest, req->server, 1, argv);
    if (conn->state == HTTP_STATE_BEGIN) {
        conn->ejs = 0;
        httpUsePrimary(conn);        
    }
    httpEnableConnEvents(conn);
}


/*
    function passRequest(req: Request, worker: Worker): Void
 */
static EjsVoid *hs_passRequest(Ejs *ejs, EjsHttpServer *server, int argc, EjsAny **argv)
{
    Ejs             *nejs;
    EjsRequest      *req, *nreq;
    EjsWorker       *worker;
    HttpConn        *conn;
    MprEvent        *event;

    req = argv[0];
    worker = argv[1];

    nejs = worker->pair->ejs;
    conn = req->conn;
    conn->ejs = nejs;

    if ((nreq = ejsCloneRequest(nejs, req, 1)) == 0) {
        ejsThrowStateError(ejs, "Cannot clone request");
        return 0;
    }
    httpSetConnContext(conn, nreq);

    if ((nreq->server = ejsCloneHttpServer(nejs, req->server, 1)) == 0) {
        ejsThrowStateError(ejs, "Cannot clone request");
        return 0;
    }
    event = mprCreateEvent(conn->dispatcher, "RequestWorker", 0, receiveRequest, nreq, MPR_EVENT_DONT_QUEUE);
    httpUseWorker(conn, nejs->dispatcher, event);
    return 0;
}


/************************************ Support *************************************/

//  TODO rethink this. This should really go into the HttpHost object

static void setHttpPipeline(Ejs *ejs, EjsHttpServer *sp) 
{
    EjsString       *vs;
    HttpHost        *host;
    HttpRoute       *route;
    Http            *http;
    HttpStage       *stage;
    cchar           *name;
    int             i;

    assert(sp->endpoint);
    http = sp->endpoint->http;
    host = mprGetFirstItem(sp->endpoint->hosts);
    route = mprGetFirstItem(host->routes);

    if (sp->outgoingStages) {
        httpClearRouteStages(route, HTTP_STAGE_TX);
        for (i = 0; i < sp->outgoingStages->length; i++) {
            vs = ejsGetProperty(ejs, sp->outgoingStages, i);
            if (vs && ejsIs(ejs, vs, String)) {
                name = vs->value;
                if (httpLookupStage(http, name) == 0) {
                    ejsThrowArgError(ejs, "Cannot find pipeline stage name %s", name);
                    return;
                }
                httpAddRouteFilter(route, name, NULL, HTTP_STAGE_TX);
            }
        }
    }
    if (sp->incomingStages) {
        httpClearRouteStages(route, HTTP_STAGE_RX);
        for (i = 0; i < sp->incomingStages->length; i++) {
            vs = ejsGetProperty(ejs, sp->incomingStages, i);
            if (vs && ejsIs(ejs, vs, String)) {
                name = vs->value;
                if (httpLookupStage(http, name) == 0) {
                    ejsThrowArgError(ejs, "Cannot find pipeline stage name %s", name);
                    return;
                }
                httpAddRouteFilter(route, name, NULL, HTTP_STAGE_RX);
            }
        }
    }
    if (sp->connector) {
        if ((stage = httpLookupStage(http, sp->connector)) == 0) {
            ejsThrowArgError(ejs, "Cannot find pipeline stage name %s", sp->connector);
            return;
        }
        route->connector = stage;
    }
}


/*
    Notification callback. This routine is called from the Http pipeline on connection state changes. 
 */
static void stateChangeNotifier(HttpConn *conn, int event, int arg)
{
    Ejs             *ejs;
    EjsRequest      *req;

    assert(conn);

    ejs = 0;
    if ((req = httpGetConnContext(conn)) != 0) {
        ejs = req->ejs;
    }
    switch (event) {
    case HTTP_EVENT_STATE:
        if (arg == HTTP_STATE_BEGIN) {
            setupConnTrace(conn);
        } else if (arg == HTTP_STATE_FINALIZED) {
            if (req) {
                if (conn->error) {
                    ejsSendRequestErrorEvent(ejs, req);
                }
                ejsSendRequestCloseEvent(ejs, req);
                if (req->cloned) {
                    ejsSendRequestCloseEvent(req->ejs, req->cloned);
                }
            }
        }
        break;

    case HTTP_EVENT_READABLE:
        /*  IO event notification for the request.  */
        if (req && req->emitter) {
            ejsSendEvent(ejs, req->emitter, "readable", NULL, req);
        } 
        break;

    case HTTP_EVENT_WRITABLE:
        if (req && req->emitter) {
            ejsSendEvent(ejs, req->emitter, "writable", NULL, req);
        }
        break;

    case HTTP_EVENT_APP_CLOSE:
        /* Connection close */
        if (req && req->conn) {
            req->conn = 0;
        }
        break;
    }
}


static void closeEjsHandler(HttpQueue *q)
{
    EjsRequest  *req;
    HttpConn    *conn;

    conn = q->conn;

    if ((req = httpGetConnContext(conn)) != 0) {
        ejsSendRequestCloseEvent(req->ejs, req);
        req->conn = 0;
    }
    httpSetConnContext(conn, 0);
    if (conn->pool && conn->ejs) {
        ejsFreePoolVM(conn->pool, conn->ejs);
        conn->ejs = 0;
    }
}


static void incomingEjs(HttpQueue *q, HttpPacket *packet)
{
    HttpConn        *conn;
    HttpRx          *rx;

    conn = q->conn;
    rx = conn->rx;

    if (httpGetPacketLength(packet) == 0) {
        if (rx->remainingContent > 0) {
            httpError(conn, HTTP_CODE_BAD_REQUEST, "Client supplied insufficient body data");
        }
        httpPutForService(q, packet, 0);
    } else {
        httpJoinPacketForService(q, packet, 0);
    }
    HTTP_NOTIFY(q->conn, HTTP_EVENT_READABLE, 0);
}


static void setupConnTrace(HttpConn *conn)
{
    EjsHttpServer   *sp;
    int             i;

    assert(conn->endpoint);
    if (conn->endpoint) {
        if ((sp = httpGetEndpointContext(conn->endpoint)) != 0) {
            for (i = 0; i < HTTP_TRACE_MAX_DIR; i++) {
                conn->trace[i] = sp->trace[i];
            }
        }
    }
}


static EjsRequest *createRequest(EjsHttpServer *sp, HttpConn *conn)
{
    Ejs             *ejs;
    EjsRequest      *req;
    EjsPath         *documents;
    cchar           *dir;

    ejs = sp->ejs;
    documents = ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_documents);
    if (ejsIs(ejs, documents, Path)) {
        dir = documents->value;
    } else {
        /* Safety fall back */
        dir = conn->rx->route->home;
    }
    req = ejsCreateRequest(ejs, sp, conn, dir);
    httpSetConnContext(conn, req);

#if FUTURE
    if (sp->pipe) {
        def = ejsRunFunction(ejs, sp->createPipeline, 
        if ((vp = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "handler"))) != 0) { 
            handler = ejsToMulti(ejs, vp);
        }
        if ((incoming = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "incoming"))) != 0) { 
            count = ejsGetProperty(ejs, incoming)
            for (i = 0; i < count; i++) {
                mprAddItem(ilist, 
            }
        }
        if ((outgoing = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "outgoing"))) != 0) { 
            count = ejsGetProperty(ejs, incoming)
        }
        if ((connector = ejsGetPropertyByName(ejs, def, ejsName(&name, "", "connector"))) != 0) { 
            connector = ejsToMulti(ejs, vp);
        }
        httpSetPipeline(conn, ejsToMulti(ejs, Handler), ejsToMulti(ejs, connector), 
    }
#endif
    return req;
}


static void startEjsHandler(HttpQueue *q)
{
    EjsHttpServer   *sp;
    EjsRequest      *req;
    Ejs             *ejs;
    HttpEndpoint    *endpoint;
    HttpConn        *conn;
    HttpRx          *rx;
    MprSocket       *lp;

    conn = q->conn;
    rx = conn->rx;
    endpoint = conn->endpoint;

    if (conn->error) {
        return;
    }
    if ((sp = httpGetEndpointContext(endpoint)) == 0) {
        lp = conn->sock->listenSock;
        if ((sp = lookupServer(conn->ejs, lp->ip, lp->port)) == 0) {
            httpError(conn, HTTP_CODE_INTERNAL_SERVER_ERROR, 
                    "No HttpServer configured to serve for request from %s:%d", lp->ip, lp->port);
            return;
        }
        ejs = sp->ejs;
        sp->endpoint = endpoint;
        sp->ip = endpoint->ip;
        sp->port = endpoint->port;
        if (!ejsIsDefined(ejs, ejsGetProperty(ejs, sp, ES_ejs_web_HttpServer_documents))) {
            ejsSetProperty(ejs, sp, ES_ejs_web_HttpServer_documents, ejsCreateStringFromAsc(ejs, conn->rx->route->home));
        }
    } else if (conn->ejs) {
        ejs = conn->ejs;
    } else {
        ejs = sp->ejs;
    }
    assert(!conn->tx->finalized);
    if (conn->notifier == 0) {
        httpSetConnNotifier(conn, stateChangeNotifier);
        assert(!conn->tx->finalized);
    }
    if ((req = createRequest(sp, conn)) != 0) {
        assert(!conn->tx->finalized);
        ejsSendEvent(ejs, sp->emitter, "readable", req, req);

        /* Send EOF if form or upload and all content has been received.  */
        if ((rx->form || rx->upload) && rx->eof) {
            HTTP_NOTIFY(conn, HTTP_EVENT_READABLE, 0);
        }
    }
}


static void readyEjsHandler(HttpQueue *q)
{
    HttpConn        *conn;
    
    conn = q->conn;
    if (conn->readq->count > 0) {
        HTTP_NOTIFY(conn, HTTP_EVENT_READABLE, 0);
    }
}


/* 
    Create the http pipeline handler
 */
HttpStage *ejsAddWebHandler(Http *http, MprModule *module)
{
    HttpStage   *handler;

    assert(http);
    if ((handler = http->ejsHandler) == 0) {
        if ((handler = httpCreateHandler(http, "ejsHandler", module)) == 0) {
            return 0;
        }
    }
    http->ejsHandler = handler;
    handler->close = closeEjsHandler;
    handler->incoming = incomingEjs;
    handler->start = startEjsHandler;
    handler->ready = readyEjsHandler;
    return handler;
}


/*  
    Mark the object properties for the garbage collector
 */
static void manageHttpServer(EjsHttpServer *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(sp, flags);
        mprMark(sp->ejs);
        mprMark(sp->endpoint);
        mprMark(sp->ssl);
        httpManageTrace(&sp->trace[0], flags);
        httpManageTrace(&sp->trace[1], flags);
        mprMark(sp->connector);
        mprMark(sp->keyFile);
        mprMark(sp->certFile);
        mprMark(sp->protocols);
        mprMark(sp->ciphers);
        mprMark(sp->ip);
        mprMark(sp->name);
        mprMark(sp->emitter);
        mprMark(sp->limits);
        mprMark(sp->outgoingStages);
        mprMark(sp->incomingStages);
        
    } else {
        if (sp->ejs && sp->ejs->httpServers) {
            mprRemoveItem(sp->ejs->httpServers, sp);
        }
        if (!sp->cloned) {
            if (sp->endpoint && !sp->hosted) {
                httpDestroyEndpoint(sp->endpoint);
                sp->endpoint = 0;
            }
        }
    }
}


static EjsHttpServer *createHttpServer(Ejs *ejs, EjsType *type, int size)
{
    EjsHttpServer   *sp;

    if ((sp = ejsCreatePot(ejs, type, 0)) == 0) {
        return 0;
    }
    sp->ejs = ejs;
    sp->hosted = ejs->hosted;
    sp->async = 1;
    httpInitTrace(sp->trace);
    return sp;
}


EjsHttpServer *ejsCloneHttpServer(Ejs *ejs, EjsHttpServer *sp, bool deep)
{
    EjsHttpServer   *nsp;

    if ((nsp = ejsClonePot(ejs, sp, deep)) == 0) {
        return 0;
    }
    nsp->cloned = sp;
    nsp->ejs = ejs;
    nsp->async = sp->async;
    nsp->endpoint = sp->endpoint;
    nsp->name = sp->name;
    nsp->ssl = sp->ssl;
    nsp->connector = sp->connector;
    nsp->port = sp->port;
    nsp->ip = sp->ip;
    nsp->certFile = sp->certFile;
    nsp->keyFile = sp->keyFile;
    nsp->ciphers = sp->ciphers;
    nsp->protocols = sp->protocols;
    httpInitTrace(nsp->trace);
    return nsp;
}


static EjsHttpServer *lookupServer(Ejs *ejs, cchar *ip, int port)
{
    EjsHttpServer   *sp;
    int             next;

    if (ip == 0) {
        ip = "";
    }
    if (ejs->httpServers) {
        for (next = 0; (sp = mprGetNextItem(ejs->httpServers, &next)) != 0; ) {
            if (sp->port <= 0 || port <= 0 || sp->port == port) {
                if (sp->ip == 0 || *sp->ip == '\0' || *ip == '\0' || scmp(sp->ip, ip) == 0) {
                    return sp;
                }
            }
        }
    }
    return 0;
}


void ejsConfigureHttpServerType(Ejs *ejs)
{
    EjsType     *type;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs.web", "HttpServer"), sizeof(EjsHttpServer), manageHttpServer, 
            EJS_TYPE_POT | EJS_TYPE_DYNAMIC_INSTANCES)) == 0) {
        return;
    }
    type->helpers.create = (EjsCreateHelper) createHttpServer;
    type->helpers.clone = (EjsCloneHelper) ejsCloneHttpServer;

    prototype = type->prototype;
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_accept, hs_accept);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_address, hs_address);
    ejsBindAccess(ejs, prototype, ES_ejs_web_HttpServer_async, hs_async, hs_set_async);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_hostedDocuments, hs_hostedDocuments);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_hostedHome, hs_hostedHome);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_close, hs_close);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_limits, hs_limits);
    ejsBindAccess(ejs, prototype, ES_ejs_web_HttpServer_hosted, hs_hosted, hs_set_hosted);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_isSecure, hs_isSecure);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_listen, hs_listen);
    ejsBindAccess(ejs, prototype, ES_ejs_web_HttpServer_name, hs_name, hs_set_name);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_port, hs_port);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_off, hs_off);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_on, hs_on);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_passRequest, hs_passRequest);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_run, hs_run);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_secure, hs_secure);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_setLimits, hs_setLimits);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_setPipeline, hs_setPipeline);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_trace, hs_trace);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_verifyClients, hs_verifyClients);
    ejsBindMethod(ejs, prototype, ES_ejs_web_HttpServer_software, hs_software);

    /* One time initializations */
    ejsLoadHttpService(ejs);
    ejsAddWebHandler(ejs->http, NULL);
}
#endif


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/ejs.web/ejsRequest.c"
 */
/************************************************************************/

/*
    ejsRequest.c -- Ejscript web framework.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */
/********************************** Includes **********************************/

#include    "me.h"

#if ME_EJS_WEB





/************************************* Code ***********************************/
 
static int connOk(Ejs *ejs, EjsRequest *req, int throwException)
{
    if (!req->conn || req->conn->rx == 0) {
        if (!ejs->exception && throwException) {
            ejsThrowString(ejs, "Connection lost or not established");
        }
        return 0;
    }
    return 1;
}


#if UNUSED
static int sortForm(MprKey **h1, MprKey **h2)
{
    return scmp((*h1)->key, (*h2)->key);
}


/*
    Create the formData string. This is a stable, sorted string of form variables
 */
static EjsString *createFormData(Ejs *ejs, EjsRequest *req)
{
    MprHash     *params;
    MprKey      *kp;
    MprList     *list;
    char        *buf, *cp;
    ssize       len;
    int         next;

    if (req->formData == 0) {
        if (req->conn && (params = req->conn->rx->params) != 0) {
            if ((list = mprCreateList(mprGetHashLength(params), 0)) != 0) {
                len = 0;
                for (kp = 0; (kp = mprGetNextKey(params, kp)) != NULL; ) {
                    mprAddItem(list, kp);
                    len += slen(kp->key) + slen(kp->data) + 2;
                }
                if ((buf = mprAlloc(len + 1)) != 0) {
                    mprSortList(list, sortForm);
                    cp = buf;
                    for (next = 0; (kp = mprGetNextItem(list, &next)) != 0; ) {
                        strcpy(cp, kp->key); cp += slen(kp->key);
                        *cp++ = '=';
                        strcpy(cp, kp->data); cp += slen(kp->data);
                        *cp++ = '&';
                    }
                    cp[-1] = '\0';
                    req->formData = ejsCreateStringFromAsc(ejs, buf);
                }
            }
        }
    }
    return req->formData;
}
#else

static EjsString *createFormData(Ejs *ejs, EjsRequest *req)
{
    return ejsCreateStringFromAsc(ejs, httpGetParamsString(req->conn));
}
#endif


#if UNUSED
/*
    Define a parameter. Key may contain "."
 */
static void defineParam(Ejs *ejs, EjsObj *params, cchar *key, cchar *svalue)
{
    EjsName     qname;
    EjsAny      *value;
    EjsObj      *vp;
    char        *subkey, *nextkey;
    int         slotNum;

    assert(params);
    value = ejsCreateStringFromAsc(ejs, svalue);

    /*  
        name.name.name
     */
    if (strchr(key, '.') == 0) {
        qname = ejsName(ejs, "", key);
        ejsSetPropertyByName(ejs, params, qname, value);

    } else {
        subkey = stok(sclone(key), ".", &nextkey);
        while (nextkey) {
            qname = ejsName(ejs, "", subkey);
            vp = ejsGetPropertyByName(ejs, params, qname);
            if (vp == 0) {
                if (snumber(nextkey)) {
                    vp = (EjsObj*) ejsCreateArray(ejs, 0);
                } else {
                    vp = ejsCreateEmptyPot(ejs);
                }
                slotNum = ejsSetPropertyByName(ejs, params, qname, vp);
                vp = ejsGetProperty(ejs, params, slotNum);
            }
            params = vp;
            subkey = stok(NULL, ".", &nextkey);
        }
        assert(params);
        qname = ejsName(ejs, "", subkey);
        ejsSetPropertyByName(ejs, params, qname, value);
    }
}
#endif


static void jsonToPot(Ejs *ejs, MprJson *json, EjsObj *obj)
{
    MprJson     *child;
    EjsName     qname;
    EjsObj      *container;
    int         i;

    for (ITERATE_JSON(json, child, i)) {
        qname = ejsName(ejs, "", child->name);
        if (child->type & MPR_JSON_VALUE) {
            ejsSetPropertyByName(ejs, obj, qname, ejsCreateStringFromAsc(ejs, child->value));
        } else if (child->type & MPR_JSON_ARRAY) {
            container = (EjsObj*) ejsCreateArray(ejs, 0);
            ejsSetPropertyByName(ejs, obj, qname, container);
            jsonToPot(ejs, child, container);
        } else {
            container = ejsCreateEmptyPot(ejs);
            ejsSetPropertyByName(ejs, obj, qname, container);
            jsonToPot(ejs, child, container);
        }
    }
}


static EjsObj *createParams(Ejs *ejs, EjsRequest *req)
{
    EjsObj      *params;
    MprJson     *hparams;

    if ((params = req->params) == 0) {
        params = (EjsObj*) ejsCreateEmptyPot(ejs);
        if (req->conn && (hparams = req->conn->rx->params) != 0) {
            jsonToPot(ejs, hparams, params);
        }
    }
    return req->params = params;
}


static EjsObj *createCookies(Ejs *ejs, EjsRequest *req)
{
    EjsObj      *argv[1];
    cchar       *cookieHeader;

    if (req->cookies) {
        return req->cookies;
    }
    if (req->conn == 0) {
        return ESV(null);
    }
    if ((cookieHeader = mprLookupKey(req->conn->rx->headers, "cookie")) == 0) {
        req->cookies = ESV(null);
    } else {
        argv[0] = (EjsObj*) ejsCreateStringFromAsc(ejs, cookieHeader);
        req->cookies = ejsRunFunctionByName(ejs, ejs->global, N("ejs.web", "parseCookies"), ejs->global, 1, argv);
    }
    return req->cookies;
}


static EjsObj *createEnv(Ejs *ejs, EjsRequest *req)
{
    if (req->env == 0) {
        req->env = ejsCreateEmptyPot(ejs);
    }
    return (EjsObj*) req->env;
}


static EjsObj *createFiles(Ejs *ejs, EjsRequest *req)
{
    HttpUploadFile  *uf;
    HttpConn        *conn;
    EjsObj          *files, *file;
    int             index;

    if (req->files == 0) {
        if (req->conn == 0) {
            return ESV(null);
        }
        conn = req->conn;
        if (conn->rx->files == 0) {
            return ESV(null);
        }
        req->files = files = (EjsObj*) ejsCreateEmptyPot(ejs);
        for (ITERATE_ITEMS(conn->rx->files, uf, index)) {
            file = (EjsObj*) ejsCreateEmptyPot(ejs);
            ejsSetPropertyByName(ejs, file, EN("filename"), ejsCreatePathFromAsc(ejs, uf->filename));
            ejsSetPropertyByName(ejs, file, EN("clientFilename"), ejsCreateStringFromAsc(ejs, uf->clientFilename));
            ejsSetPropertyByName(ejs, file, EN("contentType"), ejsCreateStringFromAsc(ejs, uf->contentType));
            ejsSetPropertyByName(ejs, file, EN("name"), ejsCreateStringFromAsc(ejs, uf->name));
            ejsSetPropertyByName(ejs, file, EN("size"), ejsCreateNumber(ejs, (MprNumber) uf->size));
            ejsSetPropertyByName(ejs, files, EN(uf->name), file);
        }
    }
    return (EjsObj*) req->files;
}


static EjsObj *createHeaders(Ejs *ejs, EjsRequest *req)
{
    EjsName     n;
    EjsString   *value;
    EjsObj      *old;
    HttpConn    *conn;
    MprKey      *kp;
    
    if (req->headers == 0) {
        req->headers = (EjsObj*) ejsCreateEmptyPot(ejs);
        conn = req->conn;
        for (kp = 0; conn && (kp = mprGetNextKey(conn->rx->headers, kp)) != 0; ) {
            n = EN(kp->key);
            if ((old = ejsGetPropertyByName(ejs, req->headers, n)) != 0) {
                value = ejsCreateStringFromAsc(ejs, sjoin(ejsToMulti(ejs, old), "; ", kp->data, NULL));
            } else {
                value = ejsCreateStringFromAsc(ejs, kp->data);
            }
            ejsSetPropertyByName(ejs, req->headers, n, value);
        }
    }
    return (EjsObj*) req->headers;
}


/*
    Callback invoked by Http to fill the http header set just before transmitting headers
 */
static int fillResponseHeaders(EjsRequest *req) 
{
    Ejs         *ejs;
    EjsObj      *vp;
    EjsTrait    *trait;
    EjsName     n;
    char        *value;
    int         i, count;
    
    if (req->responseHeaders) {
        ejs = req->ejs;
        count = ejsGetLength(ejs, req->responseHeaders);
        for (i = 0; i < count; i++) {
            trait = ejsGetPropertyTraits(ejs, req->responseHeaders, i);
            if (trait && trait->attributes & 
                    (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER | EJS_FUN_MODULE_INITIALIZER)) {
                continue;
            }
            n = ejsGetPropertyName(ejs, req->responseHeaders, i);
            vp = ejsGetProperty(ejs, req->responseHeaders, i);
            if (n.name && vp && req->conn) {
                if (ejsIsDefined(ejs, vp)) {
                    value = ejsToMulti(ejs, vp);
                    httpSetHeaderString(req->conn, ejsToMulti(ejs, n.name), value);
                }
            }
        }
    }
    return 0;
}


static EjsObj *createResponseHeaders(Ejs *ejs, EjsRequest *req)
{
    MprKey      *kp;
    HttpConn    *conn;
    
    if (req->responseHeaders == 0) {
        req->responseHeaders = (EjsObj*) ejsCreateEmptyPot(ejs);
        conn = req->conn;
        if (conn && conn->tx) {
            /* Get default headers */
            for (kp = 0; (kp = mprGetNextKey(conn->tx->headers, kp)) != 0; ) {
                ejsSetPropertyByName(ejs, req->responseHeaders, EN(kp->key), ejsCreateStringFromAsc(ejs, kp->data));
            }
            conn->headersCallback = (HttpHeadersCallback) fillResponseHeaders;
            conn->headersCallbackArg = req;
        }
    }
    return (EjsObj*) req->responseHeaders;
}


static EjsString *getSessionKey(Ejs *ejs, EjsRequest *req)
{
    cchar   *cookie;
    char    *id, *cp, *value;
    int     quoted, len;

    if (!req->conn) {
        return 0;
    }
    cookie = httpGetCookies(req->conn);
    if (cookie && (value = strstr(cookie, EJS_SESSION)) != 0) {
        value += strlen(EJS_SESSION);
        while (isspace((uchar) *value) || *value == '=') {
            value++;
        }
        quoted = 0;
        if (*value == '"') {
            value++;
            quoted++;
        }
        for (cp = value; *cp; cp++) {
            if (quoted) {
                if (*cp == '"' && cp[-1] != '\\') {
                    break;
                }
            } else {
                if ((*cp == ',' || *cp == ';') && cp[-1] != '\\') {
                    break;
                }
            }
        }
        len = (int) (cp - value);
        id = mprMemdup(value, len + 1);
        id[len] = '\0';
        return ejsCreateStringFromAsc(ejs, id);
    }
    return 0;
}


/*
    This will get the current session or create a new session if required
 */
static EjsSession *getSession(Ejs *ejs, EjsRequest *req, int create)
{
    HttpConn    *conn;
    EjsString   *key;

    conn = req->conn;
    if (req->probedSession || !conn) {
        return req->session;
    }
    key = getSessionKey(ejs, req);
    if (key || create) {
        req->session = ejsGetSession(ejs, key, conn->limits->sessionTimeout, create);
        if (req->session && !key) {
            //UNICODE
            httpSetCookie(conn, EJS_SESSION, (char*) req->session->key->value, "/", NULL, 0, conn->secure);
        }
        req->probedSession = 1;
    }
    return req->session;
}


static EjsString *createString(Ejs *ejs, cchar *value)
{
    if (value == 0) {
        return ESV(null);
    }
    return ejsCreateStringFromAsc(ejs, value);
}


static int getDefaultInt(Ejs *ejs, EjsNumber *value, int defaultValue)
{
    if (value == 0 || ejsIs(ejs, value, Null)) {
        return defaultValue;
    }
    return ejsGetInt(ejs, value);
}


static cchar *getDefaultString(Ejs *ejs, EjsString *value, cchar *defaultValue)
{
    if (value == 0 || ejsIs(ejs, value, Null)) {
        return defaultValue;
    }
    return ejsToMulti(ejs, value);
}


static cchar *getRequestString(Ejs *ejs, EjsObj *value)
{
    if (value == 0) {
        return "";
    }
    return ejsToMulti(ejs, value);
}


static EjsAny *mapNull(Ejs *ejs, EjsAny *value)
{
    if (value == 0) {
        return ESV(null);
    }
    return value;
}


/*
    Get the best public host name for the serving host
 */
static cchar *getHost(HttpConn *conn, EjsRequest *req)
{
    cchar       *hostName, *cp;

    if (req->server && req->server->name && *req->server->name) {
        hostName = req->server->name;
    } else if (conn && conn->rx->hostHeader && conn->rx->hostHeader) {
        hostName = conn->rx->hostHeader;
    } else if (conn && conn->sock) {
        hostName = conn->sock->acceptIp;
    } else {
        hostName = "localhost";
    }
    if ((cp = schr(hostName, ':')) != 0) {
        return snclone(hostName, cp - hostName);
    }
    return hostName;
}


static EjsObj *getLimits(Ejs *ejs, EjsRequest *req)
{
    if (req->limits == 0) {
        req->limits = ejsCreateEmptyPot(ejs);
        if (req->conn) {
            ejsGetHttpLimits(ejs, req->limits, req->conn->limits, 0);
        }
    }
    return req->limits;
}


static char *makeRelativeHome(Ejs *ejs, EjsRequest *req)
{
    HttpRx      *rx;
    cchar       *path, *end, *sp;
    char        *home, *cp;
    int         levels;

    if (req->conn == NULL) {
        return sclone("/");
    }
    rx = req->conn->rx;
    path = rx->pathInfo;
    assert(path && *path == '/');
    end = &path[strlen(path)];
    if (path[1]) {
        for (levels = 1, sp = &path[1]; sp < end; sp++) {
            if (*sp == '/' && sp[-1] != '/') {
                levels++;
            }
        }
    } else {
        levels = 0;
    }
    home = mprAlloc(levels * 3 + 1);
    if (levels) {
        for (cp = home; levels > 0; levels--) {
            strcpy(cp, "../");
            cp += 3;
        }
        *cp = '\0';
    } else {
        //  TODO - was "./" -- if this is reverted, change mprAlloc to be +2 
        *home = '\0';
    }
    return home;
}


/*
    Lookup a property. These properties are virtualized.
 */
static EjsAny *getRequestProperty(Ejs *ejs, EjsRequest *req, int slotNum)
{
    EjsAny      *value, *app;
    HttpConn    *conn;
    cchar       *pathInfo, *scriptName;
    char        *path, *filename, *uri, *ip, *scheme;
    int         port;

    conn = req->conn;

    switch (slotNum) {
    case ES_ejs_web_Request_absHome:
        if (req->absHome == 0) {
            if (req->conn) {
                scheme = conn->secure ? "https" : "http";
                ip = conn->sock ? conn->sock->acceptIp : req->server->ip;
                port = conn->sock ? conn->sock->acceptPort : req->server->port;
                uri = sfmt("%s://%s:%d%s/", scheme, ip, port, conn->rx->scriptName);
                req->absHome = (EjsObj*) ejsCreateUriFromAsc(ejs, uri);
            } else {
                req->absHome = ESV(null);
            }
        }
        return req->absHome;

#if UNUSED
    case ES_ejs_web_Request_authGroup:
        return createString(ejs, conn ? conn->authGroup : NULL);
#endif
            
    case ES_ejs_web_Request_authType:
        return createString(ejs, conn ? conn->authType : NULL);

    case ES_ejs_web_Request_authUser:
        return createString(ejs, conn ? conn->username : NULL);

    case ES_ejs_web_Request_autoFinalizing:
        return ejsCreateBoolean(ejs, !req->dontAutoFinalize);

    case ES_ejs_web_Request_config:
        value = EST(Object)->helpers.getProperty(ejs, req, slotNum);
        if (value == 0 || ejsIs(ejs, value, Null)) {
            /* Default to App.config */
            app = ejsGetProperty(ejs, ejs->global, ES_App);
            value = ejsGetProperty(ejs, app, ES_App_config);
            ejsSetProperty(ejs, req, slotNum, value);
        }
        return mapNull(ejs, value);

    case ES_ejs_web_Request_contentLength:
        return ejsCreateNumber(ejs, conn ? (MprNumber) conn->rx->length : 0);

    case ES_ejs_web_Request_contentType:
        if (conn) {
            createHeaders(ejs, req);
            return mapNull(ejs, ejsGetPropertyByName(ejs, req->headers, EN("content-type")));
        } else return ESV(null);

    case ES_ejs_web_Request_cookies:
        if (conn) {
            return createCookies(ejs, req);
        } else return ESV(null);

    case ES_ejs_web_Request_dir:
        return req->dir;

    case ES_ejs_web_Request_env:
        return createEnv(ejs, req);

    case ES_ejs_web_Request_errorMessage:
        return createString(ejs, conn ? conn->errorMsg : NULL);

    case ES_ejs_web_Request_filename:
        if (req->filename == 0) {
            pathInfo = ejsToMulti(ejs, req->pathInfo);
            if (req->dir) {
                filename = mprJoinPath(req->dir->value, &pathInfo[1]);
                req->filename = ejsCreatePathFromAsc(ejs, filename);
            } else {
                req->filename = ejsCreatePathFromAsc(ejs, pathInfo);
            }
        }
        return req->filename ? (EjsObj*) req->filename : ESV(null);

    case ES_ejs_web_Request_files:
        return createFiles(ejs, req);

    case ES_ejs_web_Request_formData:
        return createFormData(ejs, req);

    case ES_ejs_web_Request_headers:
        return createHeaders(ejs, req);

    case ES_ejs_web_Request_home:
        if (req->home == 0) {
            if (conn) {
                req->home = ejsCreateUriFromAsc(ejs, makeRelativeHome(ejs, req));
            } else return ESV(null);
        }
        return req->home;

    case ES_ejs_web_Request_host:
        if (req->host == 0) {
            /* getHost can handle a null conn */
            req->host = createString(ejs, getHost(conn, req));
        }
        return req->host;

    case ES_ejs_web_Request_isSecure:
        return ejsCreateBoolean(ejs, conn ? conn->secure : 0);

    case ES_ejs_web_Request_limits:
        return getLimits(ejs, req);

    case ES_ejs_web_Request_localAddress:
        return createString(ejs, conn ? conn->sock->acceptIp : NULL);

    case ES_ejs_web_Request_log:
        if (req->log == 0) {
            app = ejsGetProperty(ejs, ejs->global, ES_App);
            req->log = ejsGetProperty(ejs, app, ES_App_log);
        }
        return req->log;

    case ES_ejs_web_Request_method:
        return createString(ejs, conn ? conn->rx->method : NULL);

    case ES_ejs_web_Request_originalMethod:
            return createString(ejs, conn ? conn->rx->originalMethod : NULL);

    case ES_ejs_web_Request_originalUri:
        if (req->originalUri == 0) {
            if (conn) {
                scheme = (conn->secure) ? "https" : "http";
                /* NOTE: conn->rx->uri is not normalized or decoded */
                req->originalUri = (EjsObj*) ejsCreateUriFromParts(ejs, scheme, getHost(conn, req), req->server->port, 
                    conn->rx->uri, conn->rx->parsedUri->query, conn->rx->parsedUri->reference, 0);
            } else {
                return ESV(null);
            }
        }
        return req->originalUri;

    case ES_ejs_web_Request_params:
        return createParams(ejs, req);

    case ES_ejs_web_Request_pathInfo:
        return req->pathInfo;

    case ES_ejs_web_Request_port:
        if (req->port == 0) {
            if (req->server) {
                req->port = ejsCreateNumber(ejs, req->server->port);
            } else return ESV(null);
        }
        return req->port;

    case ES_ejs_web_Request_protocol:
        return createString(ejs, conn ? conn->protocol : NULL);

    case ES_ejs_web_Request_query:
        if (req->query == 0) {
            req->query = createString(ejs, conn ? conn->rx->parsedUri->query : NULL);
        }
        return req->query;

    case ES_ejs_web_Request_reference:
        if (req->reference == 0) {
            req->reference = createString(ejs, conn ? conn->rx->parsedUri->reference : NULL);
        } 
        return req->reference;

    case ES_ejs_web_Request_referrer:
        return createString(ejs, conn ? conn->rx->referrer: NULL);

    case ES_ejs_web_Request_remoteAddress:
        return createString(ejs, conn ? conn->ip : NULL);

    case ES_ejs_web_Request_responded:
        return ejsCreateBoolean(ejs, conn->tx->responded);

    case ES_ejs_web_Request_responseHeaders:
        return createResponseHeaders(ejs, req);

    case ES_ejs_web_Request_route:
        return mapNull(ejs, req->route);

    case ES_ejs_web_Request_scheme:
        if (req->scheme == 0) {
            req->scheme = createString(ejs, (conn && conn->secure) ? "https" : "http");
        }
        return req->scheme;

    case ES_ejs_web_Request_scriptName:
        return req->scriptName ? req->scriptName : ESV(empty);

    case ES_ejs_web_Request_server:
        return req->server;

    case ES_ejs_web_Request_session:
        if (req->session == 0) {
            req->session = getSession(ejs, req, 1);
        }
        return req->session ? req->session : ESV(null);

    case ES_ejs_web_Request_sessionID:
        getSession(ejs, req, 0);
        return (req->session) ? req->session->key : ESV(null);

    case ES_ejs_web_Request_status:
        if (conn) {
            return ejsCreateNumber(ejs, conn->tx->status);
        } else return ESV(null);

    case ES_ejs_web_Request_uri:
        if (req->uri == 0) {
            scriptName = getDefaultString(ejs, req->scriptName, "");
            if (conn) {
                path = sjoin(scriptName, getDefaultString(ejs, req->pathInfo, conn->rx->uri), NULL);
                scheme = (conn->secure) ? "https" : "http";
                req->uri = ejsCreateUriFromParts(ejs, 
                    getDefaultString(ejs, req->scheme, scheme),
                    getDefaultString(ejs, req->host, getHost(conn, req)),
                    getDefaultInt(ejs, req->port, req->server->port),
                    path,
                    getDefaultString(ejs, req->query, conn->rx->parsedUri->query),
                    getDefaultString(ejs, req->reference, conn->rx->parsedUri->reference), 
                    0);
            } else {
                path = sjoin(scriptName, getDefaultString(ejs, req->pathInfo, NULL), NULL);
                req->uri = ejsCreateUriFromParts(ejs, 
                    getDefaultString(ejs, req->scheme, NULL),
                    getDefaultString(ejs, req->host, NULL),
                    getDefaultInt(ejs, req->port, 0),
                    path,
                    getDefaultString(ejs, req->query, NULL),
                    getDefaultString(ejs, req->reference, NULL), 
                    0);
            }
        }
        return req->uri;

#if ES_ejs_web_Request_writeBuffer
    case ES_ejs_web_Request_writeBuffer:
        return req->writeBuffer;
#endif

    default:
        if (slotNum < req->pot.numProp) {
            return EST(Object)->helpers.getProperty(ejs, req, slotNum);
        }
    }
    return 0;
}


static int getRequestPropertyCount(Ejs *ejs, EjsRequest *req)
{
    return ES_ejs_web_Request_NUM_INSTANCE_PROP;
}


static EjsName getRequestPropertyName(Ejs *ejs, EjsRequest *req, int slotNum)
{
    EjsName     qname;

    qname = ejsGetPropertyName(ejs, TYPE(req)->prototype, slotNum);
    if (qname.name == 0) {
        qname = ejsGetPotPropertyName(ejs, &req->pot, slotNum);
    }
    return qname;
}


static int lookupRequestProperty(Ejs *ejs, EjsRequest *req, EjsName qname)
{
    int slotNum;
    
    slotNum = ejsLookupProperty(ejs, TYPE(req)->prototype, qname);
    if (slotNum < 0) {
        slotNum = ejsLookupPotProperty(ejs, &req->pot, qname);
    }
    return slotNum;
}


static int getNum(Ejs *ejs, EjsObj *vp)
{
    if (!ejsIs(ejs, vp, Number) && (vp = (EjsObj*) ejsToNumber(ejs, vp)) == 0) {
        return 0;
    }
    return (int) ((EjsNumber*) vp)->value;
}


static int setRequestProperty(Ejs *ejs, EjsRequest *req, int slotNum,  EjsObj *value)
{
    EjsType     *type;
    EjsUri      *up;

    switch (slotNum) {
    default:
        return EST(Object)->helpers.setProperty(ejs, req, slotNum, value);

    case ES_ejs_web_Request_config:
        req->config = value;
        break;

    case ES_ejs_web_Request_absHome:
        req->absHome = (EjsObj*) ejsToUri(ejs, value);
        break;

    case ES_ejs_web_Request_autoFinalizing:
        req->dontAutoFinalize = !ejsGetBoolean(ejs, value);
        break;

    case ES_ejs_web_Request_dir:
        req->dir = ejsToPath(ejs, value);
        req->filename = 0;
        break;

    case ES_ejs_web_Request_filename:
        req->filename = ejsToPath(ejs, value);
        break;

    case ES_ejs_web_Request_headers:
        /*
            This updates the cached header set only. The original headers in the http module are unchanged.
         */
        req->headers = value;
        break;

    case ES_ejs_web_Request_home:
        req->home = ejsToUri(ejs, value);
        break;

    case ES_ejs_web_Request_host:
        req->host = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_log:
        type = ejsGetType(ejs, ES_Logger);
        if (!ejsIsA(ejs, value, type)) {
            ejsThrowArgError(ejs, "Property is not a logger");
            break;
        }
        req->log = value;
        break;

    case ES_ejs_web_Request_pathInfo:
        req->pathInfo = ejsToString(ejs, value);
        req->filename = 0;
        req->uri = 0;
        break;

    case ES_ejs_web_Request_port:
        req->port = ejsToNumber(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_query:
        req->query = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_reference:
        req->reference = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_responded:
        req->conn->tx->responded = (value == ESV(true));
        break;

    case ES_ejs_web_Request_responseHeaders:
        req->responseHeaders = value;
        break;

    case ES_ejs_web_Request_route:
        req->route = value;
        break;

    case ES_ejs_web_Request_scriptName:
        req->scriptName = ejsToString(ejs, value);
        req->filename = 0;
        req->uri = 0;
        req->absHome = 0;
        break;

    case ES_ejs_web_Request_server:
        type = ejsGetTypeByName(ejs, N("ejs.web", "HttpServer"));
        if (!ejsIsA(ejs, value, type)) {
            ejsThrowArgError(ejs, "Property is not an instance of HttpServer");
            break;
        }
        req->server = (EjsHttpServer*) value;
        break;

    case ES_ejs_web_Request_scheme:
        req->scheme = ejsToString(ejs, value);
        req->uri = 0;
        break;

    case ES_ejs_web_Request_uri:
        up = ejsToUri(ejs, value);
        req->uri = up;
        req->filename = 0;
        if (!connOk(ejs, req, 0)) {
            /*
                This is really just for unit testing without a connection
             */
            if (up->uri->scheme) {
                req->scheme = ejsCreateStringFromAsc(ejs, up->uri->scheme);
            }
            if (up->uri->host) {
                req->host = ejsCreateStringFromAsc(ejs, up->uri->host);
            }
            if (up->uri->port) {
                req->port = ejsCreateNumber(ejs, up->uri->port);
            }
            if (up->uri->path) {
                req->pathInfo = ejsCreateStringFromAsc(ejs, up->uri->path);
            }
            if (up->uri->query) {
                req->query = ejsCreateStringFromAsc(ejs, up->uri->query);
            }
            if (up->uri->reference) {
                req->reference = ejsCreateStringFromAsc(ejs, up->uri->reference);
            }
        }
        break;

#if ES_ejs_web_Request_writeBuffer
    case ES_ejs_web_Request_writeBuffer:
        req->writeBuffer = (EjsByteArray*) value;
        break;
#endif

    /*
        Read-only fields
     */
    case ES_ejs_web_Request_authGroup:
    case ES_ejs_web_Request_authType:
    case ES_ejs_web_Request_authUser:
    case ES_ejs_web_Request_contentLength:
    case ES_ejs_web_Request_cookies:
    case ES_ejs_web_Request_env:
    case ES_ejs_web_Request_errorMessage:
    case ES_ejs_web_Request_formData:
    case ES_ejs_web_Request_files:
    case ES_ejs_web_Request_isSecure:
    case ES_ejs_web_Request_limits:
    case ES_ejs_web_Request_localAddress:
    case ES_ejs_web_Request_originalMethod:
    case ES_ejs_web_Request_originalUri:
    case ES_ejs_web_Request_params:
    case ES_ejs_web_Request_protocol:
    case ES_ejs_web_Request_referrer:
    case ES_ejs_web_Request_remoteAddress:
    case ES_ejs_web_Request_session:
    case ES_ejs_web_Request_sessionID:
        ejsThrowReferenceError(ejs, "Property is readonly");
        break;

    /*
        These tests require a connection
     */
    case ES_ejs_web_Request_method:
        if (connOk(ejs, req, 0)) {
            httpSetMethod(req->conn, getRequestString(ejs, value));
        }
        break;

    case ES_ejs_web_Request_status:
        if (connOk(ejs, req, 0)) {
            httpSetStatus(req->conn, getNum(ejs, value));
        }
        break;
    }
    return 0;
}


/******************************************************************************/
/*  
    function get async(): Boolean
 */
static EjsObj *req_async(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    return ESV(true);
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *req_set_async(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (argv[0] != ESV(true)) {
        ejsThrowIOError(ejs, "Request only supports async mode");
    }
    return 0;
}


/*  
    function autoFinalize(): Void

    Auto-finalize the request if dontAutoFinalize has not been set.
 */
static EjsObj *req_autoFinalize(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    /* If writeBuffer is set, HttpServer is capturning output for caching */
    if (req->conn && !req->dontAutoFinalize) {
        if (!req->writeBuffer) {
            httpFinalize(req->conn);
        }
        req->finalized = 1;
    }
    return 0;
}


/*  
    function close(): Void
 */
static EjsObj *req_close(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (req->conn) {
        if (!req->writeBuffer) {
            httpFinalize(req->conn);
        }
        req->finalized = 1;
        httpCloseRx(req->conn);
    }
    ejsSendRequestCloseEvent(ejs, req);
    return 0;
}


/*  
    function destroySession(): Void
 */
static EjsObj *req_destroySession(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsSession  *sp;

    if ((sp = getSession(ejs, req, 0)) != 0) {
        ejsDestroySession(ejs, sp);
    }
    req->probedSession = 0;
    req->session = 0;
    return 0;
}


/*  
    function dontAutoFinalize(): Void
 */
static EjsObj *req_dontAutoFinalize(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    req->dontAutoFinalize = 1;
    return 0;
}


/*  
    function finalize(): Void

    This routine is idempotent. If using writeBuffers, it will be called multiple times.
 */
static EjsObj *req_finalize(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (req->conn) {
        if (!req->writeBuffer || req->writeBuffer == ESV(null)) {
            httpFinalize(req->conn);
            httpFlush(req->conn);
            httpEnableConnEvents(req->conn);
        } else {
            httpSetResponded(req->conn);
        }
    }
    req->finalized = 1;
    return 0;
}


/*  
    function get finalized(): Boolean
 */
static EjsBoolean *req_finalized(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    return ejsCreateBoolean(ejs, req->conn == 0 || req->finalized || req->conn->tx->finalizedOutput);
}


/*  
    function flush(dir: Number = Stream.WRITE): Void
 */
static EjsObj *req_flush(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    int     dir;

    if (req->conn) {
        dir = (argc == 1) ? ejsGetInt(ejs, argv[0]) : EJS_STREAM_WRITE;
        if (dir & EJS_STREAM_WRITE) {
            httpFlush(req->conn);
        }
    }
    return 0;
}


/*  
    function header(key: String): String
 */
static EjsObj *req_header(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsObj      *value;
    EjsName     qname;
    char        *key;
    int         count, i;

    createHeaders(ejs, req);
    key = (char*) ejsToMulti(ejs, argv[0]);

    if ((value = ejsGetPropertyByName(ejs, req->headers, EN(key))) == 0) {
        count = ejsGetLength(ejs, req->headers);
        for (i = 0; i < count; i++) {
            qname = ejsGetPropertyName(ejs, req->headers, i);
            if (mcaselesscmp(qname.name->value, key) == 0) {
                value = ejsGetProperty(ejs, req->headers, i);
                break;
            }
        }
    }
    return (value) ? value : ESV(null);
}


/*  
    function off(name: [String|Array], listener: Function): Void
 */
static EjsObj *req_off(Ejs *ejs, EjsRequest *req, int argc, EjsAny **argv)
{
    ejsRemoveObserver(ejs, req->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function on(name: [String|Array], listener: Function): Request
 */
static EjsRequest *req_on(Ejs *ejs, EjsRequest *req, int argc, EjsAny **argv)
{
    HttpConn    *conn;
    
    conn = req->conn;
    ejsAddObserver(ejs, &req->emitter, argv[0], argv[1]);

    if (conn->readq->count > 0) {
        ejsSendEvent(ejs, req->emitter, "readable", NULL, req);
    }
    //  TODO - should not ned to test finalizedConnector
    if (!conn->tx->finalizedConnector && 
            !conn->error && HTTP_STATE_CONNECTED <= conn->state && conn->state < HTTP_STATE_FINALIZED &&
            conn->writeq->ioCount == 0) {
        ejsSendEvent(ejs, req->emitter, "writable", NULL, req);
    }
    return req;
}


/*  
    function read(buffer, offset, count): Number?
 */
static EjsNumber *req_read(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsByteArray    *ba;
    ssize           offset, count, nbytes;

    if (!connOk(ejs, req, 1)) return 0;

    ba = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]) : -1;

    ejsResetByteArray(ejs, ba);
    if (!ejsMakeRoomInByteArray(ejs, ba, count >= 0 ? count : ME_MAX_BUFFER)) {
        return 0;
    }
    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (count < 0) {
        count = ba->size - offset;
    }
    if (count < 0) {
        ejsThrowStateError(ejs, "Read count is negative");
        return 0;
    }
    assert(count > 0);
    nbytes = httpRead(req->conn, (char*) &ba->value[offset], count);
    if (nbytes < 0) {
        ejsThrowIOError(ejs, "Cannot read from socket");
        return 0;
    }
    if (nbytes == 0) {
        if (httpIsEof(req->conn)) {
            //  TODO -- should this set req->conn to zero?
            return ESV(null);
        }
    }
    ba->writePosition += nbytes;
    return ejsCreateNumber(ejs, (MprNumber) nbytes);
}


/*  
    function setHeader(key: String, value: String, overwrite: Boolean = true): Void
 */
static EjsObj *req_setHeader(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsString   *value;
    EjsObj      *old;
    cchar       *key;
    int         overwrite;

    if (!connOk(ejs, req, 1)) return 0;
    key = ejsToMulti(ejs, argv[0]);
    value = (EjsString*) argv[1];
    overwrite = argc < 3 || argv[2] == ESV(true);
    createResponseHeaders(ejs, req);
    if (scaselessmatch(key, "content-length")) {
        httpSetContentLength(req->conn, ejsGetInt(ejs, value));
    } else if (scaselessmatch(key, "x-chunk-size")) {
        /* Just until we have filters - to disable chunk filtering */
        httpSetChunkSize(req->conn, ejsGetInt(ejs, value));
    }
    if (!overwrite) {
        if ((old = ejsGetPropertyByName(ejs, req->responseHeaders, EN(key))) != 0) {
            value = ejsSprintf(ejs, "%@, %@", old, value);
        }
    }
    ejsSetPropertyByName(ejs, req->responseHeaders, EN(key), value);

    return 0;
}


/*  
    function set limits(limits: Object): Void
 */
static EjsObj *req_setLimits(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    if (!connOk(ejs, req, 1)) return 0;
    if (req->conn->limits == req->server->endpoint->limits) {
        httpSetUniqueConnLimits(req->conn);
    }
    if (req->limits == 0) {
        req->limits = ejsCreateEmptyPot(ejs);
        ejsGetHttpLimits(ejs, req->limits, req->conn->limits, 0);
    }
    ejsBlendObject(ejs, req->limits, argv[0], EJS_BLEND_OVERWRITE);
    ejsSetHttpLimits(ejs, req->conn->limits, req->limits, 0);
    if (req->session) {
        ejsSetSessionTimeout(ejs, req->session, req->conn->limits->sessionTimeout);
    }
    return 0;
}


/*  
    function trace(options): Void
 */
static EjsObj *req_trace(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    ejsSetupHttpTrace(ejs, req->conn->trace, argv[0]);
    return 0;
}


/*
    Single channel for all write data
 */
static ssize writeResponseData(Ejs *ejs, EjsRequest *req, cchar *buf, ssize len)
{
    ssize   written;
    
    if (req->writeBuffer && req->writeBuffer != ESV(null)) {
        if ((written = ejsCopyToByteArray(ejs, req->writeBuffer, -1, buf, len)) > 0) {
            //  TODO - need API to do combined write to ByteArray and inc writePosition
            req->writeBuffer->writePosition += written;
        }
        httpSetResponded(req->conn);
        return written;
    } else {
        return httpWriteBlock(req->conn->writeq, buf, len, HTTP_BUFFER);
    }
}


/*  
    Write text to the client. This call writes the arguments back to the client's browser. 
    This and writeFile are the lowest channel for write data.
 
    function write(data: Object): Number
 */
static EjsNumber *req_write(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsString       *s;
    EjsObj          *data;
    EjsByteArray    *ba;
    HttpConn        *conn;
    ssize           len, written, total;
    int             err, i;

    conn = req->conn;
    if (!connOk(ejs, req, 1) || httpIsOutputFinalized(conn)) {
        return 0;
    }
    err = 0;
    total = written = 0;
    args = (EjsArray*) argv[0];

    for (i = 0; i < args->length; i++) {
        data = args->data[i];
        switch (TYPE(data)->sid) {
        case S_String:
            s = (EjsString*) data;
            if ((written = writeResponseData(ejs, req, s->value, s->length)) != s->length) {
                err++;
            }
            break;

        case S_ByteArray:
            ba = (EjsByteArray*) data;
            len = ba->writePosition - ba->readPosition;
            if ((written = writeResponseData(ejs, req, (char*) &ba->value[ba->readPosition], len)) != len) {
                err++;
            } else {
                ba->readPosition += len;
            }
            break;

        default:
            s = (EjsString*) ejsToString(ejs, data);
            if (s == NULL || (written = writeResponseData(ejs, req, s->value, s->length)) != s->length) {
                err++;
            }
        }
        if (err) {
            ejsThrowIOError(ejs, "%s", conn->errorMsg);
        }
        if (ejs->exception) {
            return 0;
        }
        req->written += written;
        total += written;
    }
    //  TODO should not need to test finalizedConnector
    if (!conn->tx->finalizedConnector && 
            !conn->error && HTTP_STATE_CONNECTED <= conn->state && conn->state < HTTP_STATE_FINALIZED &&
            conn->writeq->ioCount == 0) {
        ejsSendEvent(ejs, req->emitter, "writable", NULL, req);
    }
    return ejsCreateNumber(ejs, (MprNumber) total);
}


/*  
    function writeFile(path: Path): Boolean

    Note: this bypasses req->writeBuffer
 */
static EjsObj *req_writeFile(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsPath         *path;
    HttpConn        *conn;
    HttpTx          *tx;
    HttpPacket      *packet;
    MprPath         *info;

    if (!connOk(ejs, req, 1)) return 0;
    conn = req->conn;
    tx = conn->tx;

    if (tx->outputRanges || conn->secure || tx->chunkSize > 0) {
        return ESV(false);
    }
    path = (EjsPath*) argv[0];
    info = &tx->fileInfo;
    if (mprGetPathInfo(path->value, info) < 0) {
        ejsThrowIOError(ejs, "Cannot open %s", path->value);
        return ESV(false);
    }
    packet = httpCreateEntityPacket(0, info->size, NULL);
    tx->length = tx->entityLength = info->size;
    httpSetSendConnector(req->conn, path->value);
    httpPutForService(conn->writeq, packet, 0);
    httpFinalize(req->conn);
    req->finalized = 1;
    return ESV(true);
}


/*
    function get written(): Number
 */
static EjsNumber *req_written(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    return ejsCreateNumber(ejs, (MprNumber) req->written);
}


/************************************ Factory *************************************/
/*
    Clone the request object into the "ejs" interpreter.
    This does a "minimal" clone for speed.
 */
EjsRequest *ejsCloneRequest(Ejs *ejs, EjsRequest *req, bool deep)
{
    HttpConn    *conn;
    EjsRequest  *nreq;
    EjsType     *type;

    type = ejsGetTypeByName(ejs, N("ejs.web", "Request"));
    if ((nreq = ejsCreatePot(ejs, type, 0)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    conn = req->conn;
    nreq->conn = conn;
    nreq->ejs = ejs;
    nreq->dir = ejsClone(ejs, req->dir, 1);
    nreq->filename = ejsClone(ejs, req->filename, 1);
    nreq->pathInfo = ejsCreateStringFromAsc(ejs, conn->rx->pathInfo);
    nreq->scriptName = ejsCreateStringFromAsc(ejs, conn->rx->scriptName);
    nreq->running = req->running;
    nreq->cloned = req;

    if (req->route) {
        nreq->route = ejsClone(ejs, req->route, 1);
    }
    if (req->config) {
        nreq->config = ejsClone(ejs, req->config, 1);
    }
    if (req->params) {
        nreq->params = ejsClone(ejs, req->params, 1);
    }
    return nreq;
}


EjsRequest *ejsCreateRequest(Ejs *ejs, EjsHttpServer *server, HttpConn *conn, cchar *dir)
{
    EjsRequest      *req;
    EjsType         *type;
    HttpRx          *rx;

    assert(server);
    assert(conn);
    assert(dir && *dir);

    type = ejsGetTypeByName(ejs, N("ejs.web", "Request"));
    if (type == NULL || (req = ejsCreateObj(ejs, type, 0)) == NULL) {
        return 0;
    }
    req->running = 1;
    req->conn = conn;
    req->ejs = ejs;
    req->server = server;
    rx = conn->rx;
    if (mprIsPathRel(dir)) {
        req->dir = ejsCreatePathFromAsc(ejs, dir);
    } else {
        req->dir = ejsCreatePathFromAsc(ejs, mprGetRelPath(dir, 0));
    }
    assert(!VISITED(req->dir));
    //  OPT -- why replicate these two
    req->pathInfo = ejsCreateStringFromAsc(ejs, rx->pathInfo);
    req->scriptName = ejsCreateStringFromAsc(ejs, rx->scriptName);
    return req;
}


void ejsSendRequestCloseEvent(Ejs *ejs, EjsRequest *req)
{
    if (!req->closed && req->emitter) {
        req->closed = 1;
        ejsSendEvent(ejs, req->emitter, "close", NULL, req);
    }
}


void ejsSendRequestErrorEvent(Ejs *ejs, EjsRequest *req)
{
    if (!req->error && req->emitter) {
        req->error = 1;
        ejsSendEvent(ejs, req->emitter, "error", NULL, req);
    }
}


void ejsSendRequestEvent(Ejs *ejs, EjsRequest *req, cchar *event)
{
    if (req->emitter) {
        ejsSendEvent(ejs, req->emitter, event, NULL, req);
    }
}


/*  
    Mark the object properties for the garbage collector
 */
static void manageRequest(EjsRequest *req, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(req, flags);
        mprMark(req->absHome);
        mprMark(req->cloned);
        mprMark(req->config);
        mprMark(req->conn);
        mprMark(req->cookies);
        mprMark(req->dir);
        mprMark(req->emitter);
        mprMark(req->env);
        mprMark(req->filename);
        mprMark(req->files);
        mprMark(req->formData);
        mprMark(req->headers);
        mprMark(req->home);
        mprMark(req->host);
        mprMark(req->limits);
        mprMark(req->log);
        mprMark(req->originalUri);
        mprMark(req->params);
        mprMark(req->pathInfo);
        mprMark(req->port);
        mprMark(req->query);
        mprMark(req->reference);
        mprMark(req->responseHeaders);
        mprMark(req->route);
        mprMark(req->scheme);
        mprMark(req->scriptName);
        mprMark(req->server);
        mprMark(req->uri);
        mprMark(req->writeBuffer);
        mprMark(req->ejs);
        mprMark(req->session);
    }
}


void ejsConfigureRequestType(Ejs *ejs)
{
    EjsType     *type;
    EjsHelpers  *helpers;
    EjsPot      *prototype;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs.web", "Request"), sizeof(EjsRequest), manageRequest, 
            EJS_TYPE_DYNAMIC_INSTANCES | EJS_TYPE_POT)) == 0) {
        return;
    }
    helpers = &type->helpers;
    helpers->getProperty = (EjsGetPropertyHelper) getRequestProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getRequestPropertyCount;
    helpers->getPropertyName = (EjsGetPropertyNameHelper) getRequestPropertyName;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupRequestProperty;
    helpers->setProperty = (EjsSetPropertyHelper) setRequestProperty;

    prototype = type->prototype;
    ejsBindAccess(ejs, prototype, ES_ejs_web_Request_async, req_async, req_set_async);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_autoFinalize, req_autoFinalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_close, req_close);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_destroySession, req_destroySession);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_dontAutoFinalize, req_dontAutoFinalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_finalize, req_finalize);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_finalized, req_finalized);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_flush, req_flush);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_header, req_header);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_off, req_off);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_on, req_on);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_read, req_read);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_setLimits, req_setLimits);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_setHeader, req_setHeader);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_trace, req_trace);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_write, req_write);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_writeFile, req_writeFile);
    ejsBindMethod(ejs, prototype, ES_ejs_web_Request_written, req_written);
}
#endif


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/ejs.web/ejsSession.c"
 */
/************************************************************************/

/**
    ejsSession.c - Native code for the Session class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/

#include    "me.h"

#if ME_EJS_WEB



/********************************** Forwards  *********************************/

static int getSessionState(Ejs *ejs, EjsSession *sp);

/************************************* Code ***********************************/

static EjsSession *initSession(Ejs *ejs, EjsSession *sp, EjsString *key, MprTicks timeout)
{
    EjsObj      *app;

    app = ejsGetPropertyByName(ejs, ejs->global, N("ejs", "App"));
    if ((sp->cache = ejsGetProperty(ejs, app, ES_App_cache)) == ESV(null)) {
        ejsThrowStateError(ejs, "App.cache is null");
        sp->cache = 0;
        return 0;
    }
    sp->timeout = timeout;
    sp->key = key;
    return sp;
}


static EjsString *makeKey(Ejs *ejs, EjsSession *sp)
{
    char        idBuf[64];
    static int  nextSession = 0;

    /* Thread race here on nextSession++ not critical */
    fmt(idBuf, sizeof(idBuf), "%08x%08x%d", PTOI(ejs) + PTOI(sp), (int) mprGetTime(), nextSession++);
    return ejsCreateStringFromAsc(ejs, mprGetMD5WithPrefix(idBuf, sizeof(idBuf), "::ejs.web.session::"));
}


/*
    Get (create) a session object using the supplied key. If the key has expired or is NULL, then generate a new key if
    create is true. The timeout is in msec.
 */
EjsSession *ejsGetSession(Ejs *ejs, EjsString *key, MprTicks timeout, int create)
{
    EjsSession  *sp;
    EjsType     *type;

    type = ejsGetTypeByName(ejs, N("ejs.web", "Session"));
    if ((sp = ejsCreateObj(ejs, type, 0)) == 0) {
        return 0;
    }
    mprSetName(sp, "session");
    if ((sp = initSession(ejs, sp, key, timeout)) == 0) {
        return 0;
    }
    if (!getSessionState(ejs, sp) && create) {
        sp->key = makeKey(ejs, sp);
    }
    return sp;
}


int ejsDestroySession(Ejs *ejs, EjsSession *sp)
{
    if (sp) {
        ejsCacheRemove(ejs, sp->cache, sp->key);
    }
    return 0;
}


static void manageSession(EjsSession *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(sp, flags);
        mprMark(sp->key);
        mprMark(sp->cache);
        mprMark(sp->options);
    }
}


/*
    Session state is read once and cached. Writes to session properties are cached with write-through
 */
static int getSessionState(Ejs *ejs, EjsSession *sp) 
{
    EjsName     qname;
    EjsObj      *src, *vp;
    int         i, count;

    if (sp->ready) {
        return 1;
    }
    sp->ready = 1;
    if (sp->key && (src = ejsCacheReadObj(ejs, sp->cache, sp->key, 0)) != 0) {
        sp->pot.numProp = 0;
        count = ejsGetLength(ejs, src);
        for (i = 0; i < count; i++) {
            if ((vp = ejsGetProperty(ejs, src, i)) == 0) {
                continue;
            }
            qname = ejsGetPropertyName(ejs, src, i);
            ejs->service->potHelpers.setProperty(ejs, sp, i, vp);
            ejs->service->potHelpers.setPropertyName(ejs, sp, i, qname);
        }
        return 1;
    }
    return 0;
}


static EjsObj *getSessionProperty(Ejs *ejs, EjsSession *sp, int slotNum)
{
    EjsObj  *value;

    getSessionState(ejs, sp);
    value = ejs->service->potHelpers.getProperty(ejs, sp, slotNum);
    if (ejsIs(ejs, value, Void)) {
        /*  Return empty string so that web pages can access session values without having to test for null/undefined */
        value = ESV(empty);
    }
    return value;
}


static EjsObj *getSessionPropertyByName(Ejs *ejs, EjsSession *sp, EjsName qname)
{
    int     slotNum;

    getSessionState(ejs, sp);
    slotNum = ejs->service->potHelpers.lookupProperty(ejs, sp, qname);
    return (slotNum < 0) ? ESV(empty) : ejs->service->potHelpers.getProperty(ejs, sp, slotNum);
}


static int lookupSessionProperty(Ejs *ejs, EjsSession *sp, EjsName qname)
{
    getSessionState(ejs, sp);
    return ejs->service->potHelpers.lookupProperty(ejs, sp, qname);
}


/*
    Set a session property with write-through to the key/value cache
 */
static int setSessionProperty(Ejs *ejs, EjsSession *sp, int slotNum, EjsAny *value)
{
    if (ejs->service->potHelpers.setProperty(ejs, sp, slotNum, value) != slotNum) {
        return EJS_ERR;
    }
    if (sp->options == 0) {
        sp->options = ejsCreateEmptyPot(ejs);
        ejsSetPropertyByName(ejs, sp->options, EN("lifespan"), 
            ejsCreateNumber(ejs, (MprNumber) (sp->timeout / MPR_TICKS_PER_SEC)));
    }
    if (ejsCacheWriteObj(ejs, sp->cache, sp->key, sp, sp->options) == 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    The timeout arg is a number of ticks to add to the current time
 */
void ejsSetSessionTimeout(Ejs *ejs, EjsSession *sp, MprTicks timeout)
{
    ejsCacheExpire(ejs, sp->cache, sp->key, ejsCreateDate(ejs, mprGetTime() + timeout));
}


/*
    function Session(key: String, options: Object)

    The constructor is bypassed when ejsGetSession is called from Request.
 */
static EjsSession *sess_constructor(Ejs *ejs, EjsSession *sp, int argc, EjsAny **argv)
{
    EjsAny      *vp;
    EjsPot      *options;
    MprTicks    timeout;

    timeout = 0;
    if (argc > 0) {
        options = argv[0];
        vp = ejsGetPropertyByName(ejs, options, EN("lifespan"));
        timeout = ejsGetInt(ejs, vp) * MPR_TICKS_PER_SEC;
    }
    return initSession(ejs, sp, sp->key, timeout);
}


/*
    static function destroySession(session: Session)
 */
static EjsVoid *sess_destroySession(Ejs *ejs, EjsType *Session, int argc, EjsAny **argv)
{
    ejsDestroySession(ejs, argv[0]);
    return 0;
}


/*
    static function key(session: Session): String
 */
static EjsString *sess_key(Ejs *ejs, EjsType *Session, int argc, EjsAny **argv)
{
    EjsSession  *sp;

    sp = argv[0];
    return sp->key;
}


void ejsConfigureSessionType(Ejs *ejs)
{
    EjsType         *type;
    EjsHelpers      *helpers;

    if ((type = ejsFinalizeScriptType(ejs, N("ejs.web", "Session"), sizeof(EjsSession), manageSession, 
            EJS_TYPE_POT | EJS_TYPE_DYNAMIC_INSTANCES)) == 0) {
        return;
    }
    /*
        Sessions are created indirectly by accessing Request.session[] which uses ejsGetSession.
     */
    helpers = &type->helpers;
    helpers->getProperty = (EjsGetPropertyHelper) getSessionProperty;
    helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getSessionPropertyByName;
    helpers->setProperty = (EjsSetPropertyHelper) setSessionProperty;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupSessionProperty;

    ejsBindConstructor(ejs, type, sess_constructor);
    ejsBindAccess(ejs, type, ES_ejs_web_Session_destorySession, sess_destroySession, 0);
    ejsBindAccess(ejs, type, ES_ejs_web_Session_key, sess_key, 0);
}
#endif


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/ejs.web/ejsWeb.c"
 */
/************************************************************************/

/*
    ejsWeb.c -- Ejscript web framework.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */
/********************************** Includes **********************************/

#include    "me.h"

#if ME_EJS_WEB





/***************************** Forward Declarations ***************************/

static int configureWebTypes(Ejs *ejs);

/************************************ Code ************************************/
/*  
    HTML escape a string
    function escapeHtml(str: String): String
 */
static EjsObj *web_escapeHtml(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *str;

    str = (EjsString*) argv[0];
    return (EjsObj*) ejsCreateStringFromAsc(ejs, mprEscapeHtml(str->value));
}


static int configureWebTypes(Ejs *ejs)
{
    int         slotNum;

    if ((slotNum = ejsLookupProperty(ejs, ejs->global, N("ejs.web", "escapeHtml"))) != 0) {
        ejsBindFunction(ejs, ejs->global, slotNum, web_escapeHtml);
    }
    ejsConfigureHttpServerType(ejs);
    ejsConfigureRequestType(ejs);
    ejsConfigureSessionType(ejs);
    return 0;
}


/*  
    Module load entry point. This must be idempotent as it will be called for each new interpreter created.
 */
int ejs_web_Init(Ejs *ejs, MprModule *mp)
{
    return ejsAddNativeModule(ejs, "ejs.web", configureWebTypes, _ES_CHECKSUM_ejs_web, EJS_LOADER_ETERNAL);
}
#endif


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/ejs.zlib/ejsZlib.c"
 */
/************************************************************************/

/*
    ejsZlib.c -- Zlib compression 

    Copyright (c) All Rights Reserved. See details at the end of the file.

 */
/********************************** Includes **********************************/



#if ME_EJS_ZLIB



#define     ZBUFSIZE (16 * 1024)

/************************************ Code ************************************/
/*
    compress(src: Path, dest: Path = null)
 */
static EjsObj *zlib_compress(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprFile     *in;
    gzFile      out;
    cchar       *src, *dest;
    uchar       inbuf[ME_MAX_BUFFER];
    ssize       nbytes;

    src = ((EjsPath*) argv[0])->value;
    dest = (argc >= 2) ? ejsToMulti(ejs, argv[1]) : 0;
    if (!dest) {
        dest = sjoin(src, ".gz", NULL);
    }
    if ((in = mprOpenFile(src, O_RDONLY | O_BINARY, 0)) == 0) {
        ejsThrowIOError(ejs, "Cannot open from %s", src);
        return 0;
    }
    if ((out = gzopen(dest, "wb")) == 0) {
        ejsThrowIOError(ejs, "Cannot open destination %s", dest);
        return 0;
    }
    while (1) {
        if ((nbytes = mprReadFile(in, inbuf, sizeof(inbuf))) < 0) {
            ejsThrowIOError(ejs, "Cannot read from %s", src);
            return 0;
        } else if (nbytes == 0) {
            break;
        }
        if (gzwrite(out, inbuf, (int) nbytes) != nbytes) {
            ejsThrowIOError(ejs, "Cannot write to %s", dest);
            return 0;
        }
    }
    mprCloseFile(in);
    gzclose(out);
    return 0;
}


/*
    uncompress(src: Path, dest: Path = null)
 */
static EjsObj *zlib_uncompress(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprFile     *out;
    gzFile      in;
    cchar       *src, *dest;
    uchar       inbuf[ME_MAX_BUFFER];
    ssize       nbytes;

    src = ((EjsPath*) argv[0])->value;
    dest = (argc >= 2) ? ejsToMulti(ejs, argv[1]) : 0;
    if (!dest) {
        dest = strim(src, ".gz", MPR_TRIM_END);
    }
    if ((in = gzopen(src, "rb")) == 0) {
        ejsThrowIOError(ejs, "Cannot open from %s", src);
        return 0;
    }
    if ((out = mprOpenFile(dest, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644)) == 0) {
        ejsThrowIOError(ejs, "Cannot open destination %s", dest);
        return 0;
    }
    while (1) {
        if ((nbytes = gzread(in, inbuf, sizeof(inbuf))) < 0) {
            ejsThrowIOError(ejs, "Cannot read from %s", src);
            return 0;
        } else if (nbytes == 0) {
            break;
        }
        if (mprWriteFile(out, inbuf, (int) nbytes) != nbytes) {
            ejsThrowIOError(ejs, "Cannot write to %s", dest);
            return 0;
        }
    }
    mprCloseFile(out);
    gzclose(in);
    return 0;
}


/*
    compressBytes(data: ByteArray): ByteArray
 */
static EjsObj *zlib_compressBytes(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsByteArray    *in, *out;
    z_stream        zs;
    char            outbuf[ZBUFSIZE];
    ssize           nbytes;
    int             level, flush;

    in = (EjsByteArray*) argv[0];
    if ((out = ejsCreateByteArray(ejs, in->size)) == 0) {
        return 0;
    }
    zs.zalloc = Z_NULL;
    zs.zfree = Z_NULL;
    zs.opaque = Z_NULL;
    level = Z_DEFAULT_COMPRESSION;
    deflateInit(&zs, level);
    zs.avail_in = (int) ejsGetByteArrayAvailableData(in);
    zs.next_in = (uchar*) &in->value[in->readPosition];
    do {
        flush = (zs.avail_in == 0) ? Z_FINISH : Z_NO_FLUSH;
        do {
            zs.avail_out = ZBUFSIZE;
            zs.next_out = (uchar*) outbuf;
            deflate(&zs, flush);
            nbytes = ZBUFSIZE - zs.avail_out;
            if (ejsCopyToByteArray(ejs, out, -1, outbuf, nbytes) != nbytes) {
                ejsThrowIOError(ejs, "Cannot copy to byte array");
                deflateEnd(&zs);
                return 0;
            }
            out->writePosition += nbytes;
        } while (zs.avail_out == 0);
        assert(zs.avail_in == 0);
    } while (flush != Z_FINISH);
    deflateEnd(&zs);
    return (EjsObj*) out;
}


/*
    uncompressBytes(data: ByteArray): ByteArray
 */
static EjsObj *zlib_uncompressBytes(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsByteArray    *in, *out;
    z_stream        zs;
    uchar           outbuf[ZBUFSIZE];
    ssize           nbytes, size;
    int             rc;

    in = (EjsByteArray*) argv[0];
    if ((out = ejsCreateByteArray(ejs, in->size)) == 0) {
        return 0;
    }
    if ((size = (int) ejsGetByteArrayAvailableData(in)) == 0) {
        return (EjsObj*) out;
    }
    zs.zalloc = Z_NULL;
    zs.zfree = Z_NULL;
    zs.opaque = Z_NULL;
    zs.avail_in = 0;
    rc = inflateInit(&zs);
    zs.next_in = &in->value[in->readPosition];
    zs.avail_in = (int) size;

    do {
        if (zs.avail_in == 0) {
            break;
        }
        do {
            zs.avail_out = ZBUFSIZE;
            zs.next_out = (uchar*) outbuf;
            if ((rc = inflate(&zs, Z_NO_FLUSH)) == Z_NEED_DICT) {
                inflateEnd(&zs);
                return 0;
            } else if (rc == Z_DATA_ERROR || rc == Z_MEM_ERROR) {
                inflateEnd(&zs);
                return 0;
            } else {
                nbytes = ZBUFSIZE - zs.avail_out;
            }
            if (ejsCopyToByteArray(ejs, out, -1, (char*) outbuf, nbytes) != nbytes) {
                ejsThrowIOError(ejs, "Cannot copy to byte array");
                inflateEnd(&zs);
                return 0;
            }
            out->writePosition += nbytes;
        } while (zs.avail_out == 0);
        assert(zs.avail_in == 0);
    } while (rc != Z_STREAM_END);

    deflateEnd(&zs);
    return (EjsObj*) out;
}


/*
    compressString(data: String): String
 */
static EjsString *zlib_compressString(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString       *in;
    MprBuf          *out;
    z_stream        zs;
    uchar           outbuf[ZBUFSIZE];
    ssize           size, nbytes;
    int             level, flush;

    in = (EjsString*) argv[0];
    if ((size = in->length) == 0) {
        return ESV(empty);
    }
    if ((out = mprCreateBuf(in->length, 0)) == 0) {
        return 0;
    }
    zs.zalloc = Z_NULL;
    zs.zfree = Z_NULL;
    zs.opaque = Z_NULL;
    level = Z_DEFAULT_COMPRESSION;
    deflateInit(&zs, level);
    zs.next_in = (uchar*) in->value;
    zs.avail_in = (int) size;
    do {
        flush = (zs.avail_in == 0) ? Z_FINISH : Z_NO_FLUSH;
        do {
            zs.avail_out = ZBUFSIZE;
            zs.next_out = outbuf;
            deflate(&zs, flush);
            nbytes = ZBUFSIZE - zs.avail_out;
            if (mprPutBlockToBuf(out, (char*) outbuf, nbytes) != nbytes) {
                ejsThrowIOError(ejs, "Cannot copy to output buffer");
                deflateEnd(&zs);
                return 0;
            }
        } while (zs.avail_out == 0);
        assert(zs.avail_in == 0);
    } while (flush != Z_FINISH);

    deflateEnd(&zs);
    return ejsCreateStringFromBytes(ejs, mprGetBufStart(out), mprGetBufLength(out));
}


/*
    uncompressString(data: String): String
 */
static EjsString *zlib_uncompressString(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString       *in;
    MprBuf          *out;
    z_stream        zs;
    uchar           outbuf[ZBUFSIZE];
    ssize           nbytes, size;
    int             rc;

    in = (EjsString*) argv[0];
    if ((out = mprCreateBuf(ZBUFSIZE, -1)) == 0) {
        return 0;
    }
    if ((size = in->length) == 0) {
        return ESV(empty);
    }
    zs.zalloc = Z_NULL;
    zs.zfree = Z_NULL;
    zs.opaque = Z_NULL;
    zs.avail_in = 0;
    rc = inflateInit(&zs);
    zs.next_in = (uchar*) in->value;
    zs.avail_in = (int) size;

    do {
        if (zs.avail_in == 0) {
            break;
        }
        do {
            zs.avail_out = ZBUFSIZE;
            zs.next_out = outbuf;
            if ((rc = inflate(&zs, Z_NO_FLUSH)) == Z_NEED_DICT) {
                inflateEnd(&zs);
                return 0;
            } else if (rc == Z_DATA_ERROR || rc == Z_MEM_ERROR) {
                inflateEnd(&zs);
                return 0;
            } else {
                nbytes = ZBUFSIZE - zs.avail_out;
            }
            if (mprPutBlockToBuf(out, (char*) outbuf, nbytes) != nbytes) {
                ejsThrowIOError(ejs, "Cannot copy to byte array");
                inflateEnd(&zs);
                return 0;
            }
        } while (zs.avail_out == 0);
        assert(zs.avail_in == 0);
    } while (rc != Z_STREAM_END);

    deflateEnd(&zs);
    return ejsCreateStringFromBytes(ejs, mprGetBufStart(out), mprGetBufLength(out));
}

/*********************************** Factory *******************************/

#if UNUSED
static int manageZlib(EjsZlib *db, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        ejsManagePot(db, flags);

    } else if (flags & MPR_MANAGE_FREE) {
        if (db->sdb) {
            zlibClose(db->ejs, db, 0, 0);
        }
    }
    return 0;
}
#endif


static int configureZlibTypes(Ejs *ejs)
{
    EjsType     *type;
    
    if ((type = ejsFinalizeScriptType(ejs, N("ejs.zlib", "Zlib"), 0, NULL, 0)) == 0) {
        return 0;
    }
    ejsBindMethod(ejs, type, ES_ejs_zlib_Zlib_compress, zlib_compress);
    ejsBindMethod(ejs, type, ES_ejs_zlib_Zlib_uncompress, zlib_uncompress);
    ejsBindMethod(ejs, type, ES_ejs_zlib_Zlib_compressBytes, zlib_compressBytes);
    ejsBindMethod(ejs, type, ES_ejs_zlib_Zlib_uncompressBytes, zlib_uncompressBytes);
    ejsBindMethod(ejs, type, ES_ejs_zlib_Zlib_compressString, zlib_compressString);
    ejsBindMethod(ejs, type, ES_ejs_zlib_Zlib_uncompressString, zlib_uncompressString);
    return 0;
}


/*
    Module load entry point. This must be idempotent as it will be called for each new interpreter created.
 */
PUBLIC int ejs_zlib_Init(Ejs *ejs, MprModule *mp)
{
    return ejsAddNativeModule(ejs, "ejs.zlib", configureZlibTypes, _ES_CHECKSUM_ejs_zlib, EJS_LOADER_ETERNAL);
}
#endif /* ME_EJS_ZLIB */

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsByteCode.c"
 */
/************************************************************************/

/**
    ejsByteCode.c - Definition of the byte code table.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/
/*
    This will define an instance of the EjsOptable which is defined in ejsByteCodeTable.h
 */
#define EJS_DEFINE_OPTABLE 1



PUBLIC EjsOptable *ejsGetOptable()
{
    return ejsOptable;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsException.c"
 */
/************************************************************************/

/**
    ejsException.c - Error Exception class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



static uchar trapByteCode[] = { EJS_OP_ATTENTION };

/************************************ Code ************************************/

static EjsAny *createException(Ejs *ejs, EjsType *type, cchar* fmt, va_list fmtArgs)
{
    EjsError    *error;
    EjsAny      *argv[1];
    char        *msg;

    assert(type);
    
#if ME_DEBUG
    /* Breakpoint opportunity */
    if (!ejs->empty) {
        mprNop(0);
    }
#endif
    msg = sfmtv(fmt, fmtArgs);
    argv[0] = ejsCreateStringFromAsc(ejs, msg);
    if (argv[0] == 0) {
        assert(argv[0]);
        return 0;
    }
    if (EST(Error)->constructor.body.proc) {
        error = (EjsError*) ejsCreateInstance(ejs, type, 1, argv);
    } else {
        error = ejsCreatePot(ejs, type, 0);
        ejsSetProperty(ejs, error, ES_Error_message, ejsCreateStringFromAsc(ejs, msg));
    }
    return error;
}


/*
    Redirect the VM to the ATTENTION op code
 */
void ejsAttention(Ejs *ejs)
{
    EjsFrame    *frame;
    uchar       *pc;

    frame = ejs->state->fp;
    if (frame && frame->attentionPc == 0) {
        /*
            Order matters. Setting the pc to the trap byte code will redirect the VM to the ATTENTION op code which
            will call mprLock(ejs->mutex) preventing a race here.
         */
        pc = frame->pc;
        frame->pc = trapByteCode;
        frame->attentionPc = pc;
    }
}


void ejsClearAttention(Ejs *ejs)
{
    EjsFrame    *frame;

    frame = ejs->state->fp;

    if (ejs->exception == 0 && frame && frame->attentionPc) {
        frame->pc = frame->attentionPc;
        frame->attentionPc = 0;
        assert(frame->pc);
    }
}


EjsAny *ejsThrowException(Ejs *ejs, EjsAny *error)
{
    assert(error);

    ejs->exception = error;
    ejsAttention(ejs);
    return error;
}


void ejsClearException(Ejs *ejs)
{
    ejs->exception = 0;
    if (ejs->state->fp) {
        ejsClearAttention(ejs);
    }
}


EjsAny *ejsCreateException(Ejs *ejs, int slot, cchar *fmt, va_list fmtArgs)
{
    EjsType     *type;
    EjsAny      *error;

    if (ejs->exception) {
        mprError("Double exception: %s", sfmtv(fmt, fmtArgs));
        return ejs->exception;
    }
    type = (ejs->initialized) ? ejsGetProperty(ejs, ejs->global, slot) : NULL;
    if (type == 0) {
        type = EST(Error);
    }
    error = createException(ejs, type, fmt, fmtArgs);
    if (error) {
        ejsThrowException(ejs, error);
    }
    return error;
}


EjsError *ejsThrowArgError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ArgError, fmt, fmtArgs);
}


EjsError *ejsThrowArithmeticError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ArithmeticError, fmt, fmtArgs);
}


EjsError *ejsThrowAssertError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_AssertError, fmt, fmtArgs);
}


EjsError *ejsThrowInstructionError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_InstructionError, fmt, fmtArgs);
}


EjsError *ejsThrowError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_Error, fmt, fmtArgs);
}


EjsError *ejsThrowIOError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_IOError, fmt, fmtArgs);
}


EjsError *ejsThrowInternalError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_InternalError, fmt, fmtArgs);
}


EjsError *ejsThrowMemoryError(Ejs *ejs)
{
    /*
        Don't do double exceptions for memory errors
     */
    if (ejs->exception == 0) {
        static va_list dummy;
        return ejsCreateException(ejs, ES_MemoryError, "Memory Error", dummy);
    }
    return (EjsError*) ejs->exception;
}


EjsError *ejsThrowOutOfBoundsError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_OutOfBoundsError, fmt, fmtArgs);
}


EjsError *ejsThrowReferenceError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ReferenceError, fmt, fmtArgs);
}


EjsError *ejsThrowResourceError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ResourceError, fmt, fmtArgs);
}


EjsString *ejsThrowString(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;
    char        *msg;

    assert(fmt);
    va_start(fmtArgs, fmt);
    msg = sfmtv(fmt, fmtArgs);
    va_end(fmtArgs);

    /*
        Throwing a string will not create a stack frame
     */
    ejs->exception = ejsCreateStringFromAsc(ejs, msg);
    ejsAttention(ejs);
    return ejs->exception;
}


EjsError *ejsThrowStateError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_StateError, fmt, fmtArgs);
}


EjsError *ejsThrowSyntaxError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_SyntaxError, fmt, fmtArgs);
}


EjsError *ejsThrowTypeError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    assert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_TypeError, fmt, fmtArgs);
}


EjsArray *ejsCaptureStack(Ejs *ejs, int uplevels)
{
    EjsFrame        *fp;
    EjsState        *state;
    EjsArray        *stack;
    wchar           *source;
    EjsObj          *frame;
    char            *filename;
    int             index, lineNumber;

    assert(ejs);

    stack = ejsCreateArray(ejs, 0);
    index = 0;
    for (state = ejs->state; state; state = state->prev) {
        for (fp = state->fp; fp; fp = fp->caller) {
            if (uplevels-- <= 0) {
                frame = ejsCreateEmptyPot(ejs);
                if (ejsGetDebugInfo(ejs, (EjsFunction*) fp, fp->pc, &filename, &lineNumber, &source) >= 0) {
                    ejsSetPropertyByName(ejs, frame, EN("filename"), ejsCreatePathFromAsc(ejs, filename));
                    ejsSetPropertyByName(ejs, frame, EN("lineno"), ejsCreateNumber(ejs, lineNumber));
                    ejsSetPropertyByName(ejs, frame, EN("code"), ejsCreateString(ejs, source, wlen(source)));
                } else {
                    ejsSetPropertyByName(ejs, frame, EN("filename"), EST(undefined));
                }
                ejsSetPropertyByName(ejs, frame, EN("func"), fp->function.name);
                ejsSetProperty(ejs, stack, index++, frame);
            }
        }
    }
    return stack;
}


/*
    Get the current exception error. May be an Error object or may be any other object that is thrown.
    Caller must NOT free.
 */
cchar *ejsGetErrorMsg(Ejs *ejs, int withStack)
{
    EjsString   *str, *tag, *msg, *message;
    EjsAny      *stack, *error, *saveException;
    char        *buf, *stackStr;

    error = ejs->exception;
    message = 0;
    stack = 0;
    tag = NULL;

    if (error) {
        tag = TYPE(error)->qname.name;
        if (ejsIs(ejs, error, Error)) {
            message = ejsGetProperty(ejs, error, ES_Error_message);
            if (withStack && ejs->initialized && ejs->state) {
                saveException = ejs->exception;
                ejsClearException(ejs);
                stack = ejsRunFunctionBySlot(ejs, error, ES_Error_formatStack, 0, NULL);
                ejsThrowException(ejs, saveException);
            }

        } else if (ejsIs(ejs, error, String)) {
            tag = ejsCreateStringFromAsc(ejs, "Error");
            message = (EjsString*) error;

        } else if (ejsIs(ejs, error, Number)) {
            tag = ejsCreateStringFromAsc(ejs, "Error");
            message = (EjsString*) error;
            
        } else if (error == EST(StopIteration)) {
            message = ejsCreateStringFromAsc(ejs, "Uncaught StopIteration exception");
        }
    }
    if (message == ESV(null) || message == 0) {
        msg = ejsCreateStringFromAsc(ejs, "Exception");
    } else{
        msg = ejsToString(ejs, message);
    }
    if (ejsIs(ejs, error, Error)) {
        stackStr = (stack) ? ejsToMulti(ejs, stack) : 0;
        if (stackStr && *stackStr) {
            buf = sfmt("%@: %@\nStack:\n%s", tag, msg, (stack) ? ejsToMulti(ejs, stack) : "");
        } else {
            buf = sfmt("%@: %@", tag, msg);
        }

    } else if (message && ejsIs(ejs, message, String)){
        buf = sfmt("%@: %@", tag, msg);

    } else if (message && ejsIs(ejs, message, Number)){
        buf = sfmt("%@: %g", tag, ((EjsNumber*) msg)->value);
        
    } else if (error) {
        EjsObj *saveException = ejs->exception;
        ejs->exception = 0;
        str = ejsToString(ejs, error);
        buf = sclone(ejsToMulti(ejs, str));
        ejs->exception = saveException;

    } else {
        buf = sclone("");
    }
    ejs->errorMsg = buf;
    return buf;
}


bool ejsHasException(Ejs *ejs)
{
    return ejs->exception != 0;
}


EjsObj *ejsGetException(Ejs *ejs)
{
    return ejs->exception;
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsHelper.c"
 */
/************************************************************************/

/**
    ejsHelper.c - Helper methods for types.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/****************************** Forward Declarations **************************/

static MprNumber parseNumber(Ejs *ejs, wchar *str);
static bool      parseBoolean(Ejs *ejs, wchar *s);

/************************************* Code ***********************************/

EjsAny *ejsAlloc(Ejs *ejs, EjsType *type, ssize extra)
{
    EjsObj      *vp;

    assert(type);
    assert(extra >= 0);

    //  OPT could have dedicated ejsAlloc as a macro when assign is zero
    if ((vp = mprAllocBlock(type->instanceSize + extra, MPR_ALLOC_MANAGER | MPR_ALLOC_ZERO)) == NULL) {
        return NULL;
    }
    //  OPT can do direct assign
    SET_TYPE(vp, type);
    ejsSetMemRef(vp);
    assert(type->manager);
    //  OPT inline here
    mprSetManager(vp, type->manager);
    return vp;
}


/**
    Cast the variable to a given target type.
    @return Returns a variable with the result of the cast or null if an exception is thrown.
 */
EjsAny *ejsCastType(Ejs *ejs, EjsAny *vp, EjsType *targetType)
{
    EjsType     *type;

    assert(ejs);
    assert(vp);
    assert(targetType);

    type = TYPE(vp);
    if (type == targetType) {
        return vp;
    }
    if (type->helpers.cast) {
        return (type->helpers.cast)(ejs, vp, targetType);
    }
    ejsThrowInternalError(ejs, "Cast helper not defined for type \"%@\"", type->qname.name);
    return 0;
}


/*
    Create a new instance of an object. Delegate to the type specific create.
 */
EjsAny *ejsCreateObj(Ejs *ejs, EjsType *type, int numSlots)
{
#if VXWORKS
    /*
     *  The VxWorks cc386 invoked linker crashes without this test. Ugh!
     */
    if (type == 0) {
        return 0;
    }
#endif
    assert(type->helpers.create);
    return (type->helpers.create)(ejs, type, numSlots);
}

int cloneCopy = 0;
int cloneRef = 0;

/**
    Copy a variable by copying all properties. If a property is a reference  type, just copy the reference.
    See ejsDeepClone for a complete recursive copy of all reference contents.
    @return Returns a variable or null if an exception is thrown.
 */
EjsAny *ejsClone(Ejs *ejs, EjsAny *src, bool deep)
{
    EjsAny      *dest;
    
    if (src == 0) {
        return 0;
    }
cloneCopy++;
    assert(TYPE(src)->helpers.clone);
    if (VISITED(src) == 0) {
        SET_VISITED(src, 1);
        dest = (TYPE(src)->helpers.clone)(ejs, src, deep);
        SET_VISITED(src, 0);
        SET_VISITED(dest, 0);
    } else {
        dest = src;
    }
    return dest;
}


/*
    Define a property and its traits.
    @return Return the slot number allocated for the property.
 */
int ejsDefineProperty(Ejs *ejs, EjsAny *vp, int slotNum, EjsName name, EjsType *propType, int64 attributes, EjsAny *value)
{
    assert(name.name);
    assert(name.space);

    return (TYPE(vp)->helpers.defineProperty)(ejs, vp, slotNum, name, propType, attributes, value);
}


/**
    Delete a property in a value
    @return Returns a status code.
 */
int ejsDeleteProperty(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsType     *type;

    assert(slotNum >= 0);
    
    type = TYPE(vp);
    assert(type->helpers.deleteProperty);
    return (type->helpers.deleteProperty)(ejs, vp, slotNum);
}


/**
    Delete a property
    @return Returns a status code.
 */
int ejsDeletePropertyByName(Ejs *ejs, EjsAny *vp, EjsName qname)
{
    EjsLookup   lookup;
    int         slotNum;

    assert(qname.name);
    assert(qname.space);
    
    if (TYPE(vp)->helpers.deletePropertyByName) {
        return (TYPE(vp)->helpers.deletePropertyByName)(ejs, vp, qname);
    } else {
        slotNum = ejsLookupVar(ejs, vp, qname, &lookup);
        if (slotNum < 0) {
            ejsThrowReferenceError(ejs, "Property \"%@\" does not exist", qname.name);
            return 0;
        }
        return ejsDeleteProperty(ejs, vp, slotNum);
    }
}


/**
    Get a property at a given slot in a variable.
    @return Returns the requested property varaible.
 */
void *ejsGetProperty(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsType     *type;

    assert(ejs);
    assert(vp);

    type = TYPE(vp);
    assert(type->helpers.getProperty);
    return (type->helpers.getProperty)(ejs, vp, slotNum);
}


void *ejsGetPropertyByName(Ejs *ejs, EjsAny *vp, EjsName name)
{
    EjsType     *type;
    int         slotNum;

    assert(ejs);
    assert(vp);

    type = TYPE(vp);

    /*
        WARNING: this is not implemented by most types
     */
    if (type->helpers.getPropertyByName) {
        return (type->helpers.getPropertyByName)(ejs, vp, name);
    }

    /*
        Fall back and use a two-step lookup and get
     */
    slotNum = ejsLookupProperty(ejs, vp, name);
    if (slotNum < 0) {
        return 0;
    }
    return ejsGetProperty(ejs, vp, slotNum);
}


EjsTrait *ejsGetPropertyTraits(Ejs *ejs, EjsAny *vp, int slotNum)
{
    assert(TYPE(vp)->helpers.getPropertyTraits);
    return (TYPE(vp)->helpers.getPropertyTraits)(ejs, vp, slotNum);
}


/**
    Return the number of properties in the variable.
    @return Returns the number of properties.
 */
int ejsGetLength(Ejs *ejs, EjsAny *vp)
{
    assert(TYPE(vp)->helpers.getPropertyCount);
    return (TYPE(vp)->helpers.getPropertyCount)(ejs, vp);
}


/**
    Return the name of a property indexed by slotNum.
    @return Returns the property name.
 */
EjsName ejsGetPropertyName(Ejs *ejs, EjsAny *vp, int slotNum)
{
    EjsType     *type;

    type = TYPE(vp);
    assert(type->helpers.getPropertyName);
    return (type->helpers.getPropertyName)(ejs, vp, slotNum);
}


int ejsPropertyHasTrait(Ejs *ejs, EjsAny *vp, int slotNum, int attributes)
{
    EjsTrait    *trait;

    assert((attributes & EJS_TRAIT_MASK) == attributes);

    if ((trait = ejsGetPropertyTraits(ejs, vp, slotNum)) != 0) {
        return trait->attributes & attributes;
    }
    return 0;
}


/**
    Get a property slot. Lookup a property name and return the slot reference. If a namespace is supplied, the property
    must be defined with the same namespace.
    @return Returns the slot number or -1 if it does not exist.
 */
int ejsLookupProperty(Ejs *ejs, EjsAny *vp, EjsName name)
{
    assert(ejs);
    assert(vp);
    assert(name.name);

    assert(TYPE(vp)->helpers.lookupProperty);
    return (TYPE(vp)->helpers.lookupProperty)(ejs, vp, name);
}


/*
    Invoke an operator.
    vp is left-hand-side
    @return Return a variable with the result or null if an exception is thrown.
 */
EjsAny *ejsInvokeOperator(Ejs *ejs, EjsAny *vp, int opCode, EjsAny *rhs)
{
    assert(vp);

    assert(TYPE(vp)->helpers.invokeOperator);
    return (TYPE(vp)->helpers.invokeOperator)(ejs, vp, opCode, rhs);
}


/*
    Set a property and return the slot number. Incoming slot may be -1 to allocate a new slot.
 */
int ejsSetProperty(Ejs *ejs, EjsAny *vp, int slotNum, EjsAny *value)
{
    assert(vp);

    assert(TYPE(vp)->helpers.setProperty);
    return (TYPE(vp)->helpers.setProperty)(ejs, vp, slotNum, value);
}


/*
    Set a property given a name.
 */
int ejsSetPropertyByName(Ejs *ejs, EjsAny *vp, EjsName qname, EjsAny *value)
{
    int     slotNum;

    assert(ejs);
    assert(vp);

    /*
        WARNING: Not all types implement this
     */
    if (TYPE(vp)->helpers.setPropertyByName) {
        return (TYPE(vp)->helpers.setPropertyByName)(ejs, vp, qname, value);
    }

    /*
        Fall back and use a two-step lookup and get
     */
    slotNum = ejsLookupProperty(ejs, vp, qname);
    if (slotNum < 0) {
        slotNum = ejsSetProperty(ejs, vp, -1, value);
        if (slotNum < 0) {
            return EJS_ERR;
        }
        if (ejsSetPropertyName(ejs, vp, slotNum, qname) < 0) {
            return EJS_ERR;
        }
        //  UNICODE
#if ME_DEBUG
        if (((EjsObj*) value)->mem == 0) {
            mprSetName(value, qname.name->value);
        }
#endif
        return slotNum;
    }
    return ejsSetProperty(ejs, vp, slotNum, value);
}


/*
    Set the property name and return the slot number. Slot may be -1 to allocate a new slot.
 */
int ejsSetPropertyName(Ejs *ejs, EjsAny *vp, int slot, EjsName qname)
{
    assert(TYPE(vp)->helpers.setPropertyName);
    return (TYPE(vp)->helpers.setPropertyName)(ejs, vp, slot, qname);
}


int ejsSetPropertyTraits(Ejs *ejs, EjsAny *vp, int slot, EjsType *type, int attributes)
{
    assert(TYPE(vp)->helpers.setPropertyTraits);
    return (TYPE(vp)->helpers.setPropertyTraits)(ejs, vp, slot, type, attributes);
}


/**
    Get a string representation of a variable.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsString *ejsToString(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, String)) {
        return (EjsString*) vp;
    }
    return ejsCast(ejs, vp, String);
}


/**
    Get a numeric representation of a variable.
    @return Returns a number variable or null if an exception is thrown.
 */
EjsNumber *ejsToNumber(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Number)) {
        return (EjsNumber*) vp;
    }
    if (TYPE(vp)->helpers.cast) {
        return (TYPE(vp)->helpers.cast)(ejs, vp, EST(Number));
    }
    ejsThrowInternalError(ejs, "CastVar helper not defined for type \"%@\"", TYPE(vp)->qname.name);
    return 0;
}


/**
    Get a boolean representation of a variable.
    @return Returns a number variable or null if an exception is thrown.
 */
EjsBoolean *ejsToBoolean(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Boolean)) {
        return (EjsBoolean*) vp;
    }
    if (TYPE(vp)->helpers.cast) {
        return (TYPE(vp)->helpers.cast)(ejs, vp, EST(Boolean));
    }
    ejsThrowInternalError(ejs, "CastVar helper not defined for type \"%@\"", TYPE(vp)->qname.name);
    return 0;
}


/**
    Get a Path representation of a variable.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsPath *ejsToPath(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Path)) {
        return (EjsPath*) vp;
    }
    return ejsCast(ejs, vp, Path);
}


/**
    Get a Uri representation of a variable.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsUri *ejsToUri(Ejs *ejs, EjsAny *vp)
{
    if (vp == 0 || ejsIs(ejs, vp, Uri)) {
        return (EjsUri*) vp;
    }
    return ejsCast(ejs, vp, Uri);
}


/*
    Fully construct a new object. We create a new instance and call all required constructors.
 */
EjsAny *ejsCreateInstance(Ejs *ejs, EjsType *type, int argc, void *argv)
{
    EjsAny  *vp;

    assert(type);

    vp = ejsCreateObj(ejs, type, 0);
    if (vp == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    if (type->constructor.block.pot.isFunction) {
        ejsRunFunction(ejs, (EjsFunction*) type, vp, argc, argv);
    }
    return vp;
}


/************************************* Misc ***********************************/

static void missingHelper(Ejs *ejs, EjsObj *obj, cchar *helper) 
{
    EjsType     *type;

    type = TYPE(obj);
    ejsThrowInternalError(ejs, "The \"%s\" helper is not defined for this type \"%@\"", helper, type->qname.name);
}


static EjsAny *castObj(Ejs *ejs, EjsObj *obj, EjsType *type)
{
    EjsString       *str;
    EjsFunction     *fun;
    EjsObj          *result;
    EjsLookup       lookup;
    
    assert(ejsIsType(ejs, type));

    if (type->hasMeta) {
        return ejsRunFunctionByName(ejs, type, N(EJS_META_NAMESPACE, "cast"), type, 1, &obj);
    }
    switch (type->sid) {
    case ES_Boolean:
        return ejsCreateBoolean(ejs, 1);

    case ES_Number:
        str = ejsToString(ejs, obj);
        if (str == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        return ejsParse(ejs, str->value, S_Number);

    case ES_String:
        if (!ejsIsType(ejs, obj) && !ejsIsPrototype(ejs, obj)) {
            if (ejsLookupVar(ejs, obj, EN("toString"), &lookup) >= 0 && lookup.obj != EST(Object)->prototype) {
                fun = ejsGetProperty(ejs, lookup.obj, lookup.slotNum);
                if (fun && ejsIsFunction(ejs, fun) && fun->body.proc != (EjsProc) ejsObjToString) {
                    result = ejsRunFunction(ejs, fun, obj, 0, NULL);
                    return result;
                }
            }
        }
        if (obj == ejs->global) {
            return ejsCreateStringFromAsc(ejs, "[object global]");
        } else {
            if (TYPE(obj)->helpers.cast && TYPE(obj)->helpers.cast != (EjsCastHelper) castObj) {
                return (TYPE(obj)->helpers.cast)(ejs, obj, type);
            }
            return ejsSprintf(ejs, "[object %@]", TYPE(obj)->qname.name);
        }

    default:
        if (ejsIsA(ejs, obj, type)) {
            return obj;
        }
        ejsThrowTypeError(ejs, "Cannot cast to this type");
        return 0;
    }
}


static EjsObj *cloneObj(Ejs *ejs, EjsObj *obj, bool deep)
{
    return obj;
}


/*
    Cast the operands depending on the operation code
 */
EjsAny *ejsCoerceOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ESV(zero), opcode, rhs);

    case EJS_OP_COMPARE_EQ:  case EJS_OP_COMPARE_NE:
        if (!ejsIsDefined(ejs, rhs)) {
            return ((opcode == EJS_OP_COMPARE_EQ) ? ESV(false): ESV(true));
        } else if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIs(ejs, rhs, Number)) {
            return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return ESV(true);

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    /* Unary operators */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %@", opcode, TYPE(lhs)->qname.name);
        return ESV(undefined);
    }
}


EjsAny *ejsInvokeOperatorDefault(Ejs *ejs, EjsAny *lhs, int opcode, EjsAny *rhs)
{
    EjsAny      *result;

    if (rhs == 0 || TYPE(lhs) != TYPE(rhs)) {
        if ((result = ejsCoerceOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }
    /* Types now match */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return ejsCreateBoolean(ejs, !(lhs == rhs));

    /* Unary operators */

    case EJS_OP_COMPARE_NOT_ZERO:
        return ESV(true);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return ESV(false);

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return ESV(one);

    /* Binary operators */

    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL:
    case EJS_OP_REM: case EJS_OP_OR: case EJS_OP_SHL: case EJS_OP_SHR:
    case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, ejsToNumber(ejs, lhs), opcode, ejsToNumber(ejs, rhs));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %@", opcode, TYPE(lhs)->qname.name);
        return 0;
    }
    assert(0);
}


static int defineProperty(Ejs *ejs, EjsObj *obj, int slotNum, EjsName qname, EjsType *propType, int64 attributes, 
    EjsObj *value)
{
    missingHelper(ejs, obj, "defineProperty");
    return MPR_ERR_BAD_STATE;
}


static int deleteProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    missingHelper(ejs, obj, "deleteProperty");
    return MPR_ERR_BAD_STATE;
}


static int deletePropertyByName(Ejs *ejs, EjsObj *obj, EjsName qname)
{
    missingHelper(ejs, obj, "deletePropertyByName");
    return MPR_ERR_BAD_STATE;
}


static EjsObj *getProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    if (obj == 0 || obj == ESV(null) || obj == ESV(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return NULL;
    }
    return NULL;
}


static int getPropertyCount(Ejs *ejs, EjsObj *obj)
{
    return 0;
}


static EjsName getPropertyName(Ejs *ejs, EjsObj *obj, int slotNum)
{
    EjsName     qname;

    qname.name = 0;
    qname.space = 0;
    return qname;
}


static EjsTrait *getPropertyTraits(Ejs *ejs, EjsAny *vp, int slotNum)
{
    return 0;
}


static int lookupProperty(struct Ejs *ejs, EjsObj *obj, EjsName qname)
{
    return -1;
}


static int setProperty(Ejs *ejs, EjsObj *obj, int slotNum, EjsObj *value)
{
    if (obj == 0 || obj == ESV(null) || obj == ESV(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return EJS_ERR;
    }
    missingHelper(ejs, obj, "setProperty");
    return MPR_ERR_BAD_STATE;
}


static int setPropertyName(Ejs *ejs, EjsObj *obj, int slotNum, EjsName qname)
{
    if (obj == 0 || obj == ESV(null) || obj == ESV(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return EJS_ERR;
    }
    missingHelper(ejs, obj, "setPropertyName");
    return MPR_ERR_BAD_STATE;
}


static int setPropertyTraits(Ejs *ejs, EjsObj *obj, int slot, EjsType *type, int attributes)
{
    if (obj == 0 || obj == ESV(null) || obj == ESV(undefined)) {
        ejsThrowReferenceError(ejs, "Object is null");
        return EJS_ERR;
    }
    missingHelper(ejs, obj, "setPropertyTraits");
    return MPR_ERR_BAD_STATE;
}


void ejsCreateObjHelpers(Ejs *ejs)
{
    EjsHelpers      *helpers;

    helpers = &ejs->service->objHelpers;
    helpers->cast                   = (EjsCastHelper) castObj;
    helpers->clone                  = (EjsCloneHelper) cloneObj;
    helpers->create                 = (EjsCreateHelper) ejsAlloc;
    helpers->defineProperty         = (EjsDefinePropertyHelper) defineProperty;
    helpers->deleteProperty         = (EjsDeletePropertyHelper) deleteProperty;
    helpers->deletePropertyByName   = (EjsDeletePropertyByNameHelper) deletePropertyByName;
    helpers->getProperty            = (EjsGetPropertyHelper) getProperty;
    helpers->getPropertyCount       = (EjsGetPropertyCountHelper) getPropertyCount;
    helpers->getPropertyName        = (EjsGetPropertyNameHelper) getPropertyName;
    helpers->getPropertyTraits      = (EjsGetPropertyTraitsHelper) getPropertyTraits;
    helpers->lookupProperty         = (EjsLookupPropertyHelper) lookupProperty;
    helpers->invokeOperator         = (EjsInvokeOperatorHelper) ejsInvokeOperatorDefault;
    helpers->setProperty            = (EjsSetPropertyHelper) setProperty;
    helpers->setPropertyName        = (EjsSetPropertyNameHelper) setPropertyName;
    helpers->setPropertyTraits      = (EjsSetPropertyTraitsHelper) setPropertyTraits;
}


/************************************* Misc ***********************************/

EjsName ejsEmptyName(Ejs *ejs, cchar *name)
{
    EjsName     n;

    n.name = ejsCreateStringFromAsc(ejs, name);
    n.space = ESV(empty);
    return n;
}


EjsName ejsEmptyWideName(Ejs *ejs, wchar *name)
{
    EjsName     n;

    n.name = ejsCreateString(ejs, name, strlen(name));
    n.space = ESV(empty);
    return n;
}


EjsName ejsName(Ejs *ejs, cchar *space, cchar *name)
{
    EjsName     n;

    n.name = ejsCreateStringFromAsc(ejs, name);
    n.space = (space) ? ejsCreateStringFromAsc(ejs, space) : NULL;
    return n;
}


EjsName ejsWideName(Ejs *ejs, wchar *space, wchar *name)
{
    EjsName     n;

    n.name = ejsCreateString(ejs, name, wlen(name));
    n.space = ejsCreateString(ejs, space, wlen(space));
    return n;
}


/*
    Parse a string based on formatting instructions and intelligently create a variable.
    Number formats:
        [(+|-)][0][OCTAL_DIGITS]
        [(+|-)][0][(x|X)][HEX_DIGITS]
        [(+|-)][DIGITS]
        [+|-][DIGITS][.][DIGITS][(e|E)[+|-]DIGITS]
 */
EjsAny *ejsParse(Ejs *ejs, wchar *str, int preferredType)
{
    wchar       *buf;
    int         sid;

    assert(str);

    buf = str;
    sid = preferredType;

    //  TODO unicode
    while (isspace((uchar) *buf)) {
        buf++;
    }    
    if (preferredType == S_Void || preferredType < 0) {
        if (*buf == '-' || *buf == '+') {
            sid = S_Number;

        } else if (*buf == '/') {
            sid = S_RegExp;

        } else if (!isdigit((uchar) *buf) && *buf != '.') {
            if (mcmp(buf, "true") == 0) {
                return ESV(true);

            } else if (mcmp(buf, "false") == 0) {
                return ESV(false);
            }
            sid = S_String;

            if (mcmp(buf, "true") == 0 || mcmp(buf, "false") == 0) {
                sid = S_Boolean;
            } else {
                sid = S_String;
            }

        } else {
            sid = S_Number;
        }
    }
    switch (sid) {
    case S_Object:
    case S_Void:
    case S_Null:
    default:
        break;

    case S_Number:
        return ejsCreateNumber(ejs, parseNumber(ejs, buf));

    case S_Boolean:
        return ejsCreateBoolean(ejs, parseBoolean(ejs, buf));

#if ME_COM_PCRE
    case S_RegExp:
        return ejsParseRegExp(ejs, ejsCreateStringFromAsc(ejs, buf));
#endif

    case S_String:
        if (mcmp(buf, "null") == 0) {
            return ejsCreateNull(ejs);

        } else if (mcmp(buf, "undefined") == 0) {
            return ejsCreateUndefined(ejs);
        }
        return ejsCreateString(ejs, buf, wlen(buf));
    }
    return ejsCreateUndefined(ejs);
}


/*
    Convert the variable to a number type. Only works for primitive types.
 */
static bool parseBoolean(Ejs *ejs, wchar *s)
{
    if (s == 0 || *s == '\0') {
        return 0;
    }
    if (mcmp(s, "false") == 0 || mcmp(s, "FALSE") == 0) {
        return 0;
    }
    return 1;
}


/*
    Convert the string buffer to a Number.
 */
static MprNumber parseNumber(Ejs *ejs, wchar *str)
{
    MprNumber   n;
    wchar       *cp, *sp;
    int64       num;
    char        nbuf[32], *dp;
    int         radix, c, negative;

    assert(str);

    num = 0;
    negative = 0;

    if (*str == '-') {
        str++;
        negative = 1;
    } else if (*str == '+') {
        str++;
    }
    if (*str != '.' && !isdigit((uchar) *str)) {
        return ((EjsNumber*) ESV(nan))->value;
    }
    /*
        Floating format: [DIGITS].[DIGITS][(e|E)[+|-]DIGITS]
     */
    if (!(*str == '0' && tolower((uchar) str[1]) == 'x')) {
        for (cp = str; *cp; cp++) {
            if (*cp == '.' || tolower((uchar) *cp) == 'e') {
                // OPT
                for (sp = str, dp = nbuf; *sp && dp < &nbuf[sizeof(nbuf) - 1]; ) {
                    *dp++ = *sp++;
                }
                *dp = '\0';
                n = atof(nbuf);
                if (negative) {
                    n = (0.0 - n);
                }
                return n;
            }
        }
    }

    /*
        Parse an integer. Observe hex and octal prefixes (0x, 0).
     */
    if (*str != '0') {
        /*
         *  Normal numbers (Radix 10)
         */
        while (isdigit((uchar) *str)) {
            num = (*str - '0') + (num * 10);
            str++;
        }
    } else {
        str++;
        if (tolower((uchar) *str) == 'x') {
            str++;
            radix = 16;
            while (*str) {
                c = tolower((uchar) *str);
                if (isdigit((uchar) c)) {
                    num = (c - '0') + (num * radix);
                } else if (c >= 'a' && c <= 'f') {
                    num = (c - 'a' + 10) + (num * radix);
                } else {
                    break;
                }
                str++;
            }

        } else{
            radix = 8;
            while (*str) {
                c = tolower((uchar) *str);
                if (isdigit((uchar) c) && c < '8') {
                    num = (c - '0') + (num * radix);
                } else {
                    break;
                }
                str++;
            }
        }
    }

    if (negative) {
        return (MprNumber) (0 - num);
    }
    return (MprNumber) num;
}


MprNumber ejsGetNumber(Ejs *ejs, EjsAny *vp)
{
    assert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    assert(ejsIs(ejs, vp, Number));
    return (vp) ? ((EjsNumber*) (vp))->value: 0;
}


bool ejsGetBoolean(Ejs *ejs, EjsAny *vp)
{
    assert(vp);
    if (!ejsIs(ejs, vp, Boolean)) {
        if ((vp = ejsCast(ejs, vp, Boolean)) == 0) {
            return 0;
        }
    }
    assert(ejsIs(ejs, vp, Boolean));
    return (vp) ? ((EjsBoolean*) (vp))->value: 0;
}


int ejsGetInt(Ejs *ejs, EjsAny *vp)
{
    assert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    assert(ejsIs(ejs, vp, Number));
    return (vp) ? ((int) (((EjsNumber*) (vp))->value)): 0;
}


int64 ejsGetInt64(Ejs *ejs, EjsAny *vp)
{
    assert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    assert(ejsIs(ejs, vp, Number));
    return (vp) ? ((int64) (((EjsNumber*) (vp))->value)): 0;
}


double ejsGetDouble(Ejs *ejs, EjsAny *vp)
{
    assert(vp);
    if (!ejsIs(ejs, vp, Number)) {
        if ((vp = ejsCast(ejs, vp, Number)) == 0) {
            return 0;
        }
    }
    assert(ejsIs(ejs, vp, Number));
    return (vp) ? ((double) (((EjsNumber*) (vp))->value)): 0;
}


void ejsMarkName(EjsName *qname)
{
    mprMark(qname->name);
    mprMark(qname->space);
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsInterp.c"
 */
/************************************************************************/

/*
    ejsInterp.c - Virtual Machine Interpreter for Ejscript.

    Copyright (c) All Rights Reserved. See details at the end of the file.

    NEXT
        - Optimize and cache stack.top
        - Fix BAD BINDING
 */

/********************************** Includes **********************************/



/********************************** Inline Code *******************************/
/*
    The stack is a stack of pointers to values. The top of stack (stack.top) always points to the current top item 
    on the stack. To push a new value, top is incremented then the value is stored. To pop, simply copy the value at 
    top and decrement top ptr.
 */
#define top                     (*state->stack)

//  TODO - ejs arg not used
#define pop(ejs)                (*state->stack--)

#define push(value)             (*(++(state->stack))) = ((EjsObj*) (value))
#define popString(ejs)          ((EjsString*) pop(ejs))
#define popOutside(ejs)         *(ejs->state->stack)--
#define pushOutside(ejs, value) (*(++(ejs->state->stack))) = ((EjsObj*) (value))

#define FRAME                   state->fp
#define FUNCTION                state->fp.function
#define BLOCK                   state->bp

#define SWAP if (1) { \
        EjsObj *swap = state->stack[0]; \
        state->stack[0] = state->stack[-1]; \
        state->stack[-1] = swap; \
    }

static void callFunction(Ejs *ejs, EjsFunction *fun, EjsAny *thisObj, int argc, int stackAdjust);

static ME_INLINE void getPropertyFromSlot(Ejs *ejs, EjsAny *thisObj, EjsAny *obj, int slotNum) 
{
    EjsFunction     *fun, *value;

    if (ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_GETTER)) {
        fun = ejsGetProperty(ejs, obj, slotNum);
        callFunction(ejs, fun, thisObj, 0, 0);
        if (ejsIsNativeFunction(ejs, fun)) {
            pushOutside(ejs, ejs->result);
        } else {
            ejs->state->fp->getter = 1;
        }
        return;
    }
    value = ejsGetProperty(ejs, obj, slotNum);
    if (ejsIsFunction(ejs, value)) {
        fun = (EjsFunction*) value;
        if (!fun->boundThis && thisObj) {
            /* Function extraction. Bind the "thisObj" into a clone of the function */
            fun = ejsCloneFunction(ejs, fun, 0);
            fun->boundThis = thisObj;
            assert(fun->boundThis != ejs->global);
        }
    }
    pushOutside(ejs, value);
}

#define GET_SLOT(thisObj, obj, slotNum) getPropertyFromSlot(ejs, thisObj, obj, slotNum)

static ME_INLINE void checkGetter(Ejs *ejs, EjsAny *value, EjsAny *thisObj, EjsAny *obj, int slotNum) 
{
    EjsFunction     *fun;

    if (ejsIsFunction(ejs, value) && !ejsIsType(ejs, value)) {
        fun = (EjsFunction*) value;
        if (ejsPropertyHasTrait(ejs, obj, slotNum, EJS_TRAIT_GETTER)) {
            if (fun->staticMethod) {
                thisObj = obj;
            }
            callFunction(ejs, fun, thisObj, 0, 0);
            if (ejsIsNativeFunction(ejs, fun)) {
                pushOutside(ejs, ejs->result);
            } else {
                ejs->state->fp->getter = 1;
            }
            return;
        } else {
            if (!fun->boundThis && thisObj && thisObj != ejs->global) {
                /* Function extraction. Bind the "thisObj" into a clone of the function */
                /* OPT - this is slow in the a case: a.b.fn */
                fun = ejsCloneFunction(ejs, fun, 0);
                fun->boundThis = thisObj;
                assert(fun->boundThis != ejs->global);
                value = fun;
            }
        }
    } else if (value == 0) {
        value = ESV(undefined);
    }
    pushOutside(ejs, value);
}

#define CHECK_VALUE(value, thisObj, obj, slotNum) checkGetter(ejs, value, thisObj, obj, slotNum)
#define CHECK_GC() if (MPR->heap->mustYield && !(ejs->state->paused)) { mprYield(0); } else 

/*
    Set a slot value when we don't know if the object is an EjsObj
 */
#define SET_SLOT(thisObj, obj, slotNum, value) storePropertyToSlot(ejs, thisObj, obj, slotNum, value)

/*
    Must clear attentionPc when changing the PC. Otherwise the next instruction will jump to a bad (stale) location.
 */
//  TODO -- should not need to clear attentionPc
#define SET_PC(fp, value) \
    if (1) { \
        (fp)->pc = (uchar*) (value); \
        (fp)->attentionPc = 0; \
    } else 

#define GET_BYTE()      *(FRAME)->pc++
#define GET_DOUBLE()    ejsDecodeDouble(ejs, &(FRAME)->pc)
#define GET_INT()       ((int) GET_NUM())

//  TODO OPT - returns 64 bits, but most cases only need 32 bits
#define GET_NUM()       ejsDecodeNum(ejs, &(FRAME)->pc)
#define GET_NAME()      getNameArg(ejs, FRAME)
#define GET_STRING()    getStringArg(ejs, FRAME)
#define GET_TYPE()      ((EjsType*) getGlobalArg(ejs, FRAME))
#define GET_WORD()      ejsDecodeInt32(ejs, &(FRAME)->pc)
#undef THIS
#define THIS            FRAME->function.boundThis
#define FILL(mark)      while (mark < FRAME->pc) { *mark++ = EJS_OP_NOP; }

// #define DEBUG_IDE 1
#if DEBUG_IDE
    static EjsOpCode traceCode(Ejs *ejs, EjsOpCode opcode);
    static int opcount[256];
#else
    #define traceCode(ejs, opcode) opcode
#endif

#if ME_UNIX_LIKE || (VXWORKS && !ME_DIAB)
    #define CASE(opcode) opcode
    #define BREAK goto *opcodeJump[opcode = traceCode(ejs, GET_BYTE())]
#else
    /*
        Traditional switch for compilers (looking at you MS) without computed goto.
     */
    #define BREAK break
    #define CASE(opcode) case opcode
#endif

/******************************** Forward Declarations ************************/

static void callInterfaceInitializers(Ejs *ejs, EjsType *type);
static void callProperty(Ejs *ejs, EjsAny *obj, int slotNum, EjsAny *thisObj, int argc, int stackAdjust);
static void checkExceptionHandlers(Ejs *ejs);
static void createExceptionBlock(Ejs *ejs, EjsEx *ex, int flags);
static EjsAny *evalBinaryExpr(Ejs *ejs, EjsAny *lhs, EjsOpCode opcode, EjsAny *rhs);
static uint findEndException(Ejs *ejs);
static EjsEx *findExceptionHandler(Ejs *ejs, int kind);
static EjsName getNameArg(Ejs *ejs, EjsFrame *fp);
static EjsAny *getNthBase(Ejs *ejs, EjsAny *obj, int nthBase);
static EjsAny *getNthBaseFromBottom(Ejs *ejs, EjsAny *obj, int nthBase);
static EjsAny *getNthBlock(Ejs *ejs, int nth);
static EjsString *getString(Ejs *ejs, EjsFrame *fp, int num);
static EjsString *getStringArg(Ejs *ejs, EjsFrame *fp);
static EjsObj *getGlobalArg(Ejs *ejs, EjsFrame *fp);
static EjsBlock *popExceptionBlock(Ejs *ejs);
static bool processException(Ejs *ejs);
static void storeProperty(Ejs *ejs, EjsObj *thisObj, EjsAny *obj, EjsName name, EjsObj *value);
static void storePropertyToSlot(Ejs *ejs, EjsObj *thisObj, EjsAny *obj, int slotNum, EjsObj *value);
static void storePropertyToScope(Ejs *ejs, EjsName qname, EjsObj *value);
static void throwNull(Ejs *ejs);

/************************************* Code ***********************************/
/*
    Virtual Machine byte code evaluation
 */
static void VM(Ejs *ejs, EjsFunction *fun, EjsAny *otherThis, int argc, int stackAdjust)
{
    EjsName     qname;
    EjsObj      *result, *vp, *v1, *v2, *obj, *value;
    int         slotNum, nthBase;
    EjsState    *state;
    EjsBlock    *blk;
    EjsObj      *global;
    EjsObj      *vobj, *thisObj;
    EjsString   *nameVar, *spaceVar;
    EjsNumber   *indexVar;
    EjsType     *type;
    EjsLookup   lookup;
    EjsEx       *ex;
    EjsFrame    *newFrame;
    EjsFunction *f1, *f2;
    EjsNamespace *nsp;
    EjsString   *str;
    int         i, offset, count, opcode, attributes, paused;

#if ME_UNIX_LIKE || (VXWORKS && !ME_DIAB)
    /*
        Direct threading computed goto processing. Include computed goto jump table.
     */
    #include    "ejsByteGoto.h"
#endif
    assert(ejs);
    assert(!mprHasMemError(ejs));
    assert(!ejs->exception);
    assert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);

    vp = 0;
    slotNum = -1;
    global = ejs->global;

    state = mprAlloc(sizeof(EjsState));
    *state = *ejs->state;
    state->prev = ejs->state;
    state->paused = ejs->state->paused;
    ejs->state = state;

    callFunction(ejs, fun, otherThis, argc, stackAdjust);
    assert(state->fp);
    FRAME->caller = 0;

#if ME_UNIX_LIKE || (VXWORKS && !ME_DIAB)
    /*
        Direct threading computed goto processing. Include computed goto jump table.
     */
    BREAK;
#else
    /*
        Traditional switch for compilers (looking at you MS) without computed goto.
     */
    while (1) {
        opcode = (EjsOpCode) GET_BYTE();
        traceCode(ejs, opcode);
        switch (opcode) {
#endif
        /*
            End of a code block. Used to mark the end of a script. Saves testing end of code block in VM loop.
                EndCode
         */
        CASE (EJS_OP_END_CODE):
            /*
                The "ejs" command needs to preserve the current ejs->result for interactive sessions.
             */
            if (ejs->result == 0) {
                // OPT - remove this
                ejs->result = ESV(undefined);
            }
            if (FRAME->getter) {
                push(ejs->result);
            }
            FRAME = 0;
            goto done;

        /*
            Return from a function with a result
                ReturnValue
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_RETURN_VALUE):
            ejs->result = pop(ejs);
            if (FRAME->caller == 0) {
                goto done;
            }
            state->stack = FRAME->stackReturn;
            if (ejs->result) {
                f1 = &FRAME->function;
                if (FRAME->function.resultType) {
                    type = FRAME->function.resultType;
                    //  TODO remove this voidType
                    if (type != EST(Void) && !ejsIsA(ejs, ejs->result, type)) {
                        if (ejs->result == ESV(null) || ejs->result == ESV(undefined)) {
                            if (FRAME->function.throwNulls) {
                                ejsThrowTypeError(ejs, "Unacceptable null or undefined return value");
                                BREAK;
                            } else if (FRAME->function.castNulls) {
                                ejs->result = ejsCastType(ejs, ejs->result, type);
                                if (ejs->exception) {
                                    BREAK;
                                }
                            }
                        } else {
                            ejs->result = ejsCastType(ejs, ejs->result, type);
                            if (ejs->exception) {
                                BREAK;
                            }
                        }
                    }
                }
            }
            if (FRAME->getter) {
                push(ejs->result);
            }
            state->bp = FRAME->function.block.prev;
            newFrame = FRAME->caller;
            FRAME = newFrame;
            CHECK_GC();
            BREAK;

        /*
            Return from a function without a result
                Return
         */
        CASE (EJS_OP_RETURN):
            ejs->result = ESV(undefined);
            if (FRAME->caller == 0) {
                goto done;
            }
            state->stack = FRAME->stackReturn;
            state->bp = FRAME->function.block.prev;
            newFrame = FRAME->caller;
            FRAME = newFrame;
            CHECK_GC();
            BREAK;

        /*
            Load the catch argument
                PushCatchArg
                Stack before (top)  []
                Stack after         [catchArg]
         */
        CASE (EJS_OP_PUSH_CATCH_ARG):
            push(ejs->exceptionArg);
            ejs->exceptionArg = 0;
            BREAK;

        /*
            Push the function call result
                 PushResult
                Stack before (top)  []
                Stack after         [result]
         */
        CASE (EJS_OP_PUSH_RESULT):
            push(ejs->result);
            BREAK;

        /*
            Save the top of stack and store in the interpreter result register
                SaveResult
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_SAVE_RESULT):
            ejs->result = pop(ejs);
            BREAK;

        /* Load Constants ----------------------------------------------- */

        /*
            Load a float constant
                LoadDouble          <double>
                Stack before (top)  []
                Stack after         [Double]
         */
        CASE (EJS_OP_LOAD_DOUBLE):
            push(ejsCreateNumber(ejs, GET_DOUBLE()));
            BREAK;

        /*
            Load a signed integer constant (up to 55 bits worth of data)
                LoadInt.64          <int64>
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_INT):
            push(ejsCreateNumber(ejs, (MprNumber) GET_NUM()));
            BREAK;

        /*
            Load integer constant between 0 and 9
                Load0, Load1, ... Load9
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_0):
        CASE (EJS_OP_LOAD_1):
        CASE (EJS_OP_LOAD_2):
        CASE (EJS_OP_LOAD_3):
        CASE (EJS_OP_LOAD_4):
        CASE (EJS_OP_LOAD_5):
        CASE (EJS_OP_LOAD_6):
        CASE (EJS_OP_LOAD_7):
        CASE (EJS_OP_LOAD_8):
        CASE (EJS_OP_LOAD_9):
            push(ejsCreateNumber(ejs, opcode - EJS_OP_LOAD_0));
            BREAK;

        /*
            Load the -1 integer constant
                LoadMinusOne
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_M1):
            push(ejsCreateNumber(ejs, -1));
            BREAK;

        /*
            Load a string constant
                LoadString          <string>
                Stack before (top)  []
                Stack after         [String]
         */
        CASE (EJS_OP_LOAD_STRING):
            push(GET_STRING());
            BREAK;

        /*
            Load a namespace constant
                LoadNamespace       <UriString>
                Stack before (top)  []
                Stack after         [Namespace]
         */
        CASE (EJS_OP_LOAD_NAMESPACE):
            str = GET_STRING();
            push(ejsCreateNamespace(ejs, str));
            BREAK;

        /*
            Load an XML constant
                LoadXML             <xmlString>
                Stack before (top)  []
                Stack after         [XML]
         */
        CASE (EJS_OP_LOAD_XML):
            v1 = ejsCreateObj(ejs, EST(XML), 0);
            str = GET_STRING();
            ejsLoadXMLString(ejs, (EjsXML*) v1, str);
            push(v1);
            BREAK;

        /*
            Load a Regexp constant
                LoadRegExp
                Stack before (top)  []
                Stack after         [RegExp]
         */
        CASE (EJS_OP_LOAD_REGEXP):
#if ME_COM_PCRE
            str = GET_STRING();
            v1 = (EjsObj*) ejsParseRegExp(ejs, str);
            push(v1);
#else
            ejsThrowReferenceError(ejs, "RegularExpression support was not included in the build");
#endif
            BREAK;

        /*
            Load a null constant
                LoadNull
                Stack before (top)  []
                Stack after         [Null]
         */
        CASE (EJS_OP_LOAD_NULL):
            push(ESV(null));
            BREAK;

        /*
            Load a void / undefined constant
                LoadUndefined
                Stack before (top)  []
                Stack after         [undefined]
         */
        CASE (EJS_OP_LOAD_UNDEFINED):
            push(ESV(undefined));
            BREAK;

        CASE (EJS_OP_LOAD_THIS):
            push(THIS);
            BREAK;

        CASE (EJS_OP_LOAD_THIS_LOOKUP):
            if (lookup.originalObj) {
                push(lookup.originalObj);
            } else {
                obj = FRAME->function.moduleInitializer ? ejs->global : (EjsObj*) FRAME;
                push(obj);
            }
            BREAK;

        /*
            Load the nth base class of "this"
                LoadThis
                Stack before (top)  []
                Stack after         [baseClass]
         */
        CASE (EJS_OP_LOAD_THIS_BASE):
            vp = getNthBase(ejs, THIS, GET_INT());
            push(vp);
            BREAK;

        /*
            Load the "global" value
                LoadGlobal
                Stack before (tp (op)  []
                Stack after         [global]
         */
        CASE (EJS_OP_LOAD_GLOBAL):
            push(ejs->global);
            BREAK;

        /*
            Load the "true" value
                LoadTrue
                Stack before (top)  []
                Stack after         [true]
         */
        CASE (EJS_OP_LOAD_TRUE):
            push(ESV(true));
            BREAK;

        /*
            Load the "false" value
                LoadFalse
                Stack before (top)  []
                Stack after         [false]
         */
        CASE (EJS_OP_LOAD_FALSE):
            push(ESV(false));
            BREAK;

        /*
            Load a global variable by slot number
                GetGlobalSlot       <slot>
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_GLOBAL_SLOT):
            GET_SLOT(NULL, global, GET_INT());
            BREAK;

        /*
            Load a local variable by slot number
                GetLocalSlot        <slot>
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_LOCAL_SLOT):
            GET_SLOT(NULL, FRAME, GET_INT());
            BREAK;

        /*
            Load a local variable in slot 0-9
                GetLocalSlot0, GetLocalSlot1, ... GetLocalSlot9
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_LOCAL_SLOT_0):
        CASE (EJS_OP_GET_LOCAL_SLOT_1):
        CASE (EJS_OP_GET_LOCAL_SLOT_2):
        CASE (EJS_OP_GET_LOCAL_SLOT_3):
        CASE (EJS_OP_GET_LOCAL_SLOT_4):
        CASE (EJS_OP_GET_LOCAL_SLOT_5):
        CASE (EJS_OP_GET_LOCAL_SLOT_6):
        CASE (EJS_OP_GET_LOCAL_SLOT_7):
        CASE (EJS_OP_GET_LOCAL_SLOT_8):
        CASE (EJS_OP_GET_LOCAL_SLOT_9):
            GET_SLOT(NULL, FRAME, opcode - EJS_OP_GET_LOCAL_SLOT_0);
            BREAK;

        /*
            Load a block scoped variable by slot number
                GetBlockSlot        <slot> <nthBlock>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = getNthBlock(ejs, GET_INT());
            GET_SLOT(NULL, obj, slotNum);
            BREAK;

        /*
            Load a property in thisObj by slot number
                GetThisSlot         <slot>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_SLOT):
            GET_SLOT(THIS, THIS, GET_INT());
            BREAK;

        /*
            Load a property in slot 0-9
                GetThisSlot0, GetThisSlot1,  ... GetThisSlot9
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_SLOT_0):
        CASE (EJS_OP_GET_THIS_SLOT_1):
        CASE (EJS_OP_GET_THIS_SLOT_2):
        CASE (EJS_OP_GET_THIS_SLOT_3):
        CASE (EJS_OP_GET_THIS_SLOT_4):
        CASE (EJS_OP_GET_THIS_SLOT_5):
        CASE (EJS_OP_GET_THIS_SLOT_6):
        CASE (EJS_OP_GET_THIS_SLOT_7):
        CASE (EJS_OP_GET_THIS_SLOT_8):
        CASE (EJS_OP_GET_THIS_SLOT_9):
            GET_SLOT(THIS, THIS, opcode - EJS_OP_GET_THIS_SLOT_0);
            BREAK;

        /*
            Load a property in an object by slot number
                GetObjSlot          <slot>
                Stack before (top)  [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_SLOT):
            vp = pop(ejs);
            GET_SLOT(vp, vp, GET_INT());
            BREAK;

        /*
            Load a property in an object from slot 0-9
                GetObjSlot0, GetObjSlot1, ... GetObjSlot9
                Stack before (top)  [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_SLOT_0):
        CASE (EJS_OP_GET_OBJ_SLOT_1):
        CASE (EJS_OP_GET_OBJ_SLOT_2):
        CASE (EJS_OP_GET_OBJ_SLOT_3):
        CASE (EJS_OP_GET_OBJ_SLOT_4):
        CASE (EJS_OP_GET_OBJ_SLOT_5):
        CASE (EJS_OP_GET_OBJ_SLOT_6):
        CASE (EJS_OP_GET_OBJ_SLOT_7):
        CASE (EJS_OP_GET_OBJ_SLOT_8):
        CASE (EJS_OP_GET_OBJ_SLOT_9):
            vp = pop(ejs);
            GET_SLOT(vp, vp, opcode - EJS_OP_GET_OBJ_SLOT_0);
            BREAK;

        /*
            Load a variable from a type by slot number
                GetTypeSlot         <slot> <nthBase>
                Stack before (top)  [objRef]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_TYPE_SLOT):
            slotNum = GET_INT();
            thisObj = pop(ejs);
            vp = getNthBase(ejs, thisObj, GET_INT());
            GET_SLOT(thisObj, vp, slotNum);
            BREAK;

        /*
            Load a type variable by slot number from this. NthBase counts from Object up rather than "this" down.
                GetThisTypeSlot     <slot> <nthBaseFromBottom>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_TYPE_SLOT):
            slotNum = GET_INT();
            type = (EjsType*) getNthBaseFromBottom(ejs, THIS, GET_INT());
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Bad base class reference");
            } else {
                GET_SLOT(THIS, type, slotNum);
            }
            BREAK;

        /*
            Load a variable by an unqualified name
                GetScopedName       <qname>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_SCOPED_NAME):
            qname = GET_NAME();
            vp = ejsGetVarByName(ejs, NULL, qname, &lookup);
            if (unlikely(vp == 0)) {
                vp = ejsGetVarByName(ejs, NULL, qname, &lookup);
                ejsThrowReferenceError(ejs, "%@ is not defined", qname.name);
            } else {
                CHECK_VALUE(vp, NULL, lookup.obj, lookup.slotNum);
            }
            BREAK;
                
        /*
            Load a variable by an unqualified name expression
                GetScopedNameExpr
                Stack before (top)  [name]
                                    [space]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_SCOPED_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            vp = ejsGetVarByName(ejs, NULL, qname, &lookup);
            if (unlikely(vp == 0)) {
                push(ESV(undefined));
            } else {
                CHECK_VALUE(vp, NULL, lookup.obj, lookup.slotNum);
            }
#if DYNAMIC_BINDING
            if (ejs->flags & EJS_FLAG_COMPILER || TYPE(lookup.obj) == EST(Object) || lookup.slotNum >= 4096) {
                BREAK;
            }
            if (lookup.obj == ejs->global) {
                *mark++ = EJS_OP_GET_GLOBAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup->obj == state->fp) {
                *mark++ = EJS_OP_GET_LOCAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup->obj == state->fp->thisObj) {
                *mark++ = EJS_OP_GET_THIS_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (ejsIsA(ejs, THIS, (EjsType*) lookup.obj)) {
                *mark++ = EJS_OP_GET_BLOCK_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBlock);

            } else {
                BREAK;
            }
            FILL(mark);
#endif
            BREAK;
                
        /*
            Load a property by property name
                GetObjName          <qname>
                Stack before (top)  [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_GET_OBJ_NAME):
#if DYNAMIC_BINDING
            mark = FRAME->pc - 1;
#endif
            qname = GET_NAME();
            vp = pop(ejs);
            if (vp == ESV(null) || vp == ESV(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            v1 = ejsGetVarByName(ejs, vp, qname, &lookup);
            CHECK_VALUE(v1, vp, lookup.obj, lookup.slotNum);
#if DYNAMIC_BINDING
            if (lookup.slotNum < 0 || lookup.slotNum > 4096 || ejs->flags & EJS_FLAG_COMPILER) {
                BREAK;
            }
            if (lookup.obj == ejs->global) {
                *mark++ = EJS_OP_GET_GLOBAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup.obj == (EjsObj*) state.fp) {
                *mark++ = EJS_OP_GET_LOCAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup.obj == state.fp->thisObj) {
                *mark++ = EJS_OP_GET_THIS_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                
            } else if (ejsIsType(ejs, lookup.obj) && ejsIsA(ejs, THIS, (EjsType*) lookup.obj)) {
                *mark++ = EJS_OP_GET_TYPE_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBlock + 1);

            } else if ((EjsObj*) TYPE(vp) == lookup.obj) {
                *mark++  = EJS_OP_GET_TYPE_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBase);

            } else {
                *mark++  = EJS_OP_GET_OBJ_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
            }
            FILL(mark);
#endif
            BREAK;

#if XXXX
        CASE (EJS_OP_GET_POLY_SLOT):
            vp = pop(ejs);
            slotNum = GET_UINT32();
            type = GET_PTR();
            if (TYPE(vp) != type) {
                GET_SLOT(thisObj, vp, slotNum);
            } else {
                v1 = ejsGetVarByName(ejs, vp, qname, &lookup);
                CHECK_VALUE(v1, vp, lookup.obj, lookup.slotNum);
            }

        /*
            Load a property by property name
                GetObjName          <qname>
                Stack before (top)  [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_GET_OBJ_NAME):
            mark = FRAME->pc - 1;
            qname = GET_NAME();
            vp = pop(ejs);
            if (vp == ESV(null) || vp == ESV(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            v1 = ejsGetVarByName(ejs, vp, qname, &lookup);
            CHECK_VALUE(v1, vp, lookup.obj, lookup.slotNum);

            if (v1 && lookup.obj == vp) {
                *mark++ = EJS_OP_GET_POLY_SLOT;
                *mark++ = lookup.slotNum;
                uint *ui = (uint*) mark;
                *ui++ = lookup.
                uint *ui = (uint*) FRAME->pc;
                *ui = ejsEncodeUint(mark, lookup.slotNum);
            }
            FILL(mark);
            BREAK;
#endif

        /*
            Load a property by property a qualified name expression
                GetObjNameExpr
                Stack before (top)  [name]
                                    [space]
                                    [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_NAME_EXPR):
            v1 = pop(ejs);
            v2 = pop(ejs);
            vp = pop(ejs);
            if (vp == 0 || vp == ESV(null) || vp == ESV(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            if (TYPE(vp)->numericIndicies && ejsIs(ejs, v1, Number)) {
                vp = ejsGetProperty(ejs, vp, ejsGetInt(ejs, v1));
                push(vp == 0 ? ESV(null) : vp);
                BREAK;
            } else {
                qname.name = ejsToString(ejs, v1);
                if (ejsIs(ejs, v2, Namespace)) {
                    qname.space = ((EjsNamespace*) v2)->value;
                } else {
                    qname.space = ejsToString(ejs, v2);
                }
                v2 = ejsGetVarByName(ejs, vp, qname, &lookup);
                CHECK_VALUE(v2, NULL, lookup.obj, lookup.slotNum);
                BREAK;
            }


        /* Store ------------------------------- */

        /*
            Store a global variable by slot number
                Stack before (top)  [value]
                Stack after         []
                PutGlobalSlot       <slot>
         */
        CASE (EJS_OP_PUT_GLOBAL_SLOT):
            SET_SLOT(NULL, global, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a local variable by slot number
                Stack before (top)  [value]
                Stack after         []
                PutLocalSlot        <slot>
         */
        CASE (EJS_OP_PUT_LOCAL_SLOT):
            SET_SLOT(NULL, FRAME, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a local variable from slot 0-9
                PutLocalSlot0, PutLocalSlot1, ... PutLocalSlot9
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_LOCAL_SLOT_0):
        CASE (EJS_OP_PUT_LOCAL_SLOT_1):
        CASE (EJS_OP_PUT_LOCAL_SLOT_2):
        CASE (EJS_OP_PUT_LOCAL_SLOT_3):
        CASE (EJS_OP_PUT_LOCAL_SLOT_4):
        CASE (EJS_OP_PUT_LOCAL_SLOT_5):
        CASE (EJS_OP_PUT_LOCAL_SLOT_6):
        CASE (EJS_OP_PUT_LOCAL_SLOT_7):
        CASE (EJS_OP_PUT_LOCAL_SLOT_8):
        CASE (EJS_OP_PUT_LOCAL_SLOT_9):
            SET_SLOT(NULL, FRAME, opcode - EJS_OP_PUT_LOCAL_SLOT_0, pop(ejs));
            BREAK;

        /*
            Store a block variable by slot number
                PutBlockSlot        <slot> <nthBlock>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = getNthBlock(ejs, GET_INT());
            SET_SLOT(NULL, obj, slotNum, pop(ejs));
            BREAK;

#if FUTURE
        /*
            Store a block variable from slot 0-9
                PutBlockSlot0, PutBlockSlot1, ... PutBlockSlot9 <nthBlock>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_BLOCK_SLOT_0):
        CASE (EJS_OP_PUT_BLOCK_SLOT_1):
        CASE (EJS_OP_PUT_BLOCK_SLOT_2):
        CASE (EJS_OP_PUT_BLOCK_SLOT_3):
        CASE (EJS_OP_PUT_BLOCK_SLOT_4):
        CASE (EJS_OP_PUT_BLOCK_SLOT_5):
        CASE (EJS_OP_PUT_BLOCK_SLOT_6):
        CASE (EJS_OP_PUT_BLOCK_SLOT_7):
        CASE (EJS_OP_PUT_BLOCK_SLOT_8):
        CASE (EJS_OP_PUT_BLOCK_SLOT_9):
            slotNum = opcode - EJS_OP_PUT_BLOCK_SLOT_0;
            obj = getNthBlock(ejs, GET_INT());
            SET_SLOT(NULL, obj, slotNum, pop(ejs));
            BREAK;
#endif

        /*
            Store a property by slot number
                PutThisSlot         <slot>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_SLOT):
            slotNum = GET_INT();
            SET_SLOT(THIS, THIS, slotNum, pop(ejs));
            BREAK;

        /*
            Store a property to slot 0-9
                PutThisSlot0, PutThisSlot1, ... PutThisSlot9,
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_SLOT_0):
        CASE (EJS_OP_PUT_THIS_SLOT_1):
        CASE (EJS_OP_PUT_THIS_SLOT_2):
        CASE (EJS_OP_PUT_THIS_SLOT_3):
        CASE (EJS_OP_PUT_THIS_SLOT_4):
        CASE (EJS_OP_PUT_THIS_SLOT_5):
        CASE (EJS_OP_PUT_THIS_SLOT_6):
        CASE (EJS_OP_PUT_THIS_SLOT_7):
        CASE (EJS_OP_PUT_THIS_SLOT_8):
        CASE (EJS_OP_PUT_THIS_SLOT_9):
            SET_SLOT(THIS, THIS, opcode - EJS_OP_PUT_THIS_SLOT_0, pop(ejs));
            BREAK;

        /* 
            Store a property by slot number
                PutObjSlot          <slot>
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_SLOT):
            vp = pop(ejs);
            SET_SLOT(NULL, vp, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a property to slot 0-9
                PutObjSlot0, PutObjSlot1, ... PutObjSlot9
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_SLOT_0):
        CASE (EJS_OP_PUT_OBJ_SLOT_1):
        CASE (EJS_OP_PUT_OBJ_SLOT_2):
        CASE (EJS_OP_PUT_OBJ_SLOT_3):
        CASE (EJS_OP_PUT_OBJ_SLOT_4):
        CASE (EJS_OP_PUT_OBJ_SLOT_5):
        CASE (EJS_OP_PUT_OBJ_SLOT_6):
        CASE (EJS_OP_PUT_OBJ_SLOT_7):
        CASE (EJS_OP_PUT_OBJ_SLOT_8):
        CASE (EJS_OP_PUT_OBJ_SLOT_9):
            vp = pop(ejs);
            SET_SLOT(NULL, vp, opcode - EJS_OP_PUT_OBJ_SLOT_0, pop(ejs));
            BREAK;

        /*
            Store a variable by an unqualified name
                PutScopedName       <qname>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_SCOPED_NAME):
            qname = GET_NAME();
            value = pop(ejs);
            storePropertyToScope(ejs, qname, value);
            BREAK;

        /*
            Store a variable by an unqualified name expression
                PutScopedName 
                Stack before (top)  [name]
                                    [space]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_SCOPED_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            value = pop(ejs);
            storePropertyToScope(ejs, qname, value);
            BREAK;

        /*
            Store a property by property name to an object
                PutObjName
                Stack before (top)  [objRef]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_NAME):
            qname = GET_NAME();
            obj = pop(ejs);
            value = pop(ejs);
            storeProperty(ejs, obj, obj, qname, value);
            BREAK;

        /*
            Store a property by a qualified property name expression to an object
                PutObjNameExpr
                Stack before (top)  [nameExpr]
                                    [spaceExpr]
                                    [objRef]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_NAME_EXPR):
            v1 = pop(ejs);
            v2 = pop(ejs);
            obj = pop(ejs);
            value = pop(ejs);
            //  TODO -- cleanup this too - push into storeProperty
            if (TYPE(obj)->numericIndicies && ejsIs(ejs, v1, Number)) {
                ejsSetProperty(ejs, obj, ejsGetInt(ejs, v1), value);
            } else {
                qname.name = ejsToString(ejs, v1);
                if (ejsIs(ejs, v2, Namespace)) {
                    qname.space = ((EjsNamespace*) v2)->value;
                } else {
                    qname.space = ejsToString(ejs, v2);
                }
                if (qname.name && qname.space) {
                    storeProperty(ejs, obj, obj, qname, value);
                }
            }
            BREAK;

        /*
            Store a type variable by slot number
                PutTypeSlot         <slot> <nthBase>
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_TYPE_SLOT):
            slotNum = GET_INT();
            vobj = pop(ejs);
            vp = getNthBase(ejs, vobj, GET_INT());
            SET_SLOT(vobj, vp, slotNum, pop(ejs));
            BREAK;

        /*
            Store a variable to a slot in the nthBase class of the current "this" object
                PutThisTypeSlot     <slot> <nthBase>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_TYPE_SLOT):
            slotNum = GET_INT();
            type = (EjsType*) getNthBaseFromBottom(ejs, THIS, GET_INT());
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Bad base class reference");
            } else {
                SET_SLOT(THIS, type, slotNum, pop(ejs));
            }
            BREAK;


        /* Function calling and return */

        /*
            Call a function by reference
                Stack before (top)  [args]
                                    [function]
                                    [thisObj]
                Stack after         []
         */
        CASE (EJS_OP_CALL):
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc - 1];
            callFunction(ejs, (EjsFunction*) state->stack[-argc], vp, argc, 2);
            BREAK;

        /*
            Call a global function by slot on the given type
                CallGlobalSlot      <slot> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_GLOBAL_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            callProperty(ejs, global, slotNum, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on the pushed object
                CallObjSlot         <slot> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == ESV(null) || vp == ESV(undefined)) {
                //  TODO -- refactor
                if (vp && (slotNum == ES_Object_iterator_get || slotNum == ES_Object_iterator_getValues)) {
                    callProperty(ejs, TYPE(vp), slotNum, vp, argc, 1);
                } else {
                    ejsThrowReferenceError(ejs, "Object reference is null or undefined");
                }
            } else {
                callProperty(ejs, TYPE(vp)->prototype, slotNum, vp, argc, 1);
            }
            BREAK;

        /*
            Call a function by slot number on the current this object.
                CallThisSlot        <slot> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_THIS_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            obj = (EjsObj*) TYPE(THIS)->prototype;
            callProperty(ejs, obj, slotNum, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on the nth enclosing block
                CallBlockSlot        <slot> <nthBlock> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = getNthBlock(ejs, GET_INT());
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            callProperty(ejs, obj, slotNum, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on an object.
                CallObjInstanceSlot <slot> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_INSTANCE_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == 0 || vp == ESV(null) || vp == ESV(undefined)) {
                ejsThrowReferenceError(ejs, "Object reference is null");
            } else {
                callProperty(ejs, vp, slotNum, vp, argc, 1);
            }
            BREAK;

        /*
            Call a static function by slot number on the pushed object
                CallObjStaticSlot   <slot> <nthBase> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_STATIC_SLOT):
            slotNum = GET_INT();
            nthBase = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == ESV(null) || vp == ESV(undefined)) {
                throwNull(ejs);
            } else {
                type = (EjsType*) getNthBase(ejs, vp, nthBase);
                callProperty(ejs, type, slotNum, type, argc, 1);
            }
            BREAK;

        /*
            Call a static function by slot number on the nth base class of the current "this" object
                CallThisStaticSlot  <slot> <nthBase> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_THIS_STATIC_SLOT):
            slotNum = GET_INT();
            nthBase = GET_INT();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            type = (EjsType*) getNthBase(ejs, THIS, nthBase);
            if (type == EST(Object)) {
                //  TODO - remove
                ejsThrowReferenceError(ejs, "Bad type reference");
                BREAK;
            }
            callProperty(ejs, type, slotNum, type, argc, 0);
            BREAK;

        /*
            Call a function by name on the pushed object
                CallObjName         <qname> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_NAME):
            qname = GET_NAME();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == 0) {
                ejsThrowReferenceError(ejs, "%@ is not defined", qname.name);
                throwNull(ejs);
                BREAK;
            }
            slotNum = ejsLookupVar(ejs, vp, qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Cannot find function \"%@\"", qname.name);
            } else {
                EjsTrait *trait = ejsGetPropertyTraits(ejs, lookup.obj, slotNum);
                if (trait && trait->attributes & EJS_PROP_STATIC) {
                    vp = lookup.obj;
                }
                callProperty(ejs, lookup.obj, slotNum, vp, argc, 1);
            }
            BREAK;

        /*
            Call a function by name in the current scope. Use existing "this" object if defined.
                CallName            <qname> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_SCOPED_NAME):
            qname = GET_NAME();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            slotNum = ejsLookupScope(ejs, qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Cannot find function %@", qname.name);
                BREAK;
            }
            fun = ejsGetProperty(ejs, lookup.obj, slotNum);
            if (ejsIsType(ejs, fun)) {
                type = (EjsType*) fun;
                callFunction(ejs, fun, NULL, argc, 0);

            } else if (!ejsIsFunction(ejs, fun)) {
                if (!ejs->exception) {
                    if ((EjsObj*) vp == (EjsObj*) ESV(undefined)) {
                        ejsThrowReferenceError(ejs, "Function is undefined");
                    } else {
                        ejsThrowReferenceError(ejs, "Reference is not a function");
                    }
                }
            } else {
                /*
                    Calculate the "this" to use for the function. If required function is a method in the current 
                    "this" object use the current thisObj. If the lookup.obj is a type, then use it. Otherwise global.
                 */
                if ((vp = fun->boundThis) == 0) {
                    if (lookup.obj == THIS) {
                        vp = THIS;
                    } else if (ejsIsPrototype(ejs, lookup.obj) && ejsIsA(ejs, THIS, lookup.type)) {
                        vp = THIS;
                    } else if (ejsIsType(ejs, lookup.obj)) {
                        vp = lookup.obj;
                    } else {
                        vp = /* lookup.obj */ ejs->global;
                    } 
                }
                callProperty(ejs, lookup.obj, slotNum, vp, argc, 0);
            }
            BREAK;

        /*
            Call a constructor
                CallConstructor     <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         [obj]
         */
        CASE (EJS_OP_CALL_CONSTRUCTOR):
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            vp = state->stack[-argc];
            if (vp == 0 || vp == ESV(null) || vp == ESV(undefined)) {
                throwNull(ejs);
                BREAK;
            }
            type = TYPE(vp);
            assert(type);
            if (type && type->constructor.block.pot.isFunction) {
                assert(type->prototype);
                callFunction(ejs, (EjsFunction*) type, vp, argc, 0);
                state->stack[0] = ejs->result;
            }
            BREAK;

        /*
            Call the next constructor
                CallNextConstructor <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_NEXT_CONSTRUCTOR):
            qname = GET_NAME();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            type = ejsGetPropertyByName(ejs, ejs->global, qname);
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Cannot find constructor %@", qname.name);
            } else {
                assert(type->constructor.block.pot.isFunction);
                callFunction(ejs, (EjsFunction*) type, THIS, argc, 0);
            }
            BREAK;

        /*
            Add a literal namespace to the set of open namespaces for the current block
                AddNamespace <string>
         */
        CASE (EJS_OP_ADD_NAMESPACE):
            str = GET_STRING();
            nsp = ejsCreateNamespace(ejs, str);
            ejsAddNamespaceToBlock(ejs, state->bp, nsp);
            if (ejsContainsAsc(ejs, str, "internal-") >= 0) {
                state->internal = nsp;
            }
            BREAK;

        /*
            Add a namespace expression (reference) to the set of open namespaces for the current block. (use namespace).
                Stack before (top)  [namespace]
                Stack after         []
                AddNamespaceRef
         */
        CASE (EJS_OP_ADD_NAMESPACE_REF):
            ejsAddNamespaceToBlock(ejs, state->bp, (EjsNamespace*) pop(ejs));
            BREAK;

        /*
            Push a new scope block on the scope chain
                OpenBlock <slotNum> <nthBlock>
         */
        CASE (EJS_OP_OPEN_BLOCK):
            slotNum = GET_INT();
            vp = getNthBlock(ejs, GET_INT());
            v1 = ejsGetProperty(ejs, vp, slotNum);
            if (!ejsIsBlock(ejs, v1)) {
                ejsThrowReferenceError(ejs, "Reference is not a block");
                BREAK;
            }
            //  OPT
            blk = ejsCloneBlock(ejs, (EjsBlock*) v1, 0);
            blk->prev = blk->scope = state->bp;
            state->bp = blk;
            blk->stackBase = state->stack;
            mprCopyName(state->bp, v1);
            ejsSetBlockLocation(blk, FRAME->line);
            BREAK;

        /*
            Add a new scope block from the stack onto on the scope chain
                OpenWith
         */
        CASE (EJS_OP_OPEN_WITH):
            vp = pop(ejs);
            blk = ejsCreateBlock(ejs, 0);
            memcpy((void*) blk, vp, TYPE(vp)->instanceSize);
            blk->prev = blk->scope = state->bp;
            state->bp = blk;
            BREAK;

        /*
            Store the top scope block off the scope chain
                CloseBlock
                CloseWith
         */
        CASE (EJS_OP_CLOSE_BLOCK):
            state->bp = state->bp->prev;
            BREAK;

        /*
            Define a class and initialize by calling any static initializer.
                DefineClass <type>
         */
        CASE (EJS_OP_DEFINE_CLASS):
            type = GET_TYPE();
            if (type == 0 || !ejsIsType(ejs, type)) {
                ejsThrowReferenceError(ejs, "Reference is not a class");
            } else {
                type->constructor.block.scope = state->bp;
                if (type && type->hasInitializer) {
                    fun = ejsGetProperty(ejs, type, 0);
                    callFunction(ejs, fun, type, 0, 0);
                    if (type->implements && !ejs->exception) {
                        callInterfaceInitializers(ejs, type);
                    }
                    state->bp = &FRAME->function.block;
                }
            }
            ejs->result = type;
            BREAK;

        /*
            Define a function. This is used only for non-method functions to capture the scope chain.
                DefineFunction <slot> <nthBlock>
         */
        CASE (EJS_OP_DEFINE_FUNCTION):
            qname = GET_NAME();
            if ((slotNum = ejsLookupScope(ejs, qname, &lookup)) >= 0) {
                f1 = ejsGetProperty(ejs, lookup.obj, lookup.slotNum);
            }
            if (slotNum < 0 || !ejsIsFunction(ejs, f1)) {
                ejsThrowReferenceError(ejs, "Reference is not a function");
            } else {
                //  TODO -- fullScope is always true if DEFINE_FUNCTION is emitted
                assert(f1->fullScope);
                if (f1->fullScope) {
                    //  TODO - why exception for global
                    if (lookup.obj != ejs->global) {
                        f2 = ejsCloneFunction(ejs, f1, 0);
                    } else {
                        f2 = f1;
                    }
                    f2->block.scope = state->bp;
                    if (FRAME->function.boundThis != ejs->global) {
                        f2->boundThis = FRAME->function.boundThis;
                    }
                    assert(f2->boundThis != ejs->global);
                    assert(!ejsIsPrototype(ejs, lookup.obj));
                    //  OPT - don't do this for global functions (if f2 == f1 and boundThis not updated (== global))
                    ejsSetProperty(ejs, lookup.obj, lookup.slotNum, f2);
                }
            }
            BREAK;


        /* Exception Handling -------------------------------------------- */

        /*
            Invoke finally blocks before acting on: return, returnValue and break/continue (goto) opcodes.
            These are injected by the compiler.
        
                call_finally
         */
        CASE (EJS_OP_CALL_FINALLY):
            if ((ex = findExceptionHandler(ejs, EJS_EX_FINALLY)) != 0) {
                uchar   *savePC;
                if (FRAME->function.inCatch) {
                    popExceptionBlock(ejs);
                }
                savePC = FRAME->pc;
                createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
                BLOCK->restartAddress = savePC;
            }
            BREAK;

        /*
            Invoke finally blocks before leaving try block. These are injected by the compiler.
        
                goto_finally
         */
        CASE (EJS_OP_GOTO_FINALLY):
            if ((ex = findExceptionHandler(ejs, EJS_EX_FINALLY)) != 0) {
                if (FRAME->function.inCatch) {
                    popExceptionBlock(ejs);
                }
                createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
            }
            BREAK;

        /*
            End of an exception block. Put at the end of the last catch/finally block
                EndException
         */
        CASE (EJS_OP_END_EXCEPTION):
            if (FRAME->function.inException) {
                FRAME->function.inCatch = 0;
                FRAME->function.inException = 0;
                if (BLOCK->restartAddress) {
                    uchar *savePC = BLOCK->restartAddress;
                    popExceptionBlock(ejs);
                    SET_PC(FRAME, savePC);
                } else {
                    offset = findEndException(ejs);
                    SET_PC(FRAME, &FRAME->function.body.code->byteCode[offset]);
                    popExceptionBlock(ejs);
                }
            }
            BREAK;

        /*
            Throw an exception
                Stack before (top)  [exceptionObj]
                Stack after         []
                Throw
         */
        CASE (EJS_OP_THROW):
            ejs->exception = pop(ejs);
            ejsAttention(ejs);
            BREAK;

        /*
            Special circumstances need attention. Exceptions, exiting and garbage collection.
         */
        CASE (EJS_OP_ATTENTION):
            CHECK_GC();
            assert(FRAME->attentionPc);
            if (FRAME->attentionPc) {
                FRAME->pc = FRAME->attentionPc;
                assert(FRAME->pc);
                FRAME->attentionPc = 0;
            }
            if (mprHasMemError(ejs) && !ejs->exception) {
                mprResetMemError(ejs);
                ejsThrowMemoryError(ejs);
            }
            if (ejs->exception && !processException(ejs)) {
                goto done;
            }
            if (ejs->exiting || mprIsStopping()) {
                goto done;
            }
            BREAK;


        /* Stack management ---------------------------------------------- */

        /*
            Pop one item off the stack
                Pop
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_POP):
            ejs->result = pop(ejs);
            assert(ejs->exception || ejs->result);
            BREAK;

        /*
            Pop N items off the stack
                PopItems            <count>
                Stack before (top)  [value]
                                    [...]
                Stack after         []
         */
        CASE (EJS_OP_POP_ITEMS):
            state->stack -= GET_BYTE();
            BREAK;

        /*
            Duplicate one item on the stack
                Stack before (top)  [value]
                Stack after         [value]
                                    [value]
         */
        CASE (EJS_OP_DUP):
            vp = state->stack[0];
            push(vp);
            BREAK;

        /*
            Duplicate two items on the stack
                Dup2
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [value1]
                                    [value2]
                                    [value1]
                                    [value2]
         */
        CASE (EJS_OP_DUP2):
            v1 = state->stack[-1];
            push(v1);
            v1 = state->stack[0];
            push(v1);
            BREAK;

        /*
            Duplicate one item on the stack
                Stack before (top)  [value]
                Stack after         [value]
                                    [value]
         */
        CASE (EJS_OP_DUP_STACK):
            i = GET_BYTE();
            if (i < 0 || i > 32) {
                ejsThrowTypeError(ejs, "Bad stack index");
            } else {
                vp = state->stack[-i];
                push(vp);
            }
            BREAK;

        /*
            Swap the top two items on the stack
                Swap
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [value2]
                                    [value1]
         */
        CASE (EJS_OP_SWAP):
            SWAP; BREAK;


        /* Branching */

        /*
            Default function argument initialization. Computed goto for functions with more than 256 parameters.
                InitDefault         <tableSize>
         */
        CASE (EJS_OP_INIT_DEFAULT_ARGS): {
            int tableSize, numNonDefault;
            /*
                Use the argc value for the current function. Compare with the number of default args.
             */
            tableSize = (schar) GET_BYTE();
            numNonDefault = FRAME->function.numArgs - FRAME->function.numDefault;
            offset = FRAME->argc - numNonDefault;
            if (offset < 0 || offset > tableSize) {
                offset = tableSize;
            }
            FRAME->pc += ((uint*) FRAME->pc)[offset];
            BREAK;
        }

        /*
            Default function argument initialization. Computed goto for functions with less than 256 parameters.
                InitDefault.8       <tableSize.8>
         */
        CASE (EJS_OP_INIT_DEFAULT_ARGS_8): {
            int tableSize, numNonDefault;
            tableSize = (schar) GET_BYTE();
            numNonDefault = FRAME->function.numArgs - FRAME->function.numDefault - FRAME->function.rest;
            offset = FRAME->argc - numNonDefault;
            if (offset < 0 || offset > tableSize) {
                offset = tableSize;
            }
            FRAME->pc += FRAME->pc[offset];
            BREAK;
        }

        /*
            Spread array/object as individual args
                Pop
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_SPREAD):
            vp = *state->stack;
            count = ejsGetLength(ejs, vp);
            if (count > 0) {
                vp = pop(ejs);
                for (i = 0; i < count; i++) {
                    push(ejsGetProperty(ejs, vp, i));
                }
                ejs->spreadArgs = count - 1;
            }
            BREAK;

        /*
            Unconditional branch to a new location
                Goto                <offset.32>
         */
        CASE (EJS_OP_GOTO):
            offset = GET_WORD();
            SET_PC(FRAME, &FRAME->pc[offset]);
            CHECK_GC();
            BREAK;

        /*
            Unconditional branch to a new location (8 bit)
                Goto.8              <offset.8>
         */
        CASE (EJS_OP_GOTO_8):
            offset = (schar) GET_BYTE();
            SET_PC(FRAME, &FRAME->pc[offset]);
            CHECK_GC();
            BREAK;

        /*
            Branch to offset if false
                BranchFalse
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_FALSE):
            offset = GET_WORD();
            goto commonBoolBranchCode;

        /*
            Branch to offset if true
                BranchTrue
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_TRUE):
            offset = GET_WORD();
            goto commonBoolBranchCode;

        /*
            Branch to offset if false (8 bit)
                BranchFalse.8
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_FALSE_8):
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_TRUE_8 + EJS_OP_BRANCH_TRUE);
            offset = (schar) GET_BYTE();
            goto commonBoolBranchCode;

        /*
            Branch to offset if true (8 bit)
                BranchTrue.8
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_TRUE_8):
            /* We want sign extension here */
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_TRUE_8 + EJS_OP_BRANCH_TRUE);
            offset = (schar) GET_BYTE();

        /*
            Common boolean branch code
         */
        commonBoolBranchCode:
            v1 = pop(ejs);
            if (v1 == 0 || !ejsIs(ejs, v1, Boolean)) {
                v1 = ejsCast(ejs, v1, Boolean);
                if (ejs->exception) {
                    BREAK;
                }
            }
            if (!ejsIs(ejs, v1, Boolean)) {
                ejsThrowTypeError(ejs, "Result of a comparision must be boolean");
                BREAK;
            }
            if (opcode == EJS_OP_BRANCH_TRUE) {
                if (((EjsBoolean*) v1)->value) {
                    SET_PC(FRAME, &FRAME->pc[offset]);
                }
            } else {
                if (((EjsBoolean*) v1)->value == 0) {
                    SET_PC(FRAME, &FRAME->pc[offset]);
                }
            }
            CHECK_GC();
            BREAK;

        /*
            Branch to offset if [value1] == null
                BranchNull
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NULL):
            push(ESV(null));
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [value1] == undefined
                BranchUndefined
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_UNDEFINED):
            push(ESV(undefined));
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [tos] value is zero
                BranchZero
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_ZERO):
            /* Fall through */

        /*
            Branch to offset if [tos] value is not zero
                BranchNotZero
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NOT_ZERO):
            push(ESV(zero));
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [value1] == [value2]
                BranchEQ
                Stack before (top)  [value1]
                Stack before (top)  [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_EQ):

        /*
            Branch to offset if [value1] === [value2]
                BranchStrictlyEQ
                Stack before (top)  [value1]
                Stack after         [value2]
         */
        CASE (EJS_OP_BRANCH_STRICTLY_EQ):

        /*
            Branch to offset if [value1] != [value2]
                BranchNotEqual
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NE):

        /*
            Branch to offset if [value1] !== [value2]
                BranchStrictlyNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_STRICTLY_NE):

        /*
            Branch to offset if [value1] <= [value2]
                BranchLE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_LE):

        /*
            Branch to offset if [value1] < [value2]
                BranchLT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_LT):

        /*
            Branch to offset if [value1] >= [value2]
                BranchGE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_GE):

        /*
            Branch to offset if [value1] > [value2]
                BranchGT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_GT):
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Handle all branches here. We convert to a compare opcode and pass to the type to handle.
         */
        commonBranchCode:
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_EQ + EJS_OP_COMPARE_EQ);
            v2 = pop(ejs);
            v1 = pop(ejs);
            result = evalBinaryExpr(ejs, v1, opcode, v2);
            if (!ejsIs(ejs, result, Boolean)) {
                ejsThrowTypeError(ejs, "Result of a comparision must be boolean");
            } else if (((EjsBoolean*) result)->value) {
                SET_PC(FRAME, &FRAME->pc[offset]);
            }
            BREAK;

        /*
            Compare if [value1] == true
                CompareTrue
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_TRUE):

        /*
            Compare if ![value1]
                CompareNotTrue
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_FALSE):
            v1 = pop(ejs);
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Compare if [value1] == NULL
                CompareNull
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NULL):
            push(ESV(null));
            goto binaryExpression;

        /*
            Compare if [item] == undefined
                CompareUndefined
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_UNDEFINED):
            push(ESV(undefined));
            goto binaryExpression;

        /*
            Compare if [item] value is zero
                CompareZero
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_ZERO):
            push(ejsCreateNumber(ejs, 0));
            goto binaryExpression;

        /*
            Compare if [tos] value is not zero
                CompareZero
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NOT_ZERO):
            push(ejsCreateNumber(ejs, 0));
            goto binaryExpression;

        /*
            Compare if [value1] == [item2]
                CompareEQ
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_EQ):

        /*
            Compare if [value1] === [item2]
                CompareStrictlyEQ
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_STRICTLY_EQ):

        /*
            Compare if [value1] != [item2]
                CompareNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NE):

        /*
            Compare if [value1] !== [item2]
                CompareStrictlyNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_STRICTLY_NE):

        /*
            Compare if [value1] <= [item2]
                CompareLE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_LE):

        /*
            Compare if [value1] < [item2]
                CompareStrictlyLT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_LT):

        /*
            Compare if [value1] >= [item2]
                CompareGE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_GE):

        /*
            Compare if [value1] > [item2]
                CompareGT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_GT):

        /*
            Binary expressions
                Stack before (top)  [right]
                                    [left]
                Stack after         [boolean]
         */
        CASE (EJS_OP_ADD):
        CASE (EJS_OP_SUB):
        CASE (EJS_OP_MUL):
        CASE (EJS_OP_DIV):
        CASE (EJS_OP_REM):
        CASE (EJS_OP_SHL):
        CASE (EJS_OP_SHR):
        CASE (EJS_OP_USHR):
        CASE (EJS_OP_AND):
        CASE (EJS_OP_OR):
        CASE (EJS_OP_XOR):
        binaryExpression:
            v2 = pop(ejs);
            v1 = pop(ejs);
            assert(v1);
            ejs->result = evalBinaryExpr(ejs, v1, opcode, v2);
            push(ejs->result);
            BREAK;


        /* Unary operators */

        /*
            Negate a value
                Neg
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_NEG):
            v1 = pop(ejs);
            //  TODO - should this assign to ejs->result
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Logical not (~value)
                LogicalNot
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_LOGICAL_NOT):
            v1 = pop(ejs);
            if ((v1 = ejsCast(ejs, v1, Boolean)) != 0) {
                result = ejsInvokeOperator(ejs, v1, opcode, 0);
                push(result);
            }
            BREAK;

        /*
            Bitwise not (!value)
                BitwiseNot
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_NOT):
            v1 = pop(ejs);
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Increment a stack variable
                Inc                 <increment>
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_INC):
            v1 = pop(ejs);
            count = (schar) GET_BYTE();
            result = evalBinaryExpr(ejs, v1, EJS_OP_ADD, ejsCreateNumber(ejs, count));
            push(result);
            BREAK;


        /* Object creation */

        /*
            Create a new object
                New
                Stack before (top)  [type]
                Stack after         [obj]
         */
        CASE (EJS_OP_NEW):
            v1 = pop(ejs);
            if (!ejsIsType(ejs, v1)) {
                if (ejsIsFunction(ejs, v1)) {
                    fun = (EjsFunction*) v1;
                    if (fun->archetype == 0) {
                        if ((fun->archetype = ejsCreateArchetype(ejs, fun, NULL)) == 0) {
                            BREAK;
                        }
                    }
                    obj = ejsCreateObj(ejs, fun->archetype, 0);
                } else {
                    ejsThrowReferenceError(ejs, "Cannot locate type");
                    BREAK;
                }
            } else {
                obj = ejsCreateObj(ejs, (EjsType*) v1, 0);
            }
            push(obj);
            ejs->result = obj;
            BREAK;
                
            /*
             Create a new array literal
             NewArray            <type> <argc>
             Stack before (top)  [<index><value>]
             [<index><value>]
             Stack after         []
             */
        CASE (EJS_OP_NEW_ARRAY):
            paused = ejsBlockGC(ejs);
            type = GET_TYPE();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            state->t1 = vp = ejsCreateObj(ejs, type, 0);
            for (i = 1 - (argc * 2); i <= 0; ) {
                indexVar = ejsToNumber(ejs, state->stack[i++]);
                if (ejs->exception) BREAK;
                v1 = state->stack[i++];
                if (v1 && indexVar) {
                    ejsSetProperty(ejs, vp, ejsGetInt(ejs, indexVar), v1);
                }
            }
            state->stack -= (argc * 2);
            push(vp);
            state->t1 = 0;
            ejsUnblockGC(ejs, paused);
            BREAK;

        /*
            Create a new object literal
                NewObject           <type> <argc> [<attributes> ...]
                Stack before (top)  [<space><name><value>]
                                    [<space><name><value>]
                Stack after         []
         */
        CASE (EJS_OP_NEW_OBJECT):
            paused = ejsBlockGC(ejs);
            type = GET_TYPE();
            argc = GET_INT();
            argc += ejs->spreadArgs;
            ejs->spreadArgs = 0;
            state->t1 = vp = ejsCreateObj(ejs, type, 0);
            for (i = 1 - (argc * 3); i <= 0; ) {
                spaceVar = ejsToString(ejs, state->stack[i++]);
                if (ejs->exception) BREAK;
                nameVar = ejsToString(ejs, state->stack[i++]);
                if (ejs->exception) BREAK;
                v1 = state->stack[i++];
                attributes = GET_INT();
                if (v1 && nameVar && spaceVar) {
                    EjsName qname = { nameVar, spaceVar };
                    ejsDefineProperty(ejs, vp, -1, qname, NULL, attributes, v1);
                }
            } 
            state->stack -= (argc * 3);
            push(vp);
            state->t1 = 0;
            ejsUnblockGC(ejs, paused);
            BREAK;


        /*
            Reference the super class
                Super
                Stack before (top)  [obj]
                Stack after         [type]
         */
        CASE (EJS_OP_SUPER):
            push(TYPE(FRAME->function.boundThis));
            BREAK;

        /*
            Delete an object property by name expression
                DeleteNameExpr
                Stack before (top)  [name]
                                    [space]
                                    [obj]
                Stack after         [true|false]
         */
        CASE (EJS_OP_DELETE_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            vp = pop(ejs);
            slotNum = ejsLookupVar(ejs, vp, qname, &lookup);
            if (slotNum < 0) {
                push(ESV(true));
            } else {
                if (ejsPropertyHasTrait(ejs, lookup.obj, slotNum, EJS_TRAIT_FIXED)) {
                    push(ESV(false));
                } else {
                    ejsDeletePropertyByName(ejs, lookup.obj, lookup.name);
                    push(ESV(true));
                }
            }
            BREAK;

        /*
            Delete an object property from the current scope
                DeleteScopedNameExpr
                Stack before (top)  [name]
                                    [space]
                Stack after         [true|false]
         */
        CASE (EJS_OP_DELETE_SCOPED_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs));
            v1 = pop(ejs);
            if (ejsIs(ejs, v1, Namespace)) {
                qname.space = ((EjsNamespace*) v1)->value;
            } else {
                qname.space = ejsToString(ejs, v1);
            }
            slotNum = ejsLookupScope(ejs, qname, &lookup);
            if (slotNum < 0) {
                push(ESV(true));
            } else {
                if (ejsPropertyHasTrait(ejs, lookup.obj, slotNum, EJS_TRAIT_FIXED)) {
                    push(ESV(false));
                } else {
                    ejsDeletePropertyByName(ejs, lookup.obj, lookup.name);
                    push(ESV(true));
                }
            }
            BREAK;

        /*
            No operation. Does nothing.
                Nop
         */
        CASE (EJS_OP_NOP):
            BREAK;

        /*
            Check if object is a given type
                IsA, Like, InstanceOf
                Stack before (top)  [type]
                                    [obj]
                Stack after         [boolean]
         */
        CASE (EJS_OP_INST_OF):
        CASE (EJS_OP_IS_A):
        CASE (EJS_OP_LIKE):
            type = (EjsType*) pop(ejs);
            v1 = pop(ejs);
            push(ejsCreateBoolean(ejs, ejsIsA(ejs, v1, type)));
            BREAK;

        /*
            Get the type of an object.
                TypeOf              <obj>
                Stack before (top)  [obj]
                Stack after         [string]
         */
        CASE (EJS_OP_TYPE_OF):
            v1 = pop(ejs);
            push(ejsGetTypeOf(ejs, v1));
            BREAK;

        /*
            Cast an object to the given the type. Throw if not castable.
                Cast
                Stack before (top)  [type]
                                    [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_CAST):
            type = (EjsType*) pop(ejs);
            if (!ejsIsType(ejs, type)) {
                ejsThrowTypeError(ejs, "Not a type");
            } else {
                v1 = pop(ejs);
                push(ejsCastType(ejs, v1, type));
            }
            BREAK;

        /*
            Cast to a boolean type
                CastBoolean
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_CAST_BOOLEAN):
            v1 = ejsCast(ejs, pop(ejs), Boolean);
            push(v1);
            BREAK;

        /*
            Test if a given name is the name of a property "in" an object
                Cast
                Stack before (top)  [obj]
                                    [name]
                Stack after         [result]
         */
        CASE (EJS_OP_IN):
            v1 = pop(ejs);
            nameVar = ejsToString(ejs, pop(ejs));
            if (nameVar == 0) {
                ejsThrowTypeError(ejs, "Cannot convert to a name");
            } else {
                EjsName n = { nameVar, NULL };
                slotNum = ejsLookupProperty(ejs, v1, n);
                if (slotNum < 0) {
                    n.space = ESV(empty);
                    slotNum = ejsLookupVar(ejs, v1, n, &lookup);
                    if (slotNum < 0 && ejsIsType(ejs, v1)) {
                        slotNum = ejsLookupVar(ejs, ((EjsType*) v1)->prototype, n, &lookup);
                    }
                }
                push(ejsCreateBoolean(ejs, slotNum >= 0));
            }
            BREAK;

        /*
            Unimplemented op codes
         */
        CASE (EJS_OP_BREAKPOINT):
            assert(0);
            BREAK;

#if !ME_UNIX_LIKE && !(VXWORKS && !ME_DIAB)
        }
    }
#endif
    
done:
#if ME_DEBUG && FUTURE
    if (ejs->initialized) {
        ejsShowOpFrequency(ejs);
    }
#endif
    assert(FRAME == 0 || FRAME->attentionPc == 0);
    ejs->state = ejs->state->prev;
    if (ejs->exception) {
        ejsAttention(ejs);
    }
}


/*
    WARNING: this may not complete the store. It may setup a setter function which then requires the VM to execute.
 */
static void storePropertyToSlot(Ejs *ejs, EjsObj *thisObj, EjsAny *obj, int slotNum, EjsObj *value)
{
    EjsFunction     *fun;
    EjsObj          *vp;
    EjsTrait        *trait;

    assert(value);

    if (slotNum < 0 && !DYNAMIC(obj)) {
        ejsThrowTypeError(ejs, "Object is not extendable");
        return;
    }
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    if (trait) {
        if (trait->attributes & EJS_TRAIT_SETTER) {
            pushOutside(ejs, value);
            fun = ejsGetProperty(ejs, obj, slotNum);
            assert(fun);
            fun = fun->setter;
            assert(fun);
            callFunction(ejs, fun, thisObj, 1, 0);
            return;
        }
        if (trait->type) {
            if (!ejsIsA(ejs, value, trait->type)) {
                if (value == ESV(null) || value == ESV(undefined)) {
                    if (trait->attributes & EJS_TRAIT_THROW_NULLS) {
                        ejsThrowTypeError(ejs, "Unacceptable null or undefined value");
                        return;
                    } else if (trait->attributes & EJS_TRAIT_CAST_NULLS) {
                        value = ejsCastType(ejs, value, trait->type);
                        if (ejs->exception) {
                            return;
                        }
                    }
                } else {
                    value = ejsCastType(ejs, value, trait->type);
                    if (ejs->exception) {
                        return;
                    }
                }
            }
        }
        if (trait->attributes & EJS_TRAIT_READONLY) {
            EjsName  qname;
            vp = ejsGetProperty(ejs, obj, slotNum);
            if (vp != value && vp != ESV(null) && vp != ESV(undefined)) {
                if (ejsInvokeOperator(ejs, vp, EJS_OP_COMPARE_EQ, value) != ESV(true)) {
                    qname = ejsGetPropertyName(ejs, obj, slotNum);
                    ejsThrowReferenceError(ejs, "Property \"%@\" is not writable", qname.name);
                    return;
                }
            }
        }
    }
    ejsSetProperty(ejs, obj, slotNum, value);
    ejs->result = value;
}


/*
    Store a property by name in the given object. Will create if the property does not already exist.
 */
static void storeProperty(Ejs *ejs, EjsObj *thisObj, EjsAny *vp, EjsName qname, EjsObj *value)
{
    EjsLookup       lookup;
    EjsTrait        *trait;
    EjsPot          *pot;
    int             slotNum;

    assert(qname.name);
    assert(vp);

    //  ONLY XML requires this.  NOTE: this bypasses ES5 traits
    //  Alternatively push this whole function down into ejsObject and have all go via setPropertyByName
    
    if (TYPE(vp)->helpers.setPropertyByName) {
        slotNum = (*TYPE(vp)->helpers.setPropertyByName)(ejs, vp, qname, value);
        if (slotNum >= 0) {
            return;
        }
    }
    if ((slotNum = ejsLookupVar(ejs, vp, qname, &lookup)) >= 0) {
        if (lookup.obj != vp) {
            trait = ejsGetPropertyTraits(ejs, lookup.obj, slotNum);
            if (trait->attributes & EJS_TRAIT_SETTER) {
                vp = lookup.obj;
                
            } else if (ejsIsPrototype(ejs, lookup.obj) || trait->attributes & EJS_TRAIT_GETTER) {
                if (TYPE(vp)->hasInstanceVars) {
                    /* The prototype properties have been inherited */
                    assert(ejsIsPot(ejs, vp));
                    slotNum = ejsCheckSlot(ejs, vp, slotNum);
                    pot = (EjsPot*) vp;
                    pot->properties->slots[slotNum].trait = ((EjsPot*) lookup.obj)->properties->slots[slotNum].trait;
                    pot->properties->slots[slotNum].value = ((EjsPot*) lookup.obj)->properties->slots[slotNum].value;
                    slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
                } else  {
                    slotNum = -1;
                }
            } else {
                /*
                    This is the fundamental asymetry between load/store. We allow loading properties from static base 
                    types, but do not allow stores. This is essential to stop bleeding of Object static properties into
                    all objects. E.g. Object.create.
                 */
                slotNum = -1;
            }
        }
    }
    if (slotNum < 0) {
        slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
    }
    if (!ejs->exception) {
        storePropertyToSlot(ejs, thisObj, vp, slotNum, value);
    }
}


/*
    Store a property by name in the scope chain. Will create properties if the given name does not already exist.
 */
static void storePropertyToScope(Ejs *ejs, EjsName qname, EjsObj *value)
{
    EjsFrame        *fp;
    EjsObj          *vp, *thisObj;
    EjsPot          *obj;
    EjsLookup       lookup;
    EjsTrait        *trait;
    int             slotNum;

    fp = ejs->state->fp;

    if ((slotNum = ejsLookupScope(ejs, qname, &lookup)) >= 0) {
        if (ejsIsPrototype(ejs, lookup.obj)) {
            thisObj = vp = (EjsObj*) fp->function.boundThis;
            trait = ejsGetPropertyTraits(ejs, lookup.obj, slotNum);
            if (trait->attributes & EJS_TRAIT_SETTER) {
                vp = lookup.obj;

            } else if (TYPE(vp)->hasInstanceVars && ejsIsPot(ejs, vp)) {
                /* The prototype properties have been inherited */
                assert(ejsIsPot(ejs, vp));
                slotNum = ejsCheckSlot(ejs, (EjsPot*) vp, slotNum);
                obj = (EjsPot*) vp;
                assert(slotNum < obj->numProp);
                assert(slotNum < ((EjsPot*) lookup.obj)->numProp);
                obj->properties->slots[slotNum].trait = ((EjsPot*) lookup.obj)->properties->slots[slotNum].trait;
                obj->properties->slots[slotNum].value = ((EjsPot*) lookup.obj)->properties->slots[slotNum].value;
                slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
            } else {
                slotNum = -1;
            }
        } else {
            thisObj = vp = lookup.obj;
        }
    } else {
        thisObj = vp = fp->function.moduleInitializer ? ejs->global : (EjsObj*) fp;
        slotNum = ejsSetPropertyName(ejs, vp, slotNum, qname);
    }
    storePropertyToSlot(ejs, thisObj, vp, slotNum, value);
}


/*
    Run the module initializer
 */
EjsObj *ejsRunInitializer(Ejs *ejs, EjsModule *mp)
{
    EjsModule   *dp;
    EjsAny      *result;
    int         next;
    
    if (mp->initialized || !mp->hasInitializer) {
        mp->initialized = 1;
        result = ESV(null);
    } else {
        mp->initialized = 1;
        if (mp->dependencies) {
            for (next = 0; (dp = mprGetNextItem(mp->dependencies, &next)) != 0;) {
                if (dp->hasInitializer && !dp->initialized) {
                    if (ejsRunInitializer(ejs, dp) == 0) {
                        return 0;
                    }
                }
            }
        }
        mprTrace(7, "Running initializer for module %@", mp->name);
        result = ejsRunFunction(ejs, mp->initializer, ejs->global, 0, NULL);
    }
    return result;
}


/*
    Run all initializers for all modules
 */
int ejsRun(Ejs *ejs)
{
    EjsModule   *mp;
    int         next;

    //  OPT - should not examine all modules just to run a script
    for (next = 0; (mp = mprGetNextItem(ejs->modules, &next)) != 0;) {
        if (!mp->initialized) {
            ejs->result = ejsRunInitializer(ejs, mp);
        }
        if (ejsCompareAsc(ejs, mp->name, EJS_DEFAULT_MODULE) == 0) {
            ejsRemoveModule(ejs, mp);
            next--;
        }
        if (ejs->exception) {
            return EJS_ERR;
        }
    }
    return 0;
}


EjsAny *ejsRunFunction(Ejs *ejs, EjsFunction *fun, EjsAny *thisObj, int argc, void *argv)
{
    int     i;
    
    assert(ejs);
    assert(fun);
    assert(ejsIsFunction(ejs, fun));
    if (ejs->exception) {
        mprTrace(0, "STOP");
    }
    assert(ejs->exception == 0);

    if (ejs->exception) {
        return 0;
    }
    ejsClearAttention(ejs);
    
    if (thisObj == 0) {
        thisObj = fun->boundThis ? fun->boundThis : ejs->global;
    }
    if (ejsIsNativeFunction(ejs, fun)) {
        if (fun->body.proc == 0) {
            ejsThrowArgError(ejs, "Native function is not defined");
            return 0;
        }
        /* Push args so they get marked */
        for (i = 0; i < argc; i++) {
            pushOutside(ejs, ((EjsAny**) argv)[i]);
        }
        ejs->result = (fun->body.proc)(ejs, thisObj, argc, argv);
        ejs->state->stack -= argc;
        if (ejs->result == 0) {
            ejs->result = ESV(null);
        }

    } else {
        for (i = 0; i < argc; i++) {
            pushOutside(ejs, ((EjsAny**) argv)[i]);
        }
        VM(ejs, fun, thisObj, argc, 0);
        ejs->state->stack -= argc;
        if (ejs->exiting || mprIsStopping()) {
            ejsAttention(ejs);
        }
    }
    return (ejs->exception) ? 0 : ejs->result;
}


EjsAny *ejsRunFunctionBySlot(Ejs *ejs, EjsAny *thisObj, int slotNum, int argc, void *argv)
{
    EjsFunction     *fun;

    if (thisObj == 0) {
        thisObj = ejs->global;
    }
    if (thisObj == ejs->global) {
        fun = ejsGetProperty(ejs, thisObj, slotNum);
    } else if (ejsIsType(ejs, thisObj)) {
        fun = ejsGetProperty(ejs, thisObj, slotNum);
    } else {
        fun = ejsGetProperty(ejs, TYPE(thisObj)->prototype, slotNum);
    }
    if (fun == 0) {
        ejsThrowReferenceError(ejs, "Cannot find function at slot %d in %N", slotNum, &TYPE(thisObj)->qname);
        return 0;
    }
    return ejsRunFunction(ejs, fun, thisObj, argc, argv);
}


//  TODO - this is inconsistent with ejsRunBySlot. This has a separate container and thisObj, whereas RunBySlot
//  has only one arg

EjsAny *ejsRunFunctionByName(Ejs *ejs, EjsAny *container, EjsName qname, EjsAny *thisObj, int argc, void *argv)
{
    EjsFunction     *fun;
    EjsLookup       lookup;

    if (thisObj == 0) {
        thisObj = ejs->global;
    }
    if (container) {
        if ((fun = ejsGetPropertyByName(ejs, container, qname)) == 0) {
            ejsThrowReferenceError(ejs, "Cannot find function %N", qname);
            return 0;
        }
    } else {
        if (ejsLookupScope(ejs, qname, &lookup) == 0) {
            ejsThrowReferenceError(ejs, "Cannot find function %N", qname);
            return 0;
        }
        fun = ejsGetProperty(ejs, lookup.obj, lookup.slotNum);
    }
    return ejsRunFunction(ejs, fun, thisObj, argc, argv);
}



static void badArgType(Ejs *ejs, EjsFunction *fun, EjsPot *activation, EjsTrait *trait, int index)
{
    EjsName     qname;

    qname = ejsGetPropertyName(ejs, activation, index);
    ejsThrowTypeError(ejs, "Unacceptable null or undefined value for argument \"%@\" in function \"%@\"", qname.name, fun->name);
}


/*
    Validate the args. This routine handles ...rest args and parameter type checking and casts. Returns the new argc 
    or < 0 on errors.
 */
static int validateArgs(Ejs *ejs, EjsFunction *fun, int argc, void *args)
{
    EjsType     *type;
    EjsTrait    *trait;
    EjsArray    *rest;
    EjsPot      *activation;
    EjsObj      *newArg, **argv;
    int         nonDefault, i, limit, numRest;

    assert(ejs->exception == 0);
    assert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);

    argv = (EjsObj**) args;
    activation = fun->activation;
    nonDefault = fun->numArgs - fun->numDefault - fun->rest;

    if (argc < nonDefault) {
        if (!fun->rest || argc != (fun->numArgs - 1)) {
            if (fun->strict || (ejsIsNativeFunction(ejs, fun) && !fun->allowMissingArgs)) {
                ejsThrowArgError(ejs, "Insufficient actual parameters %d. Call requires %d parameter(s).", argc, nonDefault);
                return EJS_ERR;
            } else {
                /* Create undefined values for missing args for script functions */
                for (i = argc; i < nonDefault; i++) {
                    pushOutside(ejs, ESV(undefined));
                }
                argc = nonDefault;
            }
        }
    }
    if ((uint) argc > fun->numArgs && !fun->rest) {
        /*
            Discard excess arguments for scripted functions. No need to discard for native procs. This allows
            ejsDefineGlobalFunction to not have to bother with specifying the number of args for native procs.
         */
        if (!ejsIsNativeFunction(ejs, fun)) {
            ejs->state->stack -=  (argc - fun->numArgs);
            argc = fun->numArgs;
        }
    }

    /*
        Handle rest "..." args
     */
    if (fun->rest && (argc > nonDefault || fun->numDefault == 0)) {
        numRest = argc - fun->numArgs + 1;
        rest = ejsCreateArray(ejs, numRest);
        if (rest == 0) {
            return EJS_ERR;
        }
        for (i = numRest - 1; i >= 0; i--) {
            ejsSetProperty(ejs, rest, i, popOutside(ejs));
        }
        argc = argc - numRest + 1;
        pushOutside(ejs, rest);
        assert((void*) rest == argv[argc-1]);
    }

    /*
        Cast args to the right types
     */
    limit = min((uint) argc, fun->numArgs);
    for (i = 0; i < limit; i++) {
        if ((trait = ejsGetPropertyTraits(ejs, activation, i)) == 0 || trait->type == 0) {
            /* No trait - all to pass */
            continue;
        }
        type = trait->type;
        if (!ejsIsA(ejs, argv[i], type)) {
            if ((argv[i] == ESV(null) || argv[i] == ESV(undefined))) {
                if (trait->attributes & EJS_TRAIT_THROW_NULLS) {
                    badArgType(ejs, fun, activation, trait, i);
                    return EJS_ERR;
                }
                if (!(trait->attributes & EJS_TRAIT_CAST_NULLS)) {
                    continue;
                }
            }
            newArg = ejsCastType(ejs, argv[i], trait->type);
            if (ejs->exception) {
                ejsClearException(ejs);
                badArgType(ejs, fun, activation, trait, i);
                return EJS_ERR;
            }
            argv[i] = newArg;
        }
    }
    return argc;
}


static void callInterfaceInitializers(Ejs *ejs, EjsType *type)
{
    EjsType         *iface;
    EjsFunction     *fun;
    EjsName         qname;
    int             next;

    for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
        if (iface->hasInitializer) {
            qname = ejsGetPropertyName(ejs, iface, 0);
            //  TODO OPT. Could run all 
            fun = ejsGetPropertyByName(ejs, type, qname);
            if (fun && ejsIsFunction(ejs, fun)) {
                callFunction(ejs, fun, type, 0, 0);
            }
        }
    }
}


/*
    Push a block. Used by compiler.
 */
EjsBlock *ejsPushBlock(Ejs *ejs, EjsBlock *original)
{
    EjsBlock    *block;

    assert(!ejsIsFunction(ejs, original));

    block = ejsCloneBlock(ejs, original, 0);
    block->scope = ejs->state->bp;
    block->prev = ejs->state->bp;
    block->stackBase = ejs->state->stack;
    ejs->state->bp = block;
    return block;
}


/*
    Pop a block frame and return to the previous frame.  This pops functions and/or lexical blocks.
 */
EjsBlock *ejsPopBlock(Ejs *ejs)
{
    EjsBlock    *bp;

    bp = ejs->state->bp;
    ejs->state->stack = bp->stackBase;
    return ejs->state->bp = bp->prev;
}


/*
    Pop an exception block
 */
static EjsBlock *popExceptionBlock(Ejs *ejs)
{
    EjsBlock     *prev;

    if ((prev = ejs->state->bp->prev) != 0) {
        if (ejs->exception == 0) {
            ejs->exception = prev->prevException;
            prev->prevException = 0;
            if (ejs->exception) {
                /* Advance by one as checkExceptionHandlers expects the PC to be advanced after parsing the opcode */
                ejs->state->fp->pc++;
                ejsAttention(ejs);
            }
        }
    }
    ejs->state->bp = prev;
    return prev;
}


/*
    Manage exceptions. Bubble up the exception until we find an exception handler for it.
 */
static bool processException(Ejs *ejs)
{
    EjsState        *state;

    state = ejs->state;

    /*
        Check at each function level for a handler to process the exception.
     */
    while (state->fp) {
        checkExceptionHandlers(ejs);
        if (ejs->exception == 0) {
            return 1;
        }
        state->stack = state->fp->stackReturn;
        state->bp = state->fp->function.block.prev;
        state->fp = state->fp->caller;
        ejsClearAttention(ejs);
    }
    return 0;
}


static EjsEx *findExceptionHandler(Ejs *ejs, int kind)
{
    EjsEx       *ex;
    EjsFrame    *fp;
    EjsCode     *code;
    uint        pc;
    int         i;

    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);

    /*
        Exception handlers are sorted with the inner most handlers first.
     */
    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        if (ex->tryStart <= pc && pc < ex->handlerEnd && (ex->flags & kind)) {
            if (ejsIsType(ejs, ejs->exception) && ((EjsType*) ejs->exception)->sid == S_StopIteration) {
                return ex;
            }
            assert(ex->catchType);
            if (kind == EJS_EX_FINALLY || ex->catchType->sid == S_Void) {
                return ex;
            }
            if (ejsIsA(ejs, ejs->exception, ex->catchType)) {
                return ex;
            }
        }
    }
    return 0;
}


static EjsEx *inHandler(Ejs *ejs, int kind)
{
    EjsEx       *ex;
    EjsFrame    *fp;
    EjsCode     *code;
    uint        pc;
    int         i;
    
    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);
    
    /*
        Exception handlers are sorted with the inner most handlers first.
     */
    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        if (ex->handlerStart <= pc && pc < ex->handlerEnd && (ex->flags & kind)) {
            return ex;
        }
    }
    return 0;
}


/*
    Find the end of the last catch/finally handler.
 */
static uint findEndException(Ejs *ejs)
{
    EjsFrame    *fp;
    EjsEx       *ex;
    EjsCode     *code;
    uint        offset, pc;
    int         i;

    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);
    offset = 0;

    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        /*
            Comparison must include try and all catch handlers, incase there are multiple catch handlers
         */
        if (ex->tryStart <= pc && pc < ex->handlerEnd) {
            offset = ex->handlerEnd;
            for (++i; i < code->numHandlers; i++) {
                /* Find the last handler of this try block. Use tryEnd as nested try blocks can start at the same location */
                if (ex->tryEnd == code->handlers[i]->tryEnd) {
                    offset = code->handlers[i]->handlerEnd;
                }
            }
        }
    }
    assert(offset);
    return offset;
}


/*
    Search for an exception handler at this level to process the exception. Return true if the exception is handled.
 */
static void checkExceptionHandlers(Ejs *ejs)
{
    EjsFrame        *fp;
    EjsCode         *code;
    EjsEx           *ex;

    ex = 0;
    fp = ejs->state->fp;
    code = fp->function.body.code;

    if (code->numHandlers == 0) {
        return;
    }
rescan:
    if (!fp->function.inException || (ejs->exception == EST(StopIteration))) {
        /*
            Normal exception in a try block. NOTE: the catch will jump or fall through to the finally block code.
            ie. We won't come here again for the finally code unless there is an exception in the catch block.
            Otherwise, No catch handler at this level and need to bubble up.
         */
        if ((ex = findExceptionHandler(ejs, EJS_EX_CATCH)) != 0) {
            createExceptionBlock(ejs, ex, ex->flags);
            return;
        }

    } else {
        /*
            Exception in a catch or finally block. If in a catch block, must first run the finally
            block before bubbling up. If in a finally block, we are done and upper levels will handle. We can be
            in a finally block and inException == 0. This happens because try blocks jump through directly
            into finally blocks (fast). But we need to check here if we are in the finally block explicitly.
         */
        if ((ex = inHandler(ejs, EJS_EX_FINALLY)) != 0) {
            /*
                If in a finally block, must advance the outer blocks's pc to be outside [tryStart .. finallyStart]
                This prevents this try block from handling this exception again.
             */
            SET_PC(fp, &fp->function.body.code->byteCode[ex->handlerEnd + 1]);
            fp->function.inCatch = fp->function.inException = 0;
            goto rescan;            
        }
    }

    /*
        Exception without a catch block or exception in a catch block. 
     */
    if ((ex = findExceptionHandler(ejs, EJS_EX_FINALLY)) != 0) {
        if (fp->function.inCatch) {
            popExceptionBlock(ejs);
        }
        createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
    } else {
        fp->function.inCatch = fp->function.inException = 0;
    }
    ejsClearAttention(ejs);
}


/*
    Called for catch and finally blocks
 */
static void createExceptionBlock(Ejs *ejs, EjsEx *ex, int flags)
{
    EjsBlock        *block;
    EjsFrame        *fp;
    EjsState        *state;
    int             i, count;

    state = ejs->state;
    fp = state->fp;
    assert(ex);

    ejsClearAttention(ejs);

    if (flags & EJS_EX_ITERATION) {
        /*
            Empty handler is a special case for iteration. We simply do a break to the handler location
            which targets the end of the for/in loop.
         */
        SET_PC(fp, &fp->function.body.code->byteCode[ex->handlerStart]);
        ejs->exception = 0;
        return;
    }

    /*
        Discard all try lexical blocks when running a catch block
     */
    if (flags & EJS_EX_CATCH) {
        for (count = 0, block = state->bp; block != (EjsBlock*) state->fp; block = block->prev) {
            count++;
        }
        count -= ex->numBlocks;
        assert(count >= 0);
        for (i = 0; i < count && count > 0; i++) {
            ejsPopBlock(ejs);
        }
        count = (int) (state->stack - fp->stackBase);
        state->stack -= (count - ex->numStack);
        assert(state->stack >= fp->stackReturn);
    }
    
    /*
        Allocate a new frame in which to execute the handler
     */
    if ((block = ejsCreateBlock(ejs, 0)) == 0) {
        /*  Exception will continue to bubble up */
        return;
    }
    block->prev = block->scope = state->bp;
    block->stackBase = state->stack;
    state->bp = block;

    /*
        Move the PC outside of the try region. If this is a catch block, this allows the finally block to still
        be found. But if this is processing a finally block, the scanning for a matching handler will be forced
        to bubble up.
     */
    SET_PC(fp, &fp->function.body.code->byteCode[ex->handlerStart]);

    if (flags & EJS_EX_CATCH) {
        ejs->exceptionArg = ejs->exception;
        fp->function.inCatch = 1;

    } else {
        /*
            Mask the exception while processing the finally block
         */
        block->prev->prevException = ejs->exception;
        fp->function.inCatch = 0;
        ejsAttention(ejs);
    }
    ejs->exception = 0;
    fp->function.inException = 1;
}


typedef struct OperMap {
    int         opcode;
    cchar       *name;
} OperMap;

static OperMap operMap[] = {
        { EJS_OP_MUL,           "*"     },
        { EJS_OP_DIV,           "/"     },
        { EJS_OP_REM,           "%"     },
        { EJS_OP_COMPARE_LT,    "<"     },
        { EJS_OP_COMPARE_GT,    ">"     },
        { EJS_OP_COMPARE_LE,    "<="    },
        { EJS_OP_COMPARE_GE,    ">="    },
        { 0,                    0       },
};


static int lookupOverloadedOperator(Ejs *ejs, EjsOpCode opcode, EjsAny *lhs)
{
    EjsName     qname;
    int         i;

    for (i = 0; operMap[i].opcode; i++) {
        if (operMap[i].opcode == opcode) {
            qname = ejsName(ejs, "", operMap[i].name);
            break;
        }
    }
    return ejsLookupProperty(ejs, TYPE(lhs), qname);
}


/*
    Evaluate a binary expression.
    OPT -- simplify and move back inline into eval loop.
 */
static EjsAny *evalBinaryExpr(Ejs *ejs, EjsAny *lhs, EjsOpCode opcode, EjsAny *rhs)
{
    EjsAny      *result;
    int         slotNum;

    if (lhs == 0) {
        lhs = ESV(undefined);
    }
    if (rhs == 0) {
        rhs = ESV(undefined);
    }
    result = ejsInvokeOperator(ejs, lhs, opcode, rhs);

    if (result == 0 && ejs->exception == 0) {
        slotNum = lookupOverloadedOperator(ejs, opcode, lhs);
        if (slotNum >= 0) {
            result = ejsRunFunctionBySlot(ejs, lhs, slotNum, 1, &rhs);
        }
    }
    return result;
}


#if FUTURE
/*
    Grow the operand evaluation stack.
    Return a negative error code on memory allocation errors or if the stack grows too big.
 */
int ejsGrowStack(Ejs *ejs, int incr)
{
    EjsStack    *sp;
    EjsFrame    *frame;
    EjsObj      **bottom;
    int         i, size, moveBy;

    sp = ejs->stack;
    sp->ejs = ejs;

    incr = max(incr, EJS_STACK_INC);

    if (sp->bottom) {
        /*
            Grow an existing stack
         */
        size = sp->size + (sizeof(EjsObj*) * incr);
        bottom = (EjsObj**) mprRealloc(sp, sp->bottom, size);
        //  OPT - don't zeroed?
        memset(&bottom[sp->size], 0, (size - sp->size) * sizeof(EjsObj*));
        moveBy = (int) ((char*) bottom - (char*) sp->bottom);
        sp->top = (EjsObj**) ((char*) sp->top + moveBy);
        sp->bottom = bottom;

        /*
            Adjust all the argv pointers.
         */
        for (frame = ejs->frame; frame; frame = frame->prev) {
            if (frame->argv) {
                frame->argv = (EjsObj**) ((char*) frame->argv + moveBy);
            }
            frame->prevStackTop = (EjsObj**) ((char*) frame->prevStackTop + moveBy);
        }

    } else {
        /*
            Allocate a stack
         */
        if (sp->top >= &sp->bottom[ME_MAX_EJS_STACK]) {
            return MPR_ERR_MEMORY;
        }
        size = (sizeof(EjsObj*) * incr);
        sp->bottom = (EjsObj**) mprAlloc(size);
        /*
            Push always begins with an increment of sp->top. Initially, sp_bottom points to the first (future) element.
         */
        sp->top = &sp->bottom[-1];
    }

    if (sp->bottom == 0) {
        return MPR_ERR_MEMORY;
    }

    sp->end = &sp->bottom[size / sizeof(EjsObj*)];
    sp->size = size;

    for (i = 1; i <= incr; i++) {
        sp->top[i] = 0;
    }
    return 0;
}
#endif


/*
    Exit the script
 */
void ejsExit(Ejs *ejs, int status)
{
    ejs->exiting = 1;
    mprSignalDispatcher(ejs->dispatcher);
}


static EjsName getNameArg(Ejs *ejs, EjsFrame *fp)
{
    EjsName     qname;

    qname.name = getStringArg(ejs, fp);
    qname.space = getStringArg(ejs, fp);
    return qname;
}


static EjsString *getString(Ejs *ejs, EjsFrame *fp, int num)
{
    return ejsCreateStringFromConst(ejs, fp->function.body.code->module, num);
}


static EjsString *getStringArg(Ejs *ejs, EjsFrame *fp)
{
    return getString(ejs, fp, (int) ejsDecodeNum(ejs, &fp->pc));
}


static EjsObj *getGlobalArg(Ejs *ejs, EjsFrame *fp)
{
    EjsObj      *obj;
    EjsName     qname;
    int         t, slotNum;

    t = (int) ejsDecodeNum(ejs, &fp->pc);
    if (t < 0) {
        return 0;
    }
    slotNum = -1;
    qname.name = 0;
    qname.space = 0;
    obj = 0;

    /*
        OPT. Could this encoding be optimized?
     */
    switch (t & EJS_ENCODE_GLOBAL_MASK) {
    default:
        assert(0);
        return 0;

    case EJS_ENCODE_GLOBAL_NOREF:
        return 0;

    case EJS_ENCODE_GLOBAL_SLOT:
        slotNum = t >> 2;
        if (0 <= slotNum && slotNum < ejsGetLength(ejs, ejs->global)) {
            obj = ejsGetProperty(ejs, ejs->global, slotNum);
        }
        break;

    case EJS_ENCODE_GLOBAL_NAME:
        qname.name = getString(ejs, fp, t >> 2);
        if (qname.name == 0) {
            assert(0);
            return 0;
        }
        qname.space = getStringArg(ejs, fp);
        if (qname.space == 0) {
            return 0;
        }
        if (qname.name) {
            obj = ejsGetPropertyByName(ejs, ejs->global, qname);
        }
        break;
    }
    return obj;
}


static void callProperty(Ejs *ejs, EjsAny *obj, int slotNum, EjsAny *thisObj, int argc, int stackAdjust)
{
    EjsTrait    *trait;
    EjsFunction *fun;

    fun = ejsGetProperty(ejs, obj, slotNum);
    trait = ejsGetPropertyTraits(ejs, obj, slotNum);
    if (trait && trait->attributes & EJS_TRAIT_GETTER) {
        fun = (EjsFunction*) ejsRunFunction(ejs, fun, thisObj, 0, NULL);
        if (ejs->exception) {
            return;
        }
    }
    callFunction(ejs, fun, thisObj, argc, stackAdjust);
}


/*
    Call a function. Supports both native and scripted functions. If native, the function is fully 
    invoked here. If scripted, a new frame is created and the pc adjusted to point to the new function.
 */
static void callFunction(Ejs *ejs, EjsFunction *fun, EjsAny *thisObj, int argc, int stackAdjust)
{
    EjsState        *state;
    EjsFrame        *fp;
    EjsType         *type;
    EjsObj          **argv;
    EjsObj          **sp;
    int             count, i, fstate;

    assert(fun);
    assert(ejs->exception == 0);
    assert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);  

    state = ejs->state;

    if (unlikely(ejsIsType(ejs, fun))) {
        type = (EjsType*) fun;
        if (thisObj == NULL) {
            thisObj = ejsCreateObj(ejs, type, 0);
        }
        ejs->result = thisObj;
        if (!type->hasConstructor) {
            ejs->state->stack -= (argc + stackAdjust);
            if (ejs->exiting || mprIsStopping()) {
                ejsAttention(ejs);
            }
            return;
        }
        
    } else if (!ejsIsFunction(ejs, fun)) {
        if (fun == ESV(undefined)) {
            ejsThrowReferenceError(ejs, "Function is undefined");
            return;
        } else {
            ejsThrowReferenceError(ejs, "Reference is not a function");
            return;
        }
    }
    if (thisObj == 0) {
        if ((thisObj = fun->boundThis) == 0) {
            thisObj = state->fp->function.boundThis;
        } 
    } 
    if (fun->boundArgs) {
        assert(ejsIs(ejs, fun->boundArgs, Array));
        count = fun->boundArgs->length;
        sp = &state->stack[1 - argc];
        for (i = argc - 1; i >= 0; i--) {
            sp[i + count] = sp[i];
        }
        for (i = 0; i < count; i++) {
            *sp++ = fun->boundArgs->data[i];
        }
        state->stack += count;
        argc += count;
    }
    
    assert(ejs->spreadArgs == 0);
    argc += ejs->spreadArgs;
    ejs->spreadArgs = 0;
    
    /*
        Validate the args. Cast to the right type, handle rest args and return with argc adjusted.
     */
    argv = NULL;
    if (argc > 0 || fun->numArgs || fun->rest) {
        argv = &(state->stack[1 - argc]);
        if ((argc = validateArgs(ejs, fun, argc, argv)) < 0) {
            return;
        }
    }
    if (ejs->exception) {
        return;
    }
    if (ejsIsNativeFunction(ejs, fun)) {
        if (fun->body.proc == 0) {
            ejsThrowInternalError(ejs, "Native function is not defined: %@", fun->name);
            return;
        }
        ejsClearAttention(ejs);
        fstate = state->paused;
        ejs->result = (fun->body.proc)(ejs, thisObj, argc, argv);
        state->paused = fstate;
        if (ejs->result == 0) {
            ejs->result = ESV(null);
        }
        state->stack -= (argc + stackAdjust);

    } else {
        if (fun->body.code && fun->body.code->debug) {
            assert(fun->body.code->debug->magic == EJS_DEBUG_MAGIC);
        }
        assert(thisObj);
        if ((fp = ejsCreateFrame(ejs, fun, thisObj, argc, argv)) == 0) {
            return;
        }
        fp->function.block.prev = state->bp;
        fp->caller = state->fp;
        fp->stackBase = state->stack;
        fp->stackReturn = state->stack - argc - stackAdjust;
        state->fp = fp;
        state->bp = (EjsBlock*) fp;
        ejsClearAttention(ejs);
    }
    assert(ejs->state->fp);
}


static void throwNull(Ejs *ejs)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
}


/*
    Object can be an instance or a type. If an instance, then step to the immediate base type to begin the count.
 */
static EjsAny *getNthBase(Ejs *ejs, EjsAny *vp, int nthBase)
{
    EjsType     *type;

    if (vp) {
        if (ejsIsType(ejs, vp) || vp == ejs->global) {
            type = (EjsType*) vp;
        } else {
            type = TYPE(vp);
            nthBase--;
        }
        for (; type && nthBase > 0; type = type->baseType) {
            nthBase--;
        }
        if (nthBase > 0) {
            ejsThrowReferenceError(ejs, "Cannot find correct base class");
            return 0;
        }
        vp = type;
    }
    return vp;
}


static EjsAny *getNthBaseFromBottom(Ejs *ejs, EjsAny *vp, int nthBase)
{
    EjsType     *type, *tp;
    int         count;

    if (vp) {
        if (ejsIsType(ejs, vp) || vp == ejs->global) {
            type = (EjsType*) vp;
        } else {
            type = TYPE(vp);
        }
        for (count = 0, tp = type->baseType; tp; tp = tp->baseType) {
            count++;
        }
        nthBase = count - nthBase;
        for (; type && nthBase > 0; type = type->baseType) {
            nthBase--;
        }
        vp = type;
    }
    return vp;
}


static EjsAny *getNthBlock(Ejs *ejs, int nth)
{
    EjsBlock    *block;

    assert(ejs);
    assert(nth >= 0);

    for (block = ejs->state->bp; block && --nth >= 0; ) {
        /* TODO - this is done for loading scripts into ejs. Really the compiler should remove these blocks */
        block = block->scope;
    }
    return block;
}


/*
    Enter a mesage into the log file
 */
void ejsLog(Ejs *ejs, cchar *fmt, ...)
{
    va_list     args;
    char        buf[ME_MAX_BUFFER];

    va_start(args, fmt);
    fmtv(buf, sizeof(buf) - 1, fmt, args);
    va_end(args);
    mprLog(0, "%s", buf);
}


#if FUTURE
#if ME_COMPILER_HAS_LIB_EDIT
static History  *cmdHistory;
static EditLine *eh; 
static cchar    *prompt;

static cchar *issuePrompt(EditLine *e) {
    return prompt;
}

static EditLine *initEditLine()
{
    EditLine    *e;
    HistEvent   ev; 

    cmdHistory = history_init(); 
    history(cmdHistory, &ev, H_SETSIZE, 100); 
    e = el_init("ejs", stdin, stdout, stderr); 
    el_set(e, EL_EDITOR, "vi");
    el_set(e, EL_HIST, history, cmdHistory);
    el_source(e, NULL);
    return e;
}


/*  
    Prompt for input with the level of current nest (block nest depth)
 */
static char *readline(cchar *msg) 
{ 
    HistEvent   ev; 
    cchar       *str; 
    char        *result;
    int         len, count; 
 
    if (eh == NULL) { 
        eh = initEditLine();
    }
    prompt = msg;
    el_set(eh, EL_PROMPT, issuePrompt);
    str = el_gets(eh, &count); 
    if (str && count > 0) { 
        result = strdup(str); 
        len = strlen(result);
        if (result[len - 1] == '\n') {
            result[len - 1] = '\0'; 
        }
        count = history(cmdHistory, &ev, H_ENTER, result); 
        return result; 
    }  
    return NULL; 
} 

#else

static char *readline(cchar *msg)
{
    char    buf[MPR_MAX_STRING];

    printf("%s", msg);
    if (fgets(buf, sizeof(buf) - 1, stdin) == 0) {
        return NULL;
    }
    return strdup(buf);
}
#endif


typedef struct EjsBreakpoint {
    cchar   *filename;
    int     lineNumber;
    int     opcode;    
} EjsBreakpoint;


static void bkpt(Ejs *ejs)
{
    EjsFrame        *fp;
    EjsState        *state;
    EjsBreakpoints  *breakpoints;
    EjsOptable      *optable;
    int             len;
    uint            offset;
    static int      once = 0;
    static int      stop = 1;

    state = ejs->state;
    fp = state->fp;
    opcount[opcode]++;

    breakpoints = ejs->breakpoints;

    offset = (uint) (fp->pc - fp->function.body.code.byteCode) - 1;
    if (offset < 0) {
        offset = 0;
    }
    str = readline("edb> ");

    Display source with current line highlighted

    optable = ejsGetOptable();
    if (mprGetLogLevel(ejs) > 7) {
        mprPrintf(ejs, "%0s %04d: [%d] %02x: %-35s # %s:%d %@",
            mprGetCurrentThreadName(fp), offset, (int) (state->stack - fp->stackReturn),
            (uchar) opcode, optable[opcode].name, fp->filename, fp->lineNumber, fp->currentLine);
    if (stop && once++ == 0) {
        mprNap(0);
    }
    assert(state->stack >= fp->stackReturn);
}
#endif


#if DEBUG_IDE
/*
    This code is only active when building in debug mode and debugging in an IDE
 */
static int ejsOpCount = 0;
static int doDebug = 1;

static EjsOpCode traceCode(Ejs *ejs, EjsOpCode opcode)
{
    EjsFrame        *fp;
    EjsState        *state;
    int             offset;
#if FUTURE
    EjsOptable      *optable;
    static int      showFrequency = 1;
#endif

    state = ejs->state;
    fp = state->fp;
    opcount[opcode]++;
    // assert(ejs->exception || (state->stack >= fp->stackReturn));

    if (1 || (ejs->initialized && doDebug)) {
        offset = (int) (fp->pc - fp->function.body.code->byteCode) - 1;
        if (offset < 0) {
            offset = 0;
        }
        fp->line = ejsGetDebugLine(ejs, (EjsFunction*) fp, fp->pc);
#if FUTURE
        optable = ejsGetOptable();
        if (showFrequency && ((once % 1000) == 999)) {
            ejsShowOpFrequency(ejs);
        }
#endif
        // assert(ejs->exception || (state->stack >= fp->stackReturn));
    }
    ejsOpCount++;
    return opcode;
}


#if FUTURE
void ejsShowOpFrequency(Ejs *ejs)
{
    EjsOptable      *optable;
    int             i;

    if (mprGetLogLevel(ejs) < 6) {
        return;
    }
    optable = ejsGetOptable();
    mprTrace(0, "Opcode Frequency");
    for (i = 0; i < 256 && optable[i].name; i++) {
        mprTrace(6, "%4d %24s %8d", (uchar) i, optable[i].name, opcount[i]);
    }
}
#endif

#endif /* ME_DEBUG */


/*
    Cleanup defines for combo builds
 */
#undef top
#undef pop
#undef push
#undef popString
#undef popOutside
#undef pushOutside
#undef FRAME
#undef FUNCTION
#undef BLOCK
#undef SWAP
#undef GET_SLOT
#undef SET_SLOT
#undef GET_BYTE
#undef GET_DOUBLE
#undef GET_INT
#undef GET_NUM
#undef GET_NAME
#undef GET_STRING
#undef GET_TYPE
#undef GET_WORD
#undef THIS
#undef FILL
#undef CASE
#undef BREAK

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsLoader.c"
 */
/************************************************************************/

/**
    ejsLoader.c - Ejscript module file file loader

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/****************************** Forward Declarations **************************/

static int  addFixup(Ejs *ejs, EjsModule *mp, int kind, EjsObj *target, int slotNum, EjsTypeFixup *fixup);
static int  alreadyLoaded(Ejs *ejs, EjsString *name, int minVersion, int maxVersion);
static EjsLoadState *createLoadState(Ejs *ejs, int flags);
static EjsTypeFixup *createFixup(Ejs *ejs, EjsModule *mp, EjsName qname, int slotNum);
static int  fixupTypes(Ejs *ejs, MprList *list);
static EjsObj *getCurrentBlock(EjsModule *mp);
static int  getVersion(cchar *name);
static int  initializeModule(Ejs *ejs, EjsModule *mp);
static int  loadBlockSection(Ejs *ejs, EjsModule *mp);
static int  loadClassSection(Ejs *ejs, EjsModule *mp);
static int  loadDependencySection(Ejs *ejs, EjsModule *mp);
static int  loadDocSection(Ejs *ejs, EjsModule *mp);
static int  loadEndBlockSection(Ejs *ejs, EjsModule *mp);
static int  loadEndFunctionSection(Ejs *ejs, EjsModule *mp);
static int  loadEndClassSection(Ejs *ejs, EjsModule *mp);
static int  loadEndModuleSection(Ejs *ejs, EjsModule *mp);
static int  loadDebugSection(Ejs *ejs, EjsModule *mp);
static int  loadExceptionSection(Ejs *ejs, EjsModule *mp);
static int  loadFunctionSection(Ejs *ejs, EjsModule *mp);
static EjsModule *loadModuleSection(Ejs *ejs, MprFile *file, EjsModuleHdr *hdr, int *created, int flags);
static int  loadNativeLibrary(Ejs *ejs, EjsModule *mp, cchar *path);
static int  loadSections(Ejs *ejs, MprFile *file, cchar *path, EjsModuleHdr *hdr, int flags);
static int  loadPropertySection(Ejs *ejs, EjsModule *mp, int sectionType);
static int  loadScriptModule(Ejs *ejs, cchar *filename, int minVersion, int maxVersion, int flags);
static char *makeModuleName(cchar *name);
static void popScope(EjsModule *mp, int keepScope);
static void pushScope(EjsModule *mp, EjsAny *block, EjsAny *obj);
static char *search(Ejs *ejs, cchar *filename, int minVersion, int maxVersion);
static int  trimModule(Ejs *ejs, char *name);
static void setDoc(Ejs *ejs, EjsModule *mp, cchar *tag, void *vp, int slotNum);

/******************************************************************************/
/**
    Load a module file and return a list of the loaded modules. This is used to load scripted module files with
    optional native (shared / DLL) implementations. If loading a scripted module that has native declarations, a
    search for the corresponding native DLL will be performed and both scripted and native module files will be loaded.
    NOTE: this may recursively call itself as it loads dependent modules.

    @param ejs Ejs handle
    @param path Module name or path to load. May be "." separated path. May include or omit the ".mod" extension.
    @param minVersion Minimum acceptable version (inclusive). Set to zero for unversioned.
    @param maxVersion Maximum acceptable version (inclusive). Set to -1 for all versions.
    @param flags Reserved. Must be set to zero.
    @param modulesArg List of modules loaded. Will only return a list if successful and doing a top level load. 
        When ejsLoadModule is called to load dependant modules, not list of modules will be returned.
        The final list of modules aggregates all modules loaded including those from dependant modules.
    @return Returns the last loaded module.
 */
int ejsLoadModule(Ejs *ejs, EjsString *path, int minVersion, int maxVersion, int flags)
{
    char    *trimmedPath, *name;
    int     status, version;

    assert(path);

    /*
        Note the cannonical name for a module is the basename of the module without extension
     */
    trimmedPath = sclone(ejsToMulti(ejs, path));
    if ((version = trimModule(ejs, trimmedPath)) != 0) {
        minVersion = maxVersion = version;
    }
    name = mprGetPathBase(trimmedPath);

    if (flags & EJS_LOADER_RELOAD ||
            (status = alreadyLoaded(ejs, ejsCreateStringFromAsc(ejs, name), minVersion, maxVersion)) == 0) {
        status = loadScriptModule(ejs, trimmedPath, minVersion, maxVersion, flags);
    }
    return status;
}


static int initializeModule(Ejs *ejs, EjsModule *mp)
{
    EjsNativeModule     *nativeModule;
    int                 paused;

    if (mp->hasNative && !mp->configured) {
        /*
            See if a native module initialization routine has been registered. If so, use that. Otherwise, look
            for a backing shared library.
         */
        if ((nativeModule = ejsLookupNativeModule(ejs, ejsToMulti(ejs, mp->name))) == 0) {
            loadNativeLibrary(ejs, mp, mp->path);
            nativeModule = ejsLookupNativeModule(ejs, ejsToMulti(ejs, mp->name));
            if (nativeModule == NULL) {
                if (ejs->exception == 0) {
                    ejsThrowIOError(ejs, "Cannot load or initialize the native module %@ in file \"%s\"", 
                        mp->name, mp->path);
                }
                return MPR_ERR_CANT_INITIALIZE;
            }
            if (!(ejs->flags & EJS_FLAG_NO_INIT)) {
                if (nativeModule->checksum != mp->checksum) {
                    ejsThrowIOError(ejs, "Module \"%s\" XXX does not match native code (%d, %d)", mp->path, 
                        nativeModule->checksum, mp->checksum);
                    return MPR_ERR_BAD_STATE;
                }
            }
        }
        if (nativeModule && (nativeModule->callback)(ejs) < 0) {
            return MPR_ERR_CANT_INITIALIZE;
        }
        if (ejs->hasError || EST(Error) == 0 || mprHasMemError(ejs)) {
            if (!ejs->exception) {
                ejsThrowIOError(ejs, "Initialization error for %s (%d, %d)", mp->path, ejs->hasError, mprHasMemError(ejs));
            }
            return MPR_ERR_CANT_INITIALIZE;
        }
    }
    mp->configured = 1;
    paused = ejsBlockGC(ejs);
    if (ejsRunInitializer(ejs, mp) == 0) {
        ejsUnblockGC(ejs, paused);
        return MPR_ERR_CANT_INITIALIZE;
    }
    ejsUnblockGC(ejs, paused);
    return 0;
}


static char *search(Ejs *ejs, cchar *filename, int minVersion, int maxVersion) 
{
    char        *path;

    assert(filename && *filename);

    if ((path = ejsSearchForModule(ejs, filename, minVersion, maxVersion)) == 0) {
        mprTrace(2, "Cannot find module file \"%s\"", filename);
        if (minVersion <= 0 && maxVersion <= 0) {
            ejsThrowReferenceError(ejs,  "Cannot find module file \"%s\"", filename);
        } else if (minVersion == 0 && maxVersion == EJS_MAX_VERSION) {
            ejsThrowReferenceError(ejs,  "Cannot find module file \"%s\"", filename);
        } else {
            ejsThrowReferenceError(ejs,  "Cannot find module file \"%s\", min version %d.%d.%d, max version %d.%d.%d", 
                filename, 
                EJS_MAJOR(minVersion), EJS_MINOR(minVersion), EJS_PATCH(minVersion),
                EJS_MAJOR(maxVersion), EJS_MINOR(maxVersion), EJS_PATCH(maxVersion));
        }
        return 0;
    }
    return path;
}


/*
    Load the sections: modules, classes, properties and functions from a module file. May load muliple logical modules.
 */
static int loadSections(Ejs *ejs, MprFile *file, cchar *path, EjsModuleHdr *hdr, int flags)
{
    EjsModule   *mp;
    int         next, rc, sectionType, created, firstModule, status;

    created = 0;
    mp = 0;
    firstModule = mprGetListLength(ejs->modules);

    while ((sectionType = (int) mprGetFileChar(file)) >= 0) {
        if (sectionType < 0 || sectionType >= EJS_SECT_MAX) {
            mprError("Bad section type %d in %@", sectionType, mp->name);
            return MPR_ERR_CANT_LOAD;
        }
        mprTrace(9, "Load section type %d", sectionType);
        assert(mp == NULL || mp->scope == NULL || mp->scope != mp->scope->scope);

        rc = 0;
        switch (sectionType) {

        case EJS_SECT_BLOCK:
            rc = loadBlockSection(ejs, mp);
            break;

        case EJS_SECT_BLOCK_END:
            rc = loadEndBlockSection(ejs, mp);
            break;

        case EJS_SECT_CLASS:
            rc = loadClassSection(ejs, mp);
            break;

        case EJS_SECT_CLASS_END:
            rc = loadEndClassSection(ejs, mp);
            break;

        case EJS_SECT_DEBUG:
            rc = loadDebugSection(ejs, mp);
            break;

        case EJS_SECT_DEPENDENCY:
            rc = loadDependencySection(ejs, mp);
            mp->firstGlobal = ejsGetLength(ejs, ejs->global);
            break;

        case EJS_SECT_EXCEPTION:
            rc = loadExceptionSection(ejs, mp);
            break;

        case EJS_SECT_FUNCTION:
            rc = loadFunctionSection(ejs, mp);
            break;

        case EJS_SECT_FUNCTION_END:
            rc = loadEndFunctionSection(ejs, mp);
            break;

        case EJS_SECT_MODULE:
            if ((mp = loadModuleSection(ejs, file, hdr, &created, flags)) == 0) {
                return MPR_ERR_CANT_LOAD;
            }
            mp->mutex = mprCreateLock();
            lock(mp);
            ejsAddModule(ejs, mp);
            mp->path = sclone(path);
            mp->file = file;
            mp->firstGlobal = (ejs->initialized) ? ejsGetLength(ejs, ejs->global) : 0;
            break;

        case EJS_SECT_MODULE_END:
            rc = loadEndModuleSection(ejs, mp);
            mp->lastGlobal = ejsGetLength(ejs, ejs->global);
            unlock(mp);
            break;

        case EJS_SECT_PROPERTY:
            rc = loadPropertySection(ejs, mp, sectionType);
            break;

        case EJS_SECT_DOC:
            rc = loadDocSection(ejs, mp);
            break;

        default:
            return MPR_ERR_CANT_LOAD;
        }
        if (rc < 0) {
            if (mp && mp->name && created) {
                ejsRemoveModule(ejs, mp);
            }
            return rc;
        }
    }
    status = 0;
    for (next = firstModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
        if (mp->loadState) {
            if (fixupTypes(ejs, mp->loadState->typeFixups) < 0) {
                return MPR_ERR_CANT_LOAD;
            }
            mp->loadState = 0;
        }
        //  TODO rationalize down to just ejs flag
        if (!ejs->empty && !(flags & EJS_LOADER_NO_INIT) && !(ejs->flags & EJS_FLAG_NO_INIT)) {
            if (!mp->initialized) {
                if ((status = initializeModule(ejs, mp)) < 0) {
                    break;
                }
            }
        }
    }
    if (ejs->loaderCallback && !ejs->exception) {
        (ejs->loaderCallback)(ejs, EJS_SECT_END, ejs->modules, firstModule);
    }
    return status;
}


/*
    Load a module section and constant pool.
 */
static EjsModule *loadModuleSection(Ejs *ejs, MprFile *file, EjsModuleHdr *hdr, int *created, int flags)
{
    EjsModule       *mp, tmod;
    EjsString       *name;
    char            *pool;
    int             version, checksum, poolSize, poolCount, nameToken;

    assert(created);

    *created = 0;
    checksum = 0;

    /*
        We don't have the constant pool yet so we cant resolve the nameToken yet.
     */
    mp = &tmod;
    memset(&tmod, 0, sizeof(tmod));
    mp->file = file;
    nameToken = ejsModuleReadInt(ejs, mp);
    version   = ejsModuleReadInt(ejs, mp);
    checksum  = ejsModuleReadInt32(ejs, mp);
    poolSize  = ejsModuleReadInt(ejs, mp);
    poolCount = ejsModuleReadInt(ejs, mp);

    if (mp->hasError || poolSize <= 0 || poolSize > EJS_MAX_POOL) {
        return 0;
    }
    if (nameToken < 0 || nameToken >= poolSize) {
        assert(0);
        return 0;
    }
    if ((pool = mprAlloc(poolSize)) == 0) {
        return 0;
    }
    if (mprReadFile(file, pool, poolSize) != poolSize) {
        return 0;
    }
    if (ejsCreateConstants(ejs, mp, poolCount, poolSize, pool) < 0) {
        return 0;
    }
    name = ejsCreateStringFromConst(ejs, mp, nameToken);

    if ((mp = ejsCreateModule(ejs, name, version, mp->constants)) == NULL) {
        return 0;
    }
    mp->constants = tmod.constants;
    mp->current = mprCreateList(-1, 0);
    pushScope(mp, 0, ejs->global);
    mp->checksum = checksum;
    *created = 1;

    mp->file = file;
    mp->flags = flags;
    mp->loadState = createLoadState(ejs, flags);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_MODULE, mp);
    }
    mprTrace(9, "Load module section %@", name);
    return mp;
}


static int loadEndModuleSection(Ejs *ejs, EjsModule *mp)
{
    mprTrace(9, "End module section %@", mp->name);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_MODULE_END, mp);
    }
    assert(mprGetListLength(mp->current) == 1);
    mp->current = 0;
    mp->file = 0;
    return 0;
}


static int loadDependencySection(Ejs *ejs, EjsModule *mp)
{
    EjsModule   *module;
    EjsString   *name;
    void        *saveCallback;
    int         next, rc, minVersion, maxVersion, checksum, nextModule;

    assert(ejs);
    assert(mp);

    name = ejsModuleReadConst(ejs, mp);
    checksum  = ejsModuleReadInt(ejs, mp);
    minVersion = ejsModuleReadInt(ejs, mp);
    maxVersion = ejsModuleReadInt(ejs, mp);
    
    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    if (ejsLookupModule(ejs, name, minVersion, maxVersion) == 0) {
        saveCallback = ejs->loaderCallback;
        nextModule = mprGetListLength(ejs->modules);
        ejs->loaderCallback = NULL;

        mprTrace(6, "    Load dependency section %@", name);
        rc = loadScriptModule(ejs, ejsToMulti(ejs, name), minVersion, maxVersion, mp->flags | EJS_LOADER_DEP);
        ejs->loaderCallback = saveCallback;
        if (rc < 0) {
            return rc;
        }
        if (mp->dependencies == 0) {
            mp->dependencies = mprCreateList(-1, 0);
        }
        for (next = nextModule; (module = mprGetNextItem(ejs->modules, &next)) != 0; ) {
            mprAddItem(mp->dependencies, module);
            if (ejs->loaderCallback) {
                (ejs->loaderCallback)(ejs, EJS_SECT_DEPENDENCY, mp, module);
            }
        }
    }
    if ((module = ejsLookupModule(ejs, name, minVersion, maxVersion)) != 0) {
        if (checksum != module->checksum) {
            ejsThrowIOError(ejs, "Cannot load module \"%@\" due to checksum mismatch.\n"
                "The program was compiled depending on a different version of module \"%@\".", mp->name, name);
            return MPR_ERR_BAD_STATE;
        }
    }
    return 0;
}


static int loadBlockSection(Ejs *ejs, EjsModule *mp)
{
    EjsBlock    *bp;
    EjsObj      *current;
    EjsName     qname;
    int         slotNum, numSlot;

    qname.space = ejsCreateStringFromAsc(ejs, EJS_BLOCK_NAMESPACE);
    qname.name = ejsModuleReadConst(ejs, mp);
    slotNum = ejsModuleReadInt(ejs, mp);
    numSlot = ejsModuleReadInt(ejs, mp);

    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    bp = ejsCreateBlock(ejs, numSlot);
    mprSetName(bp, MPR_NAME("block"));
    current = getCurrentBlock(mp);

    /*
        TODO - replace this strict mode with dont-delete on a per property basis. Redefinition is then okay if the
        property to be replaced is !dont-delete
     */
    if (mp->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, current, qname) >= 0) {
            ejsThrowReferenceError(ejs, "Block \"%@\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
    slotNum = ejsDefineProperty(ejs, current, slotNum, qname, EST(Block), 0, bp);
    if (slotNum < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_BLOCK, mp, current, slotNum, qname.name, numSlot, bp);
    }
    pushScope(mp, bp, bp);
    return 0;
}


static int loadEndBlockSection(Ejs *ejs, EjsModule *mp)
{
    mprTrace(9, "    End block section %@", mp->name);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_BLOCK_END, mp);
    }
    popScope(mp, 0);
    return 0;
}


static int loadClassSection(Ejs *ejs, EjsModule *mp)
{
    EjsType         *type, *baseType, *iface;
    EjsTypeFixup    *fixup, *ifixup;
    EjsName         qname, baseClassName, ifaceClassName;
    int             attributes, numTypeProp, numInstanceProp, numInterfaces, i, slotNum;

    fixup = 0;
    ifixup = 0;
    
    qname = ejsModuleReadName(ejs, mp);
    attributes = ejsModuleReadInt(ejs, mp);
    slotNum = ejsModuleReadInt(ejs, mp);
    ejsModuleReadType(ejs, mp, &baseType, &fixup, &baseClassName, 0);
    numTypeProp = ejsModuleReadInt(ejs, mp);
    numInstanceProp = ejsModuleReadInt(ejs, mp);
    numInterfaces = ejsModuleReadInt(ejs, mp);

    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    if (fixup || (baseType && baseType->needFixup)) {
        attributes |= EJS_TYPE_FIXUP;
    }
    /*
        See if the type has been registered in the set of immutable types. If so, can use without creating.
     */
    type = ejsGetPropertyByName(ejs, ejs->service->immutable, qname);
    if (type == 0) {
        if (attributes & EJS_TYPE_FIXUP) {
            baseType = 0;
            if (fixup == 0) {
                fixup = createFixup(ejs, mp, (baseType) ? baseType->qname : EST(Object)->qname, -1);
            }
        }
        mprTrace(9, "    Load %@ class %@ for module %@ at slotNum %d", qname.space, qname.name, mp->name, slotNum);

        type = ejsCreateType(ejs, qname, mp, baseType, NULL, slotNum, numTypeProp, numInstanceProp, 0, 0, attributes);
        if (type == 0) {
            ejsThrowInternalError(ejs, "Cannot create class %@", qname.name);
            return MPR_ERR_BAD_STATE;
        }

    } else {
        if (ejsConfigureType(ejs, type, mp, baseType, numTypeProp, numInstanceProp, attributes) < 0) {
            ejsThrowInternalError(ejs, "Cannot configure class %@", qname.name);
            return MPR_ERR_BAD_STATE;
        }
        mp->hasNative = 1;
#if FUTURE
        /*
            Currently errors on Namespace
         */
        if (attributes & EJS_TYPE_HAS_CONSTRUCTOR && !type->hasConstructor) {
            mprError("WARNING: module indicates a constructor required but none exists for \"%@\"", type->qname.name);
        }
#endif
#if UNUSED && KEEP
        if (!type->native) {
            mprError("WARNING: type not defined as native: \"%@\"", type->qname.name);
        }
#endif
    }
        
    /*
        Read implemented interfaces. Add to type->implements. Create fixup record if the interface type is not yet known.
     */
    if (numInterfaces > 0) {
        if (!type->implements) {
            type->implements = mprCreateList(numInterfaces, 0);
        }
        for (i = 0; i < numInterfaces; i++) {
            if (ejsModuleReadType(ejs, mp, &iface, &ifixup, &ifaceClassName, 0) < 0) {
                return MPR_ERR_CANT_READ;
            }
            if (type->endClass == 0) {
                if (iface) {
                    mprAddItem(type->implements, iface);
                } else if (addFixup(ejs, mp, EJS_FIXUP_INTERFACE_TYPE, (EjsObj*) type, -1, ifixup) < 0) {
                    ejsThrowMemoryError(ejs);
                    return MPR_ERR_MEMORY;
                }
            }
        }
    }
    slotNum = ejsDefineProperty(ejs, ejs->global, slotNum, qname, EST(Type), attributes, (EjsObj*) type);
    if (slotNum < 0) {
        ejsThrowMemoryError(ejs);
        return MPR_ERR_MEMORY;
    }
    type->module = mp;
    if (fixup) {
        if (addFixup(ejs, mp, EJS_FIXUP_BASE_TYPE, (EjsObj*) type, -1, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_MEMORY;
        }
    }
    setDoc(ejs, mp, "class", ejs->global, slotNum);

    pushScope(mp, type, type);
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_CLASS, mp, slotNum, qname, type, attributes);
    }
    if (type->endClass) {
        mprSeekFile(mp->file, SEEK_SET, type->endClass);
    }
    return 0;
}


static int loadEndClassSection(Ejs *ejs, EjsModule *mp)
{
    EjsType     *type;

    mprTrace(9, "    End class section");

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_CLASS_END, mp, mp->scope);
    }
    type = (EjsType*) mp->scope;
    if (type->endClass == 0) {
        type->endClass = (int) mprGetFilePosition(mp->file) - 1;
        if (type->hasScriptFunctions) {
            type->hasScriptFunctions = 1;
        }
        if (type->hasScriptFunctions && type->baseType) {
            ejsDefineTypeNamespaces(ejs, type);
        }
        if (type->dynamicInstances) {
            type->mutableInstances = 1;
        }
    }
    popScope(mp, 0);
    return 0;
}


static int loadFunctionSection(Ejs *ejs, EjsModule *mp)
{
    EjsType         *returnType, *currentType;
    EjsTypeFixup    *fixup;
    EjsFunction     *fun;
    EjsName         qname, returnTypeName;
    EjsPot          *block;
    uchar           *code;
    int             slotNum, numProp, numArgs, numDefault, codeLen, numExceptions, attributes, strict, sn;

    strict = 0;
    code = 0;

    qname = ejsModuleReadName(ejs, mp);
    attributes = ejsModuleReadInt(ejs, mp);
    strict = ejsModuleReadByte(ejs, mp);
    ejsModuleReadType(ejs, mp, &returnType, &fixup, &returnTypeName, 0);
    slotNum = ejsModuleReadInt(ejs, mp);
    numProp = ejsModuleReadInt(ejs, mp);
    numArgs = ejsModuleReadInt(ejs, mp);
    numDefault = ejsModuleReadInt(ejs, mp);
    numExceptions = ejsModuleReadInt(ejs, mp);
    codeLen = ejsModuleReadInt(ejs, mp);
    
    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    block = (EjsPot*) getCurrentBlock(mp);
    currentType = 0;
    if (ejsIsType(ejs, block)) {
        currentType = (EjsType*) block;
        if (!(attributes & (EJS_FUN_CONSTRUCTOR | EJS_PROP_STATIC))) {
            block = ((EjsType*) currentType)->prototype;
        }
    }
    assert(block);
    assert(numArgs >= 0 && numArgs < EJS_MAX_ARGS);
    assert(numExceptions >= 0 && numExceptions < EJS_MAX_EXCEPTIONS);

    mprTrace(9, "Loading function %N at slot %d", qname, slotNum);

    if (attributes & EJS_PROP_NATIVE) {
        mp->hasNative = 1;
    }
    if (attributes & EJS_FUN_MODULE_INITIALIZER) {
        mp->hasInitializer = 1;
    }
    fun = 0;
    if ((sn = ejsLookupProperty(ejs, block, qname)) >= 0) {
        fun = ejsGetProperty(ejs, block, sn);
    }
    if (fun == 0 || (attributes & EJS_TRAIT_SETTER && !fun->setter) || (attributes & EJS_FUN_OVERRIDE)) {
        /*
            Read the code
         */
        if (codeLen > 0) {
            if ((code = mprAlloc(codeLen)) == 0) {
                return MPR_ERR_MEMORY;
            }
            if (mprReadFile(mp->file, code, codeLen) != codeLen) {
                return MPR_ERR_CANT_READ;
            }
            if (currentType) {
                currentType->hasScriptFunctions = 1;
            }
        }
        if (attributes & EJS_FUN_CONSTRUCTOR) {
            fun = (EjsFunction*) block;
            ejsInitFunction(ejs, fun, qname.name, code, codeLen, numArgs, numDefault, numExceptions, returnType, 
                attributes, mp, NULL, strict);
            assert(fun->isConstructor);
        } else {
            fun = ejsCreateFunction(ejs, qname.name, code, codeLen, numArgs, numDefault, numExceptions, returnType, 
                attributes, mp, mp->scope, strict);
        }
        if (fun == 0) {
            return MPR_ERR_MEMORY;
        }
        assert(fun->block.pot.isBlock);
        assert(fun->block.pot.isFunction);
        if (numProp > 0) {
            fun->activation = ejsCreateActivation(ejs, fun, numProp);
        }
        if (!(attributes & EJS_FUN_CONSTRUCTOR)) {
            if (attributes & EJS_FUN_MODULE_INITIALIZER && block == ejs->global) {
                mp->initializer = fun;
                slotNum = -1;
            } else {
                if ((slotNum = ejsDefineProperty(ejs, block, slotNum, qname, EST(Function), attributes, fun)) < 0) {
                    return MPR_ERR_MEMORY;
                }
            }
        }
        if (fixup) {
            assert(returnType == 0);
            if (addFixup(ejs, mp, EJS_FIXUP_RETURN_TYPE, (EjsObj*) fun, -1, fixup) < 0) {
                ejsThrowMemoryError(ejs);
                return MPR_ERR_MEMORY;
            }
        }
        if (currentType && attributes & EJS_FUN_CONSTRUCTOR) {
            setDoc(ejs, mp, "fun", ejs->global, ejsLookupProperty(ejs, ejs->global, currentType->qname));
        } else {
            setDoc(ejs, mp, "fun", block, slotNum);
        }
    } else {
        if (attributes & EJS_TRAIT_SETTER && fun->setter) {
            fun = fun->setter;
        }
        if ((slotNum = ejsDefineProperty(ejs, block, slotNum, qname, EST(Function), attributes, fun)) < 0) {
            return MPR_ERR_MEMORY;
        }
        assert(fun->endFunction);
        assert(mprGetFilePosition(mp->file) <= fun->endFunction);
        mprSeekFile(mp->file, SEEK_SET, fun->endFunction);
    }
    assert(fun);
    mp->currentMethod = fun;
    pushScope(mp, ejsIsType(ejs, fun) ? NULL : fun, fun->activation);
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_FUNCTION, mp, block, slotNum, qname, fun, attributes);
    }
    return 0;
}


static int loadEndFunctionSection(Ejs *ejs, EjsModule *mp)
{
    EjsFunction     *fun;

    mprTrace(9, "    End function section");

    fun = (EjsFunction*) mp->scope;
    fun->endFunction = (int) mprGetFilePosition(mp->file) - 1;
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_FUNCTION_END, mp, fun);
    }
    popScope(mp, ejsIsType(ejs, fun));
    return 0;
}


static int loadDebugSection(Ejs *ejs, EjsModule *mp)
{
    EjsFunction     *fun;
    int             size;

    fun = mp->currentMethod;
    assert(fun);

    /* 
        Note the location in the file and skip over
     */
    assert(!fun->isNativeProc);
    size = ejsModuleReadInt32(ejs, mp);
    fun->body.code->debugOffset = (int) mprGetFilePosition(mp->file);
    mprSeekFile(mp->file, SEEK_CUR, size);
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_DEBUG, mp, fun);
    }
    return 0;
}


static int loadExceptionSection(Ejs *ejs, EjsModule *mp)
{
    EjsFunction     *fun;
    EjsType         *catchType;
    EjsTypeFixup    *fixup;
    EjsCode         *code;
    EjsEx           *ex;
    int             tryStart, tryEnd, handlerStart, handlerEnd, numBlocks, numStack, flags, i;

    fun = mp->currentMethod;
    assert(fun);

    flags = 0;
    code = fun->body.code;

    for (i = 0; i < code->numHandlers; i++) {
        flags        = ejsModuleReadByte(ejs, mp);
        tryStart     = ejsModuleReadInt(ejs, mp);
        tryEnd       = ejsModuleReadInt(ejs, mp);
        handlerStart = ejsModuleReadInt(ejs, mp);
        handlerEnd   = ejsModuleReadInt(ejs, mp);
        numBlocks    = ejsModuleReadInt(ejs, mp);
        numStack     = ejsModuleReadInt(ejs, mp);
        ejsModuleReadType(ejs, mp, &catchType, &fixup, 0, 0);
        if (mp->hasError) {
            return MPR_ERR_CANT_READ;
        }
        ex = ejsAddException(ejs, fun, tryStart, tryEnd, catchType, handlerStart, handlerEnd, numBlocks, 
            numStack, flags, i);
        if (fixup) {
            assert(catchType == 0);
            if (addFixup(ejs, mp, EJS_FIXUP_EXCEPTION, (EjsObj*) ex, 0, fixup) < 0) {
                assert(0);
                return MPR_ERR_MEMORY;
            }
        }
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_EXCEPTION, mp, fun);
    }
    return 0;
}


static int loadPropertySection(Ejs *ejs, EjsModule *mp, int sectionType)
{
    EjsType         *type, *ctype;
    EjsTypeFixup    *fixup;
    EjsName         qname, propTypeName;
    EjsObj          *current, *value;
    int             slotNum, attributes, fixupKind;

    value = 0;
    current = getCurrentBlock(mp);
    qname = ejsModuleReadName(ejs, mp);

    attributes = ejsModuleReadInt(ejs, mp);
    slotNum = ejsModuleReadInt(ejs, mp);
    ejsModuleReadType(ejs, mp, &type, &fixup, &propTypeName, 0);

    /*
        This is used for namespace values. It is required when compiling (only) and thus module init code is not 
        being run -- but we still need the value of the namespace if a script wants to declare a variable qualified
        by the namespace that is defined in the module.
     */
    if (attributes & EJS_PROP_HAS_VALUE) {
        EjsString  *str;
        if ((str = ejsModuleReadConst(ejs, mp)) == 0) {
            return MPR_ERR_CANT_READ;
        }
        /*  Only doing for namespaces currently */
        value = (EjsObj*) ejsCreateNamespace(ejs, str);
    }
    mprTrace(9, "Loading property %N at slot %d", qname, slotNum);

    if (attributes & EJS_PROP_NATIVE) {
        mp->hasNative = 1;
    }
#if UNUSED && KEEP
    if (mp->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, current, qname) >= 0) {
            ejsThrowReferenceError(ejs, "property \"%@\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
#endif
    if (ejsIsType(ejs, current)) {
        ctype = (EjsType*) current;
        if (!(attributes & EJS_TRAIT_READONLY)) {
            if (attributes & EJS_PROP_STATIC) {
                ctype->mutable = 1;
            } else {
                ctype->mutableInstances = 1;
            }
        }
        if (!(attributes & EJS_PROP_STATIC) && current != ejs->global && ctype->prototype) {
            current = (EjsObj*) ((EjsType*) current)->prototype;
        }
    }
    slotNum = ejsDefineProperty(ejs, current, slotNum, qname, type, attributes, value);
    if (slotNum < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    if (fixup) {
        if (ejsIsFunction(ejs, current)) {
            fixupKind = EJS_FIXUP_LOCAL;
        } else if (ejsIsType(ejs, current) && !(attributes & EJS_PROP_STATIC) && current != ejs->global) {
            assert(((EjsType*) current)->prototype);
            current = (EjsObj*) ((EjsType*) current)->prototype;
            fixupKind = EJS_FIXUP_INSTANCE_PROPERTY;
        } else {
            fixupKind = EJS_FIXUP_TYPE_PROPERTY;
        }
        assert(type == 0);
        if (addFixup(ejs, mp, fixupKind, current, slotNum, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_MEMORY;
        }
    }
    setDoc(ejs, mp, "var", current, slotNum);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_PROPERTY, mp, current, slotNum, qname, attributes, propTypeName);
    }
    return 0;
}


static int loadDocSection(Ejs *ejs, EjsModule *mp)
{
    EjsString   *doc;

    mprTrace(9, "    Documentation section");

    doc = ejsModuleReadConst(ejs, mp);

    if (ejs->flags & EJS_FLAG_DOC) {
        mp->doc = doc;
        if (ejs->loaderCallback) {
            (ejs->loaderCallback)(ejs, EJS_SECT_DOC, doc);
        }
    }
    return 0;
}


/*
    Check if a native module exists at the given path. If so, load it. If the path is a scripted module
    but has a corresponding native module, then load that.
 */
static int loadNativeLibrary(Ejs *ejs, EjsModule *mp, cchar *modPath)
{
    MprModule   *native;
    char        *base, *bare, *path, *moduleName, initName[ME_MAX_PATH], *cp;

    /*
        Replace ".mod" with ".so", ".dll" or ".dylib"
     */
    bare = sclone(modPath);
    if ((cp = strrchr(bare, '.')) != 0 && strcmp(cp, EJS_MODULE_EXT) == 0) {
        *cp = '\0';
    }
    base = mprGetPathBase(bare);
    if (!sstarts(base, "lib")) {
        path = mprJoinPath(mprGetPathDir(bare), sjoin("lib", base, ME_SHOBJ, NULL));
    } else {
        path = sjoin(bare, ME_SHOBJ, NULL);
    }
    if (! mprPathExists(path, R_OK)) {
        mprError("Native module not found %s", path);
        return MPR_ERR_CANT_ACCESS;
    }
    /*
        Build the DSO entry point name. Format is "Name_ModuleInit" where Name has "." converted to "_"
        Typical name: ejs_io_Init or com_acme_rockets_Init
     */
    moduleName = (char*) ejsToMulti(ejs, mp->name);
    moduleName[0] = tolower((uchar) moduleName[0]);
    fmt(initName, sizeof(initName), "%s_Init", moduleName);
    for (cp = initName; *cp; cp++) {
        if (*cp == '.') {
            *cp = '_';
        }
    }
    mprTrace(5, "Loading native module %s", path);
    native = mprCreateModule(mp->name->value, path, initName, ejs);
    if (mprLoadModule(native) < 0) {
        return MPR_ERR_CANT_READ;
    }
    return 0;
}


static int loadScriptModule(Ejs *ejs, cchar *filename, int minVersion, int maxVersion, int flags)
{
    EjsModuleHdr    hdr;
    EjsModule       *mp;
    MprFile         *file;
    char            *path;
    int             next, status, firstModule;

    assert(filename && *filename);
    assert(ejs->exception == 0);

    if ((path = search(ejs, filename, minVersion, maxVersion)) == 0) {
        return MPR_ERR_CANT_ACCESS;
    }
    if ((file = mprOpenFile(path, O_RDONLY | O_BINARY, 0666)) == NULL) {
        ejsThrowIOError(ejs, "Cannot open module file %s", path);
        return MPR_ERR_CANT_OPEN;
    }
    mprHold(file);
    mprTrace(5, "Loading module %s", path);
    mprEnableFileBuffering(file, 0, 0);
    firstModule = mprGetListLength(ejs->modules);

    /*
        Read module file header
     */
    status = 0;
    if ((mprReadFile(file, &hdr, sizeof(hdr))) != sizeof(hdr)) {
        ejsThrowIOError(ejs, "Cannot read module file %s, corrupt header", path);
        status = MPR_ERR_CANT_LOAD;

    } else if ((int) ejsSwapInt32(ejs, hdr.magic) != EJS_MODULE_MAGIC) {
        ejsThrowIOError(ejs, "Bad module file format in %s", path);
        status = MPR_ERR_CANT_LOAD;

    } else if (ejsSwapInt32(ejs, hdr.fileVersion) != EJS_MODULE_VERSION) {
        ejsThrowIOError(ejs, "Incompatible module file format in %s", path);
        status = MPR_ERR_CANT_LOAD;

    } else {
        if (ejs->loaderCallback) {
            (ejs->loaderCallback)(ejs, EJS_SECT_START, path, &hdr);
        }
        /*
            WARNING: this may block and GC may run
         */
        if ((status = loadSections(ejs, file, path, &hdr, flags)) < 0) {
            if (ejs->exception == 0) {
                ejsThrowReferenceError(ejs, "Cannot load module file %s", path);
                status = MPR_ERR_CANT_LOAD;
            }
        }
    }
    if (status) {
        for (next = firstModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
            ejsRemoveModule(ejs, mp);
        }
    }
    mprCloseFile(file);
    mprRelease(file);
    return status;
}


static int fixupTypes(Ejs *ejs, MprList *list)
{
    EjsTypeFixup    *fixup;
    EjsType         *type, *targetType;
    EjsTrait        *trait;
    EjsFunction     *targetFunction;
    EjsEx           *targetException;
    int             next;

    for (next = 0; (fixup = (EjsTypeFixup*) mprGetNextItem(list, &next)) != 0; ) {
        type = 0;
        if (fixup->typeSlotNum >= 0) {
            type = ejsGetProperty(ejs, ejs->global, fixup->typeSlotNum);
        } else if (fixup->typeName.name) {
            assert(fixup->typeSlotNum < 0);
            type = ejsGetPropertyByName(ejs, ejs->global, fixup->typeName);
        } else {
            continue;
        }
        if (type == 0) {
            if (fixup->typeName.name) {
                ejsThrowReferenceError(ejs, "Cannot fixup forward type reference for \"%@\". Fixup kind %d", 
                    fixup->typeName.name, fixup->kind);
            }
            return MPR_ERR_CANT_LOAD;
        }
        switch (fixup->kind) {
        case EJS_FIXUP_BASE_TYPE:
            assert(fixup->target);
            targetType = (EjsType*) fixup->target;
            targetType->needFixup = 1;
            ejsFixupType(ejs, targetType, type, 0);
            if (targetType->constructor.block.namespaces.length == 0 && type->hasScriptFunctions) {
                ejsDefineTypeNamespaces(ejs, targetType);
            }
            break;

        case EJS_FIXUP_INTERFACE_TYPE:
            targetType = (EjsType*) fixup->target;
            mprAddItem(targetType->implements, type);
            break;

        case EJS_FIXUP_RETURN_TYPE:
            assert(fixup->target);
            targetFunction = (EjsFunction*) fixup->target;
            targetFunction->resultType = type;
            break;

        case EJS_FIXUP_TYPE_PROPERTY:
            assert(fixup->target);
            trait = ejsGetPropertyTraits(ejs, fixup->target, fixup->slotNum);
            assert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_INSTANCE_PROPERTY:
            assert(fixup->target);
            assert(ejsIsBlock(ejs, fixup->target));
            assert(((EjsPot*) fixup->target)->isPrototype);
            trait = ejsGetPropertyTraits(ejs, fixup->target, fixup->slotNum);
            assert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_LOCAL:
            assert(fixup->target);
            trait = ejsGetPropertyTraits(ejs, fixup->target, fixup->slotNum);
            assert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_EXCEPTION:
            assert(fixup->target);
            targetException = (EjsEx*) fixup->target;
            targetException->catchType = type;
            break;

        default:
            assert(0);
        }
    }
    return 0;
}


/*
    Parse a major.minor.version string
 */
int ejsParseModuleVersion(cchar *name)
{
    char    *tok;
    int     major, minor, patch;

    minor = patch = 0;
    major = (int) stoi(name);
    if ((tok = strchr(name, '.')) != 0) {
        minor = (int) stoi(++tok);
    }
    if (tok && (tok = strchr(tok, '.')) != 0) {
        patch = (int) stoi(++tok);
    }
    return EJS_MAKE_VERSION(major, minor, patch);
}


/*
    Remove "-version" and ".mod"
 */
static int trimModule(Ejs *ejs, char *name)
{
    cchar   *lastSlash;
    char    *cp, *vp;

    if ((cp = strrchr(name, '.')) != 0 && strcmp(cp, EJS_MODULE_EXT) == 0) {
        *cp = '\0';
    }
    if ((vp = strrchr(name, '-')) == 0) {
        return 0;
    }
    lastSlash = mprGetLastPathSeparator(name);
    if (lastSlash && lastSlash > vp) {
        /* There is a "-" but it is in the directory portion of the name and not in the module name */
        return 0;
    }
    *vp++ = '\0';
    if (isdigit((uchar) *vp)) {
        return ejsParseModuleVersion(vp);
    }
    return 0;
}


/*
    Extract the version from a module name
 */
static int getVersion(cchar *name)
{
    char    *vp;

    if ((vp = strrchr(name, '-')) == 0) {
        return 0;
    }
    return ejsParseModuleVersion(++vp);
}


/*
    Search for a file. If found, Return the path where the file was located. Otherwise return null.
 */
static char *probe(Ejs *ejs, cchar *path, int minVersion, int maxVersion)
{
    MprDirEntry     *dp, *best;
    MprList         *files;
    char            *dir, *base, *ext;
    int             next, nameLen, version, bestVersion;

    assert(ejs);
    assert(path);

    mprTrace(7, "Probe for file %s", path);

    if (maxVersion == 0) {
        if (mprPathExists(path, R_OK)) {
            return sclone(path);
        }
        return 0;
    }
    dir = mprGetPathDir(path);
    base = mprGetPathBase(path);
    if ((ext = strrchr(base, '.')) != 0) {
        *ext++ = '\0';
    }
    files = mprGetPathFiles(dir, MPR_PATH_RELATIVE);
    nameLen = (int) strlen(base);
    bestVersion = -1;
    best = 0;

    for (next = 0; (dp = mprGetNextItem(files, &next)) != 0; ) {
        if (strncmp(dp->name, base, nameLen) != 0) {
            continue;
        }
        if ((ext = strrchr(dp->name, '.')) == 0 || strcmp(ext, EJS_MODULE_EXT) != 0) {
            continue;
        }
        if (dp->name[nameLen] == '-') {
            version = getVersion(dp->name);
        } else if (&dp->name[nameLen] == ext) {
            version = 0;
        } else {
            continue;
        }
        if (version == 0 || (minVersion <= version && version <= maxVersion)) {
            if (best == 0 || bestVersion < version) {
                bestVersion = version;
                best = dp;
            }
        }
    }
    return (best == 0) ? 0 : mprJoinPath(dir, best->name);
}


/*
    Search for a module. moduleName is a filename or path name. It MUST have a ".mod" extension.

    The search strategy is: Given a name "a.b.c", scan for:

        1. File named a.b.c
        2. File named a/b/c
        3. File named a.b.c in EJSPATH
        4. File named a/b/c in EJSPATH
        5. File named c in EJSPATH
 */
static char *searchForModule(Ejs *ejs, cchar *moduleName, int minVersion, int maxVersion)
{
    EjsPath     *dir;
    char        *withDotMod, *path, *filename, *basename, *cp, *slash, *name, *bootSearch, *tok, *searchDir;
    int         i;

    assert(moduleName && *moduleName);

    slash = 0;
    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    withDotMod = makeModuleName(moduleName);
    name = mprNormalizePath(withDotMod);

    mprTrace(7, "Search for module \"%s\"", name);

    /*
        1. Search for path directly
     */
    if ((path = probe(ejs, name, minVersion, maxVersion)) != 0) {
        return path;
    }

    /*
        2. Search for "a/b/c"
     */
    slash = sclone(name);
    for (cp = slash; *cp; cp++) {
        if (*cp == '.') {
            *cp = mprGetPathSeparators(name)[0];
        }
    }
    if ((path = probe(ejs, slash, minVersion, maxVersion)) != 0) {
        return path;
    }

    if (ejs->search) {
        /*
            3. Search for "a.b.c" in EJSPATH
         */
        for (i = 0; i < ejs->search->length; i++) {
            dir = ejsGetProperty(ejs, ejs->search, i);
            if (!ejsIs(ejs, dir, Path)) {
                continue;
            }
            filename = mprJoinPath(dir->value, name);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

        /*
            4. Search for "a/b/c" in EJSPATH
         */
        for (i = 0; i < ejs->search->length; i++) {
            dir = ejsGetProperty(ejs, ejs->search, i);
            if (!ejsIs(ejs, dir, Path)) {
                continue;
            }
            filename = mprJoinPath(dir->value, slash);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

        /*
            5. Search for "c" in EJSPATH
         */
        basename = mprGetPathBase(slash);
        for (i = 0; i < ejs->search->length; i++) {
            dir = ejsGetProperty(ejs, ejs->search, i);
            if (!ejsIs(ejs, dir, Path)) {
                continue;
            }
            filename = mprJoinPath(dir->value, basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

    } else {
        /*
            Used when bootstrapping the VM
         */
        basename = mprGetPathBase(name);
        if (ejs->bootSearch) {
            bootSearch = sclone(ejs->bootSearch);
            searchDir = stok(bootSearch, MPR_SEARCH_SEP, &tok);
            while (searchDir && *searchDir) {
                filename = mprJoinPath(searchDir, basename);
                if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                    return path;
                }
                searchDir = stok(NULL, MPR_SEARCH_SEP, &tok);
            }

        } else {
            /* Search bin */
            filename = mprJoinPath(mprGetAppDir(), basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
            /* Search "." */
            path = mprGetCurrentPath();
            filename = mprJoinPath(path, basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }
    }
    return 0;
}


char *ejsSearchForModule(Ejs *ejs, cchar *moduleName, int minVersion, int maxVersion)
{
    char        *path, *withDotMod, *name;

    assert(moduleName && *moduleName);

    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    withDotMod = makeModuleName(moduleName);
    name = mprNormalizePath(withDotMod);

    path = searchForModule(ejs, name, minVersion, maxVersion);
    if (path) {
        mprTrace(6, "Found %s at %s", name, path);
    }
    return path;
}


/*
    Ensure name has a ".mod" extension
 */
static char *makeModuleName(cchar *name)
{
    char    *cp;

    if ((cp = strrchr(name, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) == 0) {
        return sclone(name);
    }
    return sjoin(name, EJS_MODULE_EXT, NULL);
}


static int alreadyLoaded(Ejs *ejs, EjsString *name, int minVersion, int maxVersion)
{
    EjsModule   *mp;

    if ((mp = ejsLookupModule(ejs, name, minVersion, maxVersion)) == 0) {
        return 0;
    }
    if (mp->compiling && ejsCompareAsc(ejs, name, EJS_DEFAULT_MODULE) != 0) {
        ejsThrowStateError(ejs, "Attempt to load module \"%@\" that is currently being compiled.", name);
        return MPR_ERR_ALREADY_EXISTS;
    }
    return 1;
}


void manageLoadState(EjsLoadState *ls, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(ls->typeFixups);
    }
}


static EjsLoadState *createLoadState(Ejs *ejs, int flags)
{
    EjsLoadState    *ls;

    ls = mprAllocObj(EjsLoadState, manageLoadState);
    ls->typeFixups = mprCreateList(-1, 0);
    ls->firstModule = mprGetListLength(ejs->modules);
    ls->flags = flags;
    return ls;
}


/*
    Read a type reference. Types are stored as either global property slot numbers or as strings (token offsets into the 
    constant pool). The lowest bit is set if the reference is a string. The type and name arguments are optional and may 
    be set to null. Return the 0 if successful, otherwise return < 0. If the type could not be resolved, allocate a 
    fixup record and return in *fixup. The caller should then call addFixup.
 */
int ejsModuleReadType(Ejs *ejs, EjsModule *mp, EjsType **typeRef, EjsTypeFixup **fixup, EjsName *typeName, int *slotNum)
{
    EjsType         *type;
    EjsName         qname;
    int             t, slot;

    assert(mp);
    assert(typeRef);
    assert(fixup);

    *typeRef = 0;
    *fixup = 0;

    if (typeName) {
        typeName->name = 0;
        typeName->space = 0;
    }
    t = ejsModuleReadInt(ejs, mp);
    slot = -1;
    qname.name = 0;
    qname.space = 0;
    type = 0;

    switch (t & EJS_ENCODE_GLOBAL_MASK) {
    default:
        mp->hasError = 1;
        return MPR_ERR_CANT_LOAD;

    case EJS_ENCODE_GLOBAL_NOREF:
        return 0;

    case EJS_ENCODE_GLOBAL_SLOT:
        /*
            Type is a builtin primitive type or we are binding globals.
         */
        slot = t >> 2;
        if (0 <= slot && slot < ejsGetLength(ejs, ejs->global)) {
            type = ejsGetProperty(ejs, ejs->global, slot);
            if (type && (EjsObj*) type != ESV(null)) {
                qname = type->qname;
            }
        }
        break;

    case EJS_ENCODE_GLOBAL_NAME:
        /*
            Type was unbound at compile time
         */
        qname.name = ejsCreateStringFromConst(ejs, mp, t >> 2);
        if (qname.name == 0) {
            mp->hasError = 1;
            return MPR_ERR_CANT_LOAD;
        }
        if ((qname.space = ejsModuleReadConst(ejs, mp)) == 0) {
            mp->hasError = 1;
            return MPR_ERR_CANT_LOAD;
        }
        if (qname.name) {
            slot = ejsLookupProperty(ejs, ejs->global, qname);
            if (slot >= 0) {
                type = ejsGetProperty(ejs, ejs->global, slot);
            }
        }
        break;
    }
    if (type == ESV(null)) {
        type = 0;
    }
    if (type) {
        if (!ejsIsType(ejs, type)) {
            mp->hasError = 1;
            return MPR_ERR_CANT_LOAD;
        }
        *typeRef = type;

    } else if (type == 0 && fixup) {
        *fixup = createFixup(ejs, mp, qname, slot);
    }
    if (typeName) {
        *typeName = qname;
    }
    if (slotNum) {
        *slotNum = slot;
    }
    return 0;
}


static EjsTypeFixup *createFixup(Ejs *ejs, EjsModule *mp, EjsName qname, int slotNum)
{
    EjsTypeFixup    *fixup;

    assert(mp->loadState->typeFixups);

    /*
        Managed by manageLoadState
     */
    if ((fixup = mprAllocZeroed(sizeof(EjsTypeFixup))) == 0) {
        return 0;
    }
    fixup->typeName = qname;
    fixup->typeSlotNum = slotNum;
    return fixup;
}


static int addFixup(Ejs *ejs, EjsModule *mp, int kind, EjsObj *target, int slotNum, EjsTypeFixup *fixup)
{
    int     index;

    assert(ejs);
    assert(fixup);
    assert(mp->loadState->typeFixups);

    fixup->kind = kind;
    fixup->target = target;
    fixup->slotNum = slotNum;

    index = mprAddItem(mp->loadState->typeFixups, fixup);
    if (index < 0) {
        return MPR_ERR_CANT_LOAD;
    }
    return 0;
}


static void setDoc(Ejs *ejs, EjsModule *mp, cchar *tag, void *vp, int slotNum)
{
    if (mp->doc) {
        ejsCreateDoc(ejs, tag, vp, slotNum, mp->doc);
        mp->doc = 0;
    }
}


static void manageDoc(EjsDoc *doc, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(doc->docString);
        mprMark(doc->brief);
        mprMark(doc->description);
        mprMark(doc->example);
        mprMark(doc->requires);
        mprMark(doc->returns);
        mprMark(doc->stability);
        mprMark(doc->spec);
        mprMark(doc->duplicate);
        mprMark(doc->defaults);
        mprMark(doc->params);
        mprMark(doc->options);
        mprMark(doc->events);
        mprMark(doc->see);
        mprMark(doc->throws);
    }
}


EjsDoc *ejsCreateDoc(Ejs *ejs, cchar *tag, void *vp, int slotNum, EjsString *docString)
{
    EjsDoc      *doc;
    char        key[32];

    if (ejs->doc == 0) {
        ejs->doc = mprCreateHash(EJS_DOC_HASH_SIZE, 0);
    }
    fmt(key, sizeof(key), "%s %Lx %d", tag, PTOL(vp), slotNum);
    if ((doc = mprLookupKey(ejs->doc, key)) != 0) {
        return doc;
    }
    if ((doc = mprAllocObj(EjsDoc, manageDoc)) == 0) {
        return 0;
    }
    doc->docString = docString;
    mprAddKey(ejs->doc, key, doc);
    return doc;
}


static EjsObj *getCurrentBlock(EjsModule *mp)
{
    return mprGetLastItem(mp->current);
}


static void pushScope(EjsModule *mp, EjsAny *block, EjsAny *obj)
{
    if (block) {
        assert(block != mp->scope);
        ((EjsBlock*) block)->scope = mp->scope;
        mp->scope = block;
        assert(mp->scope != mp->scope->scope);
    }
    mprPushItem(mp->current, obj);
}


static void popScope(EjsModule *mp, int keepScope)
{
    mprPopItem(mp->current);
    if (!keepScope) {
        assert(mp->scope != mp->scope->scope);
        mp->scope = mp->scope->scope;
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsModule.c"
 */
/************************************************************************/

/**
    ejsModule.c - Ejscript module management

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/********************************** Forwards **********************************/

static void manageConstants(EjsConstants *constants, int flags);
static void manageDebug(EjsDebug *debug, int flags);
static void manageModule(EjsModule *module, int flags);

/************************************ Code ************************************/

EjsModule *ejsCreateModule(Ejs *ejs, EjsString *name, int version, EjsConstants *constants)
{
    EjsModule   *mp;

    assert(version >= 0);

    if ((mp = mprAllocObj(EjsModule, manageModule)) == NULL) {
        assert(mp);
        return 0;
    }
    mp->name = name;
    mp->version = version;
    mp->vname = (version) ? ejsSprintf(ejs, "%@-%d", name, version) : mp->name;
    if ((mp->constants = constants) == 0) {
        if (ejsCreateConstants(ejs, mp, 0, EC_BUFSIZE, NULL) < 0) {
            return 0;
        }
    }
    assert(mp->checksum == 0);
    return mp;
}


static void manageModule(EjsModule *mp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(mp->name);
        mprMark(mp->vname);
        mprMark(mp->mutex);
        mprMark(mp->constants);
        mprMark(mp->initializer);
        mprMark(mp->loadState);
        mprMark(mp->dependencies);
        mprMark(mp->file);
        mprMark(mp->current);
        mprMark(mp->currentMethod);
        mprMark(mp->scope);
        mprMark(mp->path);
        mprMark(mp->code);
        mprMark(mp->doc);
        mprMark(mp->globalProperties);

    } else if (flags & MPR_MANAGE_FREE) {
        mprCloseFile(mp->file);
        ejsRemoveModuleFromAll(mp);
    }
}


static void manageNativeModule(EjsNativeModule *nm, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(nm->name);
    }
}


/*
    Register a native module callback to be invoked when it it time to configure the module. This is used by loadable modules
    when they are built statically.
 */
int ejsAddNativeModule(Ejs *ejs, cchar *name, EjsNativeCallback callback, int checksum, int flags)
{
    EjsService          *sp;
    EjsNativeModule     *nm;

    sp = ejs->service;
    if (ejsLookupNativeModule(ejs, name)) {
        return 0;
    }
    if ((nm = mprAllocObj(EjsNativeModule, manageNativeModule)) == NULL) {
        return MPR_ERR_MEMORY;
    }
    nm->name = sclone(name);
    nm->callback = callback;
    nm->checksum = checksum;
    nm->flags = flags;

    if (mprAddKey(sp->nativeModules, nm->name, nm) == 0) {
        return EJS_ERR;
    }
    return 0;
}


EjsNativeModule *ejsLookupNativeModule(Ejs *ejs, cchar *name) 
{
    return mprLookupKey(ejs->service->nativeModules, name);
}


/*
    Lookup a module name in the set of loaded modules
    If minVersion is <= 0, then any version up to, but not including maxVersion is acceptable.
    If maxVersion is < 0, then any version greater than minVersion is acceptable.
    If both are zero, then match the name itself and ignore minVersion and maxVersion
    If both are -1, then any version is acceptable.
    If both are equal, then only that version is acceptable.
 */
EjsModule *ejsLookupModule(Ejs *ejs, EjsString *name, int minVersion, int maxVersion)
{
    EjsModule   *mp, *best;
    int         next;

    if (maxVersion < 0) {
        maxVersion = MAXINT;
    }
    best = 0;
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(ejs->modules, &next)) != 0; ) {
        if ((minVersion == 0 && maxVersion == 0) || (minVersion <= mp->version && mp->version <= maxVersion)) {
            if (mp->name == name) {
                if (best == 0 || best->version < mp->version) {
                    best = mp;
                }
            }
        }
    }
    return best;
}


int ejsAddModule(Ejs *ejs, EjsModule *mp)
{
    assert(ejs->modules);
    return mprAddItem(ejs->modules, mp);
}


void ejsRemoveModule(Ejs *ejs, EjsModule *mp)
{
    mprRemoveItem(ejs->modules, mp);
}


void ejsRemoveModuleFromAll(EjsModule *mp)
{
    Ejs         *ejs;
    EjsService  *sp;
    int         next;

    if ((sp = MPR->ejsService) == 0) {
        return;
    }
    lock(sp);
    for (ITERATE_ITEMS(sp->vmlist, ejs, next)) {
        mprRemoveItem(ejs->modules, mp);
    }
    unlock(sp);
}


/************************************************* Constants ***************************************************/

static void manageConstants(EjsConstants *cp, int flags)
{
    int     i;
    
    if (flags & MPR_MANAGE_MARK) {
        mprMark(cp->pool);
        mprMark(cp->table);
        mprMark(cp->index);
        /*
            Racing here, but okay. May miss a few new elements, but they will be picked up on the next sweep.
         */
        for (i = 0; i < cp->indexCount; i++) {
            if (!(PTOI(cp->index[i]) & 0x1)) {
                mprMark(cp->index[i]);
            }
        }
    }
}


/*
    Create the module constants. Count is the number of strings in the constant pool. Size is the size of the pool.
    The optional pool parameter supplies a pre-allocated buffer of constant strings.
 */
int ejsCreateConstants(Ejs *ejs, EjsModule *mp, int count, ssize size, char *pool)
{
    EjsConstants    *constants;
    char            *pp;
    int             i;

    assert(ejs);

    if ((constants = mprAllocObj(EjsConstants, manageConstants)) == 0) {
        return MPR_ERR_MEMORY;
    }
    lock(mp);
    mp->constants = constants;

    if (ejs->compiling && ((constants->table = mprCreateHash(EJS_DOC_HASH_SIZE, MPR_HASH_STATIC_VALUES)) == 0)) {
        unlock(mp);
        return MPR_ERR_MEMORY;
    }
    constants->poolSize = size;
    if ((constants->pool = pool) == 0) {
        assert(count == 0);
        if ((constants->pool = mprAlloc(size)) == 0) {
            unlock(mp);
            return MPR_ERR_MEMORY;
        }
    }
    if (count) {
        constants->poolLength = size;
        if ((constants->index = mprAlloc(count * sizeof(EjsString*))) == NULL) {
            unlock(mp);
            return MPR_ERR_MEMORY;
        }
        assert(pool);
        if (pool) {
            for (pp = pool, i = 0; pp < &pool[constants->poolLength]; i++) {
                constants->index[i] = (void*) (((pp - pool) << 1) | 0x1);
                pp += slen(pp) + 1;
            }
            constants->indexCount = count;
        }
    }
    unlock(mp);
    return 0;
}


int ejsGrowConstants(Ejs *ejs, EjsModule *mp, ssize len)
{
    EjsConstants    *cp;
    int             indexSize;

    lock(mp);
    cp = mp->constants;
    if ((cp->poolLength + len) >= cp->poolSize) {
        cp->poolSize = ((cp->poolSize + len) + EC_BUFSIZE - 1) / EC_BUFSIZE * EC_BUFSIZE;
        if ((cp->pool = mprRealloc(cp->pool, cp->poolSize)) == 0) {
            unlock(mp);
            return MPR_ERR_MEMORY;
        }
    }
    if (cp->indexCount >= cp->indexSize) {
        indexSize = ((cp->indexCount + EJS_INDEX_INCR) / EJS_INDEX_INCR) * EJS_INDEX_INCR;
        if ((cp->index = mprRealloc(cp->index, indexSize * sizeof(EjsString*))) == NULL) {
            unlock(mp);
            return MPR_ERR_MEMORY;
        }
        cp->indexSize = indexSize;
    }
    unlock(mp);
    return 0;
}


int ejsAddConstant(Ejs *ejs, EjsModule *mp, cchar *str)
{
    EjsConstants    *cp;
    ssize           len, oldLen;
    int             index;

    cp = mp->constants;
    if (cp->locked) {
        mprError("Constant pool for module is locked. Cannot add constant \"%s\".",  str);
        return MPR_ERR_CANT_WRITE;
    }
    lock(mp);
    len = slen(str) + 1;
    if (ejsGrowConstants(ejs, mp, len) < 0) {
        unlock(mp);
        return MPR_ERR_MEMORY;
    }
    memcpy(&cp->pool[cp->poolLength], str, len);
    oldLen = cp->poolLength;
    cp->poolLength += len;

    mprAddKey(cp->table, str, ITOP(cp->indexCount));
    cp->index[cp->indexCount] = ITOP(oldLen << 1 | 1);
    index = cp->indexCount++;
    unlock(mp);
    return index;
}


EjsString *ejsCreateStringFromConst(Ejs *ejs, EjsModule *mp, int index)
{
    EjsConstants    *constants;
    EjsString       *sp;
    cchar           *str;
    int             value;

    lock(mp);
    constants = mp->constants;
    if (index < 0 || index >= constants->indexCount) {
        assert(!(index < 0 || index >= constants->indexCount));
        unlock(mp);
        return 0;
    }
    value = PTOI(constants->index[index]);
    if (value & 0x1) {
        str = &constants->pool[value >> 1];
        constants->index[index] = sp = ejsInternMulti(ejs, str, slen(str));
    }
    unlock(mp);
    assert(constants->index[index]);
    return constants->index[index];
}


/************************************************** Debug ******************************************************/

EjsDebug *ejsCreateDebug(Ejs *ejs, int length)
{
    EjsDebug    *debug;
    ssize       size;
    int         count;

    count = (length > 0) ? length : EJS_DEBUG_INCR;
    size = sizeof(EjsDebug) + (count * sizeof(EjsLine));
    if ((debug = mprAllocBlock(size, MPR_ALLOC_MANAGER)) == 0) {
        return NULL;
    }
    mprSetManager(debug, (MprManager) manageDebug);
    debug->size = count;
    debug->numLines = length;
    debug->magic = EJS_DEBUG_MAGIC;
    return debug;
}


int ejsAddDebugLine(Ejs *ejs, EjsDebug **debugp, int offset, wchar *source)
{
    EjsDebug    *debug;
    EjsLine     *line;
    ssize       len;
    int         numLines;

    assert(debugp);
    
    if (*debugp == 0) {
        *debugp = ejsCreateDebug(ejs, 0);
    }
    debug = *debugp;
    assert(debug->magic == EJS_DEBUG_MAGIC);
    if (debug->numLines >= debug->size) {
        debug->size += EJS_DEBUG_INCR;
        len = sizeof(EjsDebug) + (debug->size * sizeof(EjsLine));
        if ((debug = mprRealloc(debug, len)) == 0) {
            return MPR_ERR_MEMORY;
        }
        *debugp = debug;
    }
    if (debug->numLines > 0 && offset == debug->lines[debug->numLines - 1].offset) {
        line = &debug->lines[debug->numLines - 1];
        numLines = debug->numLines;
    } else {
        line = &debug->lines[debug->numLines];
        numLines = debug->numLines + 1;
    }
    line->source = source;
    line->offset = offset;
    debug->numLines = numLines;
    return 0;
}


static void manageDebug(EjsDebug *debug, int flags)
{
    int     i;

    assert(debug->magic == EJS_DEBUG_MAGIC);

    if (flags & MPR_MANAGE_MARK) {
        for (i = 0; i < debug->numLines; i++) {
            mprMark(debug->lines[i].source);
        }
    } else if (flags & MPR_MANAGE_FREE) {
        /* Value to signify the debug record has been freed */
        debug->magic = 7;
    }
}


/*
    Demand load debug information for a function
 */
static EjsDebug *loadDebug(Ejs *ejs, EjsFunction *fun)
{
    EjsModule   *mp;
    EjsDebug    *debug;
    EjsLine     *line;
    EjsCode     *code;
    MprOff      prior;
    int         i, length;

    mp = fun->body.code->module;
    code = fun->body.code;
    prior = 0;
    debug = NULL;

    /*
        Synchronize with ejsLoadModule. May be multiple threads using immutable types
     */
    lock(mp);
    if (mp->file == 0) {
        if ((mp->file = mprOpenFile(mp->path, O_RDONLY | O_BINARY, 0666)) == NULL) {
            mprTrace(5, "Cannot open module file %s", mp->path);
            unlock(mp);
            return NULL;
        }
        mprEnableFileBuffering(mp->file, 0, 0);
    } else {
        prior = mprGetFilePosition(mp->file);
    }
    if (mprSeekFile(mp->file, SEEK_SET, code->debugOffset) != code->debugOffset) {
        mprSeekFile(mp->file, SEEK_SET, prior);
        unlock(mp);
        return 0;
    }
    length = ejsModuleReadInt(ejs, mp);
    if (!mp->hasError) {
        if ((debug = ejsCreateDebug(ejs, length)) != 0) {
            assert(debug->numLines == length);
            for (i = 0; i < debug->numLines; i++) {
                line = &debug->lines[i];
                line->offset = ejsModuleReadInt(ejs, mp);
                line->source = ejsModuleReadMultiAsWide(ejs, mp);
            }
        }
    }
    if (prior) {
        mprSeekFile(mp->file, SEEK_SET, prior);
    } else {
        mprCloseFile(mp->file);
        mp->file = 0;
    }
    unlock(mp);
    if (mp->hasError) {
        return NULL;
    }
    return debug;
}


EjsLine *ejsGetDebugLine(Ejs *ejs, EjsFunction *fun, uchar *pc)
{
    EjsCode     *code;
    EjsDebug    *debug;
    int         i, offset;

    code = fun->body.code;
    if (code == 0) {
        return NULL;
    }
    offset = (int) (pc - code->byteCode) - 1;
    debug = code->debug;
    if (debug == 0) {
        if (code->debugOffset == 0) {
            return NULL;
        }
        if (debug == 0 && code->debugOffset) {
            if ((debug = loadDebug(ejs, fun)) == 0) {
                return NULL;
            }
            code->debug = debug;
        }
    }
    /*
        Source format is:  path|line| code
     */
    if (debug->numLines > 0) {
        for (i = 0; i < debug->numLines; i++) {
            if (offset < debug->lines[i].offset) {
                break;
            }
        }
        if (i > 0) {
            i--;
        }
        return &debug->lines[i];
    }
    return NULL;
}


int ejsGetDebugInfo(Ejs *ejs, EjsFunction *fun, uchar *pc, char **pathp, int *linep, wchar **sourcep)
{
    EjsLine     *line;
    wchar       *str, *tok, *path, *lineno, *source;

    if ((line = ejsGetDebugLine(ejs, fun, pc)) == 0) {
        return MPR_ERR_CANT_FIND;
    }
    str = wclone(line->source);
    path = wtok(str, "|", &tok);
    lineno = wtok(NULL, "|", &tok);
    source = tok;
    if (pathp) {
        *pathp = wclone(path);
    }
    if (linep) {
        *linep = (int) wtoi(lineno);
    }
    if (sourcep) {
        *sourcep = wclone(source);
    }
    return 0;
}


/************************************************** Encoding ******************************************************/
/*
    Decode a 32 bit integer. The maximum encoded value is EJS_ENCODE_MAX_WORD as the value is number encoded
 */
int ejsDecodeInt32(Ejs *ejs, uchar **pp)
{
    uchar   *start;
    int     value;

    start = *pp;
    value = (int) ejsDecodeNum(ejs, pp);
    *pp = start + 4;
    return value;
}


int64 ejsDecodeNum(Ejs *ejs, uchar **pp)
{
    uchar   *pos;
    uint64  t;
    uint    c;
    int     sign, shift;

    pos = *pp;
    c = (uint) *pos++;

    /*
        Map sign bit (0,1) to 1,-1
     */
    sign = 1 - ((c & 0x1) << 1);
    t = (c >> 1) & 0x3f;
    shift = 6;

    while (c & 0x80) {
        c = *pos++;
        t |= (c & 0x7f) << shift;
        shift += 7;
    }
    *pp = pos;
    return t * sign;
}


/*
    Decode a double using swapping
 */
double ejsDecodeDouble(Ejs *ejs, uchar **pp)
{
    double   value;

    memcpy(&value, *pp, sizeof(double));
    value = ejsSwapDouble(ejs, value);
    *pp += sizeof(double);
    return value;
}


/*
    Encode a number in a RLL encoding. Encoding is:
        Bit     0:  Sign
        Bits  1-6:  Low 6 bits (0-64)
        Bit     7:  Extension bit
        Bits 8-15:  Next 7 bits
        Bits   16:  Extension bit
        ...
 */
int ejsEncodeNum(Ejs *ejs, uchar *pos, int64 number)
{
    uchar       *start;
    uint        encoded;
    uint64      unumber;

    assert(pos);

    start = pos;
    if (number < 0) {
        unumber = -number;
        encoded = (uint) (((unumber & 0x3F) << 1) | 1);
    } else {
        encoded = (uint) (((number & 0x3F) << 1));
        unumber = number;
    }
    unumber >>= 6;

    while (unumber) {
        *pos++ = encoded | 0x80;
        encoded = (int) (unumber & 0x7f);
        unumber >>= 7;
    }
    *pos++ = encoded;
    assert((pos - start) < 11);
    return (int) (pos - start);
}


#if UNUSED && KEEP
int ejsEncodeUint(Ejs *ejs, uchar *pos, uint number)
{
    uchar       *start;
    uint        encoded;

    assert(pos);

    start = pos;
    encoded = (uint) (((number & 0x3F) << 1));
    number >>= 6;

    while (number) {
        *pos++ = encoded | 0x80;
        encoded = (int) (number & 0x7f);
        number >>= 7;
    }
    *pos++ = encoded;
    assert((pos - start) < 11);
    return (int) (pos - start);
}
#endif


/*
    Encode a 32 bit integer. The maximum encoded value is EJS_ENCODE_MAX_WORD as the value is number encoded
 */
int ejsEncodeInt32(Ejs *ejs, uchar *pos, int number)
{
    int         len;

    assert(pos);
    if (abs(number) > EJS_ENCODE_MAX_WORD) {
        assert("Code generation error. Word exceeds maximum");
        return 0;
    }
    memset(pos, 0, 4);
    len = ejsEncodeNum(ejs, pos, (int64) number);
    assert(len <= 4);
    len = 4;
    return len;
}


/*
    Encode a double using swapping
 */
int ejsEncodeDouble(Ejs *ejs, uchar *pos, double number)
{
    number = ejsSwapDouble(ejs, number);
    memcpy(pos, &number, sizeof(double));
    return sizeof(double);
}


int ejsEncodeByteAtPos(Ejs *ejs, uchar *pos, int value)
{
    assert(pos);
    *pos = value;
    return 0;
}


int ejsEncodeInt32AtPos(Ejs *ejs, uchar *pos, int value)
{
    return ejsEncodeInt32(ejs, pos, value);
}



void ejsModuleReadBlock(Ejs *ejs, EjsModule *mp, char *buf, int len)
{
    assert(mp);

    if (mprReadFile(mp->file, buf, len) != len) {
        mp->hasError = 1;
    }
}


int ejsModuleReadByte(Ejs *ejs, EjsModule *mp)
{
    int     c;

    assert(mp);

    if ((c = mprGetFileChar(mp->file)) < 0) {
        mp->hasError = 1;
        return 0;
    }
    return c;
}


/*
    Read a string constant. String constants are stored as token offsets into
    the constant pool. The pool contains null terminated UTF-8 strings.
 */
EjsString *ejsModuleReadConst(Ejs *ejs, EjsModule *mp)
{
    int     t;

    t = ejsModuleReadInt(ejs, mp);
    return ejsCreateStringFromConst(ejs, mp, t);
}


/*
    Decode a 4 byte number from a file
 */
int ejsModuleReadInt32(Ejs *ejs, EjsModule *mp)
{
    uchar   buf[4], *pp;

    assert(mp);

    if (mprReadFile(mp->file, buf, 4) != 4) {
        mp->hasError = 1;
        return 0;
    }
    pp = buf;
    return ejsDecodeInt32(ejs, &pp);
}



/*
    Read a multibyte string. The length is encoded first, followed by a string of bytes.
 */
char *ejsModuleReadMulti(Ejs *ejs, EjsModule *mp)
{
    char    *buf;
    int     len;

    assert(mp);

    len = ejsModuleReadInt(ejs, mp);
    assert(len >= 0);
    if (mp->hasError || (buf = mprAlloc(len)) == 0) {
        return NULL;
    }
    if (mprReadFile(mp->file, buf, len) != len) {
        mp->hasError = 1;
        return NULL;
    }
    return buf;
}


/*
    Read a multibyte string. The length is encoded first, followed by a string of bytes.
 */
wchar *ejsModuleReadMultiAsWide(Ejs *ejs, EjsModule *mp)
{
    assert(mp);

    //  OPT - need direct multi to wide without the double copy
    return amtow(ejsModuleReadMulti(ejs, mp), NULL);
}


int ejsModuleReadInt(Ejs *ejs, EjsModule *mp)
{
    return (int) ejsModuleReadNum(ejs, mp);
}


/*
    Read an encoded number. Numbers are variable-length and little-endian encoded in 7 bits with the 0x80 
    bit of each byte being a continuation bit.
 */
int64 ejsModuleReadNum(Ejs *ejs, EjsModule *mp)
{
    int64   t;
    int     c, sign, shift;

    assert(ejs);
    assert(mp);
    assert(mp->file);

    if ((c = mprGetFileChar(mp->file)) < 0) {
        mp->hasError = 1;
        return 0;
    }
    /* Map sign bit (0,1) to 1,-1 */
    sign = 1 - ((c & 0x1) << 1);
    t = (c >> 1) & 0x3f;
    shift = 6;
    
    while (c & 0x80) {
        if ((c = mprGetFileChar(mp->file)) < 0) {
            mp->hasError = 1;
            return 0;
        }
        t |= (c & 0x7f) << shift;
        shift += 7;
    }
    return (t * sign);
}


/*
    Read a constant qname. String constants are stored as token offsets into
    the constant pool. The pool contains null terminated UTF-8 strings.
 */
EjsName ejsModuleReadName(Ejs *ejs, EjsModule *mp)
{
    EjsName     qname;
    int         t;

    t = ejsModuleReadInt(ejs, mp);
    qname.name = ejsCreateStringFromConst(ejs, mp, t);
    t = ejsModuleReadInt(ejs, mp);
    qname.space = ejsCreateStringFromConst(ejs, mp, t);
    return qname;
}


#if UNUSED && KEEP
int ejsSwapInt16(Ejs *ejs, int word)
{
    if (mprGetEndian(ejs) == ME_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF) << 8) | ((word & 0xFF00) >> 8);
}
#endif


int ejsSwapInt32(Ejs *ejs, int word)
{
    if (mprGetEndian(ejs) == ME_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF000000) >> 24) | ((word & 0xFF0000) >> 8) | ((word & 0xFF00) << 8) | ((word & 0xFF) << 24);
}


int64 ejsSwapInt64(Ejs *ejs, int64 a)
{
    int64   low, high;

    if (mprGetEndian(ejs) == ME_LITTLE_ENDIAN) {
        return a;
    }
    low = a & 0xFFFFFFFF;
    high = (a >> 32) & 0xFFFFFFFF;
    return (int64) ((low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32);
}


double ejsSwapDouble(Ejs *ejs, double a)
{
    union {
        int64   i;
        double  d;
    } alias;
    
    if (mprGetEndian(ejs) == ME_LITTLE_ENDIAN) {
        return a;
    }
    alias.d = a;
    return (double) ejsSwapInt64(ejs, alias.i);
}


#if UNUSED && KEEP
double ejsSwapDouble(Ejs *ejs, double a)
{
    int64   low, high;

    if (mprGetEndian(ejs) == ME_LITTLE_ENDIAN) {
        return a;
    }
    low = ((int64) a) & 0xFFFFFFFF;
    high = (((int64) a) >> 32) & 0xFFFFFFFF;
    return  (double) ((low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32);
}
#endif

/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsScope.c"
 */
/************************************************************************/

/**
    ejsScope.c - Lookup variables in the scope chain.
  
    This modules provides variable lookup and scope chain management.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Forwards *********************************/

static int lookupVarInBlock(Ejs *ejs, EjsBlock *bp, EjsName name, EjsLookup *lookup);

/************************************* Code ***********************************/
/*
    Look for a variable by name in the scope chain and return the location in "lookup" and a positive slot number if found. 
    If the name.space is non-empty, then only the given namespace will be used. Otherwise the set of open namespaces will 
    be used. The lookup structure will contain details about the location of the variable.
 */
int ejsLookupScope(Ejs *ejs, EjsName name, EjsLookup *lookup)
{
    EjsBlock        *bp;
    int             slotNum;

    assert(ejs);
    assert(name.name);
    assert(name.space);
    assert(lookup);

    memset(lookup, 0, sizeof(*lookup));

    //  OPT -- remove nthBlock. Not needed if not binding
    if (ejs->state) {
        for (lookup->nthBlock = 0, bp = ejs->state->bp; bp; bp = bp->scope, lookup->nthBlock++) {
            if ((slotNum = lookupVarInBlock(ejs, bp, name, lookup)) >= 0) {
                return slotNum;
            }
        }
    }
    return lookupVarInBlock(ejs, ejs->global, name, lookup);
}


/*
    Look for a variable by name in the scope chain and return the location in "lookup" and a positive slot number if found. 
    If the name.space is non-empty, then only the given namespace will be used. Otherwise the set of open namespaces will 
    be used. The lookup structure will contain details about the location of the variable.
 */
static int lookupVarInBlock(Ejs *ejs, EjsBlock *bp, EjsName name, EjsLookup *lookup)
{
    EjsFrame        *frame;
    EjsState        *state;
    EjsType         *type;
    EjsObj          *thisObj;
    EjsPot          *prototype;
    int             slotNum, nthBase;

    assert(ejs);
    assert(name.name);
    assert(name.space);
    assert(lookup);

    state = ejs->state;
    slotNum = -1;
    thisObj = state->fp->function.boundThis;

    /* Search simple block */
    lookup->originalObj = bp;
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, bp, name, lookup)) >= 0) {
        return slotNum;
    }
    /* Optimized lookup for frames and types. Simple blocks don't need prototype lookup - so examine the type of block */
    if (ejsIsFrame(ejs, bp)) {
        frame = (EjsFrame*) bp;
        if (thisObj && frame->function.boundThis == thisObj && 
                thisObj != ejs->global && !frame->function.staticMethod && 
                !frame->function.isInitializer) {
            lookup->originalObj = thisObj;
            /* Instance method only */
            if ((slotNum = ejsLookupVarWithNamespaces(ejs, thisObj, name, lookup)) >= 0) {
                return slotNum;
            }
            /* Search prototype chain */
            for (nthBase = 1, type = TYPE(thisObj); type; type = type->baseType, nthBase++) {
                if ((prototype = type->prototype) == 0 || prototype->shortScope) {
                    break;
                }
                if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
                    lookup->nthBase = nthBase;
                    lookup->type = type;
                    return slotNum;
                }
            }
            if (frame->function.isConstructor) {
                for (nthBase = 1, type = (EjsType*) TYPE(thisObj); type; type = type->baseType, nthBase++) {
                    if (type->constructor.block.pot.shortScope) {
                        break;
                    }
                    if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
                        lookup->nthBase = nthBase;
                        return slotNum;
                    }
                }
            }
            thisObj = 0;
        }
    } else if (ejsIsType(ejs, bp)) {
        /* Search base class chain */
        //  OPT -- remove nthBase. Not needed if not binding.
        for (nthBase = 1, type = (EjsType*) bp; type; type = type->baseType, nthBase++) {
            if (type->constructor.block.pot.shortScope) {
                break;
            }
            if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
                lookup->nthBase = nthBase;
                return slotNum;
            }
        }
    }
    return -1;
}


/*
    Find a property in an object or its prototype and base classes.
 */
int ejsLookupVar(Ejs *ejs, EjsAny *obj, EjsName name, EjsLookup *lookup)
{
    EjsType     *type;
    EjsPot      *prototype;
    int         slotNum, nthBase;

    assert(obj);
    assert(lookup);

    memset(lookup, 0, sizeof(*lookup));

    /* Lookup simple object */
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, name, lookup)) >= 0) {
        return slotNum;
    }
    /* Lookup prototype chain */
    for (nthBase = 1, type = TYPE(obj); type; type = type->baseType, nthBase++) {
        if ((prototype = type->prototype) == 0 || prototype->shortScope) {
            break;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, prototype, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    /* Lookup base-class chain */
    type = ejsIsType(ejs, obj) ? ((EjsType*) obj)->baseType : TYPE(obj);
    for (nthBase = 1; type; type = type->baseType, nthBase++) {
        if (type->constructor.block.pot.shortScope) {
            continue;
        }
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, type, name, lookup)) >= 0) {
            lookup->nthBase = nthBase;
            return slotNum;
        }
    }
    return -1;
}


/*
    Find a variable in an object considering namespaces. If the space is "", then search for the property name using
    the set of open namespaces.
 */
int ejsLookupVarWithNamespaces(Ejs *ejs, EjsAny *obj, EjsName name, EjsLookup *lookup)
{
    EjsNamespace    *nsp;
    EjsName         qname, target;
    EjsString       *space;
    EjsBlock        *b;
    MprList         *globalSpaces;
    int             next, slotNum;

    assert(obj);
    assert(name.name);
    assert(name.space);
    assert(lookup);

    b = (EjsBlock*) ejs->global;
    globalSpaces = &b->namespaces;

    if (name.space->value[0]) {
        /* Lookup with an explicit namespace */
        slotNum = ejsLookupProperty(ejs, obj, name);
        lookup->name = name;

    } else {
        /* 
            Lookup with the set of open namespaces in the current scope 
            Special lookup with space == NULL. Means lookup only match if there is only one property of this name 
         */
        qname.space = NULL;
        qname.name = name.name;
        if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
            if (TYPE(obj)->virtualSlots) {
                lookup->name = name;
            } else {
                target = ejsGetPropertyName(ejs, obj, slotNum);
                lookup->name = target;
                space = name.space;
                if (space->value[0] && space != target.space) {
                    /* Unique name match. Name matches, but namespace does not */
                    slotNum = -1;
                } else if (target.space && target.space->value[0]) {
                    /* OPT - Look at global spaces first */
                    for (next = -1; (nsp = mprGetPrevItem(globalSpaces, &next)) != 0; ) {
                        if (nsp->value == target.space) {
                            goto done;
                        }
                    }
                    //  OPT -- need a fast way to know if the space is a standard reserved namespace or not */
                    /* Verify namespace is open */
                    for (b = ejs->state->bp; b; b = b->scope) {
                        //  OPT. Doing some namespaces multiple times. Fix in compiler.
                        for (next = -1; (nsp = mprGetPrevItem(&b->namespaces, &next)) != 0; ) {
                            if (nsp->value == target.space) {
                                goto done;
                            }
                        }
                    }
                    slotNum = -1;
                }
            }

        } else {
            qname = name;
            for (b = ejs->state->bp; b; b = b->scope) {
                for (next = -1; (nsp = (EjsNamespace*) mprGetPrevItem(&b->namespaces, &next)) != 0; ) {
                    qname.space = nsp->value;
                    if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
                        // mprTrace(5, "WARNING: Object has multiple properties of the same name \"%@\"", name.name); 
                        goto done;
                    }
                }
            }
            for (next = -1; (nsp = mprGetPrevItem(globalSpaces, &next)) != 0; ) {
                qname.space = nsp->value;
                if ((slotNum = ejsLookupProperty(ejs, obj, qname)) >= 0) {
                    // mprTrace(5, "WARNING: Object has multiple properties of the same name \"%@\"", name.name); 
                    goto done;
                }
            }
        }
    }
done:
    if (slotNum >= 0) {
        //  OPT MUST GET RID OF THIS. Means that every store does a get
        lookup->ref = ejsGetProperty(ejs, obj, slotNum);
        if (ejs->exception) {
            slotNum = -1;
        } else {
            lookup->obj = obj;
            lookup->slotNum = slotNum;
            lookup->trait = ejsGetPropertyTraits(ejs, lookup->obj, lookup->slotNum);
        }
    }
    return slotNum;
}


/*
    Get a variable by name. If obj is specified, it contains an explicit object in which to search for the variable name. 
    Otherwise, the full execution scope is consulted. The lookup fields will be set as residuals.
 */
EjsAny *ejsGetVarByName(Ejs *ejs, EjsAny *obj, EjsName name, EjsLookup *lookup)
{
    EjsObj  *result;
    int     slotNum;

    assert(ejs);

    //  OPT - really nice to remove this
    //  OPT -- perhaps delegate the logic below down into a getPropertyByName?
    if (obj && TYPE(obj)->helpers.getPropertyByName) {
        if ((result = (TYPE(obj)->helpers.getPropertyByName)(ejs, obj, name)) != 0) {
            return result;
        }
    }
    if (obj) {
        slotNum = ejsLookupVar(ejs, obj, name, lookup);
    } else {
        slotNum = ejsLookupScope(ejs, name, lookup);
    }
    if (slotNum < 0) {
        return 0;
    }
    return ejsGetProperty(ejs, lookup->obj, slotNum);
}


void ejsShowBlockScope(Ejs *ejs, EjsBlock *block)
{
#if ME_DEBUG
    EjsNamespace    *nsp;
    MprList         *namespaces;
    int             nextNsp;

    mprTrace(6, "\n  Block scope");
    for (; block; block = block->scope) {
        mprTrace(6, "    Block \"%s\" 0x%08x", mprGetName(block), block);
        namespaces = &block->namespaces;
        if (namespaces) {
            for (nextNsp = 0; (nsp = (EjsNamespace*) mprGetNextItem(namespaces, &nextNsp)) != 0; ) {
                mprTrace(6, "        \"%@\"", nsp->value);
            }
        }
    }
#endif
}


void ejsShowCurrentScope(Ejs *ejs)
{
#if ME_DEBUG
    EjsNamespace    *nsp;
    MprList         *namespaces;
    EjsBlock        *block;
    int             nextNsp;

    mprTrace(6, "\n  Current scope");
    for (block = ejs->state->bp; block; block = block->scope) {
        mprTrace(6, "    Block \"%s\" 0x%08x", mprGetName(block), block);
        namespaces = &block->namespaces;
        if (namespaces) {
            for (nextNsp = 0; (nsp = (EjsNamespace*) mprGetNextItem(namespaces, &nextNsp)) != 0; ) {
                mprTrace(6, "        \"%@\"", nsp->value);
            }
        }
    }
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */

/************************************************************************/
/*
    Start of file "src/vm/ejsService.c"
 */
/************************************************************************/

/**
    ejsService.c - Ejscript interpreter factory

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************** Includes **********************************/



/*********************************** Forward **********************************/

static void cloneProperties(Ejs *ejs, Ejs *master);
static int  configureEjs(Ejs *ejs);
static void defineSharedTypes(Ejs *ejs);
static void initSearchPath(Ejs *ejs, cchar *search);
static void initStack(Ejs *ejs);
static int  loadRequiredModules(Ejs *ejs, MprList *require);
static void manageEjs(Ejs *ejs, int flags);
static void manageEjsService(EjsService *service, int flags);
#if UNUSED && OPT
static void poolTimer(EjsPool *pool, MprEvent *event);
#endif
static int  runSpecificMethod(Ejs *ejs, cchar *className, cchar *methodName);
static int  searchForMethod(Ejs *ejs, cchar *methodName, EjsType **typeReturn);

/************************************* Code ***********************************/

static EjsService *createService()
{
    EjsService  *sp;

    if (MPR->ejsService) {
        return MPR->ejsService;
    }
    if ((sp = mprAllocObj(EjsService, manageEjsService)) == NULL) {
        return 0;
    }
    mprGlobalLock();
    MPR->ejsService = sp;
#if FUTURE && KEEP
    mprSetMemNotifier((MprMemNotifier) allocNotifier);
#endif
    sp->nativeModules = mprCreateHash(-1, MPR_HASH_STATIC_KEYS);
    sp->mutex = mprCreateLock();
    sp->vmlist = mprCreateList(-1, MPR_LIST_STATIC_VALUES);
    sp->intern = ejsCreateIntern(sp);
    sp->dtoaSpin[0] = mprCreateSpinLock();
    sp->dtoaSpin[1] = mprCreateSpinLock();
    ejsInitCompiler(sp);
    mprGlobalUnlock();
    return sp;
}


static void manageEjsService(EjsService *sp, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(sp->http);
        mprMark(sp->mutex);
        mprMark(sp->vmlist);
        mprMark(sp->nativeModules);
        mprMark(sp->intern);
        mprMark(sp->immutable);
        mprMark(sp->dtoaSpin[0]);
        mprMark(sp->dtoaSpin[1]);

    } else if (flags & MPR_MANAGE_FREE) {
        ejsDestroyIntern(sp->intern);
        sp->mutex = NULL;
    }
}


PUBLIC void ejsDestroy(Ejs *ejs)
{
    if (ejs) {
        ejsDestroyVM(ejs);
    }
    MPR->ejsService = 0;
}


Ejs *ejsCreateVM(int argc, cchar **argv, int flags)
{
    EjsService  *sp;
    Ejs         *ejs;

    if ((ejs = mprAllocObj(Ejs, manageEjs)) == NULL) {
        return 0;
    }
    sp = ejs->service = MPR->ejsService;
    if (sp == 0) {
        sp = ejs->service = createService();
        defineSharedTypes(ejs);
    }
    ejs->empty = 1;
    ejs->state = mprAllocZeroed(sizeof(EjsState));
    ejs->argc = argc;
    ejs->argv = argv;
    ejs->name = sfmt("ejs-%d", sp->seqno++);
    ejs->dispatcher = mprCreateDispatcher(ejs->name, 0);
    ejs->mutex = mprCreateLock(ejs);
    ejs->dontExit = sp->dontExit;
    ejs->flags |= (flags & (EJS_FLAG_NO_INIT | EJS_FLAG_DOC | EJS_FLAG_HOSTED));
    ejs->hosted = (flags & EJS_FLAG_HOSTED) ? 1 : 0;

    ejs->global = ejsCreateBlock(ejs, 0);
    mprSetName(ejs->global, "global");
    ejsDefineGlobalNamespaces(ejs);

    /*
        Modules are not marked in the modules list. This way, modules are collected when not referenced.
        Workers are marked. This way workers are preserved to run in the background until they exit.
        Stable lists without locking.
     */
    ejs->modules = mprCreateList(-1, MPR_LIST_STATIC_VALUES | MPR_LIST_STABLE);
    ejs->workers = mprCreateList(0, MPR_LIST_STABLE);

    initStack(ejs);
    initSearchPath(ejs, 0);
    mprAddItem(sp->vmlist, ejs);

    if (ejs->hasError || mprHasMemError(ejs)) {
        ejsDestroyVM(ejs);
        mprError("Cannot create VM");
        return 0;
    }
    mprTrace(5, "ejs: create VM");
    return ejs;
}


Ejs *ejsCloneVM(Ejs *master)
{
    EjsModule   *mp;
    Ejs         *ejs;
    int         next;

    if (master) {
        assert(!master->empty);
        if ((ejs = ejsCreateVM(master->argc, master->argv, master ? master->flags : 0)) == 0) {
            return 0;
        }
        cloneProperties(ejs, master);
        ejsFixTraits(ejs, ejs->global);
        ejs->sqlite = master->sqlite;
        ejs->http = master->http;
        ejs->initialized = master->initialized;
        ejs->empty = 0;
        for (next = 0; (mp = mprGetNextItem(master->modules, &next)) != 0;) {
            ejsAddModule(ejs, mp);
        }
        return ejs;
    }
    return ejsCreateVM(0, 0, 0);
}


/*
    Load the standard ejs modules with an optional override search path and list of required modules.
    If the require list is empty, then ejs->empty will be true. This routine should only be called once for an interpreter.
 */
int ejsLoadModules(Ejs *ejs, cchar *search, MprList *require)
{
    EjsService      *sp;

    sp = ejs->service;
    assert(mprGetListLength(ejs->modules) == 0);

    ejs->empty = !(require == 0 || mprGetListLength(require));
    if (search) {
        initSearchPath(ejs, search);
    }
    lock(sp);
    if (loadRequiredModules(ejs, require) < 0) {
        if (ejs->exception) {
            ejsReportError(ejs, "Cannot initialize interpreter");
        }
        ejsDestroyVM(ejs);
        unlock(sp);
        return MPR_ERR_CANT_READ;
    }
    unlock(sp);
    if (mprHasMemError(ejs)) {
        mprError("Memory allocation error during initialization");
        ejsDestroyVM(ejs);
        return MPR_ERR_MEMORY;
    }
    assert(!ejs->exception);
    return 0;
}


void ejsDestroyVM(Ejs *ejs)
{
    EjsService  *sp;
    EjsState    *state;
    EjsModule   *mp;   
    MprList     *modules;
    int         next;

    ejs->destroying = 1;
    sp = ejs->service;
    if (sp) {
        modules = ejs->modules;
        ejs->modules = 0;
        for (ITERATE_ITEMS(modules, mp, next)) {
            ejsRemoveModule(ejs, mp);
        }
        ejsRemoveWorkers(ejs);
        state = ejs->state;
        if (state && state->stackBase) {
            mprVirtFree(state->stackBase, state->stackSize);
            state->stackBase = 0;
            ejs->state = 0;
        }
        mprRemoveItem(sp->vmlist, ejs);
        ejs->service = 0;
        ejs->result = 0;
        if (ejs->dispatcher) {
            mprDestroyDispatcher(ejs->dispatcher);
        }
        if (ejs->http) {
            httpStopConnections(ejs);
        }
    }
    mprTrace(6, "ejs: destroy VM");
}


static void manageEjs(Ejs *ejs, int flags)
{
    EjsState    *start, *state;
    EjsObj      *vp, **vpp, **top;
    EjsModule   *mp;
    int         next;

    if (flags & MPR_MANAGE_MARK) {
        mprMark(ejs->name);
        mprMark(ejs->exception);
        mprMark(ejs->result);
        /*
            Mark active call stack
         */
        start = ejs->state;
        if (start) {
            for (state = start; state; state = state->prev) {
                mprMark(state);
                mprMark(state->fp);
                mprMark(state->bp);
                mprMark(state->internal);
                mprMark(state->t1);
            }

            /*
                Mark the evaluation stack. Stack itself is virtually allocated and immune from GC.
             */
            top = start->stack;
            for (vpp = start->stackBase; vpp <= top; vpp++) {
                if ((vp = *vpp) != NULL) {
                    mprMark(vp);
                }
            }
        }
        mprMark(ejs->service);
        mprMark(ejs->global);
        mprMark(ejs->search);
        mprMark(ejs->className);
        mprMark(ejs->methodName);
        mprMark(ejs->errorMsg);
        mprMark(ejs->hostedDocuments);
        mprMark(ejs->hostedHome);
        mprMark(ejs->exceptionArg);
        mprMark(ejs->dispatcher);
        mprMark(ejs->workers);
        for (next = 0; (mp = mprGetNextItem(ejs->modules, &next)) != 0;) {
            if (!mp->initialized) {
                mprMark(mp);
            }
        }
        mprMark(ejs->modules);
        mprMark(ejs->httpServers);
        mprMark(ejs->doc);
        mprMark(ejs->http);
        mprMark(ejs->mutex);

    } else if (flags & MPR_MANAGE_FREE) {
        ejsDestroyVM(ejs);
    }
}


static void managePool(EjsPool *pool, int flags)
{
    if (flags & MPR_MANAGE_MARK) {
        mprMark(pool->list);
        mprMark(pool->timer);
        mprMark(pool->mutex);
        mprMark(pool->template);
        mprMark(pool->templateScript);
        mprMark(pool->startScript);
        mprMark(pool->startScriptPath);
        mprMark(pool->hostedDocuments);
        mprMark(pool->hostedHome);
    }
}


/*
    Create a pool for virtual machines
 */
EjsPool *ejsCreatePool(int poolMax, cchar *templateScript, cchar *startScript, cchar *startScriptPath, 
        cchar *home, cchar *documents)
{
    EjsPool     *pool;

    if ((pool = mprAllocObj(EjsPool, managePool)) == 0) {
        return 0;
    }
    if ((pool->list = mprCreateList(-1, 0)) == 0) {
        return 0;
    }
    pool->mutex = mprCreateLock();
    pool->max = poolMax <= 0 ? MAXINT : poolMax;
    if (templateScript) {
        pool->templateScript = sclone(templateScript);
    }
    if (startScript) {
        pool->startScript = sclone(startScript);
    }
    if (startScriptPath) {
        pool->startScriptPath = sclone(startScriptPath);
    }
    if (home) {
        pool->hostedHome = sclone(home);
    }
    if (documents) {
        pool->hostedDocuments = sclone(documents);
    }
    return pool;
}


Ejs *ejsAllocPoolVM(EjsPool *pool, int flags)
{
    Ejs         *ejs;
    EjsString   *script;
    int         paused;

    assert(pool);

    if ((ejs = mprPopItem(pool->list)) == 0) {
        if (pool->count >= pool->max) {
            mprError("Too many ejs VMS: %d max %d", pool->count, pool->max);
            return 0;
        }
        lock(pool);
        if (pool->template == 0) {
            /*
                Create the pool template VM
             */
            if ((pool->template = ejsCreateVM(0, 0, flags)) == 0) {
                unlock(pool);
                return 0;
            }
            if (ejsLoadModules(pool->template, 0, 0) < 0) {
                unlock(pool);
                return 0;
            }
            if (pool->templateScript) {
                script = ejsCreateStringFromAsc(pool->template, pool->templateScript);
                paused = ejsBlockGC(pool->template);
                if (ejsLoadScriptLiteral(pool->template, script, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_BIND) < 0) {
                    mprError("Cannot execute \"%@\"\n%s", script, ejsGetErrorMsg(pool->template, 1));
                    unlock(pool);
                    ejsUnblockGC(pool->template, paused);
                    return 0;
                }
                ejsUnblockGC(pool->template, paused);
            }
        }
        unlock(pool);

        if ((ejs = ejsCloneVM(pool->template)) == 0) {
            mprError("Cannot alloc ejs VM");
            return 0;
        }
        if (pool->hostedDocuments) {
            ejs->hostedDocuments = pool->hostedDocuments;
        }
        if (pool->hostedHome) {
            ejs->hostedHome = pool->hostedHome;
        }
        mprAddRoot(ejs);
        if (pool->startScriptPath) {
            if (ejsLoadScriptFile(ejs, pool->startScriptPath, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_BIND) < 0) {
                mprError("Cannot load \"%s\"\n%s", pool->startScriptPath, ejsGetErrorMsg(ejs, 1));
                mprRemoveRoot(ejs);
                return 0;
            }
        } else if (pool->startScript) {
            script = ejsCreateStringFromAsc(ejs, pool->startScript);
            if (ejsLoadScriptLiteral(ejs, script, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_BIND) < 0) {
                mprError("Cannot load \"%@\"\n%s", script, ejsGetErrorMsg(ejs, 1));
                mprRemoveRoot(ejs);
                return 0;
            }
        }
        mprRemoveRoot(ejs);
        pool->count++;
    }
    pool->lastActivity = mprGetTime();
    mprTrace(5, "ejs: Alloc VM active %d, allocated %d, max %d", pool->count - mprGetListLength(pool->list), 
        pool->count, pool->max);

#if UNUSED && OPT
    /*
        Disabled because it most of the interp is not being freed due to references from the EjsService
     */
    if (!pool->timer && !mprGetDebugMode()) {
        pool->timer = mprCreateTimerEvent(NULL, "ejsPoolTimer", EJS_POOL_INACTIVITY_TIMEOUT, poolTimer, pool,
            MPR_EVENT_CONTINUOUS | MPR_EVENT_QUICK);
    }
#endif
    return ejs;
}


void ejsFreePoolVM(EjsPool *pool, Ejs *ejs)
{
    assert(pool);
    assert(ejs);
    assert(!ejs->exception);

    ejs->exception = 0;
    pool->lastActivity = mprGetTime();
    mprPushItem(pool->list, ejs);
    mprTrace(5, "ejs: Free VM, active %d, allocated %d, max %d", pool->count - mprGetListLength(pool->list), pool->count,
        pool->max);
}


#if UNUSED && OPT
static void poolTimer(EjsPool *pool, MprEvent *event)
{
    Ejs     *vm;
    int     next;

    if (mprGetElapsedTime(pool->lastActivity) > EJS_POOL_INACTIVITY_TIMEOUT && !mprGetDebugMode()) {
        for (ITERATE_ITEMS(pool->list, vm, next)) {
            vm->abandoned = 1;
        }
        mprClearList(pool->list);
        pool->count = 0;
        pool->template = 0;
        mprTrace(5, "ejs: Release %d VMs in inactive pool. Invoking GC.", pool->count);
        mprRequestGC(MPR_GC_FORCE);
        mprRemoveEvent(event);
        pool->timer = 0;
    }
}
#endif


void ejsSetDispatcher(Ejs *ejs, MprDispatcher *dispatcher)
{
    ejs->dispatcher = dispatcher;
}


void ejsApplyObjHelpers(EjsService *sp, EjsType *type)
{
    type->helpers = sp->objHelpers;
}


void ejsApplyPotHelpers(EjsService *sp, EjsType *type)
{
    type->helpers = sp->potHelpers;
    type->isPot = 1;
}


void ejsApplyBlockHelpers(EjsService *sp, EjsType *type)
{
    type->helpers = sp->blockHelpers;
    type->isPot = 1;
}


static void defineSharedTypes(Ejs *ejs)
{
    /*  
        Create the essential bootstrap types. Order matters.
     */
    ejsCreateBootstrapTypes(ejs);
    ejsCreateArrayType(ejs);
    ejsCreateNamespaceType(ejs);
    ejsCreateFunctionType(ejs);
    ejsCreateFrameType(ejs);
    ejsCreateConfigType(ejs);

    /*
        These types are used by the compiler. Must work with an empty interpreter. Order does not matter.
     */
    ejsCreateBooleanType(ejs);
    ejsCreateErrorType(ejs);
    ejsCreateIteratorType(ejs);
    ejsCreateVoidType(ejs);
    ejsCreateNumberType(ejs);
    ejsCreatePathType(ejs);
    ejsCreateRegExpType(ejs);
    ejsCreateXMLType(ejs);
    ejsCreateXMLListType(ejs);

    ejsCreateGlobalNamespaces(ejs);
    ejsAddNativeModule(ejs, "ejs", configureEjs, _ES_CHECKSUM_ejs, 0);

#if ME_EJS_ONE_MODULE
    #if ME_COM_SQLITE && ME_EJS_DB
        ejs_db_sqlite_Init(ejs, NULL);
    #endif
#if ME_EJS_WEB
    ejs_web_Init(ejs, NULL);
#endif
#if ME_EJS_ZLIB
    ejs_zlib_Init(ejs, NULL);
#endif
#endif
}


static void cloneProperties(Ejs *ejs, Ejs *master)
{
    EjsAny      *vp, *mvp;
    EjsName     qname;
    EjsTrait    *trait;
    int         i, immutable, numProp;

    assert(ejs);
    assert(master);

    /*
        For subsequent VMs, copy global references to immutable types and functions.
     */
    numProp = ((EjsPot*) master->global)->numProp;
    for (i = 0; i < numProp; i++) {
        vp = ejsGetProperty(master, master->global, i);
        qname = ejsGetPropertyName(master, master->global, i);
        ejsSetPropertyName(ejs, ejs->global, i, qname);
        trait = ejsGetPropertyTraits(master, master->global, i);
        ejsSetPropertyTraits(ejs, ejs->global, i, trait->type, trait->attributes);
        immutable = 0;
        if (ejsIsType(ejs, vp)) {
            if (!((EjsType*) vp)->mutable) {
                immutable = 1;
            }
        } else if (!TYPE(vp)->mutableInstances || ejsIsFunction(ejs, vp)) {
            immutable = 1;
        } else if (vp == master->global) {
            vp = ejs->global;
            immutable = 1;
        }
        if (!immutable) {
            mvp = vp;
            vp = ejsClone(ejs, mvp, 1);
        }
        ejsSetProperty(ejs, ejs->global, i, vp);
    }
}


static void initStack(Ejs *ejs)
{
    EjsState    *state;

    /*
        This will allocate memory virtually for systems with virutal memory. Otherwise, it will just use malloc.
     */
    state = ejs->state;
    state->stackSize = MPR_PAGE_ALIGN(ME_MAX_EJS_STACK, mprGetPageSize(ejs));
    if ((state->stackBase = mprVirtAlloc(state->stackSize, MPR_MAP_READ | MPR_MAP_WRITE)) != 0) {
        state->stack = &state->stackBase[-1];
    }
}


/*  
    This will configure all the core types by defining native methods and properties
    This runs after ejs.mod is loaded. NOTE: this does not happen when compiling ejs.mod (ejs->empty).
 */
static int configureEjs(Ejs *ejs)
{
    if (!ejs->service->immutableInitialized) {
        /* 
            Configure shared immutable types
         */
        ejsConfigureIteratorType(ejs);
        ejsConfigureErrorType(ejs);
        ejsConfigureNullType(ejs);
        ejsConfigureBooleanType(ejs);
        ejsConfigureVoidType(ejs);
        ejsConfigureNumberType(ejs);

        ejsConfigurePathType(ejs);
        ejsConfigureFileSystemType(ejs);
        ejsConfigureFileType(ejs);
        ejsConfigureArrayType(ejs);
        ejsConfigureByteArrayType(ejs);
        ejsConfigureCmdType(ejs);
        ejsConfigureDateType(ejs);
        ejsConfigureFunctionType(ejs);
        ejsConfigureGCType(ejs);
        ejsConfigureHttpType(ejs);
        ejsConfigureLocalCacheType(ejs);
        ejsConfigureMprLogType(ejs);
        ejsConfigureMathType(ejs);
        ejsConfigureMemoryType(ejs);
        ejsConfigureNamespaceType(ejs);
        ejsConfigureRegExpType(ejs);
        ejsConfigureSocketType(ejs);
        ejsConfigureStringType(ejs);
        ejsConfigureSystemType(ejs);
        ejsConfigureTimerType(ejs);
        ejsConfigureWorkerType(ejs);
        ejsConfigureXMLType(ejs);
        ejsConfigureXMLListType(ejs);
#if ME_HTTP_WEB_SOCKETS
        ejsConfigureWebSocketType(ejs);
#endif
        ejs->service->immutableInitialized = 1;
    }
    /*
        These types have global properties that must be initialized for all interpreters
     */
    ejsConfigureObjectType(ejs);
    ejsConfigureDebugType(ejs);
    ejsConfigureJSONType(ejs);
    ejsConfigureUriType(ejs);
    /*
        Configure mutables
     */
    ejsConfigureGlobalBlock(ejs);
    ejsConfigureAppType(ejs);
    ejsDefineConfigProperties(ejs);
    ejs->initialized = 1;
    return 0;
}


/*  
    Preload required modules. If require is NULL, then load the standard set.
    Otherwise only load those specified in require.
 */
static int loadRequiredModules(Ejs *ejs, MprList *require)
{
    char    *name;
    int     rc, next, paused;

    rc = 0;
    paused = ejsBlockGC(ejs);
    if (require) {
        for (next = 0; rc == 0 && (name = mprGetNextItem(require, &next)) != 0; ) {
            rc += ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, name), 0, 0, EJS_LOADER_STRICT);
        }
    } else {
        rc += ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, "ejs"), 0, 0, EJS_LOADER_STRICT);
    }
    ejsFreezeGlobal(ejs);
    ejsUnblockGC(ejs, paused);
    return rc;
}


static void initSearchPath(Ejs *ejs, cchar *search)
{
    if ((ejs->bootSearch = search) == 0) {
        ejs->bootSearch = getenv("EJSPATH");
    }
    if (ejs->bootSearch) {
        ejs->search = ejsCreateSearchPath(ejs, ejs->bootSearch);
    } else {
        ejs->search = ejsCreateSearchPath(ejs, NULL);
    }
}


void ejsSetSearchPath(Ejs *ejs, EjsArray *paths)
{
    assert(ejs);
    assert(paths && paths);
    assert(ejsIs(ejs, paths, Array));

    ejs->search = paths;
}


EjsArray *ejsCreateSearchPath(Ejs *ejs, cchar *search)
{
    EjsArray    *ap;
    char        *dir, *next, *tok, *home;

    ap = ejsCreateArray(ejs, 0);

    if (search) {
        next = sclone(search);
        dir = stok(next, MPR_SEARCH_SEP, &tok);
        while (dir && *dir) {
            ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, dir));
            dir = stok(NULL, MPR_SEARCH_SEP, &tok);
        }
        return (EjsArray*) ap;
    }

    /*
        Create a default search path
        . : APP_EXE_DIR : /usr/local/lib/ejs/VERSION/bin : ~/.ejs
     */
    ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, "."));
    ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, mprGetAppDir()));
#if !VXWORKS
    if (!smatch(mprGetAppDir(), ME_VAPP_PREFIX "/bin")) {
        ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, ME_VAPP_PREFIX "/bin"));
    }
#endif
    if ((home = getenv("HOME")) != 0) {
        ejsSetProperty(ejs, ap, -1, ejsCreatePathFromAsc(ejs, sfmt("%s/.ejs", home)));
    }
    return (EjsArray*) ap;
}


int ejsEvalModule(cchar *path)
{
    Ejs             *ejs;
    Mpr             *mpr;
    int             status;

    status = 0;
    if ((mpr = mprCreate(0, NULL, 0)) == 0) {
        status = MPR_ERR_MEMORY;

    } else if ((ejs = ejsCreateVM(0, 0, 0)) == 0) {
        status = MPR_ERR_MEMORY;

    } else if (ejsLoadModule(ejs, ejsCreateStringFromAsc(ejs, path), -1, -1, 0) < 0) {
        status = MPR_ERR_CANT_READ;

    } else if (ejsRun(ejs) < 0) {
        status = EJS_ERR;
    }
    mprDestroy();
    return status;
}


static int runProgram(Ejs *ejs, MprEvent *event)
{
    /*
        Run all module initialization code. This includes plain old scripts.
     */
    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    if (ejs->className || ejs->methodName) {
        if (runSpecificMethod(ejs, ejs->className, ejs->methodName) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


int ejsRunProgram(Ejs *ejs, cchar *className, cchar *methodName)
{
    if (className) {
        ejs->className = sclone(className);
    }
    if (methodName) {
        ejs->methodName = sclone(methodName);
    }
    mprRelayEvent(ejs->dispatcher, (MprEventProc) runProgram, ejs, NULL);

    if (ejs->exception) {
        return EJS_ERR;
    }
    return 0;
}


/*  
    Run the specified method in the named class. If methodName is null, default to "main".
    If className is null, search for the first class containing the method name.
 */
static int runSpecificMethod(Ejs *ejs, cchar *className, cchar *methodName)
{
    EjsType         *type;
    EjsFunction     *fun;
    EjsArray        *args;
    int             i, slotNum;

    type = 0;
    if (className == 0 && methodName == 0) {
        return 0;
    }
    if (className) {
        className = sclone(className);
    }
    if (methodName == 0) {
        methodName = "main";
    }
    methodName = sclone(methodName);
    /*  
        Search for the first class with the given name
     */
    if (className == 0 || *className == '\0') {
        if (searchForMethod(ejs, methodName, &type) < 0) {
            return EJS_ERR;
        }
    } else {
        type = (EjsType*) ejsGetPropertyByName(ejs, ejs->global, N(EJS_PUBLIC_NAMESPACE, className));
    }
    if (type == 0 || !ejsIsType(ejs, type)) {
        mprError("Cannot find class \"%s\"", className);
        return EJS_ERR;
    }
    slotNum = ejsLookupProperty(ejs, type, N(EJS_PUBLIC_NAMESPACE, methodName));
    if (slotNum < 0) {
        return MPR_ERR_CANT_ACCESS;
    }
    fun = (EjsFunction*) ejsGetProperty(ejs, type, slotNum);
    if (! ejsIsFunction(ejs, fun)) {
        mprError("Property is not a function");
        return MPR_ERR_BAD_STATE;
    }
    if (!ejsPropertyHasTrait(ejs, type, slotNum, EJS_PROP_STATIC)) {
        mprError("Method is not declared static");
        return EJS_ERR;
    }
    args = ejsCreateArray(ejs, ejs->argc);
    for (i = 0; i < ejs->argc; i++) {
        ejsSetProperty(ejs, args, i, ejsCreateStringFromAsc(ejs, ejs->argv[i]));
    }
    if (ejsRunFunction(ejs, fun, NULL, 1, &args) == 0) {
        return EJS_ERR;
    }
    return 0;
}


int ejsAddObserver(Ejs *ejs, EjsObj **emitterPtr, EjsObj *name, EjsFunction *observer)
{
    EjsAny      *argv[2];
    EjsObj      *emitter;
    EjsArray    *list;
    int         i;

    if (*emitterPtr == 0) {
        *emitterPtr = ejsCreateInstance(ejs, ejsGetTypeByName(ejs, N("ejs", "Emitter")), 0, NULL);
    }
    emitter = *emitterPtr;

    argv[1] = observer;
    if (ejsIs(ejs, name, Array)) {
        list = (EjsArray*) name;
        for (i = 0; i < list->length; i++) {
            name = ejsGetProperty(ejs, list, i);
            if (!ejsIs(ejs, name, Null)) {
                argv[0] = name;
                ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_on, 2, argv);
            }
        }
    } else {
        argv[0] = name;
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_on, 2, argv);
    }
    return 0;
}


int ejsHasObservers(Ejs *ejs, EjsObj *emitter)
{
    if (emitter) {
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_hasObservers, 0, NULL);
    }
    return 0;
}


int ejsRemoveObserver(Ejs *ejs, EjsObj *emitter, EjsObj *name, EjsFunction *observer)
{
    EjsAny      *argv[2];
    EjsArray    *list;
    int         i;

    if (emitter) {
        argv[1] = observer;
        if (ejsIs(ejs, name, Array)) {
            list = (EjsArray*) name;
            for (i = 0; i < list->length; i++) {
                name = ejsGetProperty(ejs, list, i);
                if (!ejsIs(ejs, name, Null)) {
                    argv[0] = name;
                    ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_off, 2, argv);
                }
            }
        } else {
            argv[0] = name;
            ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_off, 2, argv);
        }
    }
    return 0;
}


int ejsSendEventv(Ejs *ejs, EjsObj *emitter, cchar *name, EjsAny *thisObj, int argc, void *args)
{
    EjsObj  **av, **argv;
    int     i;

    if (emitter) {
        argv = args;
        av = mprAlloc((argc + 2) * sizeof(EjsObj*));
        av[0] = (EjsObj*) ejsCreateStringFromAsc(ejs, name);
        av[1] = thisObj ? thisObj : ESV(null);
        for (i = 0; i < argc; i++) {
            av[i + 2] = argv[i];
        }
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_fireThis, argc + 2, av);
    }
    return 0;
}


int ejsSendEvent(Ejs *ejs, EjsObj *emitter, cchar *name, EjsAny *thisObj, EjsAny *arg)
{
    EjsObj  **argv;

    argv = (EjsObj**) (void*) &arg;
    return ejsSendEventv(ejs, emitter, name, thisObj, 1, argv);
}


/*  
    Search for the named method in all types.
 */
static int searchForMethod(Ejs *ejs, cchar *methodName, EjsType **typeReturn)
{
    EjsFunction *method;
    EjsType     *type;
    EjsName     qname;
    EjsObj      *global, *vp;
    int         globalCount, slotNum, methodCount;
    int         methodSlot;

    assert(methodName && *methodName);
    assert(typeReturn);

    global = ejs->global;
    globalCount = ejsGetLength(ejs, global);

    /*  
        Search for the named method in all types
     */
    for (slotNum = 0; slotNum < globalCount; slotNum++) {
        vp = ejsGetProperty(ejs, global, slotNum);
        if (vp == 0 || !ejsIsType(ejs, vp)) {
            continue;
        }
        type = (EjsType*) vp;
        methodCount = ejsGetLength(ejs, type);

        for (methodSlot = 0; methodSlot < methodCount; methodSlot++) {
            method = (EjsFunction*) ejsGetProperty(ejs, type, methodSlot);
            if (method == 0) {
                continue;
            }

            qname = ejsGetPropertyName(ejs, type, methodSlot);
            if (qname.name && qname.name == ejsCreateStringFromAsc(ejs, methodName)) {
                *typeReturn = type;
            }
        }
    }
    return 0;
}


void ejsRedirectLoggingToFile(MprFile *file, int level)
{
    if (level >= 0) {
        mprSetLogLevel(level);
    }
    if (file) {
        mprSetLogFile(file);
    }
}


int ejsBlockGC(Ejs *ejs)
{
    int     paused;

    paused = ejs->state->paused;
    ejs->state->paused = 1;
    return paused;
}


void ejsUnblockGC(Ejs *ejs, int paused)
{
    assert(paused != -1);
    if (paused != -1) {
        ejs->state->paused = paused;
    }
}


#if FUTURE && KEEP
/*  
    Notifier callback function. Invoked by mprAlloc on allocation errors. This will prevent the allocation error
    bubbling up to the global memory failure handler.
 */
static void allocNotifier(int flags, uint size)
{
    /*
        This has problems. Now many interpreters and need locking to implement this.
        Possible soln - use ejsAttention.
     */
    MprAllocStats   *alloc;
    EjsObj          *argv[2], *thisObj;
    char            msg[MPR_MAX_STRING];
    va_list         dummy = NULL_INIT;

    alloc = mprGetAllocStats(ejs);
    if (granted) {
        if (ejs->memoryCallback) {
            argv[0] = ejsCreateNumber(ejs, size);
            argv[1] = ejsCreateNumber(ejs, total);
            thisObj = ejs->memoryCallback->boundThis ? ejs->memoryCallback->boundThis : ejs->global; 
            ejsRunFunction(ejs, ejs->memoryCallback, thisObj, 2, argv);
        }
        if (!ejs->exception) {
            fmt(msg, sizeof(msg), "Low memory condition. Total mem: %d. Request for %d bytes granted.", total, size);
            ejsCreateException(ejs, ES_MemoryError, msg, dummy);
        }
    } else {
        if (!ejs->exception) {
            fmt(msg, sizeof(msg), "Memory depleted. Total mem: %d. Request for %d bytes denied.", total, size);
            ejsCreateException(ejs, ES_MemoryError, msg, dummy);
        }
    }
}
#endif




void ejsReportError(Ejs *ejs, char *fmt, ...)
{
    va_list     arg;
    cchar       *emsg;
    char        *msg, *buf;

    va_start(arg, fmt);
    
    /*  
        Compiler error format is:
        program:SEVERITY:line:errorCode:message
        Where program is either "ejsc" or "ejs"
        Where SEVERITY is either "error" or "warn"
     */
    if ((emsg = ejsGetErrorMsg(ejs, 1)) != 0) {
        msg = (char*) emsg;
        buf = 0;
    } else {
        msg = buf = sfmtv(fmt, arg);
    }
    if (ejs->exception) {
        char *name = MPR->name;
        mprRawLog(0, "%s: %s\n", name, msg);
    } else {
        mprError("%s", msg);
    }
    va_end(arg);
}


void ejsLockVm(Ejs *ejs)
{
    mprLock(ejs->mutex);
}


void ejsUnlockVm(Ejs *ejs)
{
    mprUnlock(ejs->mutex);
}


void ejsLockService()
{
    mprLock(((EjsService*) MPR->ejsService)->mutex);
}


void ejsUnlockService()
{
    mprUnlock(((EjsService*) MPR->ejsService)->mutex);
}


void ejsLoadHttpService(Ejs *ejs)
{
    ejsLockService();
    if (mprGetMpr()->httpService == 0) {
        httpCreate(HTTP_CLIENT_SIDE | HTTP_SERVER_SIDE);
    }
    ejs->http = ejs->service->http = mprGetMpr()->httpService;
    if (ejs->http == 0) {
        mprError("Cannot load Http Service");
    }
    ejsUnlockService();
}


int ejsAddImmutable(Ejs *ejs, int slotNum, EjsName qname, EjsAny *value)
{
    int     foundSlot;

    assert((ejsIsType(ejs, value) && !((EjsType*) value)->mutable) ||
              (!ejsIsType(ejs, value) && !TYPE(value)->mutableInstances));
    
    if ((foundSlot = ejsLookupProperty(ejs, ejs->service->immutable, qname)) >= 0) {
        return foundSlot;
    }
    slotNum = ejsSetProperty(ejs, ejs->service->immutable, slotNum, value);
    ejsSetPropertyName(ejs, ejs->service->immutable, slotNum, qname);
    return slotNum;
}


EjsAny *ejsGetImmutable(Ejs *ejs, int slotNum)
{
    return ejsGetProperty(ejs, ejs->service->immutable, slotNum);
}


EjsAny *ejsGetImmutableByName(Ejs *ejs, EjsName qname)
{
    return ejsGetPropertyByName(ejs, ejs->service->immutable, qname);
}


void ejsDisableExit(Ejs *ejs)
{
    EjsService  *sp;

    sp = MPR->ejsService;
    if (sp) {
        sp->dontExit = 1;
    }
}


/*
    @copy   default

    Copyright (c) Embedthis Software. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis Open Source license or you may acquire a 
    commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
#endif /* ME_COM_EJS */
